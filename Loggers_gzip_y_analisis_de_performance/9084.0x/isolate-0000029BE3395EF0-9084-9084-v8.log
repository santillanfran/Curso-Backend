v8-version,9,6,180,15,-node.13,0
v8-platform,windows,unknown
shared-library,C:\\Program Files\\nodejs\\node.exe,0x7ff7e70f0000,0x7ff7eae6d000,0
shared-library,C:\\WINDOWS\\SYSTEM32\\ntdll.dll,0x7ff9972f0000,0x7ff9974e8000,0
shared-library,C:\\WINDOWS\\System32\\KERNEL32.DLL,0x7ff9971f0000,0x7ff9972ad000,0
shared-library,C:\\WINDOWS\\System32\\KERNELBASE.dll,0x7ff994f00000,0x7ff9951ce000,0
shared-library,C:\\WINDOWS\\System32\\WS2_32.dll,0x7ff996910000,0x7ff99697b000,0
shared-library,C:\\WINDOWS\\System32\\RPCRT4.dll,0x7ff996bd0000,0x7ff996cf5000,0
shared-library,C:\\WINDOWS\\System32\\PSAPI.DLL,0x7ff995820000,0x7ff995828000,0
shared-library,C:\\WINDOWS\\System32\\ADVAPI32.dll,0x7ff996b20000,0x7ff996bce000,0
shared-library,C:\\WINDOWS\\System32\\msvcrt.dll,0x7ff996860000,0x7ff9968fe000,0
shared-library,C:\\WINDOWS\\SYSTEM32\\dbghelp.dll,0x7ff98e3a0000,0x7ff98e584000,0
shared-library,C:\\WINDOWS\\System32\\sechost.dll,0x7ff997150000,0x7ff9971ec000,0
shared-library,C:\\WINDOWS\\System32\\ucrtbase.dll,0x7ff994d20000,0x7ff994e20000,0
shared-library,C:\\WINDOWS\\SYSTEM32\\IPHLPAPI.DLL,0x7ff993df0000,0x7ff993e2b000,0
shared-library,C:\\WINDOWS\\System32\\USER32.dll,0x7ff9954f0000,0x7ff995690000,0
shared-library,C:\\WINDOWS\\SYSTEM32\\USERENV.dll,0x7ff9948d0000,0x7ff9948fe000,0
shared-library,C:\\WINDOWS\\System32\\win32u.dll,0x7ff994ca0000,0x7ff994cc2000,0
shared-library,C:\\WINDOWS\\System32\\GDI32.dll,0x7ff995830000,0x7ff99585a000,0
shared-library,C:\\WINDOWS\\System32\\gdi32full.dll,0x7ff9951d0000,0x7ff9952db000,0
shared-library,C:\\WINDOWS\\System32\\msvcp_win.dll,0x7ff994c00000,0x7ff994c9d000,0
shared-library,C:\\WINDOWS\\System32\\CRYPT32.dll,0x7ff994a10000,0x7ff994b66000,0
shared-library,C:\\WINDOWS\\System32\\bcrypt.dll,0x7ff994e20000,0x7ff994e47000,0
shared-library,C:\\WINDOWS\\SYSTEM32\\WINMM.dll,0x7ff98bf50000,0x7ff98bf77000,0
shared-library,C:\\WINDOWS\\SYSTEM32\\CRYPTBASE.DLL,0x7ff9942f0000,0x7ff9942fc000,0
shared-library,C:\\WINDOWS\\System32\\IMM32.DLL,0x7ff996980000,0x7ff9969b0000,0
shared-library,C:\\WINDOWS\\SYSTEM32\\powrprof.dll,0x7ff9947d0000,0x7ff99481b000,0
shared-library,C:\\WINDOWS\\SYSTEM32\\UMPDC.dll,0x7ff9947b0000,0x7ff9947c2000,0
shared-library,C:\\WINDOWS\\system32\\uxtheme.dll,0x7ff992470000,0x7ff99250e000,0
shared-library,C:\\WINDOWS\\System32\\combase.dll,0x7ff996d00000,0x7ff997054000,0
shared-library,C:\\WINDOWS\\system32\\mswsock.dll,0x7ff994100000,0x7ff99416a000,0
shared-library,C:\\WINDOWS\\SYSTEM32\\kernel.appcore.dll,0x7ff992850000,0x7ff992862000,0
shared-library,C:\\WINDOWS\\System32\\bcryptPrimitives.dll,0x7ff994b70000,0x7ff994bf2000,0
shared-library-end
tick,0x7ff99738cfc4,143709,0,0x0,6
profiler,begin,1000
new,CodeRange,0x29be7270000,0
new,MemoryChunk,0x1bd2e700000,262144
new,MemoryChunk,0x16c66ec0000,262144
new,MemoryChunk,0x1d014680000,262144
new,MemoryChunk,0x91406c0000,262144
new,MemoryChunk,0x7c8f640000,262144
heap-capacity,1031072
heap-available,4346066752
new,MemoryChunk,0x147335c0000,262144
new,MemoryChunk,0x3f7f2c0000,262144
new,MemoryChunk,0x25ca2700000,262144
new,MemoryChunk,0x14121bc0000,262144
new,MemoryChunk,0x394c9e00000,262144
new,MemoryChunk,0x13c5c2c0000,262144
new,MemoryChunk,0x1d498280000,262144
new,MemoryChunk,0x29be7280000,262144
new,MemoryChunk,0x2b58ff40000,262144
code-creation,Builtin,2,149766,0x7ff7e7d326e4,812,DeoptimizationEntry_Eager
code-creation,Builtin,2,149781,0x7ff7e7d32a24,816,DeoptimizationEntry_Soft
code-creation,Builtin,2,149789,0x7ff7e7d32d64,816,DeoptimizationEntry_Bailout
code-creation,Builtin,2,149798,0x7ff7e7d330a4,816,DeoptimizationEntry_Lazy
code-creation,Builtin,2,149806,0x7ff7e7d333e4,96,DynamicCheckMapsTrampoline
code-creation,Builtin,2,149814,0x7ff7e7d33464,96,DynamicCheckMapsWithFeedbackVectorTrampoline
code-creation,Builtin,2,149823,0x7ff7e7d334e4,1388,RecordWriteEmitRememberedSetSaveFP
code-creation,Builtin,2,149832,0x7ff7e7d33a64,460,RecordWriteOmitRememberedSetSaveFP
code-creation,Builtin,2,149840,0x7ff7e7d33c64,668,RecordWriteEmitRememberedSetIgnoreFP
code-creation,Builtin,2,149849,0x7ff7e7d33f24,216,RecordWriteOmitRememberedSetIgnoreFP
code-creation,Builtin,2,149895,0x7ff7e7d34024,376,EphemeronKeyBarrierSaveFP
code-creation,Builtin,2,149907,0x7ff7e7d341a4,140,EphemeronKeyBarrierIgnoreFP
code-creation,Builtin,2,149916,0x7ff7e7d34264,100,AdaptorWithBuiltinExitFrame
code-creation,Builtin,2,149924,0x7ff7e7d342e4,328,CallFunction_ReceiverIsNullOrUndefined
code-creation,Builtin,2,149933,0x7ff7e7d34464,380,CallFunction_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,149941,0x7ff7e7d345e4,416,CallFunction_ReceiverIsAny
code-creation,Builtin,2,149950,0x7ff7e7d347a4,104,CallBoundFunction
code-creation,Builtin,2,149958,0x7ff7e7d34824,160,Call_ReceiverIsNullOrUndefined
code-creation,Builtin,2,149966,0x7ff7e7d348e4,160,Call_ReceiverIsNotNullOrUndefined
code-creation,Builtin,2,149975,0x7ff7e7d349a4,160,Call_ReceiverIsAny
code-creation,Builtin,2,149983,0x7ff7e7d34a64,992,Call_ReceiverIsNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,149991,0x7ff7e7d34e64,992,Call_ReceiverIsNullOrUndefined_Baseline
code-creation,Builtin,2,150000,0x7ff7e7d35264,1072,Call_ReceiverIsNotNullOrUndefined_Baseline_Compact
code-creation,Builtin,2,150009,0x7ff7e7d356a4,1072,Call_ReceiverIsNotNullOrUndefined_Baseline
code-creation,Builtin,2,150018,0x7ff7e7d35ae4,1072,Call_ReceiverIsAny_Baseline_Compact
code-creation,Builtin,2,150026,0x7ff7e7d35f24,1072,Call_ReceiverIsAny_Baseline
code-creation,Builtin,2,150034,0x7ff7e7d36364,944,Call_ReceiverIsNullOrUndefined_WithFeedback
code-creation,Builtin,2,150043,0x7ff7e7d36724,944,Call_ReceiverIsNotNullOrUndefined_WithFeedback
code-creation,Builtin,2,150052,0x7ff7e7d36ae4,944,Call_ReceiverIsAny_WithFeedback
code-creation,Builtin,2,150060,0x7ff7e7d36ea4,748,CallProxy
code-creation,Builtin,2,150068,0x7ff7e7d371a4,156,CallVarargs
code-creation,Builtin,2,150076,0x7ff7e7d37264,956,CallWithSpread
code-creation,Builtin,2,150084,0x7ff7e7d37624,1960,CallWithSpread_Baseline
code-creation,Builtin,2,150092,0x7ff7e7d37de4,1932,CallWithSpread_WithFeedback
code-creation,Builtin,2,150100,0x7ff7e7d385a4,872,CallWithArrayLike
code-creation,Builtin,2,150108,0x7ff7e7d38924,1820,CallWithArrayLike_WithFeedback
code-creation,Builtin,2,150117,0x7ff7e7d39064,156,CallForwardVarargs
code-creation,Builtin,2,150125,0x7ff7e7d39124,156,CallFunctionForwardVarargs
code-creation,Builtin,2,150133,0x7ff7e7d391e4,132,CallFunctionTemplate_CheckAccess
code-creation,Builtin,2,150141,0x7ff7e7d392a4,232,CallFunctionTemplate_CheckCompatibleReceiver
code-creation,Builtin,2,150150,0x7ff7e7d393a4,320,CallFunctionTemplate_CheckAccessAndCompatibleReceiver
code-creation,Builtin,2,150159,0x7ff7e7d39524,32,ConstructFunction
code-creation,Builtin,2,150167,0x7ff7e7d39564,104,ConstructBoundFunction
code-creation,Builtin,2,150187,0x7ff7e7d395e4,28,ConstructedNonConstructable
code-creation,Builtin,2,150195,0x7ff7e7d39624,100,Construct
code-creation,Builtin,2,150212,0x7ff7e7d396a4,156,ConstructVarargs
code-creation,Builtin,2,150220,0x7ff7e7d39764,980,ConstructWithSpread
code-creation,Builtin,2,150228,0x7ff7e7d39b64,1760,ConstructWithSpread_Baseline
code-creation,Builtin,2,150236,0x7ff7e7d3a264,1776,ConstructWithSpread_WithFeedback
code-creation,Builtin,2,150245,0x7ff7e7d3a964,928,ConstructWithArrayLike
code-creation,Builtin,2,150253,0x7ff7e7d3ad24,1660,ConstructWithArrayLike_WithFeedback
code-creation,Builtin,2,150261,0x7ff7e7d3b3a4,196,ConstructForwardVarargs
code-creation,Builtin,2,150269,0x7ff7e7d3b4a4,196,ConstructFunctionForwardVarargs
code-creation,Builtin,2,150278,0x7ff7e7d3b5a4,804,Construct_Baseline
code-creation,Builtin,2,150286,0x7ff7e7d3b8e4,820,Construct_WithFeedback
code-creation,Builtin,2,150294,0x7ff7e7d3bc24,488,JSConstructStubGeneric
code-creation,Builtin,2,150302,0x7ff7e7d3be24,384,JSBuiltinsConstructStub
code-creation,Builtin,2,150310,0x7ff7e7d3bfe4,688,FastNewObject
code-creation,Builtin,2,150318,0x7ff7e7d3c2a4,300,FastNewClosure
code-creation,Builtin,2,150325,0x7ff7e7d3c3e4,732,ConstructProxy
code-creation,Builtin,2,150333,0x7ff7e7d3c6e4,360,JSEntry
code-creation,Builtin,2,150341,0x7ff7e7d3c864,360,JSConstructEntry
code-creation,Builtin,2,150349,0x7ff7e7d3c9e4,360,JSRunMicrotasksEntry
code-creation,Builtin,2,150379,0x7ff7e7d3cb64,96,JSEntryTrampoline
code-creation,Builtin,2,150389,0x7ff7e7d3cbe4,96,JSConstructEntryTrampoline
code-creation,Builtin,2,150397,0x7ff7e7d3cc64,284,ResumeGeneratorTrampoline
code-creation,Builtin,2,150405,0x7ff7e7d3cda4,1124,StringCodePointAt
code-creation,Builtin,2,150413,0x7ff7e7d3d224,1564,StringFromCodePointAt
code-creation,Builtin,2,150421,0x7ff7e7d3d864,560,StringEqual
code-creation,Builtin,2,150436,0x7ff7e7d3daa4,296,StringGreaterThan
code-creation,Builtin,2,150444,0x7ff7e7d3dbe4,296,StringGreaterThanOrEqual
code-creation,Builtin,2,150452,0x7ff7e7d3dd24,296,StringLessThan
code-creation,Builtin,2,150460,0x7ff7e7d3de64,296,StringLessThanOrEqual
code-creation,Builtin,2,150468,0x7ff7e7d3dfa4,2532,StringSubstring
code-creation,Builtin,2,150476,0x7ff7e7d3e9a4,80,OrderedHashTableHealIndex
code-creation,Builtin,2,150485,0x7ff7e7d3ea24,1172,InterpreterEntryTrampoline
code-creation,Builtin,2,150493,0x7ff7e7d3eee4,76,InterpreterPushArgsThenCall
code-creation,Builtin,2,150501,0x7ff7e7d3ef64,84,InterpreterPushUndefinedAndArgsThenCall
code-creation,Builtin,2,150509,0x7ff7e7d3efe4,84,InterpreterPushArgsThenCallWithFinalSpread
code-creation,Builtin,2,150518,0x7ff7e7d3f064,80,InterpreterPushArgsThenConstruct
code-creation,Builtin,2,150526,0x7ff7e7d3f0e4,80,InterpreterPushArgsThenConstructArrayFunction
code-creation,Builtin,2,150535,0x7ff7e7d3f164,84,InterpreterPushArgsThenConstructWithFinalSpread
code-creation,Builtin,2,150544,0x7ff7e7d3f1e4,84,InterpreterEnterAtBytecode
code-creation,Builtin,2,150552,0x7ff7e7d3f264,220,InterpreterEnterAtNextBytecode
code-creation,Builtin,2,150560,0x7ff7e7d3f364,52,InterpreterOnStackReplacement
code-creation,Builtin,2,150569,0x7ff7e7d3f3a4,596,BaselineOutOfLinePrologue
code-creation,Builtin,2,150577,0x7ff7e7d3f624,56,BaselineOnStackReplacement
code-creation,Builtin,2,150585,0x7ff7e7d3f664,84,BaselineLeaveFrame
code-creation,Builtin,2,150593,0x7ff7e7d3f6e4,220,BaselineOrInterpreterEnterAtBytecode
code-creation,Builtin,2,150602,0x7ff7e7d3f7e4,228,BaselineOrInterpreterEnterAtNextBytecode
code-creation,Builtin,2,150615,0x7ff7e7d3f8e4,196,InterpreterOnStackReplacement_ToBaseline
code-creation,Builtin,2,150624,0x7ff7e7d3f9e4,1008,CompileLazy
code-creation,Builtin,2,150636,0x7ff7e7d3fde4,68,CompileLazyDeoptimizedCode
code-creation,Builtin,2,150644,0x7ff7e7d3fe64,272,InstantiateAsmJs
code-creation,Builtin,2,150652,0x7ff7e7d3ffa4,32,NotifyDeoptimized
code-creation,Builtin,2,150660,0x7ff7e7d3ffe4,52,ContinueToCodeStubBuiltin
code-creation,Builtin,2,150669,0x7ff7e7d40024,60,ContinueToCodeStubBuiltinWithResult
code-creation,Builtin,2,150677,0x7ff7e7d40064,56,ContinueToJavaScriptBuiltin
code-creation,Builtin,2,150685,0x7ff7e7d400a4,64,ContinueToJavaScriptBuiltinWithResult
code-creation,Builtin,2,150694,0x7ff7e7d40124,292,CallApiCallback
code-creation,Builtin,2,150702,0x7ff7e7d40264,276,CallApiGetter
code-creation,Builtin,2,150709,0x7ff7e7d403a4,12,HandleApiCall
code-creation,Builtin,2,150717,0x7ff7e7d403e4,12,HandleApiCallAsFunction
code-creation,Builtin,2,150725,0x7ff7e7d40424,12,HandleApiCallAsConstructor
code-creation,Builtin,2,150734,0x7ff7e7d40464,64,AllocateInYoungGeneration
code-creation,Builtin,2,150742,0x7ff7e7d404e4,52,AllocateRegularInYoungGeneration
code-creation,Builtin,2,150750,0x7ff7e7d40524,64,AllocateInOldGeneration
code-creation,Builtin,2,150758,0x7ff7e7d405a4,52,AllocateRegularInOldGeneration
code-creation,Builtin,2,150767,0x7ff7e7d405e4,432,CopyFastSmiOrObjectElements
code-creation,Builtin,2,150775,0x7ff7e7d407a4,500,GrowFastDoubleElements
code-creation,Builtin,2,150783,0x7ff7e7d409a4,404,GrowFastSmiOrObjectElements
code-creation,Builtin,2,150791,0x7ff7e7d40b64,392,DebugBreakTrampoline
code-creation,Builtin,2,150799,0x7ff7e7d40d24,180,ToNumber
code-creation,Builtin,2,150807,0x7ff7e7d40de4,292,ToNumber_Baseline
code-creation,Builtin,2,150815,0x7ff7e7d40f24,360,ToNumeric_Baseline
code-creation,Builtin,2,150823,0x7ff7e7d410a4,104,PlainPrimitiveToNumber
code-creation,Builtin,2,150831,0x7ff7e7d41124,212,ToNumberConvertBigInt
code-creation,Builtin,2,150839,0x7ff7e7d41224,132,Typeof
code-creation,Builtin,2,150852,0x7ff7e7d412e4,104,BigIntToI64
code-creation,Builtin,2,150861,0x7ff7e7d41364,4,BigIntToI32Pair
code-creation,Builtin,2,150869,0x7ff7e7d413a4,232,I64ToBigInt
code-creation,Builtin,2,150877,0x7ff7e7d414a4,4,I32PairToBigInt
code-creation,Builtin,2,150885,0x7ff7e7d414e4,112,ToBooleanLazyDeoptContinuation
code-creation,Builtin,2,150893,0x7ff7e7d41564,4304,KeyedLoadIC_PolymorphicName
code-creation,Builtin,2,150901,0x7ff7e7d42664,15964,KeyedStoreIC_Megamorphic
code-creation,Builtin,2,150910,0x7ff7e7d464e4,280,LoadGlobalIC_NoFeedback
code-creation,Builtin,2,150918,0x7ff7e7d46624,68,LoadIC_FunctionPrototype
code-creation,Builtin,2,150926,0x7ff7e7d466a4,12,LoadIC_StringLength
code-creation,Builtin,2,150934,0x7ff7e7d466e4,16,LoadIC_StringWrapperLength
code-creation,Builtin,2,150942,0x7ff7e7d46724,3128,LoadIC_NoFeedback
code-creation,Builtin,2,150950,0x7ff7e7d47364,32,StoreGlobalIC_Slow
code-creation,Builtin,2,150958,0x7ff7e7d473a4,7380,StoreIC_NoFeedback
code-creation,Builtin,2,150966,0x7ff7e7d490a4,184,KeyedLoadIC_SloppyArguments
code-creation,Builtin,2,150974,0x7ff7e7d49164,72,LoadIndexedInterceptorIC
code-creation,Builtin,2,150982,0x7ff7e7d491e4,240,KeyedStoreIC_SloppyArguments_Standard
code-creation,Builtin,2,150990,0x7ff7e7d492e4,240,KeyedStoreIC_SloppyArguments_GrowNoTransitionHandleCOW
code-creation,Builtin,2,150999,0x7ff7e7d493e4,240,KeyedStoreIC_SloppyArguments_NoTransitionIgnoreOOB
code-creation,Builtin,2,151008,0x7ff7e7d494e4,240,KeyedStoreIC_SloppyArguments_NoTransitionHandleCOW
code-creation,Builtin,2,151017,0x7ff7e7d495e4,14472,StoreFastElementIC_Standard
code-creation,Builtin,2,151025,0x7ff7e7d4cea4,9724,StoreFastElementIC_GrowNoTransitionHandleCOW
code-creation,Builtin,2,151034,0x7ff7e7d4f4a4,13492,StoreFastElementIC_NoTransitionIgnoreOOB
code-creation,Builtin,2,151043,0x7ff7e7d52964,6168,StoreFastElementIC_NoTransitionHandleCOW
code-creation,Builtin,2,151051,0x7ff7e7d541a4,8544,ElementsTransitionAndStore_Standard
code-creation,Builtin,2,151060,0x7ff7e7d56324,19536,ElementsTransitionAndStore_GrowNoTransitionHandleCOW
code-creation,Builtin,2,151069,0x7ff7e7d5afa4,8544,ElementsTransitionAndStore_NoTransitionIgnoreOOB
code-creation,Builtin,2,151077,0x7ff7e7d5d124,11132,ElementsTransitionAndStore_NoTransitionHandleCOW
code-creation,Builtin,2,151086,0x7ff7e7d5fca4,828,KeyedHasIC_PolymorphicName
code-creation,Builtin,2,151094,0x7ff7e7d5ffe4,172,KeyedHasIC_SloppyArguments
code-creation,Builtin,2,151103,0x7ff7e7d600a4,72,HasIndexedInterceptorIC
code-creation,Builtin,2,151111,0x7ff7e7d60124,228,DynamicCheckMaps
code-creation,Builtin,2,151123,0x7ff7e7d60224,188,DynamicCheckMapsWithFeedbackVector
code-creation,Builtin,2,151132,0x7ff7e7d602e4,172,EnqueueMicrotask
code-creation,Builtin,2,151140,0x7ff7e7d603a4,8,RunMicrotasksTrampoline
code-creation,Builtin,2,151148,0x7ff7e7d603e4,3600,RunMicrotasks
code-creation,Builtin,2,151156,0x7ff7e7d61224,2696,HasProperty
code-creation,Builtin,2,151164,0x7ff7e7d61ce4,1192,DeleteProperty
code-creation,Builtin,2,151182,0x7ff7e7d621a4,2000,CopyDataProperties
code-creation,Builtin,2,151192,0x7ff7e7d629a4,9260,SetDataProperties
code-creation,Builtin,2,151209,0x7ff7e7d64de4,28,Abort
code-creation,Builtin,2,151217,0x7ff7e7d64e24,28,AbortCSADcheck
code-creation,Builtin,2,151224,0x7ff7e7d64e64,12,EmptyFunction
code-creation,Builtin,2,151232,0x7ff7e7d64ea4,12,Illegal
code-creation,Builtin,2,151240,0x7ff7e7d64ee4,12,StrictPoisonPillThrower
code-creation,Builtin,2,151248,0x7ff7e7d64f24,12,UnsupportedThrower
code-creation,Builtin,2,151256,0x7ff7e7d64f64,64,ReturnReceiver
code-creation,Builtin,2,151264,0x7ff7e7d64fe4,36,ArrayConstructor
code-creation,Builtin,2,151272,0x7ff7e7d65024,416,ArrayConstructorImpl
code-creation,Builtin,2,151280,0x7ff7e7d651e4,220,ArrayNoArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,151289,0x7ff7e7d652e4,220,ArrayNoArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,151298,0x7ff7e7d653e4,180,ArrayNoArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,151307,0x7ff7e7d654a4,180,ArrayNoArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,151336,0x7ff7e7d65564,180,ArrayNoArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,151347,0x7ff7e7d65624,180,ArrayNoArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,151356,0x7ff7e7d656e4,192,ArrayNoArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,151366,0x7ff7e7d657e4,192,ArrayNoArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,151375,0x7ff7e7d658e4,520,ArraySingleArgumentConstructor_PackedSmi_DontOverride
code-creation,Builtin,2,151384,0x7ff7e7d65b24,484,ArraySingleArgumentConstructor_HoleySmi_DontOverride
code-creation,Builtin,2,151393,0x7ff7e7d65d24,444,ArraySingleArgumentConstructor_PackedSmi_DisableAllocationSites
code-creation,Builtin,2,151402,0x7ff7e7d65ee4,408,ArraySingleArgumentConstructor_HoleySmi_DisableAllocationSites
code-creation,Builtin,2,151411,0x7ff7e7d660a4,444,ArraySingleArgumentConstructor_Packed_DisableAllocationSites
code-creation,Builtin,2,151420,0x7ff7e7d66264,408,ArraySingleArgumentConstructor_Holey_DisableAllocationSites
code-creation,Builtin,2,151429,0x7ff7e7d66424,452,ArraySingleArgumentConstructor_PackedDouble_DisableAllocationSites
code-creation,Builtin,2,151438,0x7ff7e7d66624,416,ArraySingleArgumentConstructor_HoleyDouble_DisableAllocationSites
code-creation,Builtin,2,151448,0x7ff7e7d667e4,64,ArrayNArgumentsConstructor
code-creation,Builtin,2,151456,0x7ff7e7d66864,12,ArrayConcat
code-creation,Builtin,2,151463,0x7ff7e7d668a4,12,ArrayPrototypeFill
code-creation,Builtin,2,151471,0x7ff7e7d668e4,952,ArrayIncludesSmiOrObject
code-creation,Builtin,2,151480,0x7ff7e7d66ca4,148,ArrayIncludesPackedDoubles
code-creation,Builtin,2,151488,0x7ff7e7d66d64,220,ArrayIncludesHoleyDoubles
code-creation,Builtin,2,151496,0x7ff7e7d66e64,560,ArrayIncludes
code-creation,Builtin,2,151504,0x7ff7e7d670a4,860,ArrayIndexOfSmiOrObject
code-creation,Builtin,2,151512,0x7ff7e7d67424,116,ArrayIndexOfPackedDoubles
code-creation,Builtin,2,151520,0x7ff7e7d674a4,116,ArrayIndexOfHoleyDoubles
code-creation,Builtin,2,151528,0x7ff7e7d67524,560,ArrayIndexOf
code-creation,Builtin,2,151536,0x7ff7e7d67764,12,ArrayPop
code-creation,Builtin,2,151544,0x7ff7e7d677a4,628,ArrayPrototypePop
code-creation,Builtin,2,151551,0x7ff7e7d67a24,12,ArrayPush
code-creation,Builtin,2,151559,0x7ff7e7d67a64,2444,ArrayPrototypePush
code-creation,Builtin,2,151567,0x7ff7e7d68424,12,ArrayShift
code-creation,Builtin,2,151575,0x7ff7e7d68464,12,ArrayUnshift
code-creation,Builtin,2,151582,0x7ff7e7d684a4,976,CloneFastJSArray
code-creation,Builtin,2,151590,0x7ff7e7d688a4,2236,CloneFastJSArrayFillingHoles
code-creation,Builtin,2,151599,0x7ff7e7d69164,1000,ExtractFastJSArray
code-creation,Builtin,2,151607,0x7ff7e7d69564,260,ArrayPrototypeEntries
code-creation,Builtin,2,151615,0x7ff7e7d696a4,248,ArrayPrototypeKeys
code-creation,Builtin,2,151623,0x7ff7e7d697a4,260,ArrayPrototypeValues
code-creation,Builtin,2,151631,0x7ff7e7d698e4,4492,ArrayIteratorPrototypeNext
code-creation,Builtin,2,151639,0x7ff7e7d6aaa4,4236,FlattenIntoArray
code-creation,Builtin,2,151647,0x7ff7e7d6bb64,4236,FlatMapIntoArray
code-creation,Builtin,2,151655,0x7ff7e7d6cc24,384,ArrayPrototypeFlat
code-creation,Builtin,2,151663,0x7ff7e7d6cde4,436,ArrayPrototypeFlatMap
code-creation,Builtin,2,151671,0x7ff7e7d6cfa4,12,ArrayBufferConstructor
code-creation,Builtin,2,151679,0x7ff7e7d6cfe4,12,ArrayBufferConstructor_DoNotInitialize
code-creation,Builtin,2,151687,0x7ff7e7d6d024,12,ArrayBufferPrototypeSlice
code-creation,Builtin,2,151695,0x7ff7e7d6d064,12,ArrayBufferPrototypeResize
code-creation,Builtin,2,151703,0x7ff7e7d6d0a4,816,AsyncFunctionEnter
code-creation,Builtin,2,151711,0x7ff7e7d6d3e4,136,AsyncFunctionReject
code-creation,Builtin,2,151719,0x7ff7e7d6d4a4,128,AsyncFunctionResolve
code-creation,Builtin,2,151727,0x7ff7e7d6d564,12,AsyncFunctionLazyDeoptContinuation
code-creation,Builtin,2,151736,0x7ff7e7d6d5a4,2836,AsyncFunctionAwaitCaught
code-creation,Builtin,2,151744,0x7ff7e7d6e0e4,2836,AsyncFunctionAwaitUncaught
code-creation,Builtin,2,151754,0x7ff7e7d6ec24,172,AsyncFunctionAwaitRejectClosure
code-creation,Builtin,2,151763,0x7ff7e7d6ece4,164,AsyncFunctionAwaitResolveClosure
code-creation,Builtin,2,151771,0x7ff7e7d6eda4,12,BigIntConstructor
code-creation,Builtin,2,151779,0x7ff7e7d6ede4,12,BigIntAsUintN
code-creation,Builtin,2,151787,0x7ff7e7d6ee24,12,BigIntAsIntN
code-creation,Builtin,2,151795,0x7ff7e7d6ee64,12,BigIntPrototypeToLocaleString
code-creation,Builtin,2,151803,0x7ff7e7d6eea4,12,BigIntPrototypeToString
code-creation,Builtin,2,151811,0x7ff7e7d6eee4,12,BigIntPrototypeValueOf
code-creation,Builtin,2,151819,0x7ff7e7d6ef24,12,CallSitePrototypeGetColumnNumber
code-creation,Builtin,2,151828,0x7ff7e7d6ef64,12,CallSitePrototypeGetEnclosingColumnNumber
code-creation,Builtin,2,151836,0x7ff7e7d6efa4,12,CallSitePrototypeGetEnclosingLineNumber
code-creation,Builtin,2,151845,0x7ff7e7d6efe4,12,CallSitePrototypeGetEvalOrigin
code-creation,Builtin,2,151853,0x7ff7e7d6f024,12,CallSitePrototypeGetFileName
code-creation,Builtin,2,151862,0x7ff7e7d6f064,12,CallSitePrototypeGetFunction
code-creation,Builtin,2,151870,0x7ff7e7d6f0a4,12,CallSitePrototypeGetFunctionName
code-creation,Builtin,2,151883,0x7ff7e7d6f0e4,12,CallSitePrototypeGetLineNumber
code-creation,Builtin,2,151891,0x7ff7e7d6f124,12,CallSitePrototypeGetMethodName
code-creation,Builtin,2,151900,0x7ff7e7d6f164,12,CallSitePrototypeGetPosition
code-creation,Builtin,2,151908,0x7ff7e7d6f1a4,12,CallSitePrototypeGetPromiseIndex
code-creation,Builtin,2,151916,0x7ff7e7d6f1e4,12,CallSitePrototypeGetScriptNameOrSourceURL
code-creation,Builtin,2,151925,0x7ff7e7d6f224,12,CallSitePrototypeGetThis
code-creation,Builtin,2,151933,0x7ff7e7d6f264,12,CallSitePrototypeGetTypeName
code-creation,Builtin,2,151941,0x7ff7e7d6f2a4,12,CallSitePrototypeIsAsync
code-creation,Builtin,2,151949,0x7ff7e7d6f2e4,12,CallSitePrototypeIsConstructor
code-creation,Builtin,2,151958,0x7ff7e7d6f324,12,CallSitePrototypeIsEval
code-creation,Builtin,2,151966,0x7ff7e7d6f364,12,CallSitePrototypeIsNative
code-creation,Builtin,2,151974,0x7ff7e7d6f3a4,12,CallSitePrototypeIsPromiseAll
code-creation,Builtin,2,151982,0x7ff7e7d6f3e4,12,CallSitePrototypeIsToplevel
code-creation,Builtin,2,151990,0x7ff7e7d6f424,12,CallSitePrototypeToString
code-creation,Builtin,2,151998,0x7ff7e7d6f464,12,ConsoleDebug
code-creation,Builtin,2,152006,0x7ff7e7d6f4a4,12,ConsoleError
code-creation,Builtin,2,152014,0x7ff7e7d6f4e4,12,ConsoleInfo
code-creation,Builtin,2,152022,0x7ff7e7d6f524,12,ConsoleLog
code-creation,Builtin,2,152029,0x7ff7e7d6f564,12,ConsoleWarn
code-creation,Builtin,2,152037,0x7ff7e7d6f5a4,12,ConsoleDir
code-creation,Builtin,2,152045,0x7ff7e7d6f5e4,12,ConsoleDirXml
code-creation,Builtin,2,152053,0x7ff7e7d6f624,12,ConsoleTable
code-creation,Builtin,2,152060,0x7ff7e7d6f664,12,ConsoleTrace
code-creation,Builtin,2,152068,0x7ff7e7d6f6a4,12,ConsoleGroup
code-creation,Builtin,2,152076,0x7ff7e7d6f6e4,12,ConsoleGroupCollapsed
code-creation,Builtin,2,152084,0x7ff7e7d6f724,12,ConsoleGroupEnd
code-creation,Builtin,2,152092,0x7ff7e7d6f764,12,ConsoleClear
code-creation,Builtin,2,152099,0x7ff7e7d6f7a4,12,ConsoleCount
code-creation,Builtin,2,152107,0x7ff7e7d6f7e4,12,ConsoleCountReset
code-creation,Builtin,2,152115,0x7ff7e7d6f824,12,ConsoleAssert
code-creation,Builtin,2,152123,0x7ff7e7d6f864,12,ConsoleProfile
code-creation,Builtin,2,152131,0x7ff7e7d6f8a4,12,ConsoleProfileEnd
code-creation,Builtin,2,152139,0x7ff7e7d6f8e4,12,ConsoleTime
code-creation,Builtin,2,152147,0x7ff7e7d6f924,12,ConsoleTimeLog
code-creation,Builtin,2,152154,0x7ff7e7d6f964,12,ConsoleTimeEnd
code-creation,Builtin,2,152162,0x7ff7e7d6f9a4,12,ConsoleTimeStamp
code-creation,Builtin,2,152181,0x7ff7e7d6f9e4,12,ConsoleContext
code-creation,Builtin,2,152190,0x7ff7e7d6fa24,12,DataViewConstructor
code-creation,Builtin,2,152207,0x7ff7e7d6fa64,12,DateConstructor
code-creation,Builtin,2,152215,0x7ff7e7d6faa4,228,DatePrototypeGetDate
code-creation,Builtin,2,152223,0x7ff7e7d6fba4,228,DatePrototypeGetDay
code-creation,Builtin,2,152231,0x7ff7e7d6fca4,228,DatePrototypeGetFullYear
code-creation,Builtin,2,152239,0x7ff7e7d6fda4,228,DatePrototypeGetHours
code-creation,Builtin,2,152249,0x7ff7e7d6fea4,212,DatePrototypeGetMilliseconds
code-creation,Builtin,2,152258,0x7ff7e7d6ffa4,228,DatePrototypeGetMinutes
code-creation,Builtin,2,152266,0x7ff7e7d700a4,228,DatePrototypeGetMonth
code-creation,Builtin,2,152274,0x7ff7e7d701a4,228,DatePrototypeGetSeconds
code-creation,Builtin,2,152282,0x7ff7e7d702a4,124,DatePrototypeGetTime
code-creation,Builtin,2,152290,0x7ff7e7d70324,212,DatePrototypeGetTimezoneOffset
code-creation,Builtin,2,152299,0x7ff7e7d70424,212,DatePrototypeGetUTCDate
code-creation,Builtin,2,152307,0x7ff7e7d70524,212,DatePrototypeGetUTCDay
code-creation,Builtin,2,152315,0x7ff7e7d70624,212,DatePrototypeGetUTCFullYear
code-creation,Builtin,2,152323,0x7ff7e7d70724,212,DatePrototypeGetUTCHours
code-creation,Builtin,2,152331,0x7ff7e7d70824,212,DatePrototypeGetUTCMilliseconds
code-creation,Builtin,2,152340,0x7ff7e7d70924,212,DatePrototypeGetUTCMinutes
code-creation,Builtin,2,152348,0x7ff7e7d70a24,212,DatePrototypeGetUTCMonth
code-creation,Builtin,2,152356,0x7ff7e7d70b24,212,DatePrototypeGetUTCSeconds
code-creation,Builtin,2,152364,0x7ff7e7d70c24,124,DatePrototypeValueOf
code-creation,Builtin,2,152372,0x7ff7e7d70ca4,368,DatePrototypeToPrimitive
code-creation,Builtin,2,152380,0x7ff7e7d70e24,12,DatePrototypeGetYear
code-creation,Builtin,2,152388,0x7ff7e7d70e64,12,DatePrototypeSetYear
code-creation,Builtin,2,152396,0x7ff7e7d70ea4,12,DateNow
code-creation,Builtin,2,152404,0x7ff7e7d70ee4,12,DateParse
code-creation,Builtin,2,152412,0x7ff7e7d70f24,12,DatePrototypeSetDate
code-creation,Builtin,2,152419,0x7ff7e7d70f64,12,DatePrototypeSetFullYear
code-creation,Builtin,2,152427,0x7ff7e7d70fa4,12,DatePrototypeSetHours
code-creation,Builtin,2,152435,0x7ff7e7d70fe4,12,DatePrototypeSetMilliseconds
code-creation,Builtin,2,152444,0x7ff7e7d71024,12,DatePrototypeSetMinutes
code-creation,Builtin,2,152452,0x7ff7e7d71064,12,DatePrototypeSetMonth
code-creation,Builtin,2,152460,0x7ff7e7d710a4,12,DatePrototypeSetSeconds
code-creation,Builtin,2,152468,0x7ff7e7d710e4,12,DatePrototypeSetTime
code-creation,Builtin,2,152476,0x7ff7e7d71124,12,DatePrototypeSetUTCDate
code-creation,Builtin,2,152484,0x7ff7e7d71164,12,DatePrototypeSetUTCFullYear
code-creation,Builtin,2,152492,0x7ff7e7d711a4,12,DatePrototypeSetUTCHours
code-creation,Builtin,2,152500,0x7ff7e7d711e4,12,DatePrototypeSetUTCMilliseconds
code-creation,Builtin,2,152508,0x7ff7e7d71224,12,DatePrototypeSetUTCMinutes
code-creation,Builtin,2,152517,0x7ff7e7d71264,12,DatePrototypeSetUTCMonth
code-creation,Builtin,2,152525,0x7ff7e7d712a4,12,DatePrototypeSetUTCSeconds
code-creation,Builtin,2,152533,0x7ff7e7d712e4,12,DatePrototypeToDateString
code-creation,Builtin,2,152541,0x7ff7e7d71324,12,DatePrototypeToISOString
code-creation,Builtin,2,152549,0x7ff7e7d71364,12,DatePrototypeToUTCString
code-creation,Builtin,2,152557,0x7ff7e7d713a4,12,DatePrototypeToString
code-creation,Builtin,2,152565,0x7ff7e7d713e4,12,DatePrototypeToTimeString
code-creation,Builtin,2,152573,0x7ff7e7d71424,12,DatePrototypeToJson
code-creation,Builtin,2,152581,0x7ff7e7d71464,12,DateUTC
code-creation,Builtin,2,152589,0x7ff7e7d714a4,12,ErrorConstructor
code-creation,Builtin,2,152597,0x7ff7e7d714e4,12,ErrorCaptureStackTrace
code-creation,Builtin,2,152605,0x7ff7e7d71524,12,ErrorPrototypeToString
code-creation,Builtin,2,152613,0x7ff7e7d71564,12,FunctionConstructor
code-creation,Builtin,2,152621,0x7ff7e7d715a4,76,FunctionPrototypeApply
code-creation,Builtin,2,152629,0x7ff7e7d71624,12,FunctionPrototypeBind
code-creation,Builtin,2,152637,0x7ff7e7d71664,32,FunctionPrototypeCall
code-creation,Builtin,2,152645,0x7ff7e7d716a4,12,FunctionPrototypeToString
code-creation,Builtin,2,152653,0x7ff7e7d716e4,196,CreateIterResultObject
code-creation,Builtin,2,152661,0x7ff7e7d717e4,804,CreateGeneratorObject
code-creation,Builtin,2,152669,0x7ff7e7d71b24,12,GeneratorFunctionConstructor
code-creation,Builtin,2,152677,0x7ff7e7d71b64,424,GeneratorPrototypeNext
code-creation,Builtin,2,152685,0x7ff7e7d71d24,428,GeneratorPrototypeReturn
code-creation,Builtin,2,152693,0x7ff7e7d71ee4,432,GeneratorPrototypeThrow
code-creation,Builtin,2,152703,0x7ff7e7d720a4,12,AsyncFunctionConstructor
code-creation,Builtin,2,152712,0x7ff7e7d720e4,376,SuspendGeneratorBaseline
code-creation,Builtin,2,152720,0x7ff7e7d72264,88,ResumeGeneratorBaseline
code-creation,Builtin,2,152728,0x7ff7e7d722e4,36,GetIteratorWithFeedbackLazyDeoptContinuation
code-creation,Builtin,2,152737,0x7ff7e7d72324,12,GlobalDecodeURI
code-creation,Builtin,2,152745,0x7ff7e7d72364,12,GlobalDecodeURIComponent
code-creation,Builtin,2,152753,0x7ff7e7d723a4,12,GlobalEncodeURI
code-creation,Builtin,2,152761,0x7ff7e7d723e4,12,GlobalEncodeURIComponent
code-creation,Builtin,2,152769,0x7ff7e7d72424,12,GlobalEscape
code-creation,Builtin,2,152777,0x7ff7e7d72464,12,GlobalUnescape
code-creation,Builtin,2,152784,0x7ff7e7d724a4,12,GlobalEval
code-creation,Builtin,2,152792,0x7ff7e7d724e4,140,GlobalIsFinite
code-creation,Builtin,2,152800,0x7ff7e7d725a4,132,GlobalIsNaN
code-creation,Builtin,2,152808,0x7ff7e7d72664,12,JsonParse
code-creation,Builtin,2,152815,0x7ff7e7d726a4,12,JsonStringify
code-creation,Builtin,2,152823,0x7ff7e7d726e4,4680,LoadIC
code-creation,Builtin,2,152831,0x7ff7e7d73964,4368,LoadIC_Megamorphic
code-creation,Builtin,2,152839,0x7ff7e7d74aa4,4592,LoadIC_Noninlined
code-creation,Builtin,2,152847,0x7ff7e7d75ca4,44,LoadICTrampoline
code-creation,Builtin,2,152855,0x7ff7e7d75ce4,24,LoadICBaseline
code-creation,Builtin,2,152863,0x7ff7e7d75d24,44,LoadICTrampoline_Megamorphic
code-creation,Builtin,2,152871,0x7ff7e7d75d64,7512,LoadSuperIC
code-creation,Builtin,2,152879,0x7ff7e7d77ae4,24,LoadSuperICBaseline
code-creation,Builtin,2,152887,0x7ff7e7d77b24,8296,KeyedLoadIC
code-creation,Builtin,2,152895,0x7ff7e7d79ba4,13340,KeyedLoadIC_Megamorphic
code-creation,Builtin,2,152903,0x7ff7e7d7cfe4,44,KeyedLoadICTrampoline
code-creation,Builtin,2,152911,0x7ff7e7d7d024,24,KeyedLoadICBaseline
code-creation,Builtin,2,152919,0x7ff7e7d7d064,44,KeyedLoadICTrampoline_Megamorphic
code-creation,Builtin,2,152927,0x7ff7e7d7d0a4,5124,StoreGlobalIC
code-creation,Builtin,2,152935,0x7ff7e7d7e4e4,44,StoreGlobalICTrampoline
code-creation,Builtin,2,152943,0x7ff7e7d7e524,24,StoreGlobalICBaseline
code-creation,Builtin,2,152951,0x7ff7e7d7e564,5368,StoreIC
code-creation,Builtin,2,152959,0x7ff7e7d7fa64,44,StoreICTrampoline
code-creation,Builtin,2,152967,0x7ff7e7d7faa4,24,StoreICBaseline
code-creation,Builtin,2,152974,0x7ff7e7d7fae4,5808,KeyedStoreIC
code-creation,Builtin,2,152982,0x7ff7e7d811a4,44,KeyedStoreICTrampoline
code-creation,Builtin,2,152990,0x7ff7e7d811e4,24,KeyedStoreICBaseline
code-creation,Builtin,2,152998,0x7ff7e7d81224,408,StoreInArrayLiteralIC
code-creation,Builtin,2,153006,0x7ff7e7d813e4,24,StoreInArrayLiteralICBaseline
code-creation,Builtin,2,153015,0x7ff7e7d81424,140,LookupContextBaseline
code-creation,Builtin,2,153023,0x7ff7e7d814e4,140,LookupContextInsideTypeofBaseline
code-creation,Builtin,2,153031,0x7ff7e7d815a4,3296,LoadGlobalIC
code-creation,Builtin,2,153039,0x7ff7e7d822a4,3280,LoadGlobalICInsideTypeof
code-creation,Builtin,2,153047,0x7ff7e7d82fa4,44,LoadGlobalICTrampoline
code-creation,Builtin,2,153055,0x7ff7e7d82fe4,24,LoadGlobalICBaseline
code-creation,Builtin,2,153063,0x7ff7e7d83024,44,LoadGlobalICInsideTypeofTrampoline
code-creation,Builtin,2,153071,0x7ff7e7d83064,24,LoadGlobalICInsideTypeofBaseline
code-creation,Builtin,2,153079,0x7ff7e7d830a4,144,LookupGlobalICBaseline
code-creation,Builtin,2,153087,0x7ff7e7d83164,144,LookupGlobalICInsideTypeofBaseline
code-creation,Builtin,2,153096,0x7ff7e7d83224,2104,CloneObjectIC
code-creation,Builtin,2,153104,0x7ff7e7d83a64,24,CloneObjectICBaseline
code-creation,Builtin,2,153112,0x7ff7e7d83aa4,2028,CloneObjectIC_Slow
code-creation,Builtin,2,153120,0x7ff7e7d842a4,2872,KeyedHasIC
code-creation,Builtin,2,153127,0x7ff7e7d84de4,24,KeyedHasICBaseline
code-creation,Builtin,2,153135,0x7ff7e7d84e24,2700,KeyedHasIC_Megamorphic
code-creation,Builtin,2,153143,0x7ff7e7d858e4,1472,IterableToList
code-creation,Builtin,2,153151,0x7ff7e7d85ee4,1276,IterableToFixedArray
code-creation,Builtin,2,153159,0x7ff7e7d863e4,748,IterableToListWithSymbolLookup
code-creation,Builtin,2,153208,0x7ff7e7d866e4,56,IterableToFixedArrayWithSymbolLookupSlow
code-creation,Builtin,2,153218,0x7ff7e7d86724,124,IterableToListMayPreserveHoles
code-creation,Builtin,2,153227,0x7ff7e7d867a4,1008,IterableToFixedArrayForWasm
code-creation,Builtin,2,153235,0x7ff7e7d86ba4,1664,StringListFromIterable
code-creation,Builtin,2,153243,0x7ff7e7d87264,1272,FindOrderedHashMapEntry
code-creation,Builtin,2,153251,0x7ff7e7d87764,4292,MapConstructor
code-creation,Builtin,2,153259,0x7ff7e7d88864,2044,MapPrototypeSet
code-creation,Builtin,2,153267,0x7ff7e7d89064,1576,MapPrototypeDelete
code-creation,Builtin,2,153275,0x7ff7e7d896a4,216,MapPrototypeGet
code-creation,Builtin,2,153283,0x7ff7e7d897a4,168,MapPrototypeHas
code-creation,Builtin,2,153291,0x7ff7e7d89864,12,MapPrototypeClear
code-creation,Builtin,2,153299,0x7ff7e7d898a4,284,MapPrototypeEntries
code-creation,Builtin,2,153307,0x7ff7e7d899e4,144,MapPrototypeGetSize
code-creation,Builtin,2,153315,0x7ff7e7d89aa4,504,MapPrototypeForEach
code-creation,Builtin,2,153323,0x7ff7e7d89ca4,284,MapPrototypeKeys
code-creation,Builtin,2,153331,0x7ff7e7d89de4,284,MapPrototypeValues
code-creation,Builtin,2,153339,0x7ff7e7d89f24,1072,MapIteratorPrototypeNext
code-creation,Builtin,2,153347,0x7ff7e7d8a364,1196,MapIteratorToList
code-creation,Builtin,2,153355,0x7ff7e7d8a824,12,NumberPrototypeToExponential
code-creation,Builtin,2,153363,0x7ff7e7d8a864,12,NumberPrototypeToFixed
code-creation,Builtin,2,153371,0x7ff7e7d8a8a4,12,NumberPrototypeToLocaleString
code-creation,Builtin,2,153379,0x7ff7e7d8a8e4,12,NumberPrototypeToPrecision
code-creation,Builtin,2,153387,0x7ff7e7d8a924,340,SameValue
code-creation,Builtin,2,153395,0x7ff7e7d8aaa4,212,SameValueNumbersOnly
code-creation,Builtin,2,153403,0x7ff7e7d8aba4,792,Add_Baseline
code-creation,Builtin,2,153411,0x7ff7e7d8aee4,828,Subtract_Baseline
code-creation,Builtin,2,153419,0x7ff7e7d8b224,808,Multiply_Baseline
code-creation,Builtin,2,153427,0x7ff7e7d8b564,832,Divide_Baseline
code-creation,Builtin,2,153434,0x7ff7e7d8b8e4,764,Modulus_Baseline
code-creation,Builtin,2,153442,0x7ff7e7d8bbe4,824,Exponentiate_Baseline
code-creation,Builtin,2,153461,0x7ff7e7d8bf24,708,BitwiseAnd_Baseline
code-creation,Builtin,2,153469,0x7ff7e7d8c224,700,BitwiseOr_Baseline
code-creation,Builtin,2,153477,0x7ff7e7d8c4e4,708,BitwiseXor_Baseline
code-creation,Builtin,2,153486,0x7ff7e7d8c7e4,720,ShiftLeft_Baseline
code-creation,Builtin,2,153494,0x7ff7e7d8cae4,720,ShiftRight_Baseline
code-creation,Builtin,2,153502,0x7ff7e7d8cde4,836,ShiftRightLogical_Baseline
code-creation,Builtin,2,153519,0x7ff7e7d8d164,720,Add_WithFeedback
code-creation,Builtin,2,153527,0x7ff7e7d8d464,780,Subtract_WithFeedback
code-creation,Builtin,2,153535,0x7ff7e7d8d7a4,776,Multiply_WithFeedback
code-creation,Builtin,2,153543,0x7ff7e7d8dae4,804,Divide_WithFeedback
code-creation,Builtin,2,153551,0x7ff7e7d8de24,724,Modulus_WithFeedback
code-creation,Builtin,2,153559,0x7ff7e7d8e124,784,Exponentiate_WithFeedback
code-creation,Builtin,2,153568,0x7ff7e7d8e464,684,BitwiseAnd_WithFeedback
code-creation,Builtin,2,153576,0x7ff7e7d8e724,676,BitwiseOr_WithFeedback
code-creation,Builtin,2,153584,0x7ff7e7d8e9e4,684,BitwiseXor_WithFeedback
code-creation,Builtin,2,153592,0x7ff7e7d8eca4,692,ShiftLeft_WithFeedback
code-creation,Builtin,2,153600,0x7ff7e7d8ef64,692,ShiftRight_WithFeedback
code-creation,Builtin,2,153608,0x7ff7e7d8f224,808,ShiftRightLogical_WithFeedback
code-creation,Builtin,2,153616,0x7ff7e7d8f564,1700,Equal_Baseline
code-creation,Builtin,2,153624,0x7ff7e7d8fc24,916,StrictEqual_Baseline
code-creation,Builtin,2,153632,0x7ff7e7d8ffe4,1268,LessThan_Baseline
code-creation,Builtin,2,153640,0x7ff7e7d904e4,1268,GreaterThan_Baseline
code-creation,Builtin,2,153648,0x7ff7e7d909e4,1268,LessThanOrEqual_Baseline
code-creation,Builtin,2,153656,0x7ff7e7d90ee4,1268,GreaterThanOrEqual_Baseline
code-creation,Builtin,2,153665,0x7ff7e7d913e4,1628,Equal_WithFeedback
code-creation,Builtin,2,153673,0x7ff7e7d91a64,944,StrictEqual_WithFeedback
code-creation,Builtin,2,153681,0x7ff7e7d91e24,1248,LessThan_WithFeedback
code-creation,Builtin,2,153690,0x7ff7e7d92324,1248,GreaterThan_WithFeedback
code-creation,Builtin,2,153699,0x7ff7e7d92824,1248,LessThanOrEqual_WithFeedback
code-creation,Builtin,2,153707,0x7ff7e7d92d24,1248,GreaterThanOrEqual_WithFeedback
code-creation,Builtin,2,153716,0x7ff7e7d93224,332,BitwiseNot_Baseline
code-creation,Builtin,2,153724,0x7ff7e7d933a4,460,Decrement_Baseline
code-creation,Builtin,2,153732,0x7ff7e7d935a4,464,Increment_Baseline
code-creation,Builtin,2,153740,0x7ff7e7d937a4,488,Negate_Baseline
code-creation,Builtin,2,153748,0x7ff7e7d939a4,316,BitwiseNot_WithFeedback
code-creation,Builtin,2,153756,0x7ff7e7d93ae4,440,Decrement_WithFeedback
code-creation,Builtin,2,153764,0x7ff7e7d93ca4,444,Increment_WithFeedback
code-creation,Builtin,2,153772,0x7ff7e7d93e64,472,Negate_WithFeedback
code-creation,Builtin,2,153780,0x7ff7e7d94064,252,ObjectAssign
code-creation,Builtin,2,153788,0x7ff7e7d94164,884,ObjectCreate
code-creation,Builtin,2,153795,0x7ff7e7d944e4,12,ObjectDefineGetter
code-creation,Builtin,2,153803,0x7ff7e7d94524,12,ObjectDefineProperties
code-creation,Builtin,2,153811,0x7ff7e7d94564,12,ObjectDefineProperty
code-creation,Builtin,2,153819,0x7ff7e7d945a4,12,ObjectDefineSetter
code-creation,Builtin,2,153827,0x7ff7e7d945e4,1528,ObjectEntries
code-creation,Builtin,2,153835,0x7ff7e7d94be4,12,ObjectFreeze
code-creation,Builtin,2,153843,0x7ff7e7d94c24,5856,ObjectGetOwnPropertyDescriptor
code-creation,Builtin,2,153851,0x7ff7e7d96324,12,ObjectGetOwnPropertyDescriptors
code-creation,Builtin,2,153860,0x7ff7e7d96364,600,ObjectGetOwnPropertyNames
code-creation,Builtin,2,153868,0x7ff7e7d965e4,12,ObjectGetOwnPropertySymbols
code-creation,Builtin,2,153876,0x7ff7e7d96624,172,ObjectHasOwn
code-creation,Builtin,2,153884,0x7ff7e7d966e4,400,ObjectIs
code-creation,Builtin,2,153891,0x7ff7e7d968a4,12,ObjectIsFrozen
code-creation,Builtin,2,153899,0x7ff7e7d968e4,12,ObjectIsSealed
code-creation,Builtin,2,153907,0x7ff7e7d96924,536,ObjectKeys
code-creation,Builtin,2,153915,0x7ff7e7d96b64,12,ObjectLookupGetter
code-creation,Builtin,2,153923,0x7ff7e7d96ba4,12,ObjectLookupSetter
code-creation,Builtin,2,153931,0x7ff7e7d96be4,2332,ObjectPrototypeHasOwnProperty
code-creation,Builtin,2,153939,0x7ff7e7d97524,236,ObjectPrototypeIsPrototypeOf
code-creation,Builtin,2,153947,0x7ff7e7d97624,12,ObjectPrototypePropertyIsEnumerable
code-creation,Builtin,2,153956,0x7ff7e7d97664,12,ObjectPrototypeGetProto
code-creation,Builtin,2,153964,0x7ff7e7d976a4,12,ObjectPrototypeSetProto
code-creation,Builtin,2,153972,0x7ff7e7d976e4,12,ObjectSeal
code-creation,Builtin,2,153980,0x7ff7e7d97724,1124,ObjectToString
code-creation,Builtin,2,153987,0x7ff7e7d97ba4,1292,ObjectValues
code-creation,Builtin,2,153995,0x7ff7e7d980e4,300,OrdinaryHasInstance
code-creation,Builtin,2,154003,0x7ff7e7d98224,364,InstanceOf
code-creation,Builtin,2,154011,0x7ff7e7d983a4,648,InstanceOf_WithFeedback
code-creation,Builtin,2,154019,0x7ff7e7d98664,668,InstanceOf_Baseline
code-creation,Builtin,2,154027,0x7ff7e7d98924,272,ForInEnumerate
code-creation,Builtin,2,154035,0x7ff7e7d98a64,148,ForInPrepare
code-creation,Builtin,2,154043,0x7ff7e7d98b24,2644,ForInFilter
code-creation,Builtin,2,154051,0x7ff7e7d995a4,56,ReflectApply
code-creation,Builtin,2,154058,0x7ff7e7d995e4,64,ReflectConstruct
code-creation,Builtin,2,154066,0x7ff7e7d99664,12,ReflectDefineProperty
code-creation,Builtin,2,154074,0x7ff7e7d996a4,12,ReflectGetOwnPropertyDescriptor
code-creation,Builtin,2,154083,0x7ff7e7d996e4,12,ReflectOwnKeys
code-creation,Builtin,2,154090,0x7ff7e7d99724,12,ReflectSet
code-creation,Builtin,2,154098,0x7ff7e7d99764,12,RegExpCapture1Getter
code-creation,Builtin,2,154106,0x7ff7e7d997a4,12,RegExpCapture2Getter
code-creation,Builtin,2,154114,0x7ff7e7d997e4,12,RegExpCapture3Getter
code-creation,Builtin,2,154122,0x7ff7e7d99824,12,RegExpCapture4Getter
code-creation,Builtin,2,154130,0x7ff7e7d99864,12,RegExpCapture5Getter
code-creation,Builtin,2,154138,0x7ff7e7d998a4,12,RegExpCapture6Getter
code-creation,Builtin,2,154146,0x7ff7e7d998e4,12,RegExpCapture7Getter
code-creation,Builtin,2,154154,0x7ff7e7d99924,12,RegExpCapture8Getter
code-creation,Builtin,2,154163,0x7ff7e7d99964,12,RegExpCapture9Getter
code-creation,Builtin,2,154183,0x7ff7e7d999a4,2272,RegExpConstructor
code-creation,Builtin,2,154203,0x7ff7e7d9a2a4,12,RegExpInputGetter
tick,0x7ff99738d044,154253,0,0x0,6
code-creation,Builtin,2,154277,0x7ff7e7d9a2e4,12,RegExpInputSetter
code-creation,Builtin,2,154291,0x7ff7e7d9a324,12,RegExpLastMatchGetter
code-creation,Builtin,2,154299,0x7ff7e7d9a364,12,RegExpLastParenGetter
code-creation,Builtin,2,154307,0x7ff7e7d9a3a4,12,RegExpLeftContextGetter
code-creation,Builtin,2,154315,0x7ff7e7d9a3e4,936,RegExpPrototypeCompile
code-creation,Builtin,2,154323,0x7ff7e7d9a7a4,12,RegExpPrototypeToString
code-creation,Builtin,2,154331,0x7ff7e7d9a7e4,12,RegExpRightContextGetter
code-creation,Builtin,2,154340,0x7ff7e7d9a824,256,RegExpExecAtom
code-creation,Builtin,2,154348,0x7ff7e7d9a964,1036,RegExpExecInternal
code-creation,Builtin,2,154356,0x7ff7e7d9ada4,8,RegExpInterpreterTrampoline
code-creation,Builtin,2,154364,0x7ff7e7d9ade4,8,RegExpExperimentalTrampoline
code-creation,Builtin,2,154372,0x7ff7e7d9ae24,2752,SetConstructor
code-creation,Builtin,2,154380,0x7ff7e7d9b924,1332,SetPrototypeHas
code-creation,Builtin,2,154388,0x7ff7e7d9be64,1784,SetPrototypeAdd
code-creation,Builtin,2,154396,0x7ff7e7d9c564,1532,SetPrototypeDelete
code-creation,Builtin,2,154404,0x7ff7e7d9cb64,12,SetPrototypeClear
code-creation,Builtin,2,154412,0x7ff7e7d9cba4,284,SetPrototypeEntries
code-creation,Builtin,2,154420,0x7ff7e7d9cce4,144,SetPrototypeGetSize
code-creation,Builtin,2,154428,0x7ff7e7d9cda4,460,SetPrototypeForEach
code-creation,Builtin,2,154436,0x7ff7e7d9cfa4,284,SetPrototypeValues
code-creation,Builtin,2,154444,0x7ff7e7d9d0e4,1004,SetIteratorPrototypeNext
code-creation,Builtin,2,154452,0x7ff7e7d9d4e4,1132,SetOrSetIteratorToList
code-creation,Builtin,2,154460,0x7ff7e7d9d964,12,SharedArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,154469,0x7ff7e7d9d9a4,12,SharedArrayBufferPrototypeSlice
code-creation,Builtin,2,154477,0x7ff7e7d9d9e4,12,SharedArrayBufferPrototypeGrow
code-creation,Builtin,2,154486,0x7ff7e7d9da24,1280,AtomicsLoad
code-creation,Builtin,2,154493,0x7ff7e7d9df64,1016,AtomicsStore
code-creation,Builtin,2,154501,0x7ff7e7d9e364,1704,AtomicsExchange
code-creation,Builtin,2,154509,0x7ff7e7d9ea24,2096,AtomicsCompareExchange
code-creation,Builtin,2,154517,0x7ff7e7d9f264,1808,AtomicsAdd
code-creation,Builtin,2,154525,0x7ff7e7d9f9a4,1808,AtomicsSub
code-creation,Builtin,2,154533,0x7ff7e7da00e4,1808,AtomicsAnd
code-creation,Builtin,2,154541,0x7ff7e7da0824,1808,AtomicsOr
code-creation,Builtin,2,154549,0x7ff7e7da0f64,1808,AtomicsXor
code-creation,Builtin,2,154556,0x7ff7e7da16a4,12,AtomicsNotify
code-creation,Builtin,2,154564,0x7ff7e7da16e4,12,AtomicsIsLockFree
code-creation,Builtin,2,154572,0x7ff7e7da1724,12,AtomicsWait
code-creation,Builtin,2,154580,0x7ff7e7da1764,12,AtomicsWaitAsync
code-creation,Builtin,2,154588,0x7ff7e7da17a4,12,StringFromCodePoint
code-creation,Builtin,2,154596,0x7ff7e7da17e4,1444,StringFromCharCode
code-creation,Builtin,2,154604,0x7ff7e7da1da4,12,StringPrototypeLastIndexOf
code-creation,Builtin,2,154612,0x7ff7e7da1de4,4464,StringPrototypeMatchAll
code-creation,Builtin,2,154620,0x7ff7e7da2f64,12,StringPrototypeLocaleCompare
code-creation,Builtin,2,154628,0x7ff7e7da2fa4,1252,StringPrototypeReplace
code-creation,Builtin,2,154637,0x7ff7e7da34a4,2948,StringPrototypeSplit
code-creation,Builtin,2,154645,0x7ff7e7da4064,12,StringRaw
code-creation,Builtin,2,154652,0x7ff7e7da40a4,12,SymbolConstructor
code-creation,Builtin,2,154660,0x7ff7e7da40e4,12,SymbolFor
code-creation,Builtin,2,154668,0x7ff7e7da4124,12,SymbolKeyFor
code-creation,Builtin,2,154676,0x7ff7e7da4164,88,TypedArrayBaseConstructor
code-creation,Builtin,2,154684,0x7ff7e7da41e4,264,TypedArrayConstructor
code-creation,Builtin,2,154692,0x7ff7e7da4324,12,TypedArrayPrototypeBuffer
code-creation,Builtin,2,154700,0x7ff7e7da4364,896,TypedArrayPrototypeByteLength
code-creation,Builtin,2,154708,0x7ff7e7da4724,368,TypedArrayPrototypeByteOffset
code-creation,Builtin,2,154717,0x7ff7e7da48a4,592,TypedArrayPrototypeLength
code-creation,Builtin,2,154726,0x7ff7e7da4b24,12,TypedArrayPrototypeCopyWithin
code-creation,Builtin,2,154736,0x7ff7e7da4b64,12,TypedArrayPrototypeFill
code-creation,Builtin,2,154744,0x7ff7e7da4ba4,12,TypedArrayPrototypeIncludes
code-creation,Builtin,2,154752,0x7ff7e7da4be4,12,TypedArrayPrototypeIndexOf
code-creation,Builtin,2,154761,0x7ff7e7da4c24,12,TypedArrayPrototypeLastIndexOf
code-creation,Builtin,2,154769,0x7ff7e7da4c64,12,TypedArrayPrototypeReverse
code-creation,Builtin,2,154777,0x7ff7e7da4ca4,316,TypedArrayPrototypeToStringTag
code-creation,Builtin,2,154785,0x7ff7e7da4de4,10680,TypedArrayPrototypeMap
code-creation,Builtin,2,154794,0x7ff7e7da77a4,792,GenericJSToWasmWrapper
code-creation,Builtin,2,154802,0x7ff7e7da7ae4,148,WasmCompileLazy
code-creation,Builtin,2,154810,0x7ff7e7da7ba4,168,WasmDebugBreak
code-creation,Builtin,2,154818,0x7ff7e7da7c64,16,WasmOnStackReplace
code-creation,Builtin,2,154826,0x7ff7e7da7ca4,140,WasmFloat32ToNumber
code-creation,Builtin,2,154834,0x7ff7e7da7d64,152,WasmFloat64ToNumber
code-creation,Builtin,2,154842,0x7ff7e7da7e24,4,WasmI32AtomicWait32
code-creation,Builtin,2,154850,0x7ff7e7da7e64,4,WasmI64AtomicWait32
code-creation,Builtin,2,154858,0x7ff7e7da7ea4,24,JSToWasmLazyDeoptContinuation
code-creation,Builtin,2,154866,0x7ff7e7da7ee4,4456,WeakMapConstructor
code-creation,Builtin,2,154874,0x7ff7e7da9064,200,WeakMapLookupHashIndex
code-creation,Builtin,2,154882,0x7ff7e7da9164,224,WeakMapGet
code-creation,Builtin,2,154890,0x7ff7e7da9264,180,WeakMapPrototypeHas
code-creation,Builtin,2,154898,0x7ff7e7da9324,204,WeakMapPrototypeSet
code-creation,Builtin,2,154906,0x7ff7e7da9424,144,WeakMapPrototypeDelete
code-creation,Builtin,2,154914,0x7ff7e7da94e4,2944,WeakSetConstructor
code-creation,Builtin,2,154922,0x7ff7e7daa0a4,180,WeakSetPrototypeHas
code-creation,Builtin,2,154930,0x7ff7e7daa164,204,WeakSetPrototypeAdd
code-creation,Builtin,2,154938,0x7ff7e7daa264,144,WeakSetPrototypeDelete
code-creation,Builtin,2,154954,0x7ff7e7daa324,384,WeakCollectionDelete
code-creation,Builtin,2,154962,0x7ff7e7daa4e4,784,WeakCollectionSet
code-creation,Builtin,2,154970,0x7ff7e7daa824,296,AsyncGeneratorResolve
code-creation,Builtin,2,154978,0x7ff7e7daa964,104,AsyncGeneratorReject
code-creation,Builtin,2,154986,0x7ff7e7daa9e4,2788,AsyncGeneratorYield
code-creation,Builtin,2,154994,0x7ff7e7dab4e4,2896,AsyncGeneratorReturn
code-creation,Builtin,2,155002,0x7ff7e7dac064,308,AsyncGeneratorResumeNext
code-creation,Builtin,2,155010,0x7ff7e7dac1a4,12,AsyncGeneratorFunctionConstructor
code-creation,Builtin,2,155019,0x7ff7e7dac1e4,1044,AsyncGeneratorPrototypeNext
code-creation,Builtin,2,155027,0x7ff7e7dac624,1048,AsyncGeneratorPrototypeReturn
code-creation,Builtin,2,155035,0x7ff7e7daca64,1048,AsyncGeneratorPrototypeThrow
code-creation,Builtin,2,155044,0x7ff7e7dacea4,2772,AsyncGeneratorAwaitCaught
code-creation,Builtin,2,155052,0x7ff7e7dad9a4,2772,AsyncGeneratorAwaitUncaught
code-creation,Builtin,2,155061,0x7ff7e7dae4a4,116,AsyncGeneratorAwaitResolveClosure
code-creation,Builtin,2,155069,0x7ff7e7dae524,128,AsyncGeneratorAwaitRejectClosure
code-creation,Builtin,2,155077,0x7ff7e7dae5e4,120,AsyncGeneratorYieldResolveClosure
code-creation,Builtin,2,155086,0x7ff7e7dae664,120,AsyncGeneratorReturnClosedResolveClosure
code-creation,Builtin,2,155094,0x7ff7e7dae6e4,112,AsyncGeneratorReturnClosedRejectClosure
code-creation,Builtin,2,155103,0x7ff7e7dae764,128,AsyncGeneratorReturnResolveClosure
code-creation,Builtin,2,155111,0x7ff7e7dae824,1608,AsyncFromSyncIteratorPrototypeNext
code-creation,Builtin,2,155120,0x7ff7e7daeea4,1724,AsyncFromSyncIteratorPrototypeThrow
code-creation,Builtin,2,155128,0x7ff7e7daf564,1744,AsyncFromSyncIteratorPrototypeReturn
code-creation,Builtin,2,155137,0x7ff7e7dafc64,100,AsyncIteratorValueUnwrap
code-creation,Builtin,2,155145,0x7ff7e7dafce4,228,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,155154,0x7ff7e7dafde4,228,CEntry_Return1_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,155163,0x7ff7e7dafee4,212,CEntry_Return1_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,155185,0x7ff7e7daffe4,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,155205,0x7ff7e7db01a4,400,CEntry_Return1_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,155214,0x7ff7e7db0364,244,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,155223,0x7ff7e7db0464,244,CEntry_Return2_DontSaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,155232,0x7ff7e7db0564,224,CEntry_Return2_DontSaveFPRegs_ArgvInRegister_NoBuiltinExit
code-creation,Builtin,2,155241,0x7ff7e7db0664,416,CEntry_Return2_SaveFPRegs_ArgvOnStack_NoBuiltinExit
code-creation,Builtin,2,155250,0x7ff7e7db0824,416,CEntry_Return2_SaveFPRegs_ArgvOnStack_BuiltinExit
code-creation,Builtin,2,155259,0x7ff7e7db09e4,4,DirectCEntry
code-creation,Builtin,2,155266,0x7ff7e7db0a24,1116,StringAdd_CheckNone
code-creation,Builtin,2,155275,0x7ff7e7db0ea4,2520,SubString
code-creation,Builtin,2,155282,0x7ff7e7db18a4,16,StackCheck
code-creation,Builtin,2,155290,0x7ff7e7db18e4,84,DoubleToI
code-creation,Builtin,2,155298,0x7ff7e7db1964,2280,GetProperty
code-creation,Builtin,2,155306,0x7ff7e7db2264,2360,GetPropertyWithReceiver
code-creation,Builtin,2,155314,0x7ff7e7db2ba4,16120,SetProperty
code-creation,Builtin,2,155322,0x7ff7e7db6aa4,13552,SetPropertyInLiteral
code-creation,Builtin,2,155330,0x7ff7e7db9fa4,8,MemCopyUint8Uint8
code-creation,Builtin,2,155338,0x7ff7e7db9fe4,8,MemMove
code-creation,Builtin,2,155345,0x7ff7e7dba024,12,IsTraceCategoryEnabled
code-creation,Builtin,2,155353,0x7ff7e7dba064,12,Trace
code-creation,Builtin,2,155361,0x7ff7e7dba0a4,12,FinalizationRegistryUnregister
code-creation,Builtin,2,155369,0x7ff7e7dba0e4,428,AsyncModuleEvaluate
code-creation,Builtin,2,155377,0x7ff7e7dba2a4,12,CallAsyncModuleFulfilled
code-creation,Builtin,2,155385,0x7ff7e7dba2e4,12,CallAsyncModuleRejected
code-creation,Builtin,2,155394,0x7ff7e7dba324,268,AggregateErrorConstructor
code-creation,Builtin,2,155402,0x7ff7e7dba464,856,ArrayPrototypeAt
code-creation,Builtin,2,155410,0x7ff7e7dba7e4,664,ArrayPrototypeConcat
code-creation,Builtin,2,155418,0x7ff7e7dbaaa4,5848,ArrayPrototypeCopyWithin
code-creation,Builtin,2,155426,0x7ff7e7dbc1a4,220,ArrayEveryLoopEagerDeoptContinuation
code-creation,Builtin,2,155435,0x7ff7e7dbc2a4,624,ArrayEveryLoopLazyDeoptContinuation
code-creation,Builtin,2,155443,0x7ff7e7dbc524,3392,ArrayEveryLoopContinuation
code-creation,Builtin,2,155451,0x7ff7e7dbd2a4,1500,ArrayEvery
code-creation,Builtin,2,155459,0x7ff7e7dbd8a4,284,ArrayFilterLoopEagerDeoptContinuation
code-creation,Builtin,2,155467,0x7ff7e7dbd9e4,992,ArrayFilterLoopLazyDeoptContinuation
code-creation,Builtin,2,155476,0x7ff7e7dbdde4,3636,ArrayFilterLoopContinuation
code-creation,Builtin,2,155484,0x7ff7e7dbec24,4308,ArrayFilter
code-creation,Builtin,2,155492,0x7ff7e7dbfd24,204,ArrayFindLoopEagerDeoptContinuation
code-creation,Builtin,2,155500,0x7ff7e7dbfe24,32,ArrayFindLoopLazyDeoptContinuation
code-creation,Builtin,2,155509,0x7ff7e7dbfe64,320,ArrayFindLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,155518,0x7ff7e7dbffe4,536,ArrayFindLoopContinuation
code-creation,Builtin,2,155526,0x7ff7e7dc0224,1488,ArrayPrototypeFind
code-creation,Builtin,2,155534,0x7ff7e7dc0824,204,ArrayFindIndexLoopEagerDeoptContinuation
code-creation,Builtin,2,155542,0x7ff7e7dc0924,32,ArrayFindIndexLoopLazyDeoptContinuation
code-creation,Builtin,2,155551,0x7ff7e7dc0964,320,ArrayFindIndexLoopAfterCallbackLazyDeoptContinuation
code-creation,Builtin,2,155560,0x7ff7e7dc0ae4,532,ArrayFindIndexLoopContinuation
code-creation,Builtin,2,155568,0x7ff7e7dc0d24,1488,ArrayPrototypeFindIndex
code-creation,Builtin,2,155576,0x7ff7e7dc1324,456,ArrayFindLastLoopContinuation
code-creation,Builtin,2,155584,0x7ff7e7dc1524,1732,ArrayPrototypeFindLast
code-creation,Builtin,2,155593,0x7ff7e7dc1c24,452,ArrayFindLastIndexLoopContinuation
code-creation,Builtin,2,155601,0x7ff7e7dc1e24,1728,ArrayPrototypeFindLastIndex
code-creation,Builtin,2,155609,0x7ff7e7dc2524,220,ArrayForEachLoopEagerDeoptContinuation
code-creation,Builtin,2,155618,0x7ff7e7dc2624,220,ArrayForEachLoopLazyDeoptContinuation
code-creation,Builtin,2,155627,0x7ff7e7dc2724,3228,ArrayForEachLoopContinuation
code-creation,Builtin,2,155637,0x7ff7e7dc33e4,1356,ArrayForEach
code-creation,Builtin,2,155645,0x7ff7e7dc3964,3632,ArrayFrom
code-creation,Builtin,2,155652,0x7ff7e7dc47a4,160,ArrayIsArray
code-creation,Builtin,2,155660,0x7ff7e7dc4864,424,LoadJoinElement_DictionaryElements_0
code-creation,Builtin,2,155669,0x7ff7e7dc4a24,44,LoadJoinElement_FastSmiOrObjectElements_0
code-creation,Builtin,2,155677,0x7ff7e7dc4a64,144,LoadJoinElement_FastDoubleElements_0
code-creation,Builtin,2,155686,0x7ff7e7dc4b24,332,ConvertToLocaleString
code-creation,Builtin,2,155694,0x7ff7e7dc4ca4,772,JoinStackPush
code-creation,Builtin,2,155702,0x7ff7e7dc4fe4,284,JoinStackPop
code-creation,Builtin,2,155709,0x7ff7e7dc5124,6744,ArrayPrototypeJoin
code-creation,Builtin,2,155717,0x7ff7e7dc6ba4,5460,ArrayPrototypeToLocaleString
code-creation,Builtin,2,155726,0x7ff7e7dc8124,236,ArrayPrototypeToString
code-creation,Builtin,2,155734,0x7ff7e7dc8224,6036,TypedArrayPrototypeJoin
code-creation,Builtin,2,155742,0x7ff7e7dc99e4,4732,TypedArrayPrototypeToLocaleString
code-creation,Builtin,2,155750,0x7ff7e7dcac64,3864,ArrayPrototypeLastIndexOf
code-creation,Builtin,2,155758,0x7ff7e7dcbba4,260,ArrayMapPreLoopLazyDeoptContinuation
code-creation,Builtin,2,155767,0x7ff7e7dcbce4,252,ArrayMapLoopEagerDeoptContinuation
code-creation,Builtin,2,155775,0x7ff7e7dcbde4,532,ArrayMapLoopLazyDeoptContinuation
code-creation,Builtin,2,155784,0x7ff7e7dcc024,3260,ArrayMapLoopContinuation
code-creation,Builtin,2,155792,0x7ff7e7dccce4,3944,ArrayMap
code-creation,Builtin,2,155799,0x7ff7e7dcdc64,1012,ArrayOf
code-creation,Builtin,2,155807,0x7ff7e7dce064,444,ArrayReduceRightPreLoopEagerDeoptContinuation
code-creation,Builtin,2,155816,0x7ff7e7dce224,204,ArrayReduceRightLoopEagerDeoptContinuation
code-creation,Builtin,2,155824,0x7ff7e7dce324,204,ArrayReduceRightLoopLazyDeoptContinuation
code-creation,Builtin,2,155833,0x7ff7e7dce424,3272,ArrayReduceRightLoopContinuation
code-creation,Builtin,2,155841,0x7ff7e7dcf124,2032,ArrayReduceRight
code-creation,Builtin,2,155849,0x7ff7e7dcf924,180,ArrayReducePreLoopEagerDeoptContinuation
code-creation,Builtin,2,155858,0x7ff7e7dcf9e4,204,ArrayReduceLoopEagerDeoptContinuation
code-creation,Builtin,2,155866,0x7ff7e7dcfae4,204,ArrayReduceLoopLazyDeoptContinuation
code-creation,Builtin,2,155875,0x7ff7e7dcfbe4,3328,ArrayReduceLoopContinuation
code-creation,Builtin,2,155883,0x7ff7e7dd0924,1636,ArrayReduce
code-creation,Builtin,2,155891,0x7ff7e7dd0fa4,3252,ArrayPrototypeReverse
code-creation,Builtin,2,155899,0x7ff7e7dd1c64,3652,ArrayPrototypeShift
code-creation,Builtin,2,155907,0x7ff7e7dd2ae4,5340,ArrayPrototypeSlice
code-creation,Builtin,2,155915,0x7ff7e7dd3fe4,220,ArraySomeLoopEagerDeoptContinuation
code-creation,Builtin,2,155923,0x7ff7e7dd40e4,592,ArraySomeLoopLazyDeoptContinuation
code-creation,Builtin,2,155932,0x7ff7e7dd4364,3380,ArraySomeLoopContinuation
code-creation,Builtin,2,155940,0x7ff7e7dd50a4,1484,ArraySome
code-creation,Builtin,2,155947,0x7ff7e7dd56a4,14328,ArrayPrototypeSplice
code-creation,Builtin,2,155956,0x7ff7e7dd8ea4,3280,ArrayPrototypeUnshift
code-creation,Builtin,2,155964,0x7ff7e7dd9ba4,332,ArrayBufferPrototypeGetByteLength
code-creation,Builtin,2,155972,0x7ff7e7dd9d24,348,ArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,155980,0x7ff7e7dd9ea4,216,ArrayBufferPrototypeGetResizable
code-creation,Builtin,2,155989,0x7ff7e7dd9fa4,332,SharedArrayBufferPrototypeGetMaxByteLength
code-creation,Builtin,2,155997,0x7ff7e7dda124,216,SharedArrayBufferPrototypeGetGrowable
code-creation,Builtin,2,156006,0x7ff7e7dda224,104,ArrayBufferIsView
code-creation,Builtin,2,156014,0x7ff7e7dda2a4,396,ToInteger
code-creation,Builtin,2,156021,0x7ff7e7dda464,3120,FastCreateDataProperty
code-creation,Builtin,2,156029,0x7ff7e7ddb0a4,680,CheckNumberInRange
code-creation,Builtin,2,156037,0x7ff7e7ddb364,640,CheckSameObject
code-creation,Builtin,2,156045,0x7ff7e7ddb624,944,BooleanConstructor
code-creation,Builtin,2,156053,0x7ff7e7ddb9e4,164,BooleanPrototypeToString
code-creation,Builtin,2,156062,0x7ff7e7ddbaa4,156,BooleanPrototypeValueOf
code-creation,Builtin,2,156072,0x7ff7e7ddbb64,1220,BigIntAddNoThrow
code-creation,Builtin,2,156080,0x7ff7e7ddc064,1316,BigIntAdd
code-creation,Builtin,2,156087,0x7ff7e7ddc5a4,1220,BigIntSubtractNoThrow
code-creation,Builtin,2,156099,0x7ff7e7ddcaa4,1316,BigIntSubtract
code-creation,Builtin,2,156108,0x7ff7e7ddcfe4,284,BigIntUnaryMinus
code-creation,Builtin,2,156115,0x7ff7e7ddd124,1352,ToString
code-creation,Builtin,2,156123,0x7ff7e7ddd6a4,156,StringPrototypeToString
code-creation,Builtin,2,156131,0x7ff7e7ddd764,156,StringPrototypeValueOf
code-creation,Builtin,2,156139,0x7ff7e7ddd824,2512,StringToList
code-creation,Builtin,2,156148,0x7ff7e7dde224,1032,StringPrototypeCharAt
code-creation,Builtin,2,156156,0x7ff7e7dde664,708,StringPrototypeCharCodeAt
code-creation,Builtin,2,156164,0x7ff7e7dde964,1304,StringPrototypeCodePointAt
code-creation,Builtin,2,156183,0x7ff7e7ddeea4,412,StringPrototypeConcat
code-creation,Builtin,2,156192,0x7ff7e7ddf064,1036,StringConstructor
code-creation,Builtin,2,156209,0x7ff7e7ddf4a4,1408,StringAddConvertLeft
code-creation,Builtin,2,156217,0x7ff7e7ddfa64,1452,StringAddConvertRight
code-creation,Builtin,2,156225,0x7ff7e7de0024,824,StringCharAt
code-creation,Builtin,2,156233,0x7ff7e7de0364,16,FastNewClosureBaseline
code-creation,Builtin,2,156241,0x7ff7e7de03a4,200,FastNewFunctionContextEval
code-creation,Builtin,2,156250,0x7ff7e7de04a4,200,FastNewFunctionContextFunction
code-creation,Builtin,2,156258,0x7ff7e7de05a4,248,CreateRegExpLiteral
code-creation,Builtin,2,156266,0x7ff7e7de06a4,1080,CreateShallowArrayLiteral
code-creation,Builtin,2,156274,0x7ff7e7de0ae4,504,CreateEmptyArrayLiteral
code-creation,Builtin,2,156282,0x7ff7e7de0ce4,1860,CreateShallowObjectLiteral
code-creation,Builtin,2,156290,0x7ff7e7de1464,400,ObjectConstructor
code-creation,Builtin,2,156298,0x7ff7e7de1624,180,CreateEmptyLiteralObject
code-creation,Builtin,2,156307,0x7ff7e7de16e4,540,NumberConstructor
code-creation,Builtin,2,156314,0x7ff7e7de1924,64,GenericLazyDeoptContinuation
code-creation,Builtin,2,156323,0x7ff7e7de19a4,64,StringToNumber
code-creation,Builtin,2,156331,0x7ff7e7de1a24,184,NonNumberToNumber
code-creation,Builtin,2,156339,0x7ff7e7de1ae4,240,NonNumberToNumeric
code-creation,Builtin,2,156346,0x7ff7e7de1be4,36,ToNumeric
code-creation,Builtin,2,156354,0x7ff7e7de1c24,1192,NumberToString
code-creation,Builtin,2,156362,0x7ff7e7de20e4,104,ToBoolean
code-creation,Builtin,2,156370,0x7ff7e7de2164,100,ToBooleanForBaselineJump
code-creation,Builtin,2,156378,0x7ff7e7de21e4,728,ToLength
code-creation,Builtin,2,156386,0x7ff7e7de24e4,1320,ToName
code-creation,Builtin,2,156393,0x7ff7e7de2a24,768,ToObject
code-creation,Builtin,2,156401,0x7ff7e7de2d64,236,NonPrimitiveToPrimitive_Default
code-creation,Builtin,2,156409,0x7ff7e7de2e64,236,NonPrimitiveToPrimitive_Number
code-creation,Builtin,2,156417,0x7ff7e7de2f64,236,NonPrimitiveToPrimitive_String
code-creation,Builtin,2,156426,0x7ff7e7de3064,328,OrdinaryToPrimitive_Number
code-creation,Builtin,2,156434,0x7ff7e7de31e4,328,OrdinaryToPrimitive_String
code-creation,Builtin,2,156442,0x7ff7e7de3364,232,FastConsoleAssert
code-creation,Builtin,2,156450,0x7ff7e7de3464,160,DataViewPrototypeGetBuffer
code-creation,Builtin,2,156458,0x7ff7e7de3524,368,DataViewPrototypeGetByteLength
code-creation,Builtin,2,156466,0x7ff7e7de36a4,368,DataViewPrototypeGetByteOffset
code-creation,Builtin,2,156475,0x7ff7e7de3824,592,DataViewPrototypeGetUint8
code-creation,Builtin,2,156483,0x7ff7e7de3aa4,592,DataViewPrototypeGetInt8
code-creation,Builtin,2,156491,0x7ff7e7de3d24,660,DataViewPrototypeGetUint16
code-creation,Builtin,2,156499,0x7ff7e7de3fe4,656,DataViewPrototypeGetInt16
code-creation,Builtin,2,156507,0x7ff7e7de42a4,824,DataViewPrototypeGetUint32
code-creation,Builtin,2,156516,0x7ff7e7de45e4,700,DataViewPrototypeGetInt32
code-creation,Builtin,2,156524,0x7ff7e7de48a4,860,DataViewPrototypeGetFloat32
code-creation,Builtin,2,156532,0x7ff7e7de4c24,924,DataViewPrototypeGetFloat64
code-creation,Builtin,2,156540,0x7ff7e7de4fe4,1000,DataViewPrototypeGetBigUint64
code-creation,Builtin,2,156550,0x7ff7e7de53e4,1016,DataViewPrototypeGetBigInt64
code-creation,Builtin,2,156559,0x7ff7e7de57e4,952,DataViewPrototypeSetUint8
code-creation,Builtin,2,156567,0x7ff7e7de5ba4,952,DataViewPrototypeSetInt8
code-creation,Builtin,2,156576,0x7ff7e7de5f64,1048,DataViewPrototypeSetUint16
code-creation,Builtin,2,156584,0x7ff7e7de63a4,1048,DataViewPrototypeSetInt16
code-creation,Builtin,2,156592,0x7ff7e7de67e4,1088,DataViewPrototypeSetUint32
code-creation,Builtin,2,156600,0x7ff7e7de6c64,1088,DataViewPrototypeSetInt32
code-creation,Builtin,2,156608,0x7ff7e7de70e4,1052,DataViewPrototypeSetFloat32
code-creation,Builtin,2,156617,0x7ff7e7de7524,1116,DataViewPrototypeSetFloat64
code-creation,Builtin,2,156625,0x7ff7e7de79a4,968,DataViewPrototypeSetBigUint64
code-creation,Builtin,2,156633,0x7ff7e7de7da4,968,DataViewPrototypeSetBigInt64
code-creation,Builtin,2,156641,0x7ff7e7de81a4,852,FinalizationRegistryConstructor
code-creation,Builtin,2,156650,0x7ff7e7de8524,1180,FinalizationRegistryRegister
code-creation,Builtin,2,156658,0x7ff7e7de89e4,688,FinalizationRegistryPrototypeCleanupSome
code-creation,Builtin,2,156667,0x7ff7e7de8ca4,340,FunctionPrototypeHasInstance
code-creation,Builtin,2,156675,0x7ff7e7de8e24,936,FastFunctionPrototypeBind
code-creation,Builtin,2,156683,0x7ff7e7de91e4,96,IncBlockCounter
code-creation,Builtin,2,156691,0x7ff7e7de9264,228,GetTemplateObject
code-creation,Builtin,2,156699,0x7ff7e7de9364,28,BytecodeBudgetInterruptFromCode
code-creation,Builtin,2,156707,0x7ff7e7de93a4,92,ForInNext
code-creation,Builtin,2,156715,0x7ff7e7de9424,132,GetImportMetaObjectBaseline
code-creation,Builtin,2,156723,0x7ff7e7de94e4,116,GetIteratorWithFeedback
code-creation,Builtin,2,156731,0x7ff7e7de9564,100,GetIteratorBaseline
code-creation,Builtin,2,156739,0x7ff7e7de95e4,272,CreateAsyncFromSyncIteratorBaseline
code-creation,Builtin,2,156747,0x7ff7e7de9724,1076,CallIteratorWithFeedback
code-creation,Builtin,2,156755,0x7ff7e7de9b64,288,MathAbs
code-creation,Builtin,2,156763,0x7ff7e7de9ca4,428,MathCeil
code-creation,Builtin,2,156771,0x7ff7e7de9e64,432,MathFloor
code-creation,Builtin,2,156778,0x7ff7e7dea024,488,MathRound
code-creation,Builtin,2,156786,0x7ff7e7dea224,428,MathTrunc
code-creation,Builtin,2,156794,0x7ff7e7dea3e4,376,MathPow
code-creation,Builtin,2,156801,0x7ff7e7dea564,404,MathMax
code-creation,Builtin,2,156809,0x7ff7e7dea724,408,MathMin
code-creation,Builtin,2,156817,0x7ff7e7dea8e4,328,MathAcos
code-creation,Builtin,2,156824,0x7ff7e7deaa64,328,MathAcosh
code-creation,Builtin,2,156832,0x7ff7e7deabe4,328,MathAsin
code-creation,Builtin,2,156840,0x7ff7e7dead64,328,MathAsinh
code-creation,Builtin,2,156847,0x7ff7e7deaee4,328,MathAtan
code-creation,Builtin,2,156855,0x7ff7e7deb064,424,MathAtan2
code-creation,Builtin,2,156862,0x7ff7e7deb224,328,MathAtanh
code-creation,Builtin,2,156870,0x7ff7e7deb3a4,328,MathCbrt
code-creation,Builtin,2,156878,0x7ff7e7deb524,168,MathClz32
code-creation,Builtin,2,156885,0x7ff7e7deb5e4,328,MathCos
code-creation,Builtin,2,156893,0x7ff7e7deb764,328,MathCosh
code-creation,Builtin,2,156901,0x7ff7e7deb8e4,328,MathExp
code-creation,Builtin,2,156908,0x7ff7e7deba64,328,MathExpm1
code-creation,Builtin,2,156916,0x7ff7e7debbe4,272,MathFround
code-creation,Builtin,2,156924,0x7ff7e7debd24,304,MathImul
code-creation,Builtin,2,156932,0x7ff7e7debe64,328,MathLog
code-creation,Builtin,2,156939,0x7ff7e7debfe4,328,MathLog1p
code-creation,Builtin,2,156947,0x7ff7e7dec164,328,MathLog10
code-creation,Builtin,2,156955,0x7ff7e7dec2e4,328,MathLog2
code-creation,Builtin,2,156962,0x7ff7e7dec464,328,MathSin
code-creation,Builtin,2,156970,0x7ff7e7dec5e4,180,MathSign
code-creation,Builtin,2,156978,0x7ff7e7dec6a4,328,MathSinh
code-creation,Builtin,2,156985,0x7ff7e7dec824,268,MathSqrt
code-creation,Builtin,2,156993,0x7ff7e7dec964,328,MathTan
code-creation,Builtin,2,157000,0x7ff7e7decae4,328,MathTanh
code-creation,Builtin,2,157008,0x7ff7e7decc64,1072,MathHypot
code-creation,Builtin,2,157016,0x7ff7e7ded0a4,340,MathRandom
code-creation,Builtin,2,157024,0x7ff7e7ded224,2980,NumberPrototypeToString
code-creation,Builtin,2,157060,0x7ff7e7dedde4,156,NumberIsFinite
code-creation,Builtin,2,157070,0x7ff7e7dedea4,344,NumberIsInteger
code-creation,Builtin,2,157078,0x7ff7e7dee024,128,NumberIsNaN
code-creation,Builtin,2,157086,0x7ff7e7dee0e4,376,NumberIsSafeInteger
code-creation,Builtin,2,157094,0x7ff7e7dee264,156,NumberPrototypeValueOf
code-creation,Builtin,2,157102,0x7ff7e7dee324,196,NumberParseFloat
code-creation,Builtin,2,157110,0x7ff7e7dee424,248,ParseInt
code-creation,Builtin,2,157117,0x7ff7e7dee524,84,NumberParseInt
code-creation,Builtin,2,157125,0x7ff7e7dee5a4,860,Add
code-creation,Builtin,2,157133,0x7ff7e7dee924,424,Subtract
code-creation,Builtin,2,157140,0x7ff7e7deeae4,608,Multiply
code-creation,Builtin,2,157148,0x7ff7e7deed64,532,Divide
code-creation,Builtin,2,157156,0x7ff7e7deefa4,592,Modulus
code-creation,Builtin,2,157163,0x7ff7e7def224,536,Exponentiate
code-creation,Builtin,2,157183,0x7ff7e7def464,344,Negate
code-creation,Builtin,2,157191,0x7ff7e7def5e4,112,BitwiseNot
code-creation,Builtin,2,157208,0x7ff7e7def664,112,Decrement
code-creation,Builtin,2,157216,0x7ff7e7def6e4,112,Increment
code-creation,Builtin,2,157224,0x7ff7e7def764,392,ShiftLeft
code-creation,Builtin,2,157231,0x7ff7e7def924,392,ShiftRight
code-creation,Builtin,2,157239,0x7ff7e7defae4,508,ShiftRightLogical
code-creation,Builtin,2,157247,0x7ff7e7defce4,388,BitwiseAnd
code-creation,Builtin,2,157255,0x7ff7e7defea4,388,BitwiseOr
code-creation,Builtin,2,157263,0x7ff7e7df0064,388,BitwiseXor
code-creation,Builtin,2,157270,0x7ff7e7df0224,804,LessThan
code-creation,Builtin,2,157278,0x7ff7e7df0564,804,LessThanOrEqual
code-creation,Builtin,2,157286,0x7ff7e7df08a4,804,GreaterThan
code-creation,Builtin,2,157294,0x7ff7e7df0be4,804,GreaterThanOrEqual
code-creation,Builtin,2,157302,0x7ff7e7df0f24,864,Equal
code-creation,Builtin,2,157309,0x7ff7e7df12a4,356,StrictEqual
code-creation,Builtin,2,157317,0x7ff7e7df1424,3248,ObjectFromEntries
code-creation,Builtin,2,157325,0x7ff7e7df20e4,772,CreateObjectWithoutProperties
code-creation,Builtin,2,157333,0x7ff7e7df2424,144,ObjectIsExtensible
code-creation,Builtin,2,157341,0x7ff7e7df24e4,152,ObjectPreventExtensions
code-creation,Builtin,2,157349,0x7ff7e7df25a4,144,ObjectGetPrototypeOf
code-creation,Builtin,2,157357,0x7ff7e7df2664,312,ObjectSetPrototypeOf
code-creation,Builtin,2,157365,0x7ff7e7df27a4,80,ObjectPrototypeToString
code-creation,Builtin,2,157373,0x7ff7e7df2824,96,ObjectPrototypeValueOf
code-creation,Builtin,2,157381,0x7ff7e7df28a4,176,ObjectPrototypeToLocaleString
code-creation,Builtin,2,157390,0x7ff7e7df2964,872,FulfillPromise
code-creation,Builtin,2,157397,0x7ff7e7df2ce4,996,RejectPromise
code-creation,Builtin,2,157405,0x7ff7e7df30e4,2432,NewPromiseCapability
code-creation,Builtin,2,157413,0x7ff7e7df3aa4,172,PromiseCapabilityDefaultReject
code-creation,Builtin,2,157422,0x7ff7e7df3b64,156,PromiseCapabilityDefaultResolve
code-creation,Builtin,2,157430,0x7ff7e7df3c24,1416,PerformPromiseThen
code-creation,Builtin,2,157438,0x7ff7e7df41e4,660,PromiseReject
code-creation,Builtin,2,157446,0x7ff7e7df44a4,292,PromiseGetCapabilitiesExecutor
code-creation,Builtin,2,157454,0x7ff7e7df45e4,112,PromiseConstructorLazyDeoptContinuation
code-creation,Builtin,2,157463,0x7ff7e7df4664,4616,PromiseAll
code-creation,Builtin,2,157470,0x7ff7e7df58a4,4936,PromiseAllSettled
code-creation,Builtin,2,157478,0x7ff7e7df6c24,1116,PromiseAllResolveElementClosure
code-creation,Builtin,2,157486,0x7ff7e7df70a4,1412,PromiseAllSettledResolveElementClosure
code-creation,Builtin,2,157495,0x7ff7e7df7664,1420,PromiseAllSettledRejectElementClosure
code-creation,Builtin,2,157504,0x7ff7e7df7c24,1192,PromiseAnyRejectElementClosure
code-creation,Builtin,2,157512,0x7ff7e7df80e4,2404,PromiseAny
code-creation,Builtin,2,157520,0x7ff7e7df8a64,2964,PromiseConstructor
code-creation,Builtin,2,157527,0x7ff7e7df9624,300,PromisePrototypeCatch
code-creation,Builtin,2,157536,0x7ff7e7df9764,88,PromiseValueThunkFinally
code-creation,Builtin,2,157544,0x7ff7e7df97e4,84,PromiseThrowerFinally
code-creation,Builtin,2,157552,0x7ff7e7df9864,908,PromiseCatchFinally
code-creation,Builtin,2,157588,0x7ff7e7df9c24,908,PromiseThenFinally
code-creation,Builtin,2,157598,0x7ff7e7df9fe4,1740,PromisePrototypeFinally
code-creation,Builtin,2,157607,0x7ff7e7dfa6e4,1372,PromiseRace
code-creation,Builtin,2,157614,0x7ff7e7dfac64,316,PromiseFulfillReactionJob
code-creation,Builtin,2,157622,0x7ff7e7dfada4,424,PromiseRejectReactionJob
code-creation,Builtin,2,157631,0x7ff7e7dfaf64,156,PromiseResolveTrampoline
code-creation,Builtin,2,157639,0x7ff7e7dfb024,668,PromiseResolve
code-creation,Builtin,2,157647,0x7ff7e7dfb2e4,712,ResolvePromise
code-creation,Builtin,2,157654,0x7ff7e7dfb5e4,2248,PromisePrototypeThen
code-creation,Builtin,2,157663,0x7ff7e7dfbee4,1152,PromiseResolveThenableJob
code-creation,Builtin,2,157671,0x7ff7e7dfc3a4,448,ProxyConstructor
code-creation,Builtin,2,157679,0x7ff7e7dfc5a4,1796,ProxyDeleteProperty
code-creation,Builtin,2,157687,0x7ff7e7dfcce4,2152,ProxyGetProperty
code-creation,Builtin,2,157695,0x7ff7e7dfd564,1084,ProxyGetPrototypeOf
code-creation,Builtin,2,157703,0x7ff7e7dfd9a4,1708,ProxyHasProperty
code-creation,Builtin,2,157710,0x7ff7e7dfe064,796,ProxyIsExtensible
code-creation,Builtin,2,157718,0x7ff7e7dfe3a4,840,ProxyPreventExtensions
code-creation,Builtin,2,157726,0x7ff7e7dfe724,1152,ProxyRevocable
code-creation,Builtin,2,157734,0x7ff7e7dfebe4,132,ProxyRevoke
code-creation,Builtin,2,157742,0x7ff7e7dfeca4,2264,ProxySetProperty
code-creation,Builtin,2,157750,0x7ff7e7dff5a4,1340,ProxySetPrototypeOf
code-creation,Builtin,2,157758,0x7ff7e7dffae4,212,ReflectIsExtensible
code-creation,Builtin,2,157766,0x7ff7e7dffbe4,216,ReflectPreventExtensions
code-creation,Builtin,2,157774,0x7ff7e7dffce4,188,ReflectGetPrototypeOf
code-creation,Builtin,2,157782,0x7ff7e7dffda4,300,ReflectSetPrototypeOf
code-creation,Builtin,2,157790,0x7ff7e7dffee4,296,ReflectGet
code-creation,Builtin,2,157798,0x7ff7e7e00024,160,ReflectDeleteProperty
code-creation,Builtin,2,157806,0x7ff7e7e000e4,148,ReflectHas
code-creation,Builtin,2,157819,0x7ff7e7e001a4,5188,RegExpPrototypeExecSlow
code-creation,Builtin,2,157827,0x7ff7e7e01624,5160,RegExpPrototypeExec
code-creation,Builtin,2,157835,0x7ff7e7e02a64,2400,RegExpPrototypeMatchAll
code-creation,Builtin,2,157844,0x7ff7e7e033e4,9516,RegExpStringIteratorPrototypeNext
code-creation,Builtin,2,157852,0x7ff7e7e05924,8932,RegExpMatchFast
code-creation,Builtin,2,157860,0x7ff7e7e07c24,3648,RegExpPrototypeMatch
code-creation,Builtin,2,157868,0x7ff7e7e08aa4,6364,RegExpReplace
code-creation,Builtin,2,157876,0x7ff7e7e0a3a4,528,RegExpPrototypeReplace
code-creation,Builtin,2,157884,0x7ff7e7e0a5e4,1424,RegExpSearchFast
code-creation,Builtin,2,157892,0x7ff7e7e0aba4,1652,RegExpPrototypeSearch
code-creation,Builtin,2,157900,0x7ff7e7e0b224,200,RegExpPrototypeSourceGetter
code-creation,Builtin,2,157908,0x7ff7e7e0b324,5968,RegExpSplit
code-creation,Builtin,2,157916,0x7ff7e7e0caa4,480,RegExpPrototypeSplit
code-creation,Builtin,2,157924,0x7ff7e7e0cca4,2276,RegExpPrototypeTest
code-creation,Builtin,2,157932,0x7ff7e7e0d5a4,1360,RegExpPrototypeTestFast
code-creation,Builtin,2,157940,0x7ff7e7e0db24,236,RegExpPrototypeGlobalGetter
code-creation,Builtin,2,157948,0x7ff7e7e0dc24,252,RegExpPrototypeIgnoreCaseGetter
code-creation,Builtin,2,157957,0x7ff7e7e0dd24,252,RegExpPrototypeMultilineGetter
code-creation,Builtin,2,157965,0x7ff7e7e0de24,252,RegExpPrototypeHasIndicesGetter
code-creation,Builtin,2,157973,0x7ff7e7e0df24,252,RegExpPrototypeLinearGetter
code-creation,Builtin,2,157982,0x7ff7e7e0e024,252,RegExpPrototypeDotAllGetter
code-creation,Builtin,2,157990,0x7ff7e7e0e124,280,RegExpPrototypeStickyGetter
code-creation,Builtin,2,157998,0x7ff7e7e0e264,280,RegExpPrototypeUnicodeGetter
code-creation,Builtin,2,158006,0x7ff7e7e0e3a4,2316,RegExpPrototypeFlagsGetter
code-creation,Builtin,2,158014,0x7ff7e7e0ece4,1520,StringPrototypeAt
code-creation,Builtin,2,158022,0x7ff7e7e0f2e4,3092,StringPrototypeEndsWith
code-creation,Builtin,2,158031,0x7ff7e7e0ff24,488,CreateHTML
code-creation,Builtin,2,158038,0x7ff7e7e10124,164,StringPrototypeAnchor
code-creation,Builtin,2,158046,0x7ff7e7e101e4,132,StringPrototypeBig
code-creation,Builtin,2,158083,0x7ff7e7e102a4,132,StringPrototypeBlink
code-creation,Builtin,2,158093,0x7ff7e7e10364,132,StringPrototypeBold
code-creation,Builtin,2,158101,0x7ff7e7e10424,172,StringPrototypeFontcolor
code-creation,Builtin,2,158109,0x7ff7e7e104e4,172,StringPrototypeFontsize
code-creation,Builtin,2,158117,0x7ff7e7e105a4,132,StringPrototypeFixed
code-creation,Builtin,2,158125,0x7ff7e7e10664,132,StringPrototypeItalics
code-creation,Builtin,2,158133,0x7ff7e7e10724,172,StringPrototypeLink
code-creation,Builtin,2,158141,0x7ff7e7e107e4,132,StringPrototypeSmall
code-creation,Builtin,2,158149,0x7ff7e7e108a4,132,StringPrototypeStrike
code-creation,Builtin,2,158157,0x7ff7e7e10964,132,StringPrototypeSub
code-creation,Builtin,2,158175,0x7ff7e7e10a24,132,StringPrototypeSup
code-creation,Builtin,2,158185,0x7ff7e7e10ae4,1060,StringPrototypeIncludes
code-creation,Builtin,2,158202,0x7ff7e7e10f24,644,StringPrototypeIndexOf
code-creation,Builtin,2,158210,0x7ff7e7e111e4,348,StringPrototypeIterator
code-creation,Builtin,2,158219,0x7ff7e7e11364,2044,StringIteratorPrototypeNext
code-creation,Builtin,2,158227,0x7ff7e7e11b64,1344,StringPrototypeMatch
code-creation,Builtin,2,158235,0x7ff7e7e120e4,1344,StringPrototypeSearch
code-creation,Builtin,2,158243,0x7ff7e7e12664,836,StringPrototypePadStart
code-creation,Builtin,2,158251,0x7ff7e7e129e4,840,StringPrototypePadEnd
code-creation,Builtin,2,158259,0x7ff7e7e12d64,120,StringRepeat
code-creation,Builtin,2,158267,0x7ff7e7e12de4,408,StringPrototypeRepeat
code-creation,Builtin,2,158275,0x7ff7e7e12fa4,11512,StringPrototypeReplaceAll
code-creation,Builtin,2,158283,0x7ff7e7e15ca4,3444,StringPrototypeSlice
code-creation,Builtin,2,158291,0x7ff7e7e16a24,3116,StringPrototypeStartsWith
code-creation,Builtin,2,158300,0x7ff7e7e17664,3384,StringPrototypeSubstr
code-creation,Builtin,2,158308,0x7ff7e7e183a4,3316,StringPrototypeSubstring
code-creation,Builtin,2,158316,0x7ff7e7e190a4,7036,StringPrototypeTrim
code-creation,Builtin,2,158324,0x7ff7e7e1ac24,6448,StringPrototypeTrimStart
code-creation,Builtin,2,158332,0x7ff7e7e1c564,5940,StringPrototypeTrimEnd
code-creation,Builtin,2,158340,0x7ff7e7e1dca4,164,SymbolPrototypeDescriptionGetter
code-creation,Builtin,2,158348,0x7ff7e7e1dd64,156,SymbolPrototypeToPrimitive
code-creation,Builtin,2,158357,0x7ff7e7e1de24,176,SymbolPrototypeToString
code-creation,Builtin,2,158365,0x7ff7e7e1dee4,156,SymbolPrototypeValueOf
code-creation,Builtin,2,158373,0x7ff7e7e1dfa4,1180,TypedArrayPrototypeAt
code-creation,Builtin,2,158381,0x7ff7e7e1e464,10260,CreateTypedArray
code-creation,Builtin,2,158389,0x7ff7e7e20ca4,1796,TypedArrayPrototypeEvery
code-creation,Builtin,2,158397,0x7ff7e7e213e4,440,TypedArrayPrototypeEntries
code-creation,Builtin,2,158405,0x7ff7e7e215a4,3680,TypedArrayPrototypeFilter
code-creation,Builtin,2,158414,0x7ff7e7e22424,1112,TypedArrayPrototypeFind
code-creation,Builtin,2,158422,0x7ff7e7e228a4,1116,TypedArrayPrototypeFindIndex
code-creation,Builtin,2,158430,0x7ff7e7e22d24,1104,TypedArrayPrototypeFindLast
code-creation,Builtin,2,158438,0x7ff7e7e231a4,1108,TypedArrayPrototypeFindLastIndex
code-creation,Builtin,2,158446,0x7ff7e7e23624,968,TypedArrayPrototypeForEach
code-creation,Builtin,2,158455,0x7ff7e7e23a24,2372,TypedArrayFrom
code-creation,Builtin,2,158463,0x7ff7e7e243a4,428,TypedArrayPrototypeKeys
code-creation,Builtin,2,158471,0x7ff7e7e24564,1032,TypedArrayOf
code-creation,Builtin,2,158478,0x7ff7e7e249a4,1080,TypedArrayPrototypeReduce
code-creation,Builtin,2,158487,0x7ff7e7e24de4,1080,TypedArrayPrototypeReduceRight
code-creation,Builtin,2,158495,0x7ff7e7e25224,2792,TypedArrayPrototypeSet
code-creation,Builtin,2,158503,0x7ff7e7e25d24,3888,TypedArrayPrototypeSlice
code-creation,Builtin,2,158511,0x7ff7e7e26c64,1788,TypedArrayPrototypeSome
code-creation,Builtin,2,158519,0x7ff7e7e27364,1064,TypedArrayMergeSort
code-creation,Builtin,2,158527,0x7ff7e7e277a4,1652,TypedArrayPrototypeSort
code-creation,Builtin,2,158535,0x7ff7e7e27e24,2812,TypedArrayPrototypeSubArray
code-creation,Builtin,2,158543,0x7ff7e7e28924,440,TypedArrayPrototypeValues
code-creation,Builtin,2,158552,0x7ff7e7e28ae4,976,WeakRefConstructor
code-creation,Builtin,2,158588,0x7ff7e7e28ee4,184,WeakRefDeref
code-creation,Builtin,2,158597,0x7ff7e7e28fa4,696,NewSloppyArgumentsElements
code-creation,Builtin,2,158606,0x7ff7e7e29264,308,NewStrictArgumentsElements
code-creation,Builtin,2,158614,0x7ff7e7e293a4,336,NewRestArgumentsElements
code-creation,Builtin,2,158622,0x7ff7e7e29524,1404,FastNewSloppyArguments
code-creation,Builtin,2,158630,0x7ff7e7e29aa4,528,FastNewStrictArguments
code-creation,Builtin,2,158639,0x7ff7e7e29ce4,560,FastNewRestArguments
code-creation,Builtin,2,158647,0x7ff7e7e29f24,700,StringSlowFlatten
code-creation,Builtin,2,158655,0x7ff7e7e2a1e4,2180,StringIndexOf
code-creation,Builtin,2,158663,0x7ff7e7e2aaa4,4,GenericBuiltinTest_JSAny_0
code-creation,Builtin,2,158671,0x7ff7e7e2aae4,20,TestHelperPlus1
code-creation,Builtin,2,158679,0x7ff7e7e2ab24,20,TestHelperPlus2
code-creation,Builtin,2,158687,0x7ff7e7e2ab64,96,NewSmiBox
code-creation,Builtin,2,158694,0x7ff7e7e2abe4,24,ReturnTwoValues
code-creation,Builtin,2,158702,0x7ff7e7e2ac24,32,Load_FastSmiElements_0
code-creation,Builtin,2,158710,0x7ff7e7e2ac64,32,Load_FastObjectElements_0
code-creation,Builtin,2,158718,0x7ff7e7e2aca4,148,Load_FastDoubleElements_0
code-creation,Builtin,2,158727,0x7ff7e7e2ad64,32,Store_FastSmiElements_0
code-creation,Builtin,2,158735,0x7ff7e7e2ada4,96,Store_FastObjectElements_0
code-creation,Builtin,2,158743,0x7ff7e7e2ae24,48,Store_FastDoubleElements_0
code-creation,Builtin,2,158751,0x7ff7e7e2ae64,40,Delete_FastSmiElements_0
code-creation,Builtin,2,158759,0x7ff7e7e2aea4,40,Delete_FastObjectElements_0
code-creation,Builtin,2,158767,0x7ff7e7e2aee4,44,Delete_FastDoubleElements_0
code-creation,Builtin,2,158775,0x7ff7e7e2af24,324,SortCompareDefault
code-creation,Builtin,2,158783,0x7ff7e7e2b0a4,96,SortCompareUserFn
code-creation,Builtin,2,158791,0x7ff7e7e2b124,12,CanUseSameAccessor_GenericElementsAccessor_0
code-creation,Builtin,2,158800,0x7ff7e7e2b164,312,Copy
code-creation,Builtin,2,158808,0x7ff7e7e2b2a4,5800,MergeAt
code-creation,Builtin,2,158815,0x7ff7e7e2c964,792,GallopLeft
code-creation,Builtin,2,158823,0x7ff7e7e2cca4,832,GallopRight
code-creation,Builtin,2,158831,0x7ff7e7e2d024,3852,ArrayTimSort
code-creation,Builtin,2,158839,0x7ff7e7e2df64,2160,ArrayPrototypeSort
code-creation,Builtin,2,158847,0x7ff7e7e2e7e4,100,WasmInt32ToHeapNumber
code-creation,Builtin,2,158855,0x7ff7e7e2e864,124,WasmTaggedNonSmiToInt32
code-creation,Builtin,2,158863,0x7ff7e7e2e8e4,76,WasmTaggedToFloat64
code-creation,Builtin,2,158871,0x7ff7e7e2e964,72,WasmMemoryGrow
code-creation,Builtin,2,158879,0x7ff7e7e2e9e4,100,WasmTableInit
code-creation,Builtin,2,158886,0x7ff7e7e2ea64,100,WasmTableCopy
code-creation,Builtin,2,158894,0x7ff7e7e2eae4,84,WasmTableFill
code-creation,Builtin,2,158902,0x7ff7e7e2eb64,72,WasmTableGrow
code-creation,Builtin,2,158910,0x7ff7e7e2ebe4,144,WasmTableGet
code-creation,Builtin,2,158918,0x7ff7e7e2eca4,240,WasmTableSet
code-creation,Builtin,2,158925,0x7ff7e7e2eda4,96,WasmRefFunc
code-creation,Builtin,2,158933,0x7ff7e7e2ee24,148,WasmAllocateFixedArray
code-creation,Builtin,2,158941,0x7ff7e7e2eee4,44,WasmThrow
code-creation,Builtin,2,158949,0x7ff7e7e2ef24,56,WasmRethrow
code-creation,Builtin,2,158957,0x7ff7e7e2ef64,44,WasmTriggerTierUp
code-creation,Builtin,2,158965,0x7ff7e7e2efa4,32,WasmStackGuard
code-creation,Builtin,2,158972,0x7ff7e7e2efe4,32,WasmStackOverflow
code-creation,Builtin,2,158980,0x7ff7e7e2f024,40,WasmTraceMemory
code-creation,Builtin,2,158988,0x7ff7e7e2f064,32,WasmTraceEnter
code-creation,Builtin,2,158996,0x7ff7e7e2f0a4,40,WasmTraceExit
code-creation,Builtin,2,159004,0x7ff7e7e2f0e4,344,WasmAllocateJSArray
code-creation,Builtin,2,159012,0x7ff7e7e2f264,104,WasmAllocatePair
code-creation,Builtin,2,159020,0x7ff7e7e2f2e4,64,WasmAllocateRtt
code-creation,Builtin,2,159028,0x7ff7e7e2f364,72,WasmAllocateFreshRtt
code-creation,Builtin,2,159036,0x7ff7e7e2f3e4,124,WasmAllocateStructWithRtt
code-creation,Builtin,2,159044,0x7ff7e7e2f464,140,WasmAllocateArray_Uninitialized
code-creation,Builtin,2,159052,0x7ff7e7e2f524,176,WasmAllocateArray_InitZero
code-creation,Builtin,2,159088,0x7ff7e7e2f5e4,180,WasmAllocateArray_InitNull
code-creation,Builtin,2,159098,0x7ff7e7e2f6a4,140,WasmArrayCopyWithChecks
code-creation,Builtin,2,159106,0x7ff7e7e2f764,248,WasmAllocateObjectWrapper
code-creation,Builtin,2,159114,0x7ff7e7e2f864,52,WasmSubtypeCheck
code-creation,Builtin,2,159122,0x7ff7e7e2f8a4,8,WasmInt32ToNumber
code-creation,Builtin,2,159130,0x7ff7e7e2f8e4,116,WasmUint32ToNumber
code-creation,Builtin,2,159138,0x7ff7e7e2f964,144,UintPtr53ToNumber
code-creation,Builtin,2,159146,0x7ff7e7e2fa24,96,WasmAtomicNotify
code-creation,Builtin,2,159154,0x7ff7e7e2faa4,116,WasmI32AtomicWait64
code-creation,Builtin,2,159162,0x7ff7e7e2fb24,116,WasmI64AtomicWait64
code-creation,Builtin,2,159182,0x7ff7e7e2fba4,596,WasmGetOwnProperty
code-creation,Builtin,2,159190,0x7ff7e7e2fe24,40,WasmTrap
code-creation,Builtin,2,159207,0x7ff7e7e2fe64,16,ThrowWasmTrapUnreachable
code-creation,Builtin,2,159215,0x7ff7e7e2fea4,16,ThrowWasmTrapMemOutOfBounds
code-creation,Builtin,2,159223,0x7ff7e7e2fee4,16,ThrowWasmTrapUnalignedAccess
code-creation,Builtin,2,159232,0x7ff7e7e2ff24,16,ThrowWasmTrapDivByZero
code-creation,Builtin,2,159240,0x7ff7e7e2ff64,16,ThrowWasmTrapDivUnrepresentable
code-creation,Builtin,2,159248,0x7ff7e7e2ffa4,16,ThrowWasmTrapRemByZero
code-creation,Builtin,2,159256,0x7ff7e7e2ffe4,16,ThrowWasmTrapFloatUnrepresentable
code-creation,Builtin,2,159264,0x7ff7e7e30024,16,ThrowWasmTrapFuncSigMismatch
code-creation,Builtin,2,159273,0x7ff7e7e30064,16,ThrowWasmTrapDataSegmentDropped
code-creation,Builtin,2,159281,0x7ff7e7e300a4,16,ThrowWasmTrapElemSegmentDropped
code-creation,Builtin,2,159289,0x7ff7e7e300e4,16,ThrowWasmTrapTableOutOfBounds
code-creation,Builtin,2,159297,0x7ff7e7e30124,16,ThrowWasmTrapRethrowNull
code-creation,Builtin,2,159306,0x7ff7e7e30164,16,ThrowWasmTrapNullDereference
code-creation,Builtin,2,159314,0x7ff7e7e301a4,16,ThrowWasmTrapIllegalCast
code-creation,Builtin,2,159322,0x7ff7e7e301e4,16,ThrowWasmTrapArrayOutOfBounds
code-creation,Builtin,2,159330,0x7ff7e7e30224,16,ThrowWasmTrapArrayTooLarge
code-creation,Builtin,2,159338,0x7ff7e7e30264,172,LoadJoinElement_GenericElementsAccessor_0
code-creation,Builtin,2,159347,0x7ff7e7e30324,24,LoadJoinTypedElement_Int32Elements_0
code-creation,Builtin,2,159355,0x7ff7e7e30364,116,LoadJoinTypedElement_Float32Elements_0
code-creation,Builtin,2,159364,0x7ff7e7e303e4,112,LoadJoinTypedElement_Float64Elements_0
code-creation,Builtin,2,159372,0x7ff7e7e30464,24,LoadJoinTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,159381,0x7ff7e7e304a4,220,LoadJoinTypedElement_BigUint64Elements_0
code-creation,Builtin,2,159390,0x7ff7e7e305a4,248,LoadJoinTypedElement_BigInt64Elements_0
code-creation,Builtin,2,159398,0x7ff7e7e306a4,24,LoadJoinTypedElement_Uint8Elements_0
code-creation,Builtin,2,159407,0x7ff7e7e306e4,24,LoadJoinTypedElement_Int8Elements_0
code-creation,Builtin,2,159415,0x7ff7e7e30724,24,LoadJoinTypedElement_Uint16Elements_0
code-creation,Builtin,2,159423,0x7ff7e7e30764,24,LoadJoinTypedElement_Int16Elements_0
code-creation,Builtin,2,159432,0x7ff7e7e307a4,132,LoadJoinTypedElement_Uint32Elements_0
code-creation,Builtin,2,159440,0x7ff7e7e30864,12,GenericBuiltinTest_Smi_0
code-creation,Builtin,2,159448,0x7ff7e7e308a4,40,CanUseSameAccessor_FastDoubleElements_0
code-creation,Builtin,2,159457,0x7ff7e7e308e4,40,CanUseSameAccessor_FastSmiElements_0
code-creation,Builtin,2,159466,0x7ff7e7e30924,40,CanUseSameAccessor_FastObjectElements_0
code-creation,Builtin,2,159474,0x7ff7e7e30964,2748,Load_GenericElementsAccessor_0
code-creation,Builtin,2,159483,0x7ff7e7e31424,24,Store_GenericElementsAccessor_0
code-creation,Builtin,2,159491,0x7ff7e7e31464,36,Delete_GenericElementsAccessor_0
code-creation,Builtin,2,159499,0x7ff7e7e314a4,24,LoadTypedElement_Int32Elements_0
code-creation,Builtin,2,159507,0x7ff7e7e314e4,164,StoreTypedElementNumeric_Int32Elements_0
code-creation,Builtin,2,159516,0x7ff7e7e315a4,180,StoreTypedElementJSAny_Int32Elements_0
code-creation,Builtin,2,159525,0x7ff7e7e31664,116,LoadTypedElement_Float32Elements_0
code-creation,Builtin,2,159533,0x7ff7e7e316e4,32,StoreTypedElementNumeric_Float32Elements_0
code-creation,Builtin,2,159576,0x7ff7e7e31724,156,StoreTypedElementJSAny_Float32Elements_0
code-creation,Builtin,2,159586,0x7ff7e7e317e4,112,LoadTypedElement_Float64Elements_0
code-creation,Builtin,2,159595,0x7ff7e7e31864,28,StoreTypedElementNumeric_Float64Elements_0
code-creation,Builtin,2,159604,0x7ff7e7e318a4,152,StoreTypedElementJSAny_Float64Elements_0
code-creation,Builtin,2,159612,0x7ff7e7e31964,24,LoadTypedElement_Uint8ClampedElements_0
code-creation,Builtin,2,159621,0x7ff7e7e319a4,24,StoreTypedElementNumeric_Uint8ClampedElements_0
code-creation,Builtin,2,159629,0x7ff7e7e319e4,620,StoreTypedElementJSAny_Uint8ClampedElements_0
code-creation,Builtin,2,159638,0x7ff7e7e31c64,220,LoadTypedElement_BigUint64Elements_0
code-creation,Builtin,2,159647,0x7ff7e7e31d64,56,StoreTypedElementNumeric_BigUint64Elements_0
code-creation,Builtin,2,159655,0x7ff7e7e31da4,200,StoreTypedElementJSAny_BigUint64Elements_0
code-creation,Builtin,2,159664,0x7ff7e7e31ea4,248,LoadTypedElement_BigInt64Elements_0
code-creation,Builtin,2,159672,0x7ff7e7e31fa4,56,StoreTypedElementNumeric_BigInt64Elements_0
code-creation,Builtin,2,159681,0x7ff7e7e31fe4,200,StoreTypedElementJSAny_BigInt64Elements_0
code-creation,Builtin,2,159690,0x7ff7e7e320e4,24,LoadTypedElement_Uint8Elements_0
code-creation,Builtin,2,159698,0x7ff7e7e32124,24,StoreTypedElementNumeric_Uint8Elements_0
code-creation,Builtin,2,159706,0x7ff7e7e32164,180,StoreTypedElementJSAny_Uint8Elements_0
code-creation,Builtin,2,159715,0x7ff7e7e32224,24,LoadTypedElement_Int8Elements_0
code-creation,Builtin,2,159723,0x7ff7e7e32264,24,StoreTypedElementNumeric_Int8Elements_0
code-creation,Builtin,2,159732,0x7ff7e7e322a4,180,StoreTypedElementJSAny_Int8Elements_0
code-creation,Builtin,2,159740,0x7ff7e7e32364,24,LoadTypedElement_Uint16Elements_0
code-creation,Builtin,2,159749,0x7ff7e7e323a4,24,StoreTypedElementNumeric_Uint16Elements_0
code-creation,Builtin,2,159757,0x7ff7e7e323e4,180,StoreTypedElementJSAny_Uint16Elements_0
code-creation,Builtin,2,159766,0x7ff7e7e324a4,24,LoadTypedElement_Int16Elements_0
code-creation,Builtin,2,159774,0x7ff7e7e324e4,24,StoreTypedElementNumeric_Int16Elements_0
code-creation,Builtin,2,159782,0x7ff7e7e32524,180,StoreTypedElementJSAny_Int16Elements_0
code-creation,Builtin,2,159791,0x7ff7e7e325e4,132,LoadTypedElement_Uint32Elements_0
code-creation,Builtin,2,159799,0x7ff7e7e326a4,164,StoreTypedElementNumeric_Uint32Elements_0
code-creation,Builtin,2,159808,0x7ff7e7e32764,180,StoreTypedElementJSAny_Uint32Elements_0
code-creation,Builtin,2,159816,0x7ff7e7e32824,12,CollatorConstructor
code-creation,Builtin,2,159824,0x7ff7e7e32864,12,CollatorInternalCompare
code-creation,Builtin,2,159832,0x7ff7e7e328a4,12,CollatorPrototypeCompare
code-creation,Builtin,2,159840,0x7ff7e7e328e4,12,CollatorSupportedLocalesOf
code-creation,Builtin,2,159848,0x7ff7e7e32924,12,CollatorPrototypeResolvedOptions
code-creation,Builtin,2,159857,0x7ff7e7e32964,12,DatePrototypeToLocaleDateString
code-creation,Builtin,2,159865,0x7ff7e7e329a4,12,DatePrototypeToLocaleString
code-creation,Builtin,2,159873,0x7ff7e7e329e4,12,DatePrototypeToLocaleTimeString
code-creation,Builtin,2,159882,0x7ff7e7e32a24,12,DateTimeFormatConstructor
code-creation,Builtin,2,159890,0x7ff7e7e32a64,12,DateTimeFormatInternalFormat
code-creation,Builtin,2,159898,0x7ff7e7e32aa4,12,DateTimeFormatPrototypeFormat
code-creation,Builtin,2,159906,0x7ff7e7e32ae4,12,DateTimeFormatPrototypeFormatRange
code-creation,Builtin,2,159915,0x7ff7e7e32b24,12,DateTimeFormatPrototypeFormatRangeToParts
code-creation,Builtin,2,159923,0x7ff7e7e32b64,12,DateTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,159932,0x7ff7e7e32ba4,12,DateTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,159940,0x7ff7e7e32be4,12,DateTimeFormatSupportedLocalesOf
code-creation,Builtin,2,159948,0x7ff7e7e32c24,12,DisplayNamesConstructor
code-creation,Builtin,2,159956,0x7ff7e7e32c64,12,DisplayNamesPrototypeOf
code-creation,Builtin,2,159964,0x7ff7e7e32ca4,12,DisplayNamesPrototypeResolvedOptions
code-creation,Builtin,2,159973,0x7ff7e7e32ce4,12,DisplayNamesSupportedLocalesOf
code-creation,Builtin,2,160009,0x7ff7e7e32d24,12,IntlGetCanonicalLocales
code-creation,Builtin,2,160019,0x7ff7e7e32d64,12,IntlSupportedValuesOf
code-creation,Builtin,2,160027,0x7ff7e7e32da4,12,ListFormatConstructor
code-creation,Builtin,2,160035,0x7ff7e7e32de4,228,ListFormatPrototypeFormat
code-creation,Builtin,2,160043,0x7ff7e7e32ee4,228,ListFormatPrototypeFormatToParts
code-creation,Builtin,2,160052,0x7ff7e7e32fe4,12,ListFormatPrototypeResolvedOptions
code-creation,Builtin,2,160060,0x7ff7e7e33024,12,ListFormatSupportedLocalesOf
code-creation,Builtin,2,160068,0x7ff7e7e33064,12,LocaleConstructor
code-creation,Builtin,2,160076,0x7ff7e7e330a4,12,LocalePrototypeBaseName
code-creation,Builtin,2,160084,0x7ff7e7e330e4,12,LocalePrototypeCalendar
code-creation,Builtin,2,160092,0x7ff7e7e33124,12,LocalePrototypeCalendars
code-creation,Builtin,2,160100,0x7ff7e7e33164,12,LocalePrototypeCaseFirst
code-creation,Builtin,2,160109,0x7ff7e7e331a4,12,LocalePrototypeCollation
code-creation,Builtin,2,160117,0x7ff7e7e331e4,12,LocalePrototypeCollations
code-creation,Builtin,2,160125,0x7ff7e7e33224,12,LocalePrototypeHourCycle
code-creation,Builtin,2,160133,0x7ff7e7e33264,12,LocalePrototypeHourCycles
code-creation,Builtin,2,160141,0x7ff7e7e332a4,12,LocalePrototypeLanguage
code-creation,Builtin,2,160149,0x7ff7e7e332e4,12,LocalePrototypeMaximize
code-creation,Builtin,2,160157,0x7ff7e7e33324,12,LocalePrototypeMinimize
code-creation,Builtin,2,160175,0x7ff7e7e33364,12,LocalePrototypeNumeric
code-creation,Builtin,2,160184,0x7ff7e7e333a4,12,LocalePrototypeNumberingSystem
code-creation,Builtin,2,160202,0x7ff7e7e333e4,12,LocalePrototypeNumberingSystems
code-creation,Builtin,2,160211,0x7ff7e7e33424,12,LocalePrototypeRegion
code-creation,Builtin,2,160219,0x7ff7e7e33464,12,LocalePrototypeScript
code-creation,Builtin,2,160227,0x7ff7e7e334a4,12,LocalePrototypeTextInfo
code-creation,Builtin,2,160235,0x7ff7e7e334e4,12,LocalePrototypeTimeZones
code-creation,Builtin,2,160243,0x7ff7e7e33524,12,LocalePrototypeToString
code-creation,Builtin,2,160251,0x7ff7e7e33564,12,LocalePrototypeWeekInfo
code-creation,Builtin,2,160259,0x7ff7e7e335a4,12,NumberFormatConstructor
code-creation,Builtin,2,160267,0x7ff7e7e335e4,12,NumberFormatInternalFormatNumber
code-creation,Builtin,2,160276,0x7ff7e7e33624,12,NumberFormatPrototypeFormatNumber
code-creation,Builtin,2,160284,0x7ff7e7e33664,12,NumberFormatPrototypeFormatToParts
code-creation,Builtin,2,160292,0x7ff7e7e336a4,12,NumberFormatPrototypeResolvedOptions
code-creation,Builtin,2,160301,0x7ff7e7e336e4,12,NumberFormatSupportedLocalesOf
code-creation,Builtin,2,160309,0x7ff7e7e33724,12,PluralRulesConstructor
code-creation,Builtin,2,160317,0x7ff7e7e33764,12,PluralRulesPrototypeResolvedOptions
code-creation,Builtin,2,160326,0x7ff7e7e337a4,12,PluralRulesPrototypeSelect
code-creation,Builtin,2,160334,0x7ff7e7e337e4,12,PluralRulesSupportedLocalesOf
code-creation,Builtin,2,160342,0x7ff7e7e33824,12,RelativeTimeFormatConstructor
code-creation,Builtin,2,160350,0x7ff7e7e33864,12,RelativeTimeFormatPrototypeFormat
code-creation,Builtin,2,160359,0x7ff7e7e338a4,12,RelativeTimeFormatPrototypeFormatToParts
code-creation,Builtin,2,160367,0x7ff7e7e338e4,12,RelativeTimeFormatPrototypeResolvedOptions
code-creation,Builtin,2,160376,0x7ff7e7e33924,12,RelativeTimeFormatSupportedLocalesOf
code-creation,Builtin,2,160384,0x7ff7e7e33964,12,SegmenterConstructor
code-creation,Builtin,2,160392,0x7ff7e7e339a4,12,SegmenterPrototypeResolvedOptions
code-creation,Builtin,2,160400,0x7ff7e7e339e4,12,SegmenterPrototypeSegment
code-creation,Builtin,2,160409,0x7ff7e7e33a24,12,SegmenterSupportedLocalesOf
code-creation,Builtin,2,160417,0x7ff7e7e33a64,12,SegmentIteratorPrototypeNext
code-creation,Builtin,2,160425,0x7ff7e7e33aa4,12,SegmentsPrototypeContaining
code-creation,Builtin,2,160433,0x7ff7e7e33ae4,12,SegmentsPrototypeIterator
code-creation,Builtin,2,160441,0x7ff7e7e33b24,12,StringPrototypeNormalizeIntl
code-creation,Builtin,2,160449,0x7ff7e7e33b64,12,StringPrototypeToLocaleLowerCase
code-creation,Builtin,2,160458,0x7ff7e7e33ba4,12,StringPrototypeToLocaleUpperCase
code-creation,Builtin,2,160494,0x7ff7e7e33be4,204,StringPrototypeToLowerCaseIntl
code-creation,Builtin,2,160504,0x7ff7e7e33ce4,12,StringPrototypeToUpperCaseIntl
code-creation,Builtin,2,160513,0x7ff7e7e33d24,652,StringToLowerCaseIntl
code-creation,Builtin,2,160521,0x7ff7e7e33fe4,12,V8BreakIteratorConstructor
code-creation,Builtin,2,160529,0x7ff7e7e34024,12,V8BreakIteratorInternalAdoptText
code-creation,Builtin,2,160538,0x7ff7e7e34064,12,V8BreakIteratorInternalBreakType
code-creation,Builtin,2,160546,0x7ff7e7e340a4,12,V8BreakIteratorInternalCurrent
code-creation,Builtin,2,160554,0x7ff7e7e340e4,12,V8BreakIteratorInternalFirst
code-creation,Builtin,2,160562,0x7ff7e7e34124,12,V8BreakIteratorInternalNext
code-creation,Builtin,2,160571,0x7ff7e7e34164,12,V8BreakIteratorPrototypeAdoptText
code-creation,Builtin,2,160579,0x7ff7e7e341a4,12,V8BreakIteratorPrototypeBreakType
code-creation,Builtin,2,160587,0x7ff7e7e341e4,12,V8BreakIteratorPrototypeCurrent
code-creation,Builtin,2,160596,0x7ff7e7e34224,12,V8BreakIteratorPrototypeFirst
code-creation,Builtin,2,160604,0x7ff7e7e34264,12,V8BreakIteratorPrototypeNext
code-creation,Builtin,2,160612,0x7ff7e7e342a4,12,V8BreakIteratorPrototypeResolvedOptions
code-creation,Builtin,2,160621,0x7ff7e7e342e4,12,V8BreakIteratorSupportedLocalesOf
code-creation,BytecodeHandler,0,160635,0x7ff7e7e34324,24,Wide
code-creation,BytecodeHandler,0,160643,0x7ff7e7e34364,24,ExtraWide
code-creation,BytecodeHandler,0,160651,0x7ff7e7e343a4,104,DebugBreakWide
code-creation,BytecodeHandler,0,160659,0x7ff7e7e34424,104,DebugBreakExtraWide
code-creation,BytecodeHandler,0,160668,0x7ff7e7e344a4,164,DebugBreak0
code-creation,BytecodeHandler,0,160676,0x7ff7e7e34564,104,DebugBreak1
code-creation,BytecodeHandler,0,160684,0x7ff7e7e345e4,104,DebugBreak2
code-creation,BytecodeHandler,0,160692,0x7ff7e7e34664,104,DebugBreak3
code-creation,BytecodeHandler,0,160700,0x7ff7e7e346e4,104,DebugBreak4
code-creation,BytecodeHandler,0,160708,0x7ff7e7e34764,104,DebugBreak5
code-creation,BytecodeHandler,0,160716,0x7ff7e7e347e4,104,DebugBreak6
code-creation,BytecodeHandler,0,160724,0x7ff7e7e34864,32,Ldar
code-creation,BytecodeHandler,0,160732,0x7ff7e7e348a4,68,LdaZero
code-creation,BytecodeHandler,0,160740,0x7ff7e7e34924,76,LdaSmi
code-creation,BytecodeHandler,0,160748,0x7ff7e7e349a4,72,LdaUndefined
code-creation,BytecodeHandler,0,160756,0x7ff7e7e34a24,72,LdaNull
code-creation,BytecodeHandler,0,160764,0x7ff7e7e34aa4,72,LdaTheHole
code-creation,BytecodeHandler,0,160772,0x7ff7e7e34b24,24,LdaTrue
code-creation,BytecodeHandler,0,160780,0x7ff7e7e34b64,24,LdaFalse
code-creation,BytecodeHandler,0,160788,0x7ff7e7e34ba4,76,LdaConstant
code-creation,BytecodeHandler,0,160795,0x7ff7e7e34c24,132,LdaContextSlot
code-creation,BytecodeHandler,0,160804,0x7ff7e7e34ce4,132,LdaImmutableContextSlot
code-creation,BytecodeHandler,0,160812,0x7ff7e7e34da4,88,LdaCurrentContextSlot
code-creation,BytecodeHandler,0,160821,0x7ff7e7e34e24,88,LdaImmutableCurrentContextSlot
code-creation,BytecodeHandler,0,160829,0x7ff7e7e34ea4,32,Star
code-creation,BytecodeHandler,0,160837,0x7ff7e7e34ee4,40,Mov
code-creation,BytecodeHandler,0,160845,0x7ff7e7e34f24,40,PushContext
code-creation,BytecodeHandler,0,160853,0x7ff7e7e34f64,36,PopContext
code-creation,BytecodeHandler,0,160861,0x7ff7e7e34fa4,56,TestReferenceEqual
code-creation,BytecodeHandler,0,160869,0x7ff7e7e34fe4,60,TestUndetectable
code-creation,BytecodeHandler,0,160877,0x7ff7e7e35024,44,TestNull
code-creation,BytecodeHandler,0,160885,0x7ff7e7e35064,44,TestUndefined
code-creation,BytecodeHandler,0,160893,0x7ff7e7e350a4,360,TestTypeOf
code-creation,BytecodeHandler,0,160901,0x7ff7e7e35224,6092,LdaGlobal
code-creation,BytecodeHandler,0,160909,0x7ff7e7e36a24,4596,LdaGlobalInsideTypeof
code-creation,BytecodeHandler,0,160918,0x7ff7e7e37c24,160,StaGlobal
code-creation,BytecodeHandler,0,160926,0x7ff7e7e37ce4,160,StaContextSlot
code-creation,BytecodeHandler,0,160934,0x7ff7e7e37da4,116,StaCurrentContextSlot
code-creation,BytecodeHandler,0,160942,0x7ff7e7e37e24,124,LdaLookupSlot
code-creation,BytecodeHandler,0,160950,0x7ff7e7e37ea4,244,LdaLookupContextSlot
code-creation,BytecodeHandler,0,160995,0x7ff7e7e37fa4,4840,LdaLookupGlobalSlot
code-creation,BytecodeHandler,0,161006,0x7ff7e7e392a4,124,LdaLookupSlotInsideTypeof
code-creation,BytecodeHandler,0,161014,0x7ff7e7e39324,244,LdaLookupContextSlotInsideTypeof
code-creation,BytecodeHandler,0,161023,0x7ff7e7e39424,4808,LdaLookupGlobalSlotInsideTypeof
code-creation,BytecodeHandler,0,161032,0x7ff7e7e3a724,220,StaLookupSlot
code-creation,BytecodeHandler,0,161040,0x7ff7e7e3a824,5292,LdaNamedProperty
code-creation,BytecodeHandler,0,161049,0x7ff7e7e3bce4,184,LdaNamedPropertyFromSuper
code-creation,BytecodeHandler,0,161057,0x7ff7e7e3bda4,216,LdaKeyedProperty
code-creation,BytecodeHandler,0,161065,0x7ff7e7e3bea4,160,LdaModuleVariable
code-creation,BytecodeHandler,0,161074,0x7ff7e7e3bf64,292,StaModuleVariable
code-creation,BytecodeHandler,0,161082,0x7ff7e7e3c0a4,176,StaNamedProperty
code-creation,BytecodeHandler,0,161090,0x7ff7e7e3c164,176,StaNamedOwnProperty
code-creation,BytecodeHandler,0,161099,0x7ff7e7e3c224,168,StaKeyedProperty
code-creation,BytecodeHandler,0,161107,0x7ff7e7e3c2e4,168,StaInArrayLiteral
code-creation,BytecodeHandler,0,161115,0x7ff7e7e3c3a4,200,StaDataPropertyInLiteral
code-creation,BytecodeHandler,0,161124,0x7ff7e7e3c4a4,164,CollectTypeProfile
code-creation,BytecodeHandler,0,161132,0x7ff7e7e3c564,1036,Add
code-creation,BytecodeHandler,0,161140,0x7ff7e7e3c9a4,1072,Sub
code-creation,BytecodeHandler,0,161148,0x7ff7e7e3cde4,1032,Mul
code-creation,BytecodeHandler,0,161156,0x7ff7e7e3d224,992,Div
code-creation,BytecodeHandler,0,161174,0x7ff7e7e3d624,920,Mod
code-creation,BytecodeHandler,0,161183,0x7ff7e7e3d9e4,988,Exp
code-creation,BytecodeHandler,0,161200,0x7ff7e7e3dde4,884,BitwiseOr
code-creation,BytecodeHandler,0,161208,0x7ff7e7e3e164,892,BitwiseXor
code-creation,BytecodeHandler,0,161216,0x7ff7e7e3e4e4,892,BitwiseAnd
code-creation,BytecodeHandler,0,161224,0x7ff7e7e3e864,904,ShiftLeft
code-creation,BytecodeHandler,0,161232,0x7ff7e7e3ec24,904,ShiftRight
code-creation,BytecodeHandler,0,161240,0x7ff7e7e3efe4,1028,ShiftRightLogical
code-creation,BytecodeHandler,0,161248,0x7ff7e7e3f424,964,AddSmi
code-creation,BytecodeHandler,0,161256,0x7ff7e7e3f824,1008,SubSmi
code-creation,BytecodeHandler,0,161264,0x7ff7e7e3fc24,920,MulSmi
code-creation,BytecodeHandler,0,161272,0x7ff7e7e3ffe4,928,DivSmi
code-creation,BytecodeHandler,0,161280,0x7ff7e7e403a4,824,ModSmi
code-creation,BytecodeHandler,0,161288,0x7ff7e7e406e4,896,ExpSmi
code-creation,BytecodeHandler,0,161296,0x7ff7e7e40aa4,492,BitwiseOrSmi
code-creation,BytecodeHandler,0,161304,0x7ff7e7e40ca4,492,BitwiseXorSmi
code-creation,BytecodeHandler,0,161312,0x7ff7e7e40ea4,492,BitwiseAndSmi
code-creation,BytecodeHandler,0,161320,0x7ff7e7e410a4,492,ShiftLeftSmi
code-creation,BytecodeHandler,0,161328,0x7ff7e7e412a4,492,ShiftRightSmi
code-creation,BytecodeHandler,0,161336,0x7ff7e7e414a4,644,ShiftRightLogicalSmi
code-creation,BytecodeHandler,0,161344,0x7ff7e7e41764,664,Inc
code-creation,BytecodeHandler,0,161352,0x7ff7e7e41a24,664,Dec
code-creation,BytecodeHandler,0,161360,0x7ff7e7e41ce4,648,Negate
code-creation,BytecodeHandler,0,161368,0x7ff7e7e41fa4,488,BitwiseNot
code-creation,BytecodeHandler,0,161376,0x7ff7e7e421a4,120,ToBooleanLogicalNot
code-creation,BytecodeHandler,0,161384,0x7ff7e7e42224,44,LogicalNot
code-creation,BytecodeHandler,0,161392,0x7ff7e7e42264,208,TypeOf
code-creation,BytecodeHandler,0,161400,0x7ff7e7e42364,120,DeletePropertyStrict
code-creation,BytecodeHandler,0,161408,0x7ff7e7e423e4,112,DeletePropertySloppy
code-creation,BytecodeHandler,0,161417,0x7ff7e7e42464,40,GetSuperConstructor
code-creation,BytecodeHandler,0,161425,0x7ff7e7e424a4,1128,CallAnyReceiver
code-creation,BytecodeHandler,0,161433,0x7ff7e7e42924,1128,CallProperty
code-creation,BytecodeHandler,0,161441,0x7ff7e7e42da4,1012,CallProperty0
code-creation,BytecodeHandler,0,161450,0x7ff7e7e431a4,1024,CallProperty1
code-creation,BytecodeHandler,0,161458,0x7ff7e7e435e4,1036,CallProperty2
code-creation,BytecodeHandler,0,161466,0x7ff7e7e43a24,1020,CallUndefinedReceiver
code-creation,BytecodeHandler,0,161476,0x7ff7e7e43e24,1052,CallUndefinedReceiver0
code-creation,BytecodeHandler,0,161485,0x7ff7e7e44264,1028,CallUndefinedReceiver1
code-creation,BytecodeHandler,0,161494,0x7ff7e7e446a4,1044,CallUndefinedReceiver2
code-creation,BytecodeHandler,0,161502,0x7ff7e7e44ae4,1128,CallWithSpread
code-creation,BytecodeHandler,0,161510,0x7ff7e7e44f64,124,CallRuntime
code-creation,BytecodeHandler,0,161518,0x7ff7e7e44fe4,156,CallRuntimeForPair
code-creation,BytecodeHandler,0,161526,0x7ff7e7e450a4,80,CallJSRuntime
code-creation,BytecodeHandler,0,161535,0x7ff7e7e45124,1248,InvokeIntrinsic
code-creation,BytecodeHandler,0,161543,0x7ff7e7e45624,1028,Construct
code-creation,BytecodeHandler,0,161551,0x7ff7e7e45a64,548,ConstructWithSpread
code-creation,BytecodeHandler,0,161559,0x7ff7e7e45ca4,1948,TestEqual
code-creation,BytecodeHandler,0,161567,0x7ff7e7e46464,1076,TestEqualStrict
code-creation,BytecodeHandler,0,161575,0x7ff7e7e468a4,1636,TestLessThan
code-creation,BytecodeHandler,0,161583,0x7ff7e7e46f24,1636,TestGreaterThan
code-creation,BytecodeHandler,0,161591,0x7ff7e7e475a4,1636,TestLessThanOrEqual
code-creation,BytecodeHandler,0,161600,0x7ff7e7e47c24,1636,TestGreaterThanOrEqual
code-creation,BytecodeHandler,0,161608,0x7ff7e7e482a4,888,TestInstanceOf
code-creation,BytecodeHandler,0,161616,0x7ff7e7e48624,160,TestIn
code-creation,BytecodeHandler,0,161624,0x7ff7e7e486e4,112,ToName
code-creation,BytecodeHandler,0,161632,0x7ff7e7e48764,220,ToNumber
code-creation,BytecodeHandler,0,161640,0x7ff7e7e48864,240,ToNumeric
code-creation,BytecodeHandler,0,161648,0x7ff7e7e48964,112,ToObject
code-creation,BytecodeHandler,0,161656,0x7ff7e7e489e4,116,ToString
code-creation,BytecodeHandler,0,161664,0x7ff7e7e48a64,404,CreateRegExpLiteral
code-creation,BytecodeHandler,0,161672,0x7ff7e7e48c24,1500,CreateArrayLiteral
code-creation,BytecodeHandler,0,161681,0x7ff7e7e49224,92,CreateArrayFromIterable
code-creation,BytecodeHandler,0,161689,0x7ff7e7e492a4,796,CreateEmptyArrayLiteral
code-creation,BytecodeHandler,0,161698,0x7ff7e7e495e4,2252,CreateObjectLiteral
code-creation,BytecodeHandler,0,161706,0x7ff7e7e49ee4,228,CreateEmptyObjectLiteral
code-creation,BytecodeHandler,0,161714,0x7ff7e7e49fe4,172,CloneObject
code-creation,BytecodeHandler,0,161723,0x7ff7e7e4a0a4,216,GetTemplateObject
code-creation,BytecodeHandler,0,161731,0x7ff7e7e4a1a4,328,CreateClosure
code-creation,BytecodeHandler,0,161739,0x7ff7e7e4a324,120,CreateBlockContext
code-creation,BytecodeHandler,0,161747,0x7ff7e7e4a3a4,132,CreateCatchContext
code-creation,BytecodeHandler,0,161756,0x7ff7e7e4a464,260,CreateFunctionContext
code-creation,BytecodeHandler,0,161764,0x7ff7e7e4a5a4,260,CreateEvalContext
code-creation,BytecodeHandler,0,161772,0x7ff7e7e4a6e4,132,CreateWithContext
code-creation,BytecodeHandler,0,161780,0x7ff7e7e4a7a4,1584,CreateMappedArguments
code-creation,BytecodeHandler,0,161789,0x7ff7e7e4ade4,596,CreateUnmappedArguments
code-creation,BytecodeHandler,0,161797,0x7ff7e7e4b064,636,CreateRestParameter
code-creation,BytecodeHandler,0,161805,0x7ff7e7e4b2e4,424,JumpLoop
code-creation,BytecodeHandler,0,161813,0x7ff7e7e4b4a4,44,Jump
code-creation,BytecodeHandler,0,161821,0x7ff7e7e4b4e4,56,JumpConstant
code-creation,BytecodeHandler,0,161829,0x7ff7e7e4b524,80,JumpIfNullConstant
code-creation,BytecodeHandler,0,161838,0x7ff7e7e4b5a4,80,JumpIfNotNullConstant
code-creation,BytecodeHandler,0,161846,0x7ff7e7e4b624,80,JumpIfUndefinedConstant
code-creation,BytecodeHandler,0,161854,0x7ff7e7e4b6a4,80,JumpIfNotUndefinedConstant
code-creation,BytecodeHandler,0,161863,0x7ff7e7e4b724,92,JumpIfUndefinedOrNullConstant
code-creation,BytecodeHandler,0,161871,0x7ff7e7e4b7a4,80,JumpIfTrueConstant
code-creation,BytecodeHandler,0,161880,0x7ff7e7e4b824,80,JumpIfFalseConstant
code-creation,BytecodeHandler,0,161888,0x7ff7e7e4b8a4,88,JumpIfJSReceiverConstant
code-creation,BytecodeHandler,0,161896,0x7ff7e7e4b924,156,JumpIfToBooleanTrueConstant
code-creation,BytecodeHandler,0,161905,0x7ff7e7e4b9e4,156,JumpIfToBooleanFalseConstant
code-creation,BytecodeHandler,0,161913,0x7ff7e7e4baa4,144,JumpIfToBooleanTrue
code-creation,BytecodeHandler,0,161923,0x7ff7e7e4bb64,144,JumpIfToBooleanFalse
code-creation,BytecodeHandler,0,161932,0x7ff7e7e4bc24,68,JumpIfTrue
code-creation,BytecodeHandler,0,161940,0x7ff7e7e4bca4,68,JumpIfFalse
code-creation,BytecodeHandler,0,161948,0x7ff7e7e4bd24,68,JumpIfNull
code-creation,BytecodeHandler,0,161956,0x7ff7e7e4bda4,68,JumpIfNotNull
code-creation,BytecodeHandler,0,161965,0x7ff7e7e4be24,68,JumpIfUndefined
code-creation,BytecodeHandler,0,161973,0x7ff7e7e4bea4,68,JumpIfNotUndefined
code-creation,BytecodeHandler,0,161981,0x7ff7e7e4bf24,76,JumpIfUndefinedOrNull
code-creation,BytecodeHandler,0,161990,0x7ff7e7e4bfa4,76,JumpIfJSReceiver
code-creation,BytecodeHandler,0,161998,0x7ff7e7e4c024,108,SwitchOnSmiNoFeedback
code-creation,BytecodeHandler,0,162006,0x7ff7e7e4c0a4,468,ForInEnumerate
code-creation,BytecodeHandler,0,162014,0x7ff7e7e4c2a4,264,ForInPrepare
code-creation,BytecodeHandler,0,162022,0x7ff7e7e4c3e4,64,ForInContinue
code-creation,BytecodeHandler,0,162030,0x7ff7e7e4c464,264,ForInNext
code-creation,BytecodeHandler,0,162038,0x7ff7e7e4c5a4,48,ForInStep
code-creation,BytecodeHandler,0,162046,0x7ff7e7e4c5e4,36,SetPendingMessage
code-creation,BytecodeHandler,0,162054,0x7ff7e7e4c624,116,Throw
code-creation,BytecodeHandler,0,162062,0x7ff7e7e4c6a4,116,ReThrow
code-creation,BytecodeHandler,0,162070,0x7ff7e7e4c724,112,Return
code-creation,BytecodeHandler,0,162078,0x7ff7e7e4c7a4,200,ThrowReferenceErrorIfHole
code-creation,BytecodeHandler,0,162087,0x7ff7e7e4c8a4,136,ThrowSuperNotCalledIfHole
code-creation,BytecodeHandler,0,162095,0x7ff7e7e4c964,136,ThrowSuperAlreadyCalledIfNotHole
code-creation,BytecodeHandler,0,162104,0x7ff7e7e4ca24,156,ThrowIfNotSuperConstructor
code-creation,BytecodeHandler,0,162113,0x7ff7e7e4cae4,124,SwitchOnGeneratorState
code-creation,BytecodeHandler,0,162121,0x7ff7e7e4cb64,512,SuspendGenerator
code-creation,BytecodeHandler,0,162129,0x7ff7e7e4cda4,128,ResumeGenerator
code-creation,BytecodeHandler,0,162137,0x7ff7e7e4ce64,156,GetIterator
code-creation,BytecodeHandler,0,162146,0x7ff7e7e4cf24,116,Debugger
code-creation,BytecodeHandler,0,162154,0x7ff7e7e4cfa4,124,IncBlockCounter
code-creation,BytecodeHandler,0,162162,0x7ff7e7e4d024,56,Abort
code-creation,BytecodeHandler,0,162181,0x7ff7e7e4d064,32,Star0
code-creation,BytecodeHandler,0,162189,0x7ff7e7e4d0a4,60,Illegal
code-creation,BytecodeHandler,0,162207,0x7ff7e7e4d0e4,108,DebugBreak1.Wide
code-creation,BytecodeHandler,0,162216,0x7ff7e7e4d164,108,DebugBreak2.Wide
code-creation,BytecodeHandler,0,162224,0x7ff7e7e4d1e4,108,DebugBreak3.Wide
code-creation,BytecodeHandler,0,162232,0x7ff7e7e4d264,108,DebugBreak4.Wide
code-creation,BytecodeHandler,0,162240,0x7ff7e7e4d2e4,108,DebugBreak5.Wide
code-creation,BytecodeHandler,0,162249,0x7ff7e7e4d364,108,DebugBreak6.Wide
code-creation,BytecodeHandler,0,162257,0x7ff7e7e4d3e4,32,Ldar.Wide
code-creation,BytecodeHandler,0,162265,0x7ff7e7e4d424,32,LdaSmi.Wide
code-creation,BytecodeHandler,0,162273,0x7ff7e7e4d464,32,LdaConstant.Wide
code-creation,BytecodeHandler,0,162281,0x7ff7e7e4d4a4,92,LdaContextSlot.Wide
code-creation,BytecodeHandler,0,162290,0x7ff7e7e4d524,92,LdaImmutableContextSlot.Wide
code-creation,BytecodeHandler,0,162298,0x7ff7e7e4d5a4,48,LdaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,162307,0x7ff7e7e4d5e4,48,LdaImmutableCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,162316,0x7ff7e7e4d624,32,Star.Wide
code-creation,BytecodeHandler,0,162324,0x7ff7e7e4d664,40,Mov.Wide
code-creation,BytecodeHandler,0,162332,0x7ff7e7e4d6a4,40,PushContext.Wide
code-creation,BytecodeHandler,0,162340,0x7ff7e7e4d6e4,36,PopContext.Wide
code-creation,BytecodeHandler,0,162348,0x7ff7e7e4d724,56,TestReferenceEqual.Wide
code-creation,BytecodeHandler,0,162357,0x7ff7e7e4d764,4724,LdaGlobal.Wide
code-creation,BytecodeHandler,0,162365,0x7ff7e7e4e9e4,4660,LdaGlobalInsideTypeof.Wide
code-creation,BytecodeHandler,0,162374,0x7ff7e7e4fc24,164,StaGlobal.Wide
code-creation,BytecodeHandler,0,162382,0x7ff7e7e4fce4,160,StaContextSlot.Wide
code-creation,BytecodeHandler,0,162391,0x7ff7e7e4fda4,116,StaCurrentContextSlot.Wide
code-creation,BytecodeHandler,0,162401,0x7ff7e7e4fe24,128,LdaLookupSlot.Wide
code-creation,BytecodeHandler,0,162410,0x7ff7e7e4fee4,248,LdaLookupContextSlot.Wide
code-creation,BytecodeHandler,0,162419,0x7ff7e7e4ffe4,4912,LdaLookupGlobalSlot.Wide
code-creation,BytecodeHandler,0,162428,0x7ff7e7e51324,128,LdaLookupSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,162436,0x7ff7e7e513e4,248,LdaLookupContextSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,162445,0x7ff7e7e514e4,4876,LdaLookupGlobalSlotInsideTypeof.Wide
code-creation,BytecodeHandler,0,162454,0x7ff7e7e52824,220,StaLookupSlot.Wide
code-creation,BytecodeHandler,0,162463,0x7ff7e7e52924,5296,LdaNamedProperty.Wide
code-creation,BytecodeHandler,0,162471,0x7ff7e7e53de4,192,LdaNamedPropertyFromSuper.Wide
code-creation,BytecodeHandler,0,162480,0x7ff7e7e53ee4,164,LdaKeyedProperty.Wide
code-creation,BytecodeHandler,0,162489,0x7ff7e7e53fa4,160,LdaModuleVariable.Wide
code-creation,BytecodeHandler,0,162497,0x7ff7e7e54064,300,StaModuleVariable.Wide
code-creation,BytecodeHandler,0,162506,0x7ff7e7e541a4,180,StaNamedProperty.Wide
code-creation,BytecodeHandler,0,162514,0x7ff7e7e54264,180,StaNamedOwnProperty.Wide
code-creation,BytecodeHandler,0,162522,0x7ff7e7e54324,172,StaKeyedProperty.Wide
code-creation,BytecodeHandler,0,162531,0x7ff7e7e543e4,172,StaInArrayLiteral.Wide
code-creation,BytecodeHandler,0,162539,0x7ff7e7e544a4,204,StaDataPropertyInLiteral.Wide
code-creation,BytecodeHandler,0,162548,0x7ff7e7e545a4,168,CollectTypeProfile.Wide
code-creation,BytecodeHandler,0,162556,0x7ff7e7e54664,988,Add.Wide
code-creation,BytecodeHandler,0,162565,0x7ff7e7e54a64,1024,Sub.Wide
code-creation,BytecodeHandler,0,162573,0x7ff7e7e54ea4,980,Mul.Wide
code-creation,BytecodeHandler,0,162580,0x7ff7e7e552a4,996,Div.Wide
code-creation,BytecodeHandler,0,162588,0x7ff7e7e556a4,924,Mod.Wide
code-creation,BytecodeHandler,0,162596,0x7ff7e7e55a64,1012,Exp.Wide
code-creation,BytecodeHandler,0,162604,0x7ff7e7e55e64,916,BitwiseOr.Wide
code-creation,BytecodeHandler,0,162613,0x7ff7e7e56224,924,BitwiseXor.Wide
code-creation,BytecodeHandler,0,162621,0x7ff7e7e565e4,924,BitwiseAnd.Wide
code-creation,BytecodeHandler,0,162629,0x7ff7e7e569a4,936,ShiftLeft.Wide
code-creation,BytecodeHandler,0,162637,0x7ff7e7e56d64,936,ShiftRight.Wide
code-creation,BytecodeHandler,0,162645,0x7ff7e7e57124,1056,ShiftRightLogical.Wide
code-creation,BytecodeHandler,0,162654,0x7ff7e7e57564,924,AddSmi.Wide
code-creation,BytecodeHandler,0,162662,0x7ff7e7e57924,968,SubSmi.Wide
code-creation,BytecodeHandler,0,162670,0x7ff7e7e57d24,920,MulSmi.Wide
code-creation,BytecodeHandler,0,162678,0x7ff7e7e580e4,924,DivSmi.Wide
code-creation,BytecodeHandler,0,162686,0x7ff7e7e584a4,824,ModSmi.Wide
code-creation,BytecodeHandler,0,162694,0x7ff7e7e587e4,896,ExpSmi.Wide
code-creation,BytecodeHandler,0,162702,0x7ff7e7e58ba4,500,BitwiseOrSmi.Wide
code-creation,BytecodeHandler,0,162711,0x7ff7e7e58da4,500,BitwiseXorSmi.Wide
code-creation,BytecodeHandler,0,162719,0x7ff7e7e58fa4,500,BitwiseAndSmi.Wide
code-creation,BytecodeHandler,0,162727,0x7ff7e7e591a4,500,ShiftLeftSmi.Wide
code-creation,BytecodeHandler,0,162736,0x7ff7e7e593a4,500,ShiftRightSmi.Wide
code-creation,BytecodeHandler,0,162744,0x7ff7e7e595a4,652,ShiftRightLogicalSmi.Wide
code-creation,BytecodeHandler,0,162753,0x7ff7e7e59864,624,Inc.Wide
code-creation,BytecodeHandler,0,162761,0x7ff7e7e59ae4,624,Dec.Wide
code-creation,BytecodeHandler,0,162769,0x7ff7e7e59d64,652,Negate.Wide
code-creation,BytecodeHandler,0,162777,0x7ff7e7e5a024,496,BitwiseNot.Wide
code-creation,BytecodeHandler,0,162785,0x7ff7e7e5a224,124,DeletePropertyStrict.Wide
code-creation,BytecodeHandler,0,162793,0x7ff7e7e5a2a4,116,DeletePropertySloppy.Wide
code-creation,BytecodeHandler,0,162802,0x7ff7e7e5a324,40,GetSuperConstructor.Wide
code-creation,BytecodeHandler,0,162811,0x7ff7e7e5a364,1132,CallAnyReceiver.Wide
code-creation,BytecodeHandler,0,162819,0x7ff7e7e5a7e4,1132,CallProperty.Wide
code-creation,BytecodeHandler,0,162827,0x7ff7e7e5ac64,1012,CallProperty0.Wide
code-creation,BytecodeHandler,0,162836,0x7ff7e7e5b064,1028,CallProperty1.Wide
code-creation,BytecodeHandler,0,162846,0x7ff7e7e5b4a4,1040,CallProperty2.Wide
code-creation,BytecodeHandler,0,162855,0x7ff7e7e5b8e4,1020,CallUndefinedReceiver.Wide
code-creation,BytecodeHandler,0,162864,0x7ff7e7e5bce4,1056,CallUndefinedReceiver0.Wide
code-creation,BytecodeHandler,0,162872,0x7ff7e7e5c124,1032,CallUndefinedReceiver1.Wide
code-creation,BytecodeHandler,0,162881,0x7ff7e7e5c564,1048,CallUndefinedReceiver2.Wide
code-creation,BytecodeHandler,0,162889,0x7ff7e7e5c9a4,1132,CallWithSpread.Wide
code-creation,BytecodeHandler,0,162898,0x7ff7e7e5ce24,128,CallRuntime.Wide
code-creation,BytecodeHandler,0,162906,0x7ff7e7e5cee4,168,CallRuntimeForPair.Wide
code-creation,BytecodeHandler,0,162915,0x7ff7e7e5cfa4,84,CallJSRuntime.Wide
code-creation,BytecodeHandler,0,162923,0x7ff7e7e5d024,1252,InvokeIntrinsic.Wide
code-creation,BytecodeHandler,0,162932,0x7ff7e7e5d524,972,Construct.Wide
code-creation,BytecodeHandler,0,162940,0x7ff7e7e5d924,484,ConstructWithSpread.Wide
code-creation,BytecodeHandler,0,162948,0x7ff7e7e5db24,1976,TestEqual.Wide
code-creation,BytecodeHandler,0,162957,0x7ff7e7e5e2e4,1080,TestEqualStrict.Wide
code-creation,BytecodeHandler,0,162965,0x7ff7e7e5e724,1524,TestLessThan.Wide
code-creation,BytecodeHandler,0,162974,0x7ff7e7e5ed24,1524,TestGreaterThan.Wide
code-creation,BytecodeHandler,0,162982,0x7ff7e7e5f324,1524,TestLessThanOrEqual.Wide
code-creation,BytecodeHandler,0,162991,0x7ff7e7e5f924,1524,TestGreaterThanOrEqual.Wide
code-creation,BytecodeHandler,0,162999,0x7ff7e7e5ff24,892,TestInstanceOf.Wide
code-creation,BytecodeHandler,0,163008,0x7ff7e7e602a4,164,TestIn.Wide
code-creation,BytecodeHandler,0,163016,0x7ff7e7e60364,116,ToName.Wide
code-creation,BytecodeHandler,0,163024,0x7ff7e7e603e4,224,ToNumber.Wide
code-creation,BytecodeHandler,0,163032,0x7ff7e7e604e4,240,ToNumeric.Wide
code-creation,BytecodeHandler,0,163040,0x7ff7e7e605e4,116,ToObject.Wide
code-creation,BytecodeHandler,0,163048,0x7ff7e7e60664,408,CreateRegExpLiteral.Wide
code-creation,BytecodeHandler,0,163057,0x7ff7e7e60824,1408,CreateArrayLiteral.Wide
code-creation,BytecodeHandler,0,163066,0x7ff7e7e60de4,796,CreateEmptyArrayLiteral.Wide
code-creation,BytecodeHandler,0,163074,0x7ff7e7e61124,2168,CreateObjectLiteral.Wide
code-creation,BytecodeHandler,0,163083,0x7ff7e7e619a4,176,CloneObject.Wide
code-creation,BytecodeHandler,0,163091,0x7ff7e7e61a64,164,GetTemplateObject.Wide
code-creation,BytecodeHandler,0,163100,0x7ff7e7e61b24,320,CreateClosure.Wide
code-creation,BytecodeHandler,0,163108,0x7ff7e7e61ca4,124,CreateBlockContext.Wide
code-creation,BytecodeHandler,0,163117,0x7ff7e7e61d24,136,CreateCatchContext.Wide
code-creation,BytecodeHandler,0,163125,0x7ff7e7e61de4,260,CreateFunctionContext.Wide
code-creation,BytecodeHandler,0,163134,0x7ff7e7e61f24,260,CreateEvalContext.Wide
code-creation,BytecodeHandler,0,163142,0x7ff7e7e62064,136,CreateWithContext.Wide
code-creation,BytecodeHandler,0,163151,0x7ff7e7e62124,440,JumpLoop.Wide
code-creation,BytecodeHandler,0,163159,0x7ff7e7e622e4,44,Jump.Wide
code-creation,BytecodeHandler,0,163178,0x7ff7e7e62324,56,JumpConstant.Wide
code-creation,BytecodeHandler,0,163187,0x7ff7e7e62364,80,JumpIfNullConstant.Wide
code-creation,BytecodeHandler,0,163205,0x7ff7e7e623e4,80,JumpIfNotNullConstant.Wide
code-creation,BytecodeHandler,0,163213,0x7ff7e7e62464,80,JumpIfUndefinedConstant.Wide
code-creation,BytecodeHandler,0,163222,0x7ff7e7e624e4,80,JumpIfNotUndefinedConstant.Wide
code-creation,BytecodeHandler,0,163231,0x7ff7e7e62564,92,JumpIfUndefinedOrNullConstant.Wide
code-creation,BytecodeHandler,0,163240,0x7ff7e7e625e4,80,JumpIfTrueConstant.Wide
code-creation,BytecodeHandler,0,163248,0x7ff7e7e62664,80,JumpIfFalseConstant.Wide
code-creation,BytecodeHandler,0,163257,0x7ff7e7e626e4,88,JumpIfJSReceiverConstant.Wide
code-creation,BytecodeHandler,0,163266,0x7ff7e7e62764,156,JumpIfToBooleanTrueConstant.Wide
code-creation,BytecodeHandler,0,163275,0x7ff7e7e62824,156,JumpIfToBooleanFalseConstant.Wide
code-creation,BytecodeHandler,0,163283,0x7ff7e7e628e4,144,JumpIfToBooleanTrue.Wide
code-creation,BytecodeHandler,0,163292,0x7ff7e7e629a4,144,JumpIfToBooleanFalse.Wide
code-creation,BytecodeHandler,0,163302,0x7ff7e7e62a64,68,JumpIfTrue.Wide
code-creation,BytecodeHandler,0,163311,0x7ff7e7e62ae4,68,JumpIfFalse.Wide
code-creation,BytecodeHandler,0,163319,0x7ff7e7e62b64,68,JumpIfNull.Wide
code-creation,BytecodeHandler,0,163328,0x7ff7e7e62be4,68,JumpIfNotNull.Wide
code-creation,BytecodeHandler,0,163336,0x7ff7e7e62c64,68,JumpIfUndefined.Wide
code-creation,BytecodeHandler,0,163344,0x7ff7e7e62ce4,68,JumpIfNotUndefined.Wide
code-creation,BytecodeHandler,0,163353,0x7ff7e7e62d64,76,JumpIfUndefinedOrNull.Wide
code-creation,BytecodeHandler,0,163361,0x7ff7e7e62de4,76,JumpIfJSReceiver.Wide
code-creation,BytecodeHandler,0,163370,0x7ff7e7e62e64,108,SwitchOnSmiNoFeedback.Wide
code-creation,BytecodeHandler,0,163378,0x7ff7e7e62ee4,472,ForInEnumerate.Wide
code-creation,BytecodeHandler,0,163387,0x7ff7e7e630e4,264,ForInPrepare.Wide
code-creation,BytecodeHandler,0,163395,0x7ff7e7e63224,64,ForInContinue.Wide
code-creation,BytecodeHandler,0,163404,0x7ff7e7e632a4,268,ForInNext.Wide
code-creation,BytecodeHandler,0,163412,0x7ff7e7e633e4,48,ForInStep.Wide
code-creation,BytecodeHandler,0,163420,0x7ff7e7e63424,160,ThrowReferenceErrorIfHole.Wide
code-creation,BytecodeHandler,0,163429,0x7ff7e7e634e4,160,ThrowIfNotSuperConstructor.Wide
code-creation,BytecodeHandler,0,163438,0x7ff7e7e635a4,124,SwitchOnGeneratorState.Wide
code-creation,BytecodeHandler,0,163446,0x7ff7e7e63624,516,SuspendGenerator.Wide
code-creation,BytecodeHandler,0,163455,0x7ff7e7e63864,128,ResumeGenerator.Wide
code-creation,BytecodeHandler,0,163463,0x7ff7e7e63924,160,GetIterator.Wide
code-creation,BytecodeHandler,0,163472,0x7ff7e7e639e4,128,IncBlockCounter.Wide
code-creation,BytecodeHandler,0,163480,0x7ff7e7e63aa4,56,Abort.Wide
code-creation,BytecodeHandler,0,163488,0x7ff7e7e63ae4,108,DebugBreak1.ExtraWide
code-creation,BytecodeHandler,0,163497,0x7ff7e7e63b64,108,DebugBreak2.ExtraWide
code-creation,BytecodeHandler,0,163505,0x7ff7e7e63be4,108,DebugBreak3.ExtraWide
code-creation,BytecodeHandler,0,163514,0x7ff7e7e63c64,108,DebugBreak4.ExtraWide
code-creation,BytecodeHandler,0,163522,0x7ff7e7e63ce4,108,DebugBreak5.ExtraWide
code-creation,BytecodeHandler,0,163531,0x7ff7e7e63d64,108,DebugBreak6.ExtraWide
code-creation,BytecodeHandler,0,163539,0x7ff7e7e63de4,32,Ldar.ExtraWide
code-creation,BytecodeHandler,0,163547,0x7ff7e7e63e24,28,LdaSmi.ExtraWide
code-creation,BytecodeHandler,0,163556,0x7ff7e7e63e64,32,LdaConstant.ExtraWide
code-creation,BytecodeHandler,0,163564,0x7ff7e7e63ea4,88,LdaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,163573,0x7ff7e7e63f24,88,LdaImmutableContextSlot.ExtraWide
code-creation,BytecodeHandler,0,163581,0x7ff7e7e63fa4,48,LdaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,163590,0x7ff7e7e63fe4,48,LdaImmutableCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,163599,0x7ff7e7e64024,28,Star.ExtraWide
code-creation,BytecodeHandler,0,163607,0x7ff7e7e64064,40,Mov.ExtraWide
code-creation,BytecodeHandler,0,163616,0x7ff7e7e640a4,36,PushContext.ExtraWide
code-creation,BytecodeHandler,0,163624,0x7ff7e7e640e4,32,PopContext.ExtraWide
code-creation,BytecodeHandler,0,163633,0x7ff7e7e64124,52,TestReferenceEqual.ExtraWide
code-creation,BytecodeHandler,0,163641,0x7ff7e7e64164,4712,LdaGlobal.ExtraWide
code-creation,BytecodeHandler,0,163650,0x7ff7e7e653e4,4648,LdaGlobalInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,163659,0x7ff7e7e66624,164,StaGlobal.ExtraWide
code-creation,BytecodeHandler,0,163667,0x7ff7e7e666e4,156,StaContextSlot.ExtraWide
code-creation,BytecodeHandler,0,163676,0x7ff7e7e667a4,116,StaCurrentContextSlot.ExtraWide
code-creation,BytecodeHandler,0,163685,0x7ff7e7e66824,128,LdaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,163693,0x7ff7e7e668e4,244,LdaLookupContextSlot.ExtraWide
code-creation,BytecodeHandler,0,163702,0x7ff7e7e669e4,4900,LdaLookupGlobalSlot.ExtraWide
code-creation,BytecodeHandler,0,163711,0x7ff7e7e67d24,128,LdaLookupSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,163720,0x7ff7e7e67de4,244,LdaLookupContextSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,163729,0x7ff7e7e67ee4,4864,LdaLookupGlobalSlotInsideTypeof.ExtraWide
code-creation,BytecodeHandler,0,163739,0x7ff7e7e69224,220,StaLookupSlot.ExtraWide
code-creation,BytecodeHandler,0,163749,0x7ff7e7e69324,5276,LdaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,163757,0x7ff7e7e6a7e4,188,LdaNamedPropertyFromSuper.ExtraWide
code-creation,BytecodeHandler,0,163766,0x7ff7e7e6a8a4,160,LdaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,163775,0x7ff7e7e6a964,160,LdaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,163784,0x7ff7e7e6aa24,296,StaModuleVariable.ExtraWide
code-creation,BytecodeHandler,0,163792,0x7ff7e7e6ab64,176,StaNamedProperty.ExtraWide
code-creation,BytecodeHandler,0,163801,0x7ff7e7e6ac24,176,StaNamedOwnProperty.ExtraWide
code-creation,BytecodeHandler,0,163810,0x7ff7e7e6ace4,168,StaKeyedProperty.ExtraWide
code-creation,BytecodeHandler,0,163818,0x7ff7e7e6ada4,168,StaInArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,163827,0x7ff7e7e6ae64,200,StaDataPropertyInLiteral.ExtraWide
code-creation,BytecodeHandler,0,163836,0x7ff7e7e6af64,168,CollectTypeProfile.ExtraWide
code-creation,BytecodeHandler,0,163845,0x7ff7e7e6b024,988,Add.ExtraWide
code-creation,BytecodeHandler,0,163853,0x7ff7e7e6b424,1024,Sub.ExtraWide
code-creation,BytecodeHandler,0,163861,0x7ff7e7e6b864,976,Mul.ExtraWide
code-creation,BytecodeHandler,0,163869,0x7ff7e7e6bc64,992,Div.ExtraWide
code-creation,BytecodeHandler,0,163877,0x7ff7e7e6c064,920,Mod.ExtraWide
code-creation,BytecodeHandler,0,163885,0x7ff7e7e6c424,1008,Exp.ExtraWide
code-creation,BytecodeHandler,0,163893,0x7ff7e7e6c824,912,BitwiseOr.ExtraWide
code-creation,BytecodeHandler,0,163902,0x7ff7e7e6cbe4,924,BitwiseXor.ExtraWide
code-creation,BytecodeHandler,0,163910,0x7ff7e7e6cfa4,924,BitwiseAnd.ExtraWide
code-creation,BytecodeHandler,0,163919,0x7ff7e7e6d364,936,ShiftLeft.ExtraWide
code-creation,BytecodeHandler,0,163927,0x7ff7e7e6d724,936,ShiftRight.ExtraWide
code-creation,BytecodeHandler,0,163936,0x7ff7e7e6dae4,1056,ShiftRightLogical.ExtraWide
code-creation,BytecodeHandler,0,163944,0x7ff7e7e6df24,920,AddSmi.ExtraWide
code-creation,BytecodeHandler,0,163953,0x7ff7e7e6e2e4,964,SubSmi.ExtraWide
code-creation,BytecodeHandler,0,163961,0x7ff7e7e6e6e4,916,MulSmi.ExtraWide
code-creation,BytecodeHandler,0,163969,0x7ff7e7e6eaa4,924,DivSmi.ExtraWide
code-creation,BytecodeHandler,0,163978,0x7ff7e7e6ee64,820,ModSmi.ExtraWide
code-creation,BytecodeHandler,0,163986,0x7ff7e7e6f1a4,896,ExpSmi.ExtraWide
code-creation,BytecodeHandler,0,163994,0x7ff7e7e6f564,500,BitwiseOrSmi.ExtraWide
code-creation,BytecodeHandler,0,164003,0x7ff7e7e6f764,500,BitwiseXorSmi.ExtraWide
code-creation,BytecodeHandler,0,164011,0x7ff7e7e6f964,500,BitwiseAndSmi.ExtraWide
code-creation,BytecodeHandler,0,164020,0x7ff7e7e6fb64,500,ShiftLeftSmi.ExtraWide
code-creation,BytecodeHandler,0,164028,0x7ff7e7e6fd64,500,ShiftRightSmi.ExtraWide
code-creation,BytecodeHandler,0,164037,0x7ff7e7e6ff64,652,ShiftRightLogicalSmi.ExtraWide
code-creation,BytecodeHandler,0,164045,0x7ff7e7e70224,624,Inc.ExtraWide
code-creation,BytecodeHandler,0,164054,0x7ff7e7e704a4,620,Dec.ExtraWide
code-creation,BytecodeHandler,0,164062,0x7ff7e7e70724,652,Negate.ExtraWide
code-creation,BytecodeHandler,0,164070,0x7ff7e7e709e4,496,BitwiseNot.ExtraWide
code-creation,BytecodeHandler,0,164079,0x7ff7e7e70be4,124,DeletePropertyStrict.ExtraWide
code-creation,BytecodeHandler,0,164087,0x7ff7e7e70c64,116,DeletePropertySloppy.ExtraWide
code-creation,BytecodeHandler,0,164096,0x7ff7e7e70ce4,36,GetSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,164105,0x7ff7e7e70d24,1128,CallAnyReceiver.ExtraWide
code-creation,BytecodeHandler,0,164113,0x7ff7e7e711a4,1128,CallProperty.ExtraWide
code-creation,BytecodeHandler,0,164122,0x7ff7e7e71624,1008,CallProperty0.ExtraWide
code-creation,BytecodeHandler,0,164130,0x7ff7e7e71a24,1024,CallProperty1.ExtraWide
code-creation,BytecodeHandler,0,164139,0x7ff7e7e71e64,1032,CallProperty2.ExtraWide
code-creation,BytecodeHandler,0,164147,0x7ff7e7e722a4,1016,CallUndefinedReceiver.ExtraWide
code-creation,BytecodeHandler,0,164156,0x7ff7e7e726a4,1056,CallUndefinedReceiver0.ExtraWide
code-creation,BytecodeHandler,0,164178,0x7ff7e7e72ae4,1028,CallUndefinedReceiver1.ExtraWide
code-creation,BytecodeHandler,0,164188,0x7ff7e7e72f24,1044,CallUndefinedReceiver2.ExtraWide
code-creation,BytecodeHandler,0,164206,0x7ff7e7e73364,1128,CallWithSpread.ExtraWide
code-creation,BytecodeHandler,0,164214,0x7ff7e7e737e4,128,CallRuntime.ExtraWide
code-creation,BytecodeHandler,0,164223,0x7ff7e7e738a4,164,CallRuntimeForPair.ExtraWide
code-creation,BytecodeHandler,0,164231,0x7ff7e7e73964,80,CallJSRuntime.ExtraWide
code-creation,BytecodeHandler,0,164240,0x7ff7e7e739e4,1252,InvokeIntrinsic.ExtraWide
code-creation,BytecodeHandler,0,164249,0x7ff7e7e73ee4,968,Construct.ExtraWide
code-creation,BytecodeHandler,0,164257,0x7ff7e7e742e4,480,ConstructWithSpread.ExtraWide
code-creation,BytecodeHandler,0,164266,0x7ff7e7e744e4,1976,TestEqual.ExtraWide
code-creation,BytecodeHandler,0,164274,0x7ff7e7e74ca4,1080,TestEqualStrict.ExtraWide
code-creation,BytecodeHandler,0,164283,0x7ff7e7e750e4,1520,TestLessThan.ExtraWide
code-creation,BytecodeHandler,0,164291,0x7ff7e7e756e4,1520,TestGreaterThan.ExtraWide
code-creation,BytecodeHandler,0,164300,0x7ff7e7e75ce4,1520,TestLessThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,164309,0x7ff7e7e762e4,1520,TestGreaterThanOrEqual.ExtraWide
code-creation,BytecodeHandler,0,164318,0x7ff7e7e768e4,892,TestInstanceOf.ExtraWide
code-creation,BytecodeHandler,0,164326,0x7ff7e7e76c64,160,TestIn.ExtraWide
code-creation,BytecodeHandler,0,164334,0x7ff7e7e76d24,116,ToName.ExtraWide
code-creation,BytecodeHandler,0,164343,0x7ff7e7e76da4,220,ToNumber.ExtraWide
code-creation,BytecodeHandler,0,164351,0x7ff7e7e76ea4,240,ToNumeric.ExtraWide
code-creation,BytecodeHandler,0,164360,0x7ff7e7e76fa4,116,ToObject.ExtraWide
code-creation,BytecodeHandler,0,164368,0x7ff7e7e77024,408,CreateRegExpLiteral.ExtraWide
code-creation,BytecodeHandler,0,164377,0x7ff7e7e771e4,1408,CreateArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,164386,0x7ff7e7e777a4,792,CreateEmptyArrayLiteral.ExtraWide
code-creation,BytecodeHandler,0,164394,0x7ff7e7e77ae4,2164,CreateObjectLiteral.ExtraWide
code-creation,BytecodeHandler,0,164403,0x7ff7e7e78364,172,CloneObject.ExtraWide
code-creation,BytecodeHandler,0,164412,0x7ff7e7e78424,164,GetTemplateObject.ExtraWide
code-creation,BytecodeHandler,0,164420,0x7ff7e7e784e4,320,CreateClosure.ExtraWide
code-creation,BytecodeHandler,0,164429,0x7ff7e7e78664,124,CreateBlockContext.ExtraWide
code-creation,BytecodeHandler,0,164437,0x7ff7e7e786e4,132,CreateCatchContext.ExtraWide
code-creation,BytecodeHandler,0,164446,0x7ff7e7e787a4,256,CreateFunctionContext.ExtraWide
code-creation,BytecodeHandler,0,164455,0x7ff7e7e788e4,256,CreateEvalContext.ExtraWide
code-creation,BytecodeHandler,0,164463,0x7ff7e7e78a24,132,CreateWithContext.ExtraWide
code-creation,BytecodeHandler,0,164472,0x7ff7e7e78ae4,436,JumpLoop.ExtraWide
code-creation,BytecodeHandler,0,164480,0x7ff7e7e78ca4,44,Jump.ExtraWide
code-creation,BytecodeHandler,0,164488,0x7ff7e7e78ce4,56,JumpConstant.ExtraWide
code-creation,BytecodeHandler,0,164497,0x7ff7e7e78d24,80,JumpIfNullConstant.ExtraWide
code-creation,BytecodeHandler,0,164505,0x7ff7e7e78da4,80,JumpIfNotNullConstant.ExtraWide
code-creation,BytecodeHandler,0,164514,0x7ff7e7e78e24,80,JumpIfUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,164523,0x7ff7e7e78ea4,80,JumpIfNotUndefinedConstant.ExtraWide
code-creation,BytecodeHandler,0,164532,0x7ff7e7e78f24,88,JumpIfUndefinedOrNullConstant.ExtraWide
code-creation,BytecodeHandler,0,164541,0x7ff7e7e78fa4,80,JumpIfTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,164549,0x7ff7e7e79024,80,JumpIfFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,164558,0x7ff7e7e790a4,88,JumpIfJSReceiverConstant.ExtraWide
code-creation,BytecodeHandler,0,164567,0x7ff7e7e79124,156,JumpIfToBooleanTrueConstant.ExtraWide
code-creation,BytecodeHandler,0,164576,0x7ff7e7e791e4,156,JumpIfToBooleanFalseConstant.ExtraWide
code-creation,BytecodeHandler,0,164585,0x7ff7e7e792a4,140,JumpIfToBooleanTrue.ExtraWide
code-creation,BytecodeHandler,0,164594,0x7ff7e7e79364,140,JumpIfToBooleanFalse.ExtraWide
code-creation,BytecodeHandler,0,164603,0x7ff7e7e79424,68,JumpIfTrue.ExtraWide
code-creation,BytecodeHandler,0,164613,0x7ff7e7e794a4,68,JumpIfFalse.ExtraWide
code-creation,BytecodeHandler,0,164621,0x7ff7e7e79524,68,JumpIfNull.ExtraWide
code-creation,BytecodeHandler,0,164630,0x7ff7e7e795a4,68,JumpIfNotNull.ExtraWide
code-creation,BytecodeHandler,0,164639,0x7ff7e7e79624,68,JumpIfUndefined.ExtraWide
code-creation,BytecodeHandler,0,164647,0x7ff7e7e796a4,68,JumpIfNotUndefined.ExtraWide
code-creation,BytecodeHandler,0,164656,0x7ff7e7e79724,76,JumpIfUndefinedOrNull.ExtraWide
code-creation,BytecodeHandler,0,164664,0x7ff7e7e797a4,72,JumpIfJSReceiver.ExtraWide
code-creation,BytecodeHandler,0,164673,0x7ff7e7e79824,108,SwitchOnSmiNoFeedback.ExtraWide
code-creation,BytecodeHandler,0,164682,0x7ff7e7e798a4,472,ForInEnumerate.ExtraWide
code-creation,BytecodeHandler,0,164690,0x7ff7e7e79aa4,264,ForInPrepare.ExtraWide
code-creation,BytecodeHandler,0,164699,0x7ff7e7e79be4,64,ForInContinue.ExtraWide
code-creation,BytecodeHandler,0,164707,0x7ff7e7e79c64,264,ForInNext.ExtraWide
code-creation,BytecodeHandler,0,164716,0x7ff7e7e79da4,44,ForInStep.ExtraWide
code-creation,BytecodeHandler,0,164724,0x7ff7e7e79de4,160,ThrowReferenceErrorIfHole.ExtraWide
code-creation,BytecodeHandler,0,164733,0x7ff7e7e79ea4,160,ThrowIfNotSuperConstructor.ExtraWide
code-creation,BytecodeHandler,0,164742,0x7ff7e7e79f64,124,SwitchOnGeneratorState.ExtraWide
code-creation,BytecodeHandler,0,164751,0x7ff7e7e79fe4,512,SuspendGenerator.ExtraWide
code-creation,BytecodeHandler,0,164759,0x7ff7e7e7a224,124,ResumeGenerator.ExtraWide
code-creation,BytecodeHandler,0,164768,0x7ff7e7e7a2a4,156,GetIterator.ExtraWide
code-creation,BytecodeHandler,0,164777,0x7ff7e7e7a364,124,IncBlockCounter.ExtraWide
code-creation,BytecodeHandler,0,164785,0x7ff7e7e7a3e4,56,Abort.ExtraWide
new,MemoryChunk,0x2840d80000,262144
new,MemoryChunk,0xe5da40000,262144
new,MemoryChunk,0x37402100000,262144
new,MemoryChunk,0x104f4280000,262144
new,MemoryChunk,0x1abee800000,262144
code-creation,Eval,10,169226,0x1abee801226,5, node:internal/main/run_main_module:1:1,0x104f42bff90,~
script-source,95,node:internal/main/run_main_module,'use strict';\x0d\n\x0d\nconst {\x0d\n  prepareMainThreadExecution\x0d\n} = require('internal/bootstrap/pre_execution');\x0d\n\x0d\nprepareMainThreadExecution(true);\x0d\n\x0d\nmarkBootstrapComplete();\x0d\n\x0d\n// Note: this loads the module through the ESM loader if the module is\x0d\n// determined to be an ES module. This hangs from the CJS module loader\x0d\n// because we currently allow monkey-patching of the module loaders\x0d\n// in the preloaded scripts through require('module').\x0d\n// runMain here might be monkey-patched by users in --require.\x0d\n// XXX: the monkey-patchability here should probably be deprecated.\x0d\nrequire('internal/modules/cjs/loader').Module.runMain(process.argv[1]);\x0d\n
code-source-info,0x1abee801226,95,0,649,C0O0C4O649,,
code-creation,Function,10,169291,0x1abee8012ce,58, node:internal/main/run_main_module:1:1,0x1abee8011a0,~
code-source-info,0x1abee8012ce,95,0,649,C0O60C3O60C8O28C13O108C15O108C19O145C22O576C25O576C30O614C35O621C40O638C47O642C51O622C57O648,,
code-creation,LazyCompile,10,169548,0x1abee80150e,76,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x147335cfea0,~
script-source,9,node:internal/bootstrap/loaders,// This file creates the internal module & binding loaders used by built-in\x0d\n// modules. In contrast\x2C user land modules are loaded using\x0d\n// lib/internal/modules/cjs/loader.js (CommonJS Modules) or\x0d\n// lib/internal/modules/esm/* (ES Modules).\x0d\n//\x0d\n// This file is compiled and run by node.cc before bootstrap/node.js\x0d\n// was called\x2C therefore the loaders are bootstrapped before we start to\x0d\n// actually bootstrap Node.js. It creates the following objects:\x0d\n//\x0d\n// C++ binding loaders:\x0d\n// - process.binding(): the legacy C++ binding loader\x2C accessible from user land\x0d\n//   because it is an object attached to the global process object.\x0d\n//   These C++ bindings are created using NODE_BUILTIN_MODULE_CONTEXT_AWARE()\x0d\n//   and have their nm_flags set to NM_F_BUILTIN. We do not make any guarantees\x0d\n//   about the stability of these bindings\x2C but still have to take care of\x0d\n//   compatibility issues caused by them from time to time.\x0d\n// - process._linkedBinding(): intended to be used by embedders to add\x0d\n//   additional C++ bindings in their applications. These C++ bindings\x0d\n//   can be created using NODE_MODULE_CONTEXT_AWARE_CPP() with the flag\x0d\n//   NM_F_LINKED.\x0d\n// - internalBinding(): the private internal C++ binding loader\x2C inaccessible\x0d\n//   from user land unless through `require('internal/test/binding')`.\x0d\n//   These C++ bindings are created using NODE_MODULE_CONTEXT_AWARE_INTERNAL()\x0d\n//   and have their nm_flags set to NM_F_INTERNAL.\x0d\n//\x0d\n// Internal JavaScript module loader:\x0d\n// - NativeModule: a minimal module system used to load the JavaScript core\x0d\n//   modules found in lib/**/*.js and deps/**/*.js. All core modules are\x0d\n//   compiled into the node binary via node_javascript.cc generated by js2c.py\x2C\x0d\n//   so they can be loaded faster without the cost of I/O. This class makes the\x0d\n//   lib/internal/*\x2C deps/internal/* modules and internalBinding() available by\x0d\n//   default to core modules\x2C and lets the core modules require itself via\x0d\n//   require('internal/bootstrap/loaders') even when this file is not written in\x0d\n//   CommonJS style.\x0d\n//\x0d\n// Other objects:\x0d\n// - process.moduleLoadList: an array recording the bindings and the modules\x0d\n//   loaded in the process and the order in which they are loaded.\x0d\n\x0d\n'use strict';\x0d\n\x0d\n// This file is compiled as if it's wrapped in a function with arguments\x0d\n// passed by node::RunBootstrapping()\x0d\n/* global process\x2C getLinkedBinding\x2C getInternalBinding\x2C primordials */\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeMap\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  Error\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  ReflectGet\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeSet\x2C\x0d\n  String\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n  TypeError\x2C\x0d\n} = primordials;\x0d\n\x0d\n// Set up process.moduleLoadList.\x0d\nconst moduleLoadList = [];\x0d\nObjectDefineProperty(process\x2C 'moduleLoadList'\x2C {\x0d\n  value: moduleLoadList\x2C\x0d\n  configurable: true\x2C\x0d\n  enumerable: true\x2C\x0d\n  writable: false\x0d\n});\x0d\n\x0d\n\x0d\n// internalBindingAllowlist contains the name of internalBinding modules\x0d\n// that are allowed for access via process.binding()... This is used\x0d\n// to provide a transition path for modules that are being moved over to\x0d\n// internalBinding.\x0d\nconst internalBindingAllowlist = new SafeSet([\x0d\n  'async_wrap'\x2C\x0d\n  'buffer'\x2C\x0d\n  'cares_wrap'\x2C\x0d\n  'config'\x2C\x0d\n  'constants'\x2C\x0d\n  'contextify'\x2C\x0d\n  'crypto'\x2C\x0d\n  'fs'\x2C\x0d\n  'fs_event_wrap'\x2C\x0d\n  'http_parser'\x2C\x0d\n  'icu'\x2C\x0d\n  'inspector'\x2C\x0d\n  'js_stream'\x2C\x0d\n  'natives'\x2C\x0d\n  'os'\x2C\x0d\n  'pipe_wrap'\x2C\x0d\n  'process_wrap'\x2C\x0d\n  'signal_wrap'\x2C\x0d\n  'spawn_sync'\x2C\x0d\n  'stream_wrap'\x2C\x0d\n  'tcp_wrap'\x2C\x0d\n  'tls_wrap'\x2C\x0d\n  'tty_wrap'\x2C\x0d\n  'udp_wrap'\x2C\x0d\n  'url'\x2C\x0d\n  'util'\x2C\x0d\n  'uv'\x2C\x0d\n  'v8'\x2C\x0d\n  'zlib'\x2C\x0d\n]);\x0d\n\x0d\nconst runtimeDeprecatedList = new SafeSet([\x0d\n  'async_wrap'\x2C\x0d\n  'crypto'\x2C\x0d\n  'http_parser'\x2C\x0d\n  'signal_wrap'\x2C\x0d\n  'url'\x2C\x0d\n  'v8'\x2C\x0d\n]);\x0d\n\x0d\nconst legacyWrapperList = new SafeSet([\x0d\n  'util'\x2C\x0d\n]);\x0d\n\x0d\n// Set up process.binding() and process._linkedBinding().\x0d\n{\x0d\n  const bindingObj = ObjectCreate(null);\x0d\n\x0d\n  process.binding = function binding(module) {\x0d\n    module = String(module);\x0d\n    // Deprecated specific process.binding() modules\x2C but not all\x2C allow\x0d\n    // selective fallback to internalBinding for the deprecated ones.\x0d\n    if (internalBindingAllowlist.has(module)) {\x0d\n      if (runtimeDeprecatedList.has(module)) {\x0d\n        runtimeDeprecatedList.delete(module);\x0d\n        process.emitWarning(\x0d\n          `Access to process.binding('${module}') is deprecated.`\x2C\x0d\n          'DeprecationWarning'\x2C\x0d\n          'DEP0111');\x0d\n      }\x0d\n      if (legacyWrapperList.has(module)) {\x0d\n        return nativeModuleRequire('internal/legacy/processbinding')[module]();\x0d\n      }\x0d\n      return internalBinding(module);\x0d\n    }\x0d\n    // eslint-disable-next-line no-restricted-syntax\x0d\n    throw new Error(`No such module: ${module}`);\x0d\n  };\x0d\n\x0d\n  process._linkedBinding = function _linkedBinding(module) {\x0d\n    module = String(module);\x0d\n    let mod = bindingObj[module];\x0d\n    if (typeof mod !== 'object')\x0d\n      mod = bindingObj[module] = getLinkedBinding(module);\x0d\n    return mod;\x0d\n  };\x0d\n}\x0d\n\x0d\n// Set up internalBinding() in the closure.\x0d\n/**\x0d\n * @type {InternalBinding}\x0d\n */\x0d\nlet internalBinding;\x0d\n{\x0d\n  const bindingObj = ObjectCreate(null);\x0d\n  // eslint-disable-next-line no-global-assign\x0d\n  internalBinding = function internalBinding(module) {\x0d\n    let mod = bindingObj[module];\x0d\n    if (typeof mod !== 'object') {\x0d\n      mod = bindingObj[module] = getInternalBinding(module);\x0d\n      ArrayPrototypePush(moduleLoadList\x2C `Internal Binding ${module}`);\x0d\n    }\x0d\n    return mod;\x0d\n  };\x0d\n}\x0d\n\x0d\nconst loaderId = 'internal/bootstrap/loaders';\x0d\nconst {\x0d\n  moduleIds\x2C\x0d\n  compileFunction\x0d\n} = internalBinding('native_module');\x0d\n\x0d\nconst getOwn = (target\x2C property\x2C receiver) => {\x0d\n  return ObjectPrototypeHasOwnProperty(target\x2C property) ?\x0d\n    ReflectGet(target\x2C property\x2C receiver) :\x0d\n    undefined;\x0d\n};\x0d\n\x0d\n/**\x0d\n * An internal abstraction for the built-in JavaScript modules of Node.js.\x0d\n * Be careful not to expose this to user land unless --expose-internals is\x0d\n * used\x2C in which case there is no compatibility guarantee about this class.\x0d\n */\x0d\nclass NativeModule {\x0d\n  /**\x0d\n   * A map from the module IDs to the module instances.\x0d\n   * @type {Map<string\x2C NativeModule>}\x0d\n   */\x0d\n  static map = new SafeMap(\x0d\n    ArrayPrototypeMap(moduleIds\x2C (id) => [id\x2C new NativeModule(id)])\x0d\n  );\x0d\n\x0d\n  constructor(id) {\x0d\n    this.filename = `${id}.js`;\x0d\n    this.id = id;\x0d\n    this.canBeRequiredByUsers = !StringPrototypeStartsWith(id\x2C 'internal/');\x0d\n\x0d\n    // The CJS exports object of the module.\x0d\n    this.exports = {};\x0d\n    // States used to work around circular dependencies.\x0d\n    this.loaded = false;\x0d\n    this.loading = false;\x0d\n\x0d\n    // The following properties are used by the ESM implementation and only\x0d\n    // initialized when the native module is loaded by users.\x0d\n    /**\x0d\n     * The C++ ModuleWrap binding used to interface with the ESM implementation.\x0d\n     * @type {ModuleWrap|undefined}\x0d\n     */\x0d\n    this.module = undefined;\x0d\n    /**\x0d\n     * Exported names for the ESM imports.\x0d\n     * @type {string[]|undefined}\x0d\n     */\x0d\n    this.exportKeys = undefined;\x0d\n  }\x0d\n\x0d\n  // To be called during pre-execution when --expose-internals is on.\x0d\n  // Enables the user-land module loader to access internal modules.\x0d\n  static exposeInternals() {\x0d\n    for (const { 0: id\x2C 1: mod } of NativeModule.map) {\x0d\n      // Do not expose this to user land even with --expose-internals.\x0d\n      if (id !== loaderId) {\x0d\n        mod.canBeRequiredByUsers = true;\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  static exists(id) {\x0d\n    return NativeModule.map.has(id);\x0d\n  }\x0d\n\x0d\n  static canBeRequiredByUsers(id) {\x0d\n    const mod = NativeModule.map.get(id);\x0d\n    return mod && mod.canBeRequiredByUsers;\x0d\n  }\x0d\n\x0d\n  // Used by user-land module loaders to compile and load builtins.\x0d\n  compileForPublicLoader() {\x0d\n    if (!this.canBeRequiredByUsers) {\x0d\n      // No code because this is an assertion against bugs\x0d\n      // eslint-disable-next-line no-restricted-syntax\x0d\n      throw new Error(`Should not compile ${this.id} for public use`);\x0d\n    }\x0d\n    this.compileForInternalLoader();\x0d\n    if (!this.exportKeys) {\x0d\n      // When using --expose-internals\x2C we do not want to reflect the named\x0d\n      // exports from core modules as this can trigger unnecessary getters.\x0d\n      const internal = StringPrototypeStartsWith(this.id\x2C 'internal/');\x0d\n      this.exportKeys = internal ? [] : ObjectKeys(this.exports);\x0d\n    }\x0d\n    this.getESMFacade();\x0d\n    this.syncExports();\x0d\n    return this.exports;\x0d\n  }\x0d\n\x0d\n  getESMFacade() {\x0d\n    if (this.module) return this.module;\x0d\n    const { ModuleWrap } = internalBinding('module_wrap');\x0d\n    const url = `node:${this.id}`;\x0d\n    const nativeModule = this;\x0d\n    const exportsKeys = ArrayPrototypeSlice(this.exportKeys);\x0d\n    ArrayPrototypePush(exportsKeys\x2C 'default');\x0d\n    this.module = new ModuleWrap(\x0d\n      url\x2C undefined\x2C exportsKeys\x2C\x0d\n      function() {\x0d\n        nativeModule.syncExports();\x0d\n        this.setExport('default'\x2C nativeModule.exports);\x0d\n      });\x0d\n    // Ensure immediate sync execution to capture exports now\x0d\n    this.module.instantiate();\x0d\n    this.module.evaluate(-1\x2C false);\x0d\n    return this.module;\x0d\n  }\x0d\n\x0d\n  // Provide named exports for all builtin libraries so that the libraries\x0d\n  // may be imported in a nicer way for ESM users. The default export is left\x0d\n  // as the entire namespace (module.exports) and updates when this function is\x0d\n  // called so that APMs and other behavior are supported.\x0d\n  syncExports() {\x0d\n    const names = this.exportKeys;\x0d\n    if (this.module) {\x0d\n      for (let i = 0; i < names.length; i++) {\x0d\n        const exportName = names[i];\x0d\n        if (exportName === 'default') continue;\x0d\n        this.module.setExport(exportName\x2C\x0d\n                              getOwn(this.exports\x2C exportName\x2C this.exports));\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  compileForInternalLoader() {\x0d\n    if (this.loaded || this.loading) {\x0d\n      return this.exports;\x0d\n    }\x0d\n\x0d\n    const id = this.id;\x0d\n    this.loading = true;\x0d\n\x0d\n    try {\x0d\n      const requireFn = StringPrototypeStartsWith(this.id\x2C 'internal/deps/') ?\x0d\n        requireWithFallbackInDeps : nativeModuleRequire;\x0d\n\x0d\n      const fn = compileFunction(id);\x0d\n      fn(this.exports\x2C requireFn\x2C this\x2C process\x2C internalBinding\x2C primordials);\x0d\n\x0d\n      this.loaded = true;\x0d\n    } finally {\x0d\n      this.loading = false;\x0d\n    }\x0d\n\x0d\n    ArrayPrototypePush(moduleLoadList\x2C `NativeModule ${id}`);\x0d\n    return this.exports;\x0d\n  }\x0d\n}\x0d\n\x0d\n// Think of this as module.exports in this file even though it is not\x0d\n// written in CommonJS style.\x0d\nconst loaderExports = {\x0d\n  internalBinding\x2C\x0d\n  NativeModule\x2C\x0d\n  require: nativeModuleRequire\x0d\n};\x0d\n\x0d\nfunction nativeModuleRequire(id) {\x0d\n  if (id === loaderId) {\x0d\n    return loaderExports;\x0d\n  }\x0d\n\x0d\n  const mod = NativeModule.map.get(id);\x0d\n  // Can't load the internal errors module from here\x2C have to use a raw error.\x0d\n  // eslint-disable-next-line no-restricted-syntax\x0d\n  if (!mod) throw new TypeError(`Missing internal module '${id}'`);\x0d\n  return mod.compileForInternalLoader();\x0d\n}\x0d\n\x0d\n// Allow internal modules from dependencies to require\x0d\n// other modules from dependencies by providing fallbacks.\x0d\nfunction requireWithFallbackInDeps(request) {\x0d\n  if (!NativeModule.map.has(request)) {\x0d\n    request = `internal/deps/${request}`;\x0d\n  }\x0d\n  return nativeModuleRequire(request);\x0d\n}\x0d\n\x0d\n// Pass the exports back to C++ land for C++ internals to use.\x0d\nreturn loaderExports;\x0d\n
code-source-info,0x1abee80150e,9,10647,11000,C0O10657C2O10668C4O10664C9O10685C13O10706C14O10729C19O10742C24O10746C29O10746C35O10890C37O10900C47O10948C60O10906C65O10900C66O10970C71O10970C75O10997,,
tick,0x7ff7e7aff27c,170227,0,0x0,3,0x7ff7e78fdb40,0x1abee801555,0x1abee8012d1
code-creation,LazyCompile,10,170251,0x1abee80221e,175,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x147335cfdd0,~
code-source-info,0x1abee80221e,9,9827,10410,C0O9846C6O9861C12O9891C16O9899C17O9930C22O9939C23O9952C30O9998C37O10029C45O9998C63O10131C70O10131C75O10167C89O10202C103O10159C108O10242C109O10254C124O10286C126O10299C141O10322C152O10341C160O10373C165O10322C170O10397C174O10405,,
code-creation,Eval,10,170650,0x1abee80312e,5, node:internal/bootstrap/pre_execution:1:1,0x1abee802d98,~
script-source,96,node:internal/bootstrap/pre_execution,'use strict';\x0d\n\x0d\nconst {\x0d\n  NumberParseInt\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeWeakMap\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n  globalThis\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  getOptionValue\x2C\x0d\n  getEmbedderOptions\x2C\x0d\n} = require('internal/options');\x0d\nconst { reconnectZeroFillToggle } = require('internal/buffer');\x0d\n\x0d\nconst { Buffer } = require('buffer');\x0d\nconst { ERR_MANIFEST_ASSERT_INTEGRITY } = require('internal/errors').codes;\x0d\nconst assert = require('internal/assert');\x0d\n\x0d\nfunction prepareMainThreadExecution(expandArgv1 = false) {\x0d\n  // TODO(joyeecheung): this is also necessary for workers when they deserialize\x0d\n  // this toggle from the snapshot.\x0d\n  reconnectZeroFillToggle();\x0d\n\x0d\n  // Patch the process object with legacy properties and normalizations\x0d\n  patchProcessObject(expandArgv1);\x0d\n  setupTraceCategoryState();\x0d\n  setupPerfHooks();\x0d\n  setupInspectorHooks();\x0d\n  setupWarningHandler();\x0d\n\x0d\n  // Resolve the coverage directory to an absolute path\x2C and\x0d\n  // overwrite process.env so that the original path gets passed\x0d\n  // to child processes even when they switch cwd.\x0d\n  if (process.env.NODE_V8_COVERAGE) {\x0d\n    process.env.NODE_V8_COVERAGE =\x0d\n      setupCoverageHooks(process.env.NODE_V8_COVERAGE);\x0d\n  }\x0d\n\x0d\n\x0d\n  setupDebugEnv();\x0d\n\x0d\n  // Print stack trace on `SIGINT` if option `--trace-sigint` presents.\x0d\n  setupStacktracePrinterOnSigint();\x0d\n\x0d\n  // Process initial diagnostic reporting configuration\x2C if present.\x0d\n  initializeReport();\x0d\n  initializeReportSignalHandlers();  // Main-thread-only.\x0d\n\x0d\n  initializeHeapSnapshotSignalHandlers();\x0d\n\x0d\n  // If the process is spawned with env NODE_CHANNEL_FD\x2C it's probably\x0d\n  // spawned by our child_process module\x2C then initialize IPC.\x0d\n  // This attaches some internal event listeners and creates:\x0d\n  // process.send()\x2C process.channel\x2C process.connected\x2C\x0d\n  // process.disconnect().\x0d\n  setupChildProcessIpcChannel();\x0d\n\x0d\n  // Load policy from disk and parse it.\x0d\n  initializePolicy();\x0d\n\x0d\n  // If this is a worker in cluster mode\x2C start up the communication\x0d\n  // channel. This needs to be done before any user code gets executed\x0d\n  // (including preload modules).\x0d\n  initializeClusterIPC();\x0d\n\x0d\n  initializeSourceMapsHandlers();\x0d\n  initializeDeprecations();\x0d\n  initializeWASI();\x0d\n  initializeCJSLoader();\x0d\n  initializeESMLoader();\x0d\n\x0d\n  const CJSLoader = require('internal/modules/cjs/loader');\x0d\n  assert(!CJSLoader.hasLoadedAnyUserCJSModule);\x0d\n  loadPreloadModules();\x0d\n  initializeFrozenIntrinsics();\x0d\n}\x0d\n\x0d\nfunction patchProcessObject(expandArgv1) {\x0d\n  const binding = internalBinding('process_methods');\x0d\n  binding.patchProcessObject(process);\x0d\n\x0d\n  require('internal/process/per_thread').refreshHrtimeBuffer();\x0d\n\x0d\n  ObjectDefineProperty(process\x2C 'argv0'\x2C {\x0d\n    enumerable: true\x2C\x0d\n    configurable: false\x2C\x0d\n    value: process.argv[0]\x0d\n  });\x0d\n  process.argv[0] = process.execPath;\x0d\n\x0d\n  if (expandArgv1 && process.argv[1] &&\x0d\n      !StringPrototypeStartsWith(process.argv[1]\x2C '-')) {\x0d\n    // Expand process.argv[1] into a full path.\x0d\n    const path = require('path');\x0d\n    try {\x0d\n      process.argv[1] = path.resolve(process.argv[1]);\x0d\n    } catch {}\x0d\n  }\x0d\n\x0d\n  // TODO(joyeecheung): most of these should be deprecated and removed\x2C\x0d\n  // except some that we need to be able to mutate during run time.\x0d\n  addReadOnlyProcessAlias('_eval'\x2C '--eval');\x0d\n  addReadOnlyProcessAlias('_print_eval'\x2C '--print');\x0d\n  addReadOnlyProcessAlias('_syntax_check_only'\x2C '--check');\x0d\n  addReadOnlyProcessAlias('_forceRepl'\x2C '--interactive');\x0d\n  addReadOnlyProcessAlias('_preload_modules'\x2C '--require');\x0d\n  addReadOnlyProcessAlias('noDeprecation'\x2C '--no-deprecation');\x0d\n  addReadOnlyProcessAlias('noProcessWarnings'\x2C '--no-warnings');\x0d\n  addReadOnlyProcessAlias('traceProcessWarnings'\x2C '--trace-warnings');\x0d\n  addReadOnlyProcessAlias('throwDeprecation'\x2C '--throw-deprecation');\x0d\n  addReadOnlyProcessAlias('profProcess'\x2C '--prof-process');\x0d\n  addReadOnlyProcessAlias('traceDeprecation'\x2C '--trace-deprecation');\x0d\n  addReadOnlyProcessAlias('_breakFirstLine'\x2C '--inspect-brk'\x2C false);\x0d\n  addReadOnlyProcessAlias('_breakNodeFirstLine'\x2C '--inspect-brk-node'\x2C false);\x0d\n}\x0d\n\x0d\nfunction addReadOnlyProcessAlias(name\x2C option\x2C enumerable = true) {\x0d\n  const value = getOptionValue(option);\x0d\n  if (value) {\x0d\n    ObjectDefineProperty(process\x2C name\x2C {\x0d\n      writable: false\x2C\x0d\n      configurable: true\x2C\x0d\n      enumerable\x2C\x0d\n      value\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction setupWarningHandler() {\x0d\n  const {\x0d\n    onWarning\x0d\n  } = require('internal/process/warning');\x0d\n  if (getOptionValue('--warnings') &&\x0d\n    process.env.NODE_NO_WARNINGS !== '1') {\x0d\n    process.on('warning'\x2C onWarning);\x0d\n  }\x0d\n}\x0d\n\x0d\n// Setup User-facing NODE_V8_COVERAGE environment variable that writes\x0d\n// ScriptCoverage to a specified file.\x0d\nfunction setupCoverageHooks(dir) {\x0d\n  const cwd = require('internal/process/execution').tryGetCwd();\x0d\n  const { resolve } = require('path');\x0d\n  const coverageDirectory = resolve(cwd\x2C dir);\x0d\n  const { sourceMapCacheToObject } =\x0d\n    require('internal/source_map/source_map_cache');\x0d\n\x0d\n  if (process.features.inspector) {\x0d\n    internalBinding('profiler').setCoverageDirectory(coverageDirectory);\x0d\n    internalBinding('profiler').setSourceMapCacheGetter(sourceMapCacheToObject);\x0d\n  } else {\x0d\n    process.emitWarning('The inspector is disabled\x2C ' +\x0d\n                        'coverage could not be collected'\x2C\x0d\n                        'Warning');\x0d\n    return '';\x0d\n  }\x0d\n  return coverageDirectory;\x0d\n}\x0d\n\x0d\nfunction setupStacktracePrinterOnSigint() {\x0d\n  if (!getOptionValue('--trace-sigint')) {\x0d\n    return;\x0d\n  }\x0d\n  const { SigintWatchdog } = require('internal/watchdog');\x0d\n\x0d\n  const watchdog = new SigintWatchdog();\x0d\n  watchdog.start();\x0d\n}\x0d\n\x0d\nfunction initializeReport() {\x0d\n  const { report } = require('internal/process/report');\x0d\n  ObjectDefineProperty(process\x2C 'report'\x2C {\x0d\n    enumerable: false\x2C\x0d\n    configurable: true\x2C\x0d\n    get() {\x0d\n      return report;\x0d\n    }\x0d\n  });\x0d\n}\x0d\n\x0d\nfunction setupDebugEnv() {\x0d\n  require('internal/util/debuglog').initializeDebugEnv(process.env.NODE_DEBUG);\x0d\n  if (getOptionValue('--expose-internals')) {\x0d\n    require('internal/bootstrap/loaders').NativeModule.exposeInternals();\x0d\n  }\x0d\n}\x0d\n\x0d\n// This has to be called after initializeReport() is called\x0d\nfunction initializeReportSignalHandlers() {\x0d\n  const { addSignalHandler } = require('internal/process/report');\x0d\n\x0d\n  addSignalHandler();\x0d\n}\x0d\n\x0d\nfunction initializeHeapSnapshotSignalHandlers() {\x0d\n  const signal = getOptionValue('--heapsnapshot-signal');\x0d\n\x0d\n  if (!signal)\x0d\n    return;\x0d\n\x0d\n  require('internal/validators').validateSignalName(signal);\x0d\n  const { writeHeapSnapshot } = require('v8');\x0d\n\x0d\n  process.on(signal\x2C () => {\x0d\n    writeHeapSnapshot();\x0d\n  });\x0d\n}\x0d\n\x0d\nfunction setupTraceCategoryState() {\x0d\n  const { isTraceCategoryEnabled } = internalBinding('trace_events');\x0d\n  const { toggleTraceCategoryState } = require('internal/process/per_thread');\x0d\n  toggleTraceCategoryState(isTraceCategoryEnabled('node.async_hooks'));\x0d\n}\x0d\n\x0d\nfunction setupPerfHooks() {\x0d\n  require('internal/perf/performance').refreshTimeOrigin();\x0d\n  require('internal/perf/utils').refreshTimeOrigin();\x0d\n}\x0d\n\x0d\nfunction setupInspectorHooks() {\x0d\n  // If Debugger.setAsyncCallStackDepth is sent during bootstrap\x2C\x0d\n  // we cannot immediately call into JS to enable the hooks\x2C which could\x0d\n  // interrupt the JS execution of bootstrap. So instead we save the\x0d\n  // notification in the inspector agent if it's sent in the middle of\x0d\n  // bootstrap\x2C and process the notification later here.\x0d\n  if (internalBinding('config').hasInspector) {\x0d\n    const {\x0d\n      enable\x2C\x0d\n      disable\x0d\n    } = require('internal/inspector_async_hook');\x0d\n    internalBinding('inspector').registerAsyncHook(enable\x2C disable);\x0d\n  }\x0d\n}\x0d\n\x0d\n// In general deprecations are initialized wherever the APIs are implemented\x2C\x0d\n// this is used to deprecate APIs implemented in C++ where the deprecation\x0d\n// utilities are not easily accessible.\x0d\nfunction initializeDeprecations() {\x0d\n  const { deprecate } = require('internal/util');\x0d\n  const pendingDeprecation = getOptionValue('--pending-deprecation');\x0d\n\x0d\n  // DEP0103: access to `process.binding('util').isX` type checkers\x0d\n  // TODO(addaleax): Turn into a full runtime deprecation.\x0d\n  const utilBinding = internalBinding('util');\x0d\n  const types = require('internal/util/types');\x0d\n  for (const name of [\x0d\n    'isArrayBuffer'\x2C\x0d\n    'isArrayBufferView'\x2C\x0d\n    'isAsyncFunction'\x2C\x0d\n    'isDataView'\x2C\x0d\n    'isDate'\x2C\x0d\n    'isExternal'\x2C\x0d\n    'isMap'\x2C\x0d\n    'isMapIterator'\x2C\x0d\n    'isNativeError'\x2C\x0d\n    'isPromise'\x2C\x0d\n    'isRegExp'\x2C\x0d\n    'isSet'\x2C\x0d\n    'isSetIterator'\x2C\x0d\n    'isTypedArray'\x2C\x0d\n    'isUint8Array'\x2C\x0d\n    'isAnyArrayBuffer'\x2C\x0d\n  ]) {\x0d\n    utilBinding[name] = pendingDeprecation ?\x0d\n      deprecate(types[name]\x2C\x0d\n                'Accessing native typechecking bindings of Node ' +\x0d\n                'directly is deprecated. ' +\x0d\n                `Please use \\`util.types.${name}\\` instead.`\x2C\x0d\n                'DEP0103') :\x0d\n      types[name];\x0d\n  }\x0d\n\x0d\n  // TODO(joyeecheung): this is a legacy property exposed to process.\x0d\n  // Now that we use the config binding to carry this information\x2C remove\x0d\n  // it from the process. We may consider exposing it properly in\x0d\n  // process.features.\x0d\n  const { noBrowserGlobals } = internalBinding('config');\x0d\n  if (noBrowserGlobals) {\x0d\n    ObjectDefineProperty(process\x2C '_noBrowserGlobals'\x2C {\x0d\n      writable: false\x2C\x0d\n      enumerable: true\x2C\x0d\n      configurable: true\x2C\x0d\n      value: noBrowserGlobals\x0d\n    });\x0d\n  }\x0d\n\x0d\n  if (pendingDeprecation) {\x0d\n    process.binding = deprecate(process.binding\x2C\x0d\n                                'process.binding() is deprecated. ' +\x0d\n                                'Please use public APIs instead.'\x2C 'DEP0111');\x0d\n\x0d\n    process._tickCallback = deprecate(process._tickCallback\x2C\x0d\n                                      'process._tickCallback() is deprecated'\x2C\x0d\n                                      'DEP0134');\x0d\n  }\x0d\n\x0d\n  // Create global.process and global.Buffer as getters so that we have a\x0d\n  // deprecation path for these in ES Modules.\x0d\n  // See https://github.com/nodejs/node/pull/26334.\x0d\n  let _process = process;\x0d\n  ObjectDefineProperty(globalThis\x2C 'process'\x2C {\x0d\n    get() {\x0d\n      return _process;\x0d\n    }\x2C\x0d\n    set(value) {\x0d\n      _process = value;\x0d\n    }\x2C\x0d\n    enumerable: false\x2C\x0d\n    configurable: true\x0d\n  });\x0d\n\x0d\n  let _Buffer = Buffer;\x0d\n  ObjectDefineProperty(globalThis\x2C 'Buffer'\x2C {\x0d\n    get() {\x0d\n      return _Buffer;\x0d\n    }\x2C\x0d\n    set(value) {\x0d\n      _Buffer = value;\x0d\n    }\x2C\x0d\n    enumerable: false\x2C\x0d\n    configurable: true\x0d\n  });\x0d\n}\x0d\n\x0d\nfunction setupChildProcessIpcChannel() {\x0d\n  if (process.env.NODE_CHANNEL_FD) {\x0d\n    const assert = require('internal/assert');\x0d\n\x0d\n    const fd = NumberParseInt(process.env.NODE_CHANNEL_FD\x2C 10);\x0d\n    assert(fd >= 0);\x0d\n\x0d\n    // Make sure it's not accidentally inherited by child processes.\x0d\n    delete process.env.NODE_CHANNEL_FD;\x0d\n\x0d\n    const serializationMode =\x0d\n      process.env.NODE_CHANNEL_SERIALIZATION_MODE || 'json';\x0d\n    delete process.env.NODE_CHANNEL_SERIALIZATION_MODE;\x0d\n\x0d\n    require('child_process')._forkChild(fd\x2C serializationMode);\x0d\n    assert(process.send);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction initializeClusterIPC() {\x0d\n  if (process.argv[1] && process.env.NODE_UNIQUE_ID) {\x0d\n    const cluster = require('cluster');\x0d\n    cluster._setupWorker();\x0d\n    // Make sure it's not accidentally inherited by child processes.\x0d\n    delete process.env.NODE_UNIQUE_ID;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction initializePolicy() {\x0d\n  const experimentalPolicy = getOptionValue('--experimental-policy');\x0d\n  if (experimentalPolicy) {\x0d\n    process.emitWarning('Policies are experimental.'\x2C\x0d\n                        'ExperimentalWarning');\x0d\n    const { pathToFileURL\x2C URL } = require('internal/url');\x0d\n    // URL here as it is slightly different parsing\x0d\n    // no bare specifiers for now\x0d\n    let manifestURL;\x0d\n    if (require('path').isAbsolute(experimentalPolicy)) {\x0d\n      manifestURL = new URL(`file://${experimentalPolicy}`);\x0d\n    } else {\x0d\n      const cwdURL = pathToFileURL(process.cwd());\x0d\n      cwdURL.pathname += '/';\x0d\n      manifestURL = new URL(experimentalPolicy\x2C cwdURL);\x0d\n    }\x0d\n    const fs = require('fs');\x0d\n    const src = fs.readFileSync(manifestURL\x2C 'utf8');\x0d\n    const experimentalPolicyIntegrity = getOptionValue('--policy-integrity');\x0d\n    if (experimentalPolicyIntegrity) {\x0d\n      const SRI = require('internal/policy/sri');\x0d\n      const { createHash\x2C timingSafeEqual } = require('crypto');\x0d\n      const realIntegrities = new SafeMap();\x0d\n      const integrityEntries = SRI.parse(experimentalPolicyIntegrity);\x0d\n      let foundMatch = false;\x0d\n      for (let i = 0; i < integrityEntries.length; i++) {\x0d\n        const {\x0d\n          algorithm\x2C\x0d\n          value: expected\x0d\n        } = integrityEntries[i];\x0d\n        const hash = createHash(algorithm);\x0d\n        hash.update(src);\x0d\n        const digest = hash.digest();\x0d\n        if (digest.length === expected.length &&\x0d\n          timingSafeEqual(digest\x2C expected)) {\x0d\n          foundMatch = true;\x0d\n          break;\x0d\n        }\x0d\n        realIntegrities.set(algorithm\x2C digest.toString('base64'));\x0d\n      }\x0d\n      if (!foundMatch) {\x0d\n        throw new ERR_MANIFEST_ASSERT_INTEGRITY(manifestURL\x2C realIntegrities);\x0d\n      }\x0d\n    }\x0d\n    require('internal/process/policy')\x0d\n      .setup(src\x2C manifestURL.href);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction initializeWASI() {\x0d\n  const { NativeModule } = require('internal/bootstrap/loaders');\x0d\n  const mod = NativeModule.map.get('wasi');\x0d\n  mod.canBeRequiredByUsers =\x0d\n    getOptionValue('--experimental-wasi-unstable-preview1');\x0d\n}\x0d\n\x0d\nfunction initializeCJSLoader() {\x0d\n  const CJSLoader = require('internal/modules/cjs/loader');\x0d\n  if (!getEmbedderOptions().noGlobalSearchPaths) {\x0d\n    CJSLoader.Module._initPaths();\x0d\n  }\x0d\n  // TODO(joyeecheung): deprecate this in favor of a proper hook?\x0d\n  CJSLoader.Module.runMain =\x0d\n    require('internal/modules/run_main').executeUserEntryPoint;\x0d\n}\x0d\n\x0d\nfunction initializeESMLoader() {\x0d\n  // Create this WeakMap in js-land because V8 has no C++ API for WeakMap.\x0d\n  internalBinding('module_wrap').callbackMap = new SafeWeakMap();\x0d\n\x0d\n  if (getEmbedderOptions().shouldNotRegisterESMLoader) return;\x0d\n\x0d\n  const {\x0d\n    setImportModuleDynamicallyCallback\x2C\x0d\n    setInitializeImportMetaObjectCallback\x0d\n  } = internalBinding('module_wrap');\x0d\n  const esm = require('internal/process/esm_loader');\x0d\n  // Setup per-isolate callbacks that locate data or callbacks that we keep\x0d\n  // track of for different ESM modules.\x0d\n  setInitializeImportMetaObjectCallback(esm.initializeImportMetaObject);\x0d\n  setImportModuleDynamicallyCallback(esm.importModuleDynamicallyCallback);\x0d\n\x0d\n  // Patch the vm module when --experimental-vm-modules is on.\x0d\n  // Please update the comments in vm.js when this block changes.\x0d\n  if (getOptionValue('--experimental-vm-modules')) {\x0d\n    const {\x0d\n      Module\x2C SourceTextModule\x2C SyntheticModule\x2C\x0d\n    } = require('internal/vm/module');\x0d\n    const vm = require('vm');\x0d\n    vm.Module = Module;\x0d\n    vm.SourceTextModule = SourceTextModule;\x0d\n    vm.SyntheticModule = SyntheticModule;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction initializeSourceMapsHandlers() {\x0d\n  const { setSourceMapsEnabled } =\x0d\n    require('internal/source_map/source_map_cache');\x0d\n  process.setSourceMapsEnabled = setSourceMapsEnabled;\x0d\n}\x0d\n\x0d\nfunction initializeFrozenIntrinsics() {\x0d\n  if (getOptionValue('--frozen-intrinsics')) {\x0d\n    process.emitWarning('The --frozen-intrinsics flag is experimental'\x2C\x0d\n                        'ExperimentalWarning');\x0d\n    require('internal/freeze_intrinsics')();\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction loadPreloadModules() {\x0d\n  // For user code\x2C we preload modules if `-r` is passed\x0d\n  const preloadModules = getOptionValue('--require');\x0d\n  if (preloadModules && preloadModules.length > 0) {\x0d\n    const {\x0d\n      Module: {\x0d\n        _preloadModules\x0d\n      }\x2C\x0d\n    } = require('internal/modules/cjs/loader');\x0d\n    _preloadModules(preloadModules);\x0d\n  }\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  patchProcessObject\x2C\x0d\n  setupCoverageHooks\x2C\x0d\n  setupWarningHandler\x2C\x0d\n  setupDebugEnv\x2C\x0d\n  setupPerfHooks\x2C\x0d\n  prepareMainThreadExecution\x2C\x0d\n  initializeDeprecations\x2C\x0d\n  initializeESMLoader\x2C\x0d\n  initializeFrozenIntrinsics\x2C\x0d\n  initializeSourceMapsHandlers\x2C\x0d\n  loadPreloadModules\x2C\x0d\n  setupTraceCategoryState\x2C\x0d\n  setupInspectorHooks\x2C\x0d\n  initializeReport\x2C\x0d\n  initializeCJSLoader\x2C\x0d\n  initializeWASI\x0d\n};\x0d\n
code-source-info,0x1abee80312e,96,0,16208,C0O0C4O16208,,
code-creation,Function,10,171421,0x1abee803c2e,426, node:internal/bootstrap/pre_execution:1:1,0x1abee8030a8,~
code-source-info,0x1abee803c2e,96,0,16208,C0O0C190O28C196O47C202O72C208O84C214O100C220O130C226O218C232O218C237O174C243O193C249O284C255O284C260O256C266O334C272O334C277O323C283O396C289O396C294O422C299O362C305O446C311O446C315O446C317O15793C324O15815C330O15838C336O15861C342O15885C348O15903C354O15922C360O15953C366O15980C372O16004C378O16035C384O16068C390O16091C396O16119C402O16143C408O16164C414O16188C420O15808C425O16207,,
code-creation,Eval,10,171628,0x1abee80556e,5, node:internal/options:1:1,0x1abee805398,~
script-source,97,node:internal/options,'use strict';\x0d\n\x0d\nconst {\x0d\n  getCLIOptions\x2C\x0d\n  getEmbedderOptions: getEmbedderOptionsFromBinding\x2C\x0d\n} = internalBinding('options');\x0d\n\x0d\nlet warnOnAllowUnauthorized = true;\x0d\n\x0d\nlet optionsMap;\x0d\nlet aliasesMap;\x0d\nlet embedderOptions;\x0d\n\x0d\n// getCLIOptions() would serialize the option values from C++ land.\x0d\n// It would error if the values are queried before bootstrap is\x0d\n// complete so that we don't accidentally include runtime-dependent\x0d\n// states into a runtime-independent snapshot.\x0d\nfunction getCLIOptionsFromBinding() {\x0d\n  if (!optionsMap) {\x0d\n    ({ options: optionsMap } = getCLIOptions());\x0d\n  }\x0d\n  return optionsMap;\x0d\n}\x0d\n\x0d\nfunction getAliasesFromBinding() {\x0d\n  if (!aliasesMap) {\x0d\n    ({ aliases: aliasesMap } = getCLIOptions());\x0d\n  }\x0d\n  return aliasesMap;\x0d\n}\x0d\n\x0d\nfunction getEmbedderOptions() {\x0d\n  if (!embedderOptions) {\x0d\n    embedderOptions = getEmbedderOptionsFromBinding();\x0d\n  }\x0d\n  return embedderOptions;\x0d\n}\x0d\n\x0d\nfunction getOptionValue(optionName) {\x0d\n  const options = getCLIOptionsFromBinding();\x0d\n  if (optionName.startsWith('--no-')) {\x0d\n    const option = options.get('--' + optionName.slice(5));\x0d\n    return option && !option.value;\x0d\n  }\x0d\n  return options.get(optionName)?.value;\x0d\n}\x0d\n\x0d\nfunction getAllowUnauthorized() {\x0d\n  const allowUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED === '0';\x0d\n\x0d\n  if (allowUnauthorized && warnOnAllowUnauthorized) {\x0d\n    warnOnAllowUnauthorized = false;\x0d\n    process.emitWarning(\x0d\n      'Setting the NODE_TLS_REJECT_UNAUTHORIZED ' +\x0d\n      'environment variable to \\'0\\' makes TLS connections ' +\x0d\n      'and HTTPS requests insecure by disabling ' +\x0d\n      'certificate verification.');\x0d\n  }\x0d\n  return allowUnauthorized;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  get options() {\x0d\n    return getCLIOptionsFromBinding();\x0d\n  }\x2C\x0d\n  get aliases() {\x0d\n    return getAliasesFromBinding();\x0d\n  }\x2C\x0d\n  getOptionValue\x2C\x0d\n  getAllowUnauthorized\x2C\x0d\n  getEmbedderOptions\x0d\n};\x0d\n
code-source-info,0x1abee80556e,97,0,1892,C0O0C4O1892,,
code-creation,Function,10,171751,0x1abee80593e,154, node:internal/options:1:1,0x1abee8054e8,~
code-source-info,0x1abee80593e,97,0,1892,C0O0C54O102C57O102C62O28C68O66C74O163C75O163C77O176C78O176C80O193C81O193C83O210C84O210C86O1675C93O1824C99O1843C105O1868C148O1690C153O1891,,
code-creation,LazyCompile,10,171850,0x1abee805e4e,69,internalBinding node:internal/bootstrap/loaders:164:45,0x147335cf920,~
code-source-info,0x1abee805e4e,9,5278,5523,C0O5304C7O5314C11O5329C15O5367C25O5394C30O5392C37O5429C48O5448C56O5484C61O5429C66O5507C68O5518,,
code-creation,LazyCompile,10,172046,0x1abee80669e,213,prepareMainThreadExecution node:internal/bootstrap/pre_execution:22:36,0x1abee803160,~
code-source-info,0x1abee80669e,96,512,2458,C10O658C15O658C18O763C21O763C25O799C28O799C31O829C34O829C37O850C40O850C43O876C46O876C49O1084C52O1096C57O1100C63O1125C66O1133C77O1190C82O1194C87O1163C91O1154C95O1225C98O1225C101O1320C104O1320C107O1429C110O1429C113O1452C116O1452C119O1513C122O1513C125O1843C128O1843C131O1921C134O1921C137O2123C140O2123C143O2152C146O2152C149O2187C152O2187C155O2216C158O2216C161O2237C164O2237C167O2263C170O2263C173O2309C179O2309C184O2352C189O2370C195O2352C199O2401C202O2401C205O2426C208O2426C212O2457,,
code-creation,LazyCompile,10,172189,0x1abee80787e,19,reconnectZeroFillToggle node:internal/buffer:1072:33,0x14121bcbdb8,~
script-source,25,node:internal/buffer,'use strict';\x0d\n\x0d\nconst {\x0d\n  BigInt\x2C\x0d\n  Float32Array\x2C\x0d\n  Float64Array\x2C\x0d\n  MathFloor\x2C\x0d\n  Number\x2C\x0d\n  Uint8Array\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n  ERR_OUT_OF_RANGE\x0d\n} = require('internal/errors').codes;\x0d\nconst { validateNumber } = require('internal/validators');\x0d\nconst {\x0d\n  asciiSlice\x2C\x0d\n  base64Slice\x2C\x0d\n  base64urlSlice\x2C\x0d\n  latin1Slice\x2C\x0d\n  hexSlice\x2C\x0d\n  ucs2Slice\x2C\x0d\n  utf8Slice\x2C\x0d\n  asciiWrite\x2C\x0d\n  base64Write\x2C\x0d\n  base64urlWrite\x2C\x0d\n  latin1Write\x2C\x0d\n  hexWrite\x2C\x0d\n  ucs2Write\x2C\x0d\n  utf8Write\x2C\x0d\n  getZeroFillToggle\x0d\n} = internalBinding('buffer');\x0d\nconst {\x0d\n  untransferable_object_private_symbol\x2C\x0d\n  setHiddenValue\x2C\x0d\n} = internalBinding('util');\x0d\n\x0d\n// Temporary buffers to convert numbers.\x0d\nconst float32Array = new Float32Array(1);\x0d\nconst uInt8Float32Array = new Uint8Array(float32Array.buffer);\x0d\nconst float64Array = new Float64Array(1);\x0d\nconst uInt8Float64Array = new Uint8Array(float64Array.buffer);\x0d\n\x0d\n// Check endianness.\x0d\nfloat32Array[0] = -1; // 0xBF800000\x0d\n// Either it is [0\x2C 0\x2C 128\x2C 191] or [191\x2C 128\x2C 0\x2C 0]. It is not possible to\x0d\n// check this with `os.endianness()` because that is determined at compile time.\x0d\nconst bigEndian = uInt8Float32Array[3] === 0;\x0d\n\x0d\nfunction checkBounds(buf\x2C offset\x2C byteLength) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined)\x0d\n    boundsError(offset\x2C buf.length - (byteLength + 1));\x0d\n}\x0d\n\x0d\nfunction checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C byteLength) {\x0d\n  if (value > max || value < min) {\x0d\n    const n = typeof min === 'bigint' ? 'n' : '';\x0d\n    let range;\x0d\n    if (byteLength > 3) {\x0d\n      if (min === 0 || min === 0n) {\x0d\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;\x0d\n      } else {\x0d\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and ` +\x0d\n                `< 2${n} ** ${(byteLength + 1) * 8 - 1}${n}`;\x0d\n      }\x0d\n    } else {\x0d\n      range = `>= ${min}${n} and <= ${max}${n}`;\x0d\n    }\x0d\n    throw new ERR_OUT_OF_RANGE('value'\x2C range\x2C value);\x0d\n  }\x0d\n  checkBounds(buf\x2C offset\x2C byteLength);\x0d\n}\x0d\n\x0d\nfunction boundsError(value\x2C length\x2C type) {\x0d\n  if (MathFloor(value) !== value) {\x0d\n    validateNumber(value\x2C type);\x0d\n    throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C 'an integer'\x2C value);\x0d\n  }\x0d\n\x0d\n  if (length < 0)\x0d\n    throw new ERR_BUFFER_OUT_OF_BOUNDS();\x0d\n\x0d\n  throw new ERR_OUT_OF_RANGE(type || 'offset'\x2C\x0d\n                             `>= ${type ? 1 : 0} and <= ${length}`\x2C\x0d\n                             value);\x0d\n}\x0d\n\x0d\n// Read integers.\x0d\nfunction readBigUInt64LE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 7];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 8);\x0d\n\x0d\n  const lo = first +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    this[++offset] * 2 ** 24;\x0d\n\x0d\n  const hi = this[++offset] +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    last * 2 ** 24;\x0d\n\x0d\n  return BigInt(lo) + (BigInt(hi) << 32n);\x0d\n}\x0d\n\x0d\nfunction readBigUInt64BE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 7];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 8);\x0d\n\x0d\n  const hi = first * 2 ** 24 +\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    this[++offset];\x0d\n\x0d\n  const lo = this[++offset] * 2 ** 24 +\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    last;\x0d\n\x0d\n  return (BigInt(hi) << 32n) + BigInt(lo);\x0d\n}\x0d\n\x0d\nfunction readBigInt64LE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 7];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 8);\x0d\n\x0d\n  const val = this[offset + 4] +\x0d\n    this[offset + 5] * 2 ** 8 +\x0d\n    this[offset + 6] * 2 ** 16 +\x0d\n    (last << 24); // Overflow\x0d\n  return (BigInt(val) << 32n) +\x0d\n    BigInt(first +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    this[++offset] * 2 ** 24);\x0d\n}\x0d\n\x0d\nfunction readBigInt64BE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 7];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 8);\x0d\n\x0d\n  const val = (first << 24) + // Overflow\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    this[++offset];\x0d\n  return (BigInt(val) << 32n) +\x0d\n    BigInt(this[++offset] * 2 ** 24 +\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    last);\x0d\n}\x0d\n\x0d\nfunction readUIntLE(offset\x2C byteLength) {\x0d\n  if (offset === undefined)\x0d\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\x0d\n  if (byteLength === 6)\x0d\n    return readUInt48LE(this\x2C offset);\x0d\n  if (byteLength === 5)\x0d\n    return readUInt40LE(this\x2C offset);\x0d\n  if (byteLength === 3)\x0d\n    return readUInt24LE(this\x2C offset);\x0d\n  if (byteLength === 4)\x0d\n    return this.readUInt32LE(offset);\x0d\n  if (byteLength === 2)\x0d\n    return this.readUInt16LE(offset);\x0d\n  if (byteLength === 1)\x0d\n    return this.readUInt8(offset);\x0d\n\x0d\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\x0d\n}\x0d\n\x0d\nfunction readUInt48LE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 5];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 6);\x0d\n\x0d\n  return first +\x0d\n    buf[++offset] * 2 ** 8 +\x0d\n    buf[++offset] * 2 ** 16 +\x0d\n    buf[++offset] * 2 ** 24 +\x0d\n    (buf[++offset] + last * 2 ** 8) * 2 ** 32;\x0d\n}\x0d\n\x0d\nfunction readUInt40LE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 4];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 5);\x0d\n\x0d\n  return first +\x0d\n    buf[++offset] * 2 ** 8 +\x0d\n    buf[++offset] * 2 ** 16 +\x0d\n    buf[++offset] * 2 ** 24 +\x0d\n    last * 2 ** 32;\x0d\n}\x0d\n\x0d\nfunction readUInt32LE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 3];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 4);\x0d\n\x0d\n  return first +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    last * 2 ** 24;\x0d\n}\x0d\n\x0d\nfunction readUInt24LE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 2];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 3);\x0d\n\x0d\n  return first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\x0d\n}\x0d\n\x0d\nfunction readUInt16LE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 1];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 2);\x0d\n\x0d\n  return first + last * 2 ** 8;\x0d\n}\x0d\n\x0d\nfunction readUInt8(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const val = this[offset];\x0d\n  if (val === undefined)\x0d\n    boundsError(offset\x2C this.length - 1);\x0d\n\x0d\n  return val;\x0d\n}\x0d\n\x0d\nfunction readUIntBE(offset\x2C byteLength) {\x0d\n  if (offset === undefined)\x0d\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\x0d\n  if (byteLength === 6)\x0d\n    return readUInt48BE(this\x2C offset);\x0d\n  if (byteLength === 5)\x0d\n    return readUInt40BE(this\x2C offset);\x0d\n  if (byteLength === 3)\x0d\n    return readUInt24BE(this\x2C offset);\x0d\n  if (byteLength === 4)\x0d\n    return this.readUInt32BE(offset);\x0d\n  if (byteLength === 2)\x0d\n    return this.readUInt16BE(offset);\x0d\n  if (byteLength === 1)\x0d\n    return this.readUInt8(offset);\x0d\n\x0d\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\x0d\n}\x0d\n\x0d\nfunction readUInt48BE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 5];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 6);\x0d\n\x0d\n  return (first * 2 ** 8 + buf[++offset]) * 2 ** 32 +\x0d\n    buf[++offset] * 2 ** 24 +\x0d\n    buf[++offset] * 2 ** 16 +\x0d\n    buf[++offset] * 2 ** 8 +\x0d\n    last;\x0d\n}\x0d\n\x0d\nfunction readUInt40BE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 4];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 5);\x0d\n\x0d\n  return first * 2 ** 32 +\x0d\n    buf[++offset] * 2 ** 24 +\x0d\n    buf[++offset] * 2 ** 16 +\x0d\n    buf[++offset] * 2 ** 8 +\x0d\n    last;\x0d\n}\x0d\n\x0d\nfunction readUInt32BE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 3];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 4);\x0d\n\x0d\n  return first * 2 ** 24 +\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    last;\x0d\n}\x0d\n\x0d\nfunction readUInt24BE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 2];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 3);\x0d\n\x0d\n  return first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\x0d\n}\x0d\n\x0d\nfunction readUInt16BE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 1];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 2);\x0d\n\x0d\n  return first * 2 ** 8 + last;\x0d\n}\x0d\n\x0d\nfunction readIntLE(offset\x2C byteLength) {\x0d\n  if (offset === undefined)\x0d\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\x0d\n  if (byteLength === 6)\x0d\n    return readInt48LE(this\x2C offset);\x0d\n  if (byteLength === 5)\x0d\n    return readInt40LE(this\x2C offset);\x0d\n  if (byteLength === 3)\x0d\n    return readInt24LE(this\x2C offset);\x0d\n  if (byteLength === 4)\x0d\n    return this.readInt32LE(offset);\x0d\n  if (byteLength === 2)\x0d\n    return this.readInt16LE(offset);\x0d\n  if (byteLength === 1)\x0d\n    return this.readInt8(offset);\x0d\n\x0d\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\x0d\n}\x0d\n\x0d\nfunction readInt48LE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 5];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 6);\x0d\n\x0d\n  const val = buf[offset + 4] + last * 2 ** 8;\x0d\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\x0d\n    first +\x0d\n    buf[++offset] * 2 ** 8 +\x0d\n    buf[++offset] * 2 ** 16 +\x0d\n    buf[++offset] * 2 ** 24;\x0d\n}\x0d\n\x0d\nfunction readInt40LE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 4];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 5);\x0d\n\x0d\n  return (last | (last & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\x0d\n    first +\x0d\n    buf[++offset] * 2 ** 8 +\x0d\n    buf[++offset] * 2 ** 16 +\x0d\n    buf[++offset] * 2 ** 24;\x0d\n}\x0d\n\x0d\nfunction readInt32LE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 3];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 4);\x0d\n\x0d\n  return first +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    (last << 24); // Overflow\x0d\n}\x0d\n\x0d\nfunction readInt24LE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 2];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 3);\x0d\n\x0d\n  const val = first + buf[++offset] * 2 ** 8 + last * 2 ** 16;\x0d\n  return val | (val & 2 ** 23) * 0x1fe;\x0d\n}\x0d\n\x0d\nfunction readInt16LE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 1];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 2);\x0d\n\x0d\n  const val = first + last * 2 ** 8;\x0d\n  return val | (val & 2 ** 15) * 0x1fffe;\x0d\n}\x0d\n\x0d\nfunction readInt8(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const val = this[offset];\x0d\n  if (val === undefined)\x0d\n    boundsError(offset\x2C this.length - 1);\x0d\n\x0d\n  return val | (val & 2 ** 7) * 0x1fffffe;\x0d\n}\x0d\n\x0d\nfunction readIntBE(offset\x2C byteLength) {\x0d\n  if (offset === undefined)\x0d\n    throw new ERR_INVALID_ARG_TYPE('offset'\x2C 'number'\x2C offset);\x0d\n  if (byteLength === 6)\x0d\n    return readInt48BE(this\x2C offset);\x0d\n  if (byteLength === 5)\x0d\n    return readInt40BE(this\x2C offset);\x0d\n  if (byteLength === 3)\x0d\n    return readInt24BE(this\x2C offset);\x0d\n  if (byteLength === 4)\x0d\n    return this.readInt32BE(offset);\x0d\n  if (byteLength === 2)\x0d\n    return this.readInt16BE(offset);\x0d\n  if (byteLength === 1)\x0d\n    return this.readInt8(offset);\x0d\n\x0d\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\x0d\n}\x0d\n\x0d\nfunction readInt48BE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 5];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 6);\x0d\n\x0d\n  const val = buf[++offset] + first * 2 ** 8;\x0d\n  return (val | (val & 2 ** 15) * 0x1fffe) * 2 ** 32 +\x0d\n    buf[++offset] * 2 ** 24 +\x0d\n    buf[++offset] * 2 ** 16 +\x0d\n    buf[++offset] * 2 ** 8 +\x0d\n    last;\x0d\n}\x0d\n\x0d\nfunction readInt40BE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 4];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 5);\x0d\n\x0d\n  return (first | (first & 2 ** 7) * 0x1fffffe) * 2 ** 32 +\x0d\n    buf[++offset] * 2 ** 24 +\x0d\n    buf[++offset] * 2 ** 16 +\x0d\n    buf[++offset] * 2 ** 8 +\x0d\n    last;\x0d\n}\x0d\n\x0d\nfunction readInt32BE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 3];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 4);\x0d\n\x0d\n  return (first << 24) + // Overflow\x0d\n    this[++offset] * 2 ** 16 +\x0d\n    this[++offset] * 2 ** 8 +\x0d\n    last;\x0d\n}\x0d\n\x0d\nfunction readInt24BE(buf\x2C offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = buf[offset];\x0d\n  const last = buf[offset + 2];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C buf.length - 3);\x0d\n\x0d\n  const val = first * 2 ** 16 + buf[++offset] * 2 ** 8 + last;\x0d\n  return val | (val & 2 ** 23) * 0x1fe;\x0d\n}\x0d\n\x0d\nfunction readInt16BE(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 1];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 2);\x0d\n\x0d\n  const val = first * 2 ** 8 + last;\x0d\n  return val | (val & 2 ** 15) * 0x1fffe;\x0d\n}\x0d\n\x0d\n// Read floats\x0d\nfunction readFloatBackwards(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 3];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 4);\x0d\n\x0d\n  uInt8Float32Array[3] = first;\x0d\n  uInt8Float32Array[2] = this[++offset];\x0d\n  uInt8Float32Array[1] = this[++offset];\x0d\n  uInt8Float32Array[0] = last;\x0d\n  return float32Array[0];\x0d\n}\x0d\n\x0d\nfunction readFloatForwards(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 3];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 4);\x0d\n\x0d\n  uInt8Float32Array[0] = first;\x0d\n  uInt8Float32Array[1] = this[++offset];\x0d\n  uInt8Float32Array[2] = this[++offset];\x0d\n  uInt8Float32Array[3] = last;\x0d\n  return float32Array[0];\x0d\n}\x0d\n\x0d\nfunction readDoubleBackwards(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 7];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 8);\x0d\n\x0d\n  uInt8Float64Array[7] = first;\x0d\n  uInt8Float64Array[6] = this[++offset];\x0d\n  uInt8Float64Array[5] = this[++offset];\x0d\n  uInt8Float64Array[4] = this[++offset];\x0d\n  uInt8Float64Array[3] = this[++offset];\x0d\n  uInt8Float64Array[2] = this[++offset];\x0d\n  uInt8Float64Array[1] = this[++offset];\x0d\n  uInt8Float64Array[0] = last;\x0d\n  return float64Array[0];\x0d\n}\x0d\n\x0d\nfunction readDoubleForwards(offset = 0) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  const first = this[offset];\x0d\n  const last = this[offset + 7];\x0d\n  if (first === undefined || last === undefined)\x0d\n    boundsError(offset\x2C this.length - 8);\x0d\n\x0d\n  uInt8Float64Array[0] = first;\x0d\n  uInt8Float64Array[1] = this[++offset];\x0d\n  uInt8Float64Array[2] = this[++offset];\x0d\n  uInt8Float64Array[3] = this[++offset];\x0d\n  uInt8Float64Array[4] = this[++offset];\x0d\n  uInt8Float64Array[5] = this[++offset];\x0d\n  uInt8Float64Array[6] = this[++offset];\x0d\n  uInt8Float64Array[7] = last;\x0d\n  return float64Array[0];\x0d\n}\x0d\n\x0d\n// Write integers.\x0d\nfunction writeBigU_Int64LE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\x0d\n\x0d\n  let lo = Number(value & 0xffffffffn);\x0d\n  buf[offset++] = lo;\x0d\n  lo = lo >> 8;\x0d\n  buf[offset++] = lo;\x0d\n  lo = lo >> 8;\x0d\n  buf[offset++] = lo;\x0d\n  lo = lo >> 8;\x0d\n  buf[offset++] = lo;\x0d\n  let hi = Number(value >> 32n & 0xffffffffn);\x0d\n  buf[offset++] = hi;\x0d\n  hi = hi >> 8;\x0d\n  buf[offset++] = hi;\x0d\n  hi = hi >> 8;\x0d\n  buf[offset++] = hi;\x0d\n  hi = hi >> 8;\x0d\n  buf[offset++] = hi;\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeBigUInt64LE(value\x2C offset = 0) {\x0d\n  return writeBigU_Int64LE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\x0d\n}\x0d\n\x0d\nfunction writeBigU_Int64BE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 7);\x0d\n\x0d\n  let lo = Number(value & 0xffffffffn);\x0d\n  buf[offset + 7] = lo;\x0d\n  lo = lo >> 8;\x0d\n  buf[offset + 6] = lo;\x0d\n  lo = lo >> 8;\x0d\n  buf[offset + 5] = lo;\x0d\n  lo = lo >> 8;\x0d\n  buf[offset + 4] = lo;\x0d\n  let hi = Number(value >> 32n & 0xffffffffn);\x0d\n  buf[offset + 3] = hi;\x0d\n  hi = hi >> 8;\x0d\n  buf[offset + 2] = hi;\x0d\n  hi = hi >> 8;\x0d\n  buf[offset + 1] = hi;\x0d\n  hi = hi >> 8;\x0d\n  buf[offset] = hi;\x0d\n  return offset + 8;\x0d\n}\x0d\n\x0d\nfunction writeBigUInt64BE(value\x2C offset = 0) {\x0d\n  return writeBigU_Int64BE(this\x2C value\x2C offset\x2C 0n\x2C 0xffffffffffffffffn);\x0d\n}\x0d\n\x0d\nfunction writeBigInt64LE(value\x2C offset = 0) {\x0d\n  return writeBigU_Int64LE(\x0d\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\x0d\n}\x0d\n\x0d\nfunction writeBigInt64BE(value\x2C offset = 0) {\x0d\n  return writeBigU_Int64BE(\x0d\n    this\x2C value\x2C offset\x2C -0x8000000000000000n\x2C 0x7fffffffffffffffn);\x0d\n}\x0d\n\x0d\nfunction writeUIntLE(value\x2C offset\x2C byteLength) {\x0d\n  if (byteLength === 6)\x0d\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\x0d\n  if (byteLength === 5)\x0d\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\x0d\n  if (byteLength === 3)\x0d\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\x0d\n  if (byteLength === 4)\x0d\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\x0d\n  if (byteLength === 2)\x0d\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\x0d\n  if (byteLength === 1)\x0d\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\x0d\n\x0d\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\x0d\n}\x0d\n\x0d\nfunction writeU_Int48LE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\x0d\n\x0d\n  const newVal = MathFloor(value * 2 ** -32);\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  buf[offset++] = newVal;\x0d\n  buf[offset++] = (newVal >>> 8);\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeU_Int40LE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\x0d\n\x0d\n  const newVal = value;\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  buf[offset++] = MathFloor(newVal * 2 ** -32);\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeU_Int32LE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\x0d\n\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeUInt32LE(value\x2C offset = 0) {\x0d\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\x0d\n}\x0d\n\x0d\nfunction writeU_Int24LE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\x0d\n\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset++] = value;\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeU_Int16LE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\x0d\n\x0d\n  buf[offset++] = value;\x0d\n  buf[offset++] = (value >>> 8);\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeUInt16LE(value\x2C offset = 0) {\x0d\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\x0d\n}\x0d\n\x0d\nfunction writeU_Int8(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  // `checkInt()` can not be used here because it checks two entries.\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  if (value > max || value < min) {\x0d\n    throw new ERR_OUT_OF_RANGE('value'\x2C `>= ${min} and <= ${max}`\x2C value);\x0d\n  }\x0d\n  if (buf[offset] === undefined)\x0d\n    boundsError(offset\x2C buf.length - 1);\x0d\n\x0d\n  buf[offset] = value;\x0d\n  return offset + 1;\x0d\n}\x0d\n\x0d\nfunction writeUInt8(value\x2C offset = 0) {\x0d\n  return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\x0d\n}\x0d\n\x0d\nfunction writeUIntBE(value\x2C offset\x2C byteLength) {\x0d\n  if (byteLength === 6)\x0d\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffffff);\x0d\n  if (byteLength === 5)\x0d\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffffff);\x0d\n  if (byteLength === 3)\x0d\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffff);\x0d\n  if (byteLength === 4)\x0d\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\x0d\n  if (byteLength === 2)\x0d\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\x0d\n  if (byteLength === 1)\x0d\n    return writeU_Int8(this\x2C value\x2C offset\x2C 0\x2C 0xff);\x0d\n\x0d\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\x0d\n}\x0d\n\x0d\nfunction writeU_Int48BE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 5);\x0d\n\x0d\n  const newVal = MathFloor(value * 2 ** -32);\x0d\n  buf[offset++] = (newVal >>> 8);\x0d\n  buf[offset++] = newVal;\x0d\n  buf[offset + 3] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset + 2] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset + 1] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset] = value;\x0d\n  return offset + 4;\x0d\n}\x0d\n\x0d\nfunction writeU_Int40BE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 4);\x0d\n\x0d\n  buf[offset++] = MathFloor(value * 2 ** -32);\x0d\n  buf[offset + 3] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset + 2] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset + 1] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset] = value;\x0d\n  return offset + 4;\x0d\n}\x0d\n\x0d\nfunction writeU_Int32BE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 3);\x0d\n\x0d\n  buf[offset + 3] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset + 2] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset + 1] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset] = value;\x0d\n  return offset + 4;\x0d\n}\x0d\n\x0d\nfunction writeUInt32BE(value\x2C offset = 0) {\x0d\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C 0\x2C 0xffffffff);\x0d\n}\x0d\n\x0d\nfunction writeU_Int24BE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 2);\x0d\n\x0d\n  buf[offset + 2] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset + 1] = value;\x0d\n  value = value >>> 8;\x0d\n  buf[offset] = value;\x0d\n  return offset + 3;\x0d\n}\x0d\n\x0d\nfunction writeU_Int16BE(buf\x2C value\x2C offset\x2C min\x2C max) {\x0d\n  value = +value;\x0d\n  checkInt(value\x2C min\x2C max\x2C buf\x2C offset\x2C 1);\x0d\n\x0d\n  buf[offset++] = (value >>> 8);\x0d\n  buf[offset++] = value;\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeUInt16BE(value\x2C offset = 0) {\x0d\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C 0\x2C 0xffff);\x0d\n}\x0d\n\x0d\nfunction writeIntLE(value\x2C offset\x2C byteLength) {\x0d\n  if (byteLength === 6)\x0d\n    return writeU_Int48LE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\x0d\n  if (byteLength === 5)\x0d\n    return writeU_Int40LE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\x0d\n  if (byteLength === 3)\x0d\n    return writeU_Int24LE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\x0d\n  if (byteLength === 4)\x0d\n    return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\x0d\n  if (byteLength === 2)\x0d\n    return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\x0d\n  if (byteLength === 1)\x0d\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\x0d\n\x0d\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\x0d\n}\x0d\n\x0d\nfunction writeInt32LE(value\x2C offset = 0) {\x0d\n  return writeU_Int32LE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\x0d\n}\x0d\n\x0d\nfunction writeInt16LE(value\x2C offset = 0) {\x0d\n  return writeU_Int16LE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\x0d\n}\x0d\n\x0d\nfunction writeInt8(value\x2C offset = 0) {\x0d\n  return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\x0d\n}\x0d\n\x0d\nfunction writeIntBE(value\x2C offset\x2C byteLength) {\x0d\n  if (byteLength === 6)\x0d\n    return writeU_Int48BE(this\x2C value\x2C offset\x2C -0x800000000000\x2C 0x7fffffffffff);\x0d\n  if (byteLength === 5)\x0d\n    return writeU_Int40BE(this\x2C value\x2C offset\x2C -0x8000000000\x2C 0x7fffffffff);\x0d\n  if (byteLength === 3)\x0d\n    return writeU_Int24BE(this\x2C value\x2C offset\x2C -0x800000\x2C 0x7fffff);\x0d\n  if (byteLength === 4)\x0d\n    return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\x0d\n  if (byteLength === 2)\x0d\n    return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\x0d\n  if (byteLength === 1)\x0d\n    return writeU_Int8(this\x2C value\x2C offset\x2C -0x80\x2C 0x7f);\x0d\n\x0d\n  boundsError(byteLength\x2C 6\x2C 'byteLength');\x0d\n}\x0d\n\x0d\nfunction writeInt32BE(value\x2C offset = 0) {\x0d\n  return writeU_Int32BE(this\x2C value\x2C offset\x2C -0x80000000\x2C 0x7fffffff);\x0d\n}\x0d\n\x0d\nfunction writeInt16BE(value\x2C offset = 0) {\x0d\n  return writeU_Int16BE(this\x2C value\x2C offset\x2C -0x8000\x2C 0x7fff);\x0d\n}\x0d\n\x0d\n// Write floats.\x0d\nfunction writeDoubleForwards(val\x2C offset = 0) {\x0d\n  val = +val;\x0d\n  checkBounds(this\x2C offset\x2C 7);\x0d\n\x0d\n  float64Array[0] = val;\x0d\n  this[offset++] = uInt8Float64Array[0];\x0d\n  this[offset++] = uInt8Float64Array[1];\x0d\n  this[offset++] = uInt8Float64Array[2];\x0d\n  this[offset++] = uInt8Float64Array[3];\x0d\n  this[offset++] = uInt8Float64Array[4];\x0d\n  this[offset++] = uInt8Float64Array[5];\x0d\n  this[offset++] = uInt8Float64Array[6];\x0d\n  this[offset++] = uInt8Float64Array[7];\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeDoubleBackwards(val\x2C offset = 0) {\x0d\n  val = +val;\x0d\n  checkBounds(this\x2C offset\x2C 7);\x0d\n\x0d\n  float64Array[0] = val;\x0d\n  this[offset++] = uInt8Float64Array[7];\x0d\n  this[offset++] = uInt8Float64Array[6];\x0d\n  this[offset++] = uInt8Float64Array[5];\x0d\n  this[offset++] = uInt8Float64Array[4];\x0d\n  this[offset++] = uInt8Float64Array[3];\x0d\n  this[offset++] = uInt8Float64Array[2];\x0d\n  this[offset++] = uInt8Float64Array[1];\x0d\n  this[offset++] = uInt8Float64Array[0];\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeFloatForwards(val\x2C offset = 0) {\x0d\n  val = +val;\x0d\n  checkBounds(this\x2C offset\x2C 3);\x0d\n\x0d\n  float32Array[0] = val;\x0d\n  this[offset++] = uInt8Float32Array[0];\x0d\n  this[offset++] = uInt8Float32Array[1];\x0d\n  this[offset++] = uInt8Float32Array[2];\x0d\n  this[offset++] = uInt8Float32Array[3];\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nfunction writeFloatBackwards(val\x2C offset = 0) {\x0d\n  val = +val;\x0d\n  checkBounds(this\x2C offset\x2C 3);\x0d\n\x0d\n  float32Array[0] = val;\x0d\n  this[offset++] = uInt8Float32Array[3];\x0d\n  this[offset++] = uInt8Float32Array[2];\x0d\n  this[offset++] = uInt8Float32Array[1];\x0d\n  this[offset++] = uInt8Float32Array[0];\x0d\n  return offset;\x0d\n}\x0d\n\x0d\nclass FastBuffer extends Uint8Array {\x0d\n  // Using an explicit constructor here is necessary to avoid relying on\x0d\n  // `Array.prototype[Symbol.iterator]`\x2C which can be mutated by users.\x0d\n  // eslint-disable-next-line no-useless-constructor\x0d\n  constructor(bufferOrLength\x2C byteOffset\x2C length) {\x0d\n    super(bufferOrLength\x2C byteOffset\x2C length);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction addBufferPrototypeMethods(proto) {\x0d\n  proto.readBigUInt64LE = readBigUInt64LE;\x0d\n  proto.readBigUInt64BE = readBigUInt64BE;\x0d\n  proto.readBigUint64LE = readBigUInt64LE;\x0d\n  proto.readBigUint64BE = readBigUInt64BE;\x0d\n  proto.readBigInt64LE = readBigInt64LE;\x0d\n  proto.readBigInt64BE = readBigInt64BE;\x0d\n  proto.writeBigUInt64LE = writeBigUInt64LE;\x0d\n  proto.writeBigUInt64BE = writeBigUInt64BE;\x0d\n  proto.writeBigUint64LE = writeBigUInt64LE;\x0d\n  proto.writeBigUint64BE = writeBigUInt64BE;\x0d\n  proto.writeBigInt64LE = writeBigInt64LE;\x0d\n  proto.writeBigInt64BE = writeBigInt64BE;\x0d\n\x0d\n  proto.readUIntLE = readUIntLE;\x0d\n  proto.readUInt32LE = readUInt32LE;\x0d\n  proto.readUInt16LE = readUInt16LE;\x0d\n  proto.readUInt8 = readUInt8;\x0d\n  proto.readUIntBE = readUIntBE;\x0d\n  proto.readUInt32BE = readUInt32BE;\x0d\n  proto.readUInt16BE = readUInt16BE;\x0d\n  proto.readUintLE = readUIntLE;\x0d\n  proto.readUint32LE = readUInt32LE;\x0d\n  proto.readUint16LE = readUInt16LE;\x0d\n  proto.readUint8 = readUInt8;\x0d\n  proto.readUintBE = readUIntBE;\x0d\n  proto.readUint32BE = readUInt32BE;\x0d\n  proto.readUint16BE = readUInt16BE;\x0d\n  proto.readIntLE = readIntLE;\x0d\n  proto.readInt32LE = readInt32LE;\x0d\n  proto.readInt16LE = readInt16LE;\x0d\n  proto.readInt8 = readInt8;\x0d\n  proto.readIntBE = readIntBE;\x0d\n  proto.readInt32BE = readInt32BE;\x0d\n  proto.readInt16BE = readInt16BE;\x0d\n\x0d\n  proto.writeUIntLE = writeUIntLE;\x0d\n  proto.writeUInt32LE = writeUInt32LE;\x0d\n  proto.writeUInt16LE = writeUInt16LE;\x0d\n  proto.writeUInt8 = writeUInt8;\x0d\n  proto.writeUIntBE = writeUIntBE;\x0d\n  proto.writeUInt32BE = writeUInt32BE;\x0d\n  proto.writeUInt16BE = writeUInt16BE;\x0d\n  proto.writeUintLE = writeUIntLE;\x0d\n  proto.writeUint32LE = writeUInt32LE;\x0d\n  proto.writeUint16LE = writeUInt16LE;\x0d\n  proto.writeUint8 = writeUInt8;\x0d\n  proto.writeUintBE = writeUIntBE;\x0d\n  proto.writeUint32BE = writeUInt32BE;\x0d\n  proto.writeUint16BE = writeUInt16BE;\x0d\n  proto.writeIntLE = writeIntLE;\x0d\n  proto.writeInt32LE = writeInt32LE;\x0d\n  proto.writeInt16LE = writeInt16LE;\x0d\n  proto.writeInt8 = writeInt8;\x0d\n  proto.writeIntBE = writeIntBE;\x0d\n  proto.writeInt32BE = writeInt32BE;\x0d\n  proto.writeInt16BE = writeInt16BE;\x0d\n\x0d\n  proto.readFloatLE = bigEndian ? readFloatBackwards : readFloatForwards;\x0d\n  proto.readFloatBE = bigEndian ? readFloatForwards : readFloatBackwards;\x0d\n  proto.readDoubleLE = bigEndian ? readDoubleBackwards : readDoubleForwards;\x0d\n  proto.readDoubleBE = bigEndian ? readDoubleForwards : readDoubleBackwards;\x0d\n  proto.writeFloatLE = bigEndian ? writeFloatBackwards : writeFloatForwards;\x0d\n  proto.writeFloatBE = bigEndian ? writeFloatForwards : writeFloatBackwards;\x0d\n  proto.writeDoubleLE = bigEndian ? writeDoubleBackwards : writeDoubleForwards;\x0d\n  proto.writeDoubleBE = bigEndian ? writeDoubleForwards : writeDoubleBackwards;\x0d\n\x0d\n  proto.asciiSlice = asciiSlice;\x0d\n  proto.base64Slice = base64Slice;\x0d\n  proto.base64urlSlice = base64urlSlice;\x0d\n  proto.latin1Slice = latin1Slice;\x0d\n  proto.hexSlice = hexSlice;\x0d\n  proto.ucs2Slice = ucs2Slice;\x0d\n  proto.utf8Slice = utf8Slice;\x0d\n  proto.asciiWrite = asciiWrite;\x0d\n  proto.base64Write = base64Write;\x0d\n  proto.base64urlWrite = base64urlWrite;\x0d\n  proto.latin1Write = latin1Write;\x0d\n  proto.hexWrite = hexWrite;\x0d\n  proto.ucs2Write = ucs2Write;\x0d\n  proto.utf8Write = utf8Write;\x0d\n}\x0d\n\x0d\n// This would better be placed in internal/worker/io.js\x2C but that doesn't work\x0d\n// because Buffer needs this and that would introduce a cyclic dependency.\x0d\nfunction markAsUntransferable(obj) {\x0d\n  if ((typeof obj !== 'object' && typeof obj !== 'function') || obj === null)\x0d\n    return;  // This object is a primitive and therefore already untransferable.\x0d\n  setHiddenValue(obj\x2C untransferable_object_private_symbol\x2C true);\x0d\n}\x0d\n\x0d\n// A toggle used to access the zero fill setting of the array buffer allocator\x0d\n// in C++.\x0d\n// |zeroFill| can be undefined when running inside an isolate where we\x0d\n// do not own the ArrayBuffer allocator.  Zero fill is always on in that case.\x0d\nlet zeroFill = getZeroFillToggle();\x0d\nfunction createUnsafeBuffer(size) {\x0d\n  zeroFill[0] = 0;\x0d\n  try {\x0d\n    return new FastBuffer(size);\x0d\n  } finally {\x0d\n    zeroFill[0] = 1;\x0d\n  }\x0d\n}\x0d\n\x0d\n// The connection between the JS land zero fill toggle and the\x0d\n// C++ one in the NodeArrayBufferAllocator gets lost if the toggle\x0d\n// is deserialized from the snapshot\x2C because V8 owns the underlying\x0d\n// memory of this toggle. This resets the connection.\x0d\nfunction reconnectZeroFillToggle() {\x0d\n  zeroFill = getZeroFillToggle();\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  FastBuffer\x2C\x0d\n  addBufferPrototypeMethods\x2C\x0d\n  markAsUntransferable\x2C\x0d\n  createUnsafeBuffer\x2C\x0d\n  readUInt16BE\x2C\x0d\n  readUInt32BE\x2C\x0d\n  reconnectZeroFillToggle\x0d\n};\x0d\n
code-source-info,0x1abee80787e,25,31788,31830,C0O31796C5O31807C11O31805C18O31829,,
code-creation,LazyCompile,10,174111,0x1abee80a0b6,397,patchProcessObject node:internal/bootstrap/pre_execution:81:28,0x1abee8031b0,~
code-source-info,0x1abee80a0b6,96,2489,4095,C0O2524C6O2524C11O2571C19O2571C24O2605C30O2605C35O2643C40O2644C44O2672C55O2693C63O2782C69O2786C76O2672C81O2800C84O2808C94O2826C98O2816C102O2841C109O2868C116O2872C123O2887C129O2921C136O2925C143O2887C150O3005C156O3005C164O3040C167O3048C175O3063C183O3079C190O3083C194O3063C199O3056C209O3257C218O3257C223O3304C232O3304C237O3358C246O3358C251O3419C260O3419C265O3478C274O3478C279O3539C288O3539C293O3604C302O3604C307O3670C316O3670C321O3742C330O3742C335O3813C344O3813C349O3874C358O3874C363O3945C374O3945C379O4016C390O4016C396O4094,,
code-creation,LazyCompile,10,174273,0x1abee80a54e,69,refreshHrtimeBuffer node:internal/process/per_thread:66:29,0x14121bd8550,~
script-source,30,node:internal/process/per_thread,'use strict';\x0d\n\x0d\n// This files contains process bootstrappers that can be\x0d\n// run when setting up each thread\x2C including the main\x0d\n// thread and the worker threads.\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeEvery\x2C\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  ArrayPrototypeIncludes\x2C\x0d\n  ArrayPrototypeMap\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeSplice\x2C\x0d\n  BigUint64Array\x2C\x0d\n  Float64Array\x2C\x0d\n  NumberMAX_SAFE_INTEGER\x2C\x0d\n  ObjectFreeze\x2C\x0d\n  ReflectApply\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeArrayIterator\x2C\x0d\n  Set\x2C\x0d\n  SetPrototypeEntries\x2C\x0d\n  SetPrototypeValues\x2C\x0d\n  StringPrototypeEndsWith\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolIterator\x2C\x0d\n  Uint32Array\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  errnoException\x2C\x0d\n  codes: {\x0d\n    ERR_ASSERTION\x2C\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_OUT_OF_RANGE\x2C\x0d\n    ERR_UNKNOWN_SIGNAL\x0d\n  }\x0d\n} = require('internal/errors');\x0d\nconst format = require('internal/util/inspect').format;\x0d\nconst {\x0d\n  validateArray\x2C\x0d\n  validateNumber\x2C\x0d\n  validateObject\x2C\x0d\n} = require('internal/validators');\x0d\nconst constants = internalBinding('constants').os.signals;\x0d\n\x0d\nconst {\x0d\n  handleProcessExit\x2C\x0d\n} = require('internal/modules/esm/handle_process_exit');\x0d\n\x0d\nconst kInternal = Symbol('internal properties');\x0d\n\x0d\nfunction assert(x\x2C msg) {\x0d\n  if (!x) throw new ERR_ASSERTION(msg || 'assertion error');\x0d\n}\x0d\n\x0d\nconst binding = internalBinding('process_methods');\x0d\n\x0d\nlet hrValues;\x0d\nlet hrBigintValues;\x0d\n\x0d\nfunction refreshHrtimeBuffer() {\x0d\n  // The 3 entries filled in by the original process.hrtime contains\x0d\n  // the upper/lower 32 bits of the second part of the value\x2C\x0d\n  // and the remaining nanoseconds of the value.\x0d\n  hrValues = new Uint32Array(binding.hrtimeBuffer);\x0d\n  // Use a BigUint64Array in the closure because this is actually a bit\x0d\n  // faster than simply returning a BigInt from C++ in V8 7.1.\x0d\n  hrBigintValues = new BigUint64Array(binding.hrtimeBuffer\x2C 0\x2C 1);\x0d\n}\x0d\n\x0d\n// Create the buffers.\x0d\nrefreshHrtimeBuffer();\x0d\n\x0d\nfunction hrtime(time) {\x0d\n  binding.hrtime();\x0d\n\x0d\n  if (time !== undefined) {\x0d\n    validateArray(time\x2C 'time');\x0d\n    if (time.length !== 2) {\x0d\n      throw new ERR_OUT_OF_RANGE('time'\x2C 2\x2C time.length);\x0d\n    }\x0d\n\x0d\n    const sec = (hrValues[0] * 0x100000000 + hrValues[1]) - time[0];\x0d\n    const nsec = hrValues[2] - time[1];\x0d\n    const needsBorrow = nsec < 0;\x0d\n    return [needsBorrow ? sec - 1 : sec\x2C needsBorrow ? nsec + 1e9 : nsec];\x0d\n  }\x0d\n\x0d\n  return [\x0d\n    hrValues[0] * 0x100000000 + hrValues[1]\x2C\x0d\n    hrValues[2]\x2C\x0d\n  ];\x0d\n}\x0d\n\x0d\nfunction hrtimeBigInt() {\x0d\n  binding.hrtimeBigInt();\x0d\n  return hrBigintValues[0];\x0d\n}\x0d\n\x0d\n// The execution of this function itself should not cause any side effects.\x0d\nfunction wrapProcessMethods(binding) {\x0d\n  const {\x0d\n    cpuUsage: _cpuUsage\x2C\x0d\n    memoryUsage: _memoryUsage\x2C\x0d\n    rss\x2C\x0d\n    resourceUsage: _resourceUsage\x0d\n  } = binding;\x0d\n\x0d\n  function _rawDebug(...args) {\x0d\n    binding._rawDebug(ReflectApply(format\x2C null\x2C args));\x0d\n  }\x0d\n\x0d\n  // Create the argument array that will be passed to the native function.\x0d\n  const cpuValues = new Float64Array(2);\x0d\n\x0d\n  // Replace the native function with the JS version that calls the native\x0d\n  // function.\x0d\n  function cpuUsage(prevValue) {\x0d\n    // If a previous value was passed in\x2C ensure it has the correct shape.\x0d\n    if (prevValue) {\x0d\n      if (!previousValueIsValid(prevValue.user)) {\x0d\n        validateObject(prevValue\x2C 'prevValue');\x0d\n\x0d\n        validateNumber(prevValue.user\x2C 'prevValue.user');\x0d\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.user'\x2C\x0d\n                                                   prevValue.user);\x0d\n      }\x0d\n\x0d\n      if (!previousValueIsValid(prevValue.system)) {\x0d\n        validateNumber(prevValue.system\x2C 'prevValue.system');\x0d\n        throw new ERR_INVALID_ARG_VALUE.RangeError('prevValue.system'\x2C\x0d\n                                                   prevValue.system);\x0d\n      }\x0d\n    }\x0d\n\x0d\n    // Call the native function to get the current values.\x0d\n    _cpuUsage(cpuValues);\x0d\n\x0d\n    // If a previous value was passed in\x2C return diff of current from previous.\x0d\n    if (prevValue) {\x0d\n      return {\x0d\n        user: cpuValues[0] - prevValue.user\x2C\x0d\n        system: cpuValues[1] - prevValue.system\x0d\n      };\x0d\n    }\x0d\n\x0d\n    // If no previous value passed in\x2C return current value.\x0d\n    return {\x0d\n      user: cpuValues[0]\x2C\x0d\n      system: cpuValues[1]\x0d\n    };\x0d\n  }\x0d\n\x0d\n  // Ensure that a previously passed in value is valid. Currently\x2C the native\x0d\n  // implementation always returns numbers <= Number.MAX_SAFE_INTEGER.\x0d\n  function previousValueIsValid(num) {\x0d\n    return typeof num === 'number' &&\x0d\n        num <= NumberMAX_SAFE_INTEGER &&\x0d\n        num >= 0;\x0d\n  }\x0d\n\x0d\n  const memValues = new Float64Array(5);\x0d\n  function memoryUsage() {\x0d\n    _memoryUsage(memValues);\x0d\n    return {\x0d\n      rss: memValues[0]\x2C\x0d\n      heapTotal: memValues[1]\x2C\x0d\n      heapUsed: memValues[2]\x2C\x0d\n      external: memValues[3]\x2C\x0d\n      arrayBuffers: memValues[4]\x0d\n    };\x0d\n  }\x0d\n\x0d\n  memoryUsage.rss = rss;\x0d\n\x0d\n  function exit(code) {\x0d\n    process.off('exit'\x2C handleProcessExit);\x0d\n\x0d\n    if (code || code === 0)\x0d\n      process.exitCode = code;\x0d\n\x0d\n    if (!process._exiting) {\x0d\n      process._exiting = true;\x0d\n      process.emit('exit'\x2C process.exitCode || 0);\x0d\n    }\x0d\n    // FIXME(joyeecheung): This is an undocumented API that gets monkey-patched\x0d\n    // in the user land. Either document it\x2C or deprecate it in favor of a\x0d\n    // better public alternative.\x0d\n    process.reallyExit(process.exitCode || 0);\x0d\n  }\x0d\n\x0d\n  function kill(pid\x2C sig) {\x0d\n    let err;\x0d\n\x0d\n    // eslint-disable-next-line eqeqeq\x0d\n    if (pid != (pid | 0)) {\x0d\n      throw new ERR_INVALID_ARG_TYPE('pid'\x2C 'number'\x2C pid);\x0d\n    }\x0d\n\x0d\n    // Preserve null signal\x0d\n    if (sig === (sig | 0)) {\x0d\n      // XXX(joyeecheung): we have to use process._kill here because\x0d\n      // it's monkey-patched by tests.\x0d\n      err = process._kill(pid\x2C sig);\x0d\n    } else {\x0d\n      sig = sig || 'SIGTERM';\x0d\n      if (constants[sig]) {\x0d\n        err = process._kill(pid\x2C constants[sig]);\x0d\n      } else {\x0d\n        throw new ERR_UNKNOWN_SIGNAL(sig);\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (err)\x0d\n      throw errnoException(err\x2C 'kill');\x0d\n\x0d\n    return true;\x0d\n  }\x0d\n\x0d\n  const resourceValues = new Float64Array(16);\x0d\n  function resourceUsage() {\x0d\n    _resourceUsage(resourceValues);\x0d\n    return {\x0d\n      userCPUTime: resourceValues[0]\x2C\x0d\n      systemCPUTime: resourceValues[1]\x2C\x0d\n      maxRSS: resourceValues[2]\x2C\x0d\n      sharedMemorySize: resourceValues[3]\x2C\x0d\n      unsharedDataSize: resourceValues[4]\x2C\x0d\n      unsharedStackSize: resourceValues[5]\x2C\x0d\n      minorPageFault: resourceValues[6]\x2C\x0d\n      majorPageFault: resourceValues[7]\x2C\x0d\n      swappedOut: resourceValues[8]\x2C\x0d\n      fsRead: resourceValues[9]\x2C\x0d\n      fsWrite: resourceValues[10]\x2C\x0d\n      ipcSent: resourceValues[11]\x2C\x0d\n      ipcReceived: resourceValues[12]\x2C\x0d\n      signalsCount: resourceValues[13]\x2C\x0d\n      voluntaryContextSwitches: resourceValues[14]\x2C\x0d\n      involuntaryContextSwitches: resourceValues[15]\x0d\n    };\x0d\n  }\x0d\n\x0d\n\x0d\n  return {\x0d\n    _rawDebug\x2C\x0d\n    cpuUsage\x2C\x0d\n    resourceUsage\x2C\x0d\n    memoryUsage\x2C\x0d\n    kill\x2C\x0d\n    exit\x0d\n  };\x0d\n}\x0d\n\x0d\nconst replaceUnderscoresRegex = /_/g;\x0d\nconst leadingDashesRegex = /^--?/;\x0d\nconst trailingValuesRegex = /=.*$/;\x0d\n\x0d\n// This builds the initial process.allowedNodeEnvironmentFlags\x0d\n// from data in the config binding.\x0d\nfunction buildAllowedFlags() {\x0d\n  const {\x0d\n    envSettings: { kAllowedInEnvironment }\x2C\x0d\n    types: { kBoolean }\x2C\x0d\n  } = internalBinding('options');\x0d\n  const { options\x2C aliases } = require('internal/options');\x0d\n\x0d\n  const allowedNodeEnvironmentFlags = [];\x0d\n  for (const { 0: name\x2C 1: info } of options) {\x0d\n    if (info.envVarSettings === kAllowedInEnvironment) {\x0d\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C name);\x0d\n      if (info.type === kBoolean) {\x0d\n        const negatedName = `--no-${name.slice(2)}`;\x0d\n        ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C negatedName);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  function isAccepted(to) {\x0d\n    if (!StringPrototypeStartsWith(to\x2C '-') || to === '--') return true;\x0d\n    const recursiveExpansion = aliases.get(to);\x0d\n    if (recursiveExpansion) {\x0d\n      if (recursiveExpansion[0] === to)\x0d\n        ArrayPrototypeSplice(recursiveExpansion\x2C 0\x2C 1);\x0d\n      return ArrayPrototypeEvery(recursiveExpansion\x2C isAccepted);\x0d\n    }\x0d\n    return options.get(to).envVarSettings === kAllowedInEnvironment;\x0d\n  }\x0d\n  for (const { 0: from\x2C 1: expansion } of aliases) {\x0d\n    if (ArrayPrototypeEvery(expansion\x2C isAccepted)) {\x0d\n      let canonical = from;\x0d\n      if (StringPrototypeEndsWith(canonical\x2C '='))\x0d\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 1);\x0d\n      if (StringPrototypeEndsWith(canonical\x2C ' <arg>'))\x0d\n        canonical = StringPrototypeSlice(canonical\x2C 0\x2C canonical.length - 4);\x0d\n      ArrayPrototypePush(allowedNodeEnvironmentFlags\x2C canonical);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  const trimLeadingDashes =\x0d\n    (flag) => StringPrototypeReplace(flag\x2C leadingDashesRegex\x2C '');\x0d\n\x0d\n  // Save these for comparison against flags provided to\x0d\n  // process.allowedNodeEnvironmentFlags.has() which lack leading dashes.\x0d\n  const nodeFlags = ArrayPrototypeMap(allowedNodeEnvironmentFlags\x2C\x0d\n                                      trimLeadingDashes);\x0d\n\x0d\n  class NodeEnvironmentFlagsSet extends Set {\x0d\n    constructor(array) {\x0d\n      super();\x0d\n      this[kInternal] = { array };\x0d\n    }\x0d\n\x0d\n    add() {\x0d\n      // No-op\x2C `Set` API compatible\x0d\n      return this;\x0d\n    }\x0d\n\x0d\n    delete() {\x0d\n      // No-op\x2C `Set` API compatible\x0d\n      return false;\x0d\n    }\x0d\n\x0d\n    clear() {\x0d\n      // No-op\x2C `Set` API compatible\x0d\n    }\x0d\n\x0d\n    has(key) {\x0d\n      // This will return `true` based on various possible\x0d\n      // permutations of a flag\x2C including present/missing leading\x0d\n      // dash(es) and/or underscores-for-dashes.\x0d\n      // Strips any values after `=`\x2C inclusive.\x0d\n      // TODO(addaleax): It might be more flexible to run the option parser\x0d\n      // on a dummy option set and see whether it rejects the argument or\x0d\n      // not.\x0d\n      if (typeof key === 'string') {\x0d\n        key = StringPrototypeReplace(key\x2C replaceUnderscoresRegex\x2C '-');\x0d\n        if (RegExpPrototypeTest(leadingDashesRegex\x2C key)) {\x0d\n          key = StringPrototypeReplace(key\x2C trailingValuesRegex\x2C '');\x0d\n          return ArrayPrototypeIncludes(this[kInternal].array\x2C key);\x0d\n        }\x0d\n        return ArrayPrototypeIncludes(nodeFlags\x2C key);\x0d\n      }\x0d\n      return false;\x0d\n    }\x0d\n\x0d\n    entries() {\x0d\n      this[kInternal].set ??=\x0d\n        new Set(new SafeArrayIterator(this[kInternal].array));\x0d\n      return SetPrototypeEntries(this[kInternal].set);\x0d\n    }\x0d\n\x0d\n    forEach(callback\x2C thisArg = undefined) {\x0d\n      ArrayPrototypeForEach(\x0d\n        this[kInternal].array\x2C\x0d\n        (v) => ReflectApply(callback\x2C thisArg\x2C [v\x2C v\x2C this])\x0d\n      );\x0d\n    }\x0d\n\x0d\n    get size() {\x0d\n      return this[kInternal].array.length;\x0d\n    }\x0d\n\x0d\n    values() {\x0d\n      this[kInternal].set ??=\x0d\n        new Set(new SafeArrayIterator(this[kInternal].array));\x0d\n      return SetPrototypeValues(this[kInternal].set);\x0d\n    }\x0d\n  }\x0d\n  NodeEnvironmentFlagsSet.prototype.keys =\x0d\n  NodeEnvironmentFlagsSet.prototype[SymbolIterator] =\x0d\n    NodeEnvironmentFlagsSet.prototype.values;\x0d\n\x0d\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype.constructor);\x0d\n  ObjectFreeze(NodeEnvironmentFlagsSet.prototype);\x0d\n\x0d\n  return ObjectFreeze(new NodeEnvironmentFlagsSet(\x0d\n    allowedNodeEnvironmentFlags\x0d\n  ));\x0d\n}\x0d\n\x0d\n// Lazy load internal/trace_events_async_hooks only if the async_hooks\x0d\n// trace event category is enabled.\x0d\nlet traceEventsAsyncHook;\x0d\n// Dynamically enable/disable the traceEventsAsyncHook\x0d\nfunction toggleTraceCategoryState(asyncHooksEnabled) {\x0d\n  if (asyncHooksEnabled) {\x0d\n    if (!traceEventsAsyncHook) {\x0d\n      traceEventsAsyncHook =\x0d\n        require('internal/trace_events_async_hooks').createHook();\x0d\n    }\x0d\n    traceEventsAsyncHook.enable();\x0d\n  } else if (traceEventsAsyncHook) {\x0d\n    traceEventsAsyncHook.disable();\x0d\n  }\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  toggleTraceCategoryState\x2C\x0d\n  assert\x2C\x0d\n  buildAllowedFlags\x2C\x0d\n  wrapProcessMethods\x2C\x0d\n  hrtime\x2C\x0d\n  hrtimeBigInt\x2C\x0d\n  refreshHrtimeBuffer\x2C\x0d\n};\x0d\n
code-source-info,0x1abee80a54e,30,1477,1925,C0O1668C7O1695C10O1703C17O1679C25O1677C31O1858C38O1894C41O1902C53O1875C61O1873C68O1924,,
code-creation,LazyCompile,10,175113,0x1abee80b60e,832,resolve node:path:158:10,0x394c9e0d510,~
script-source,41,node:path,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  FunctionPrototypeBind\x2C\x0d\n  StringPrototypeCharCodeAt\x2C\x0d\n  StringPrototypeIndexOf\x2C\x0d\n  StringPrototypeLastIndexOf\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeToLowerCase\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  CHAR_UPPERCASE_A\x2C\x0d\n  CHAR_LOWERCASE_A\x2C\x0d\n  CHAR_UPPERCASE_Z\x2C\x0d\n  CHAR_LOWERCASE_Z\x2C\x0d\n  CHAR_DOT\x2C\x0d\n  CHAR_FORWARD_SLASH\x2C\x0d\n  CHAR_BACKWARD_SLASH\x2C\x0d\n  CHAR_COLON\x2C\x0d\n  CHAR_QUESTION_MARK\x2C\x0d\n} = require('internal/constants');\x0d\nconst {\x0d\n  validateObject\x2C\x0d\n  validateString\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst platformIsWin32 = (process.platform === 'win32');\x0d\n\x0d\nfunction isPathSeparator(code) {\x0d\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\x0d\n}\x0d\n\x0d\nfunction isPosixPathSeparator(code) {\x0d\n  return code === CHAR_FORWARD_SLASH;\x0d\n}\x0d\n\x0d\nfunction isWindowsDeviceRoot(code) {\x0d\n  return (code >= CHAR_UPPERCASE_A && code <= CHAR_UPPERCASE_Z) ||\x0d\n         (code >= CHAR_LOWERCASE_A && code <= CHAR_LOWERCASE_Z);\x0d\n}\x0d\n\x0d\n// Resolves . and .. elements in a path with directory names\x0d\nfunction normalizeString(path\x2C allowAboveRoot\x2C separator\x2C isPathSeparator) {\x0d\n  let res = '';\x0d\n  let lastSegmentLength = 0;\x0d\n  let lastSlash = -1;\x0d\n  let dots = 0;\x0d\n  let code = 0;\x0d\n  for (let i = 0; i <= path.length; ++i) {\x0d\n    if (i < path.length)\x0d\n      code = StringPrototypeCharCodeAt(path\x2C i);\x0d\n    else if (isPathSeparator(code))\x0d\n      break;\x0d\n    else\x0d\n      code = CHAR_FORWARD_SLASH;\x0d\n\x0d\n    if (isPathSeparator(code)) {\x0d\n      if (lastSlash === i - 1 || dots === 1) {\x0d\n        // NOOP\x0d\n      } else if (dots === 2) {\x0d\n        if (res.length < 2 || lastSegmentLength !== 2 ||\x0d\n            StringPrototypeCharCodeAt(res\x2C res.length - 1) !== CHAR_DOT ||\x0d\n            StringPrototypeCharCodeAt(res\x2C res.length - 2) !== CHAR_DOT) {\x0d\n          if (res.length > 2) {\x0d\n            const lastSlashIndex = StringPrototypeLastIndexOf(res\x2C separator);\x0d\n            if (lastSlashIndex === -1) {\x0d\n              res = '';\x0d\n              lastSegmentLength = 0;\x0d\n            } else {\x0d\n              res = StringPrototypeSlice(res\x2C 0\x2C lastSlashIndex);\x0d\n              lastSegmentLength =\x0d\n                res.length - 1 - StringPrototypeLastIndexOf(res\x2C separator);\x0d\n            }\x0d\n            lastSlash = i;\x0d\n            dots = 0;\x0d\n            continue;\x0d\n          } else if (res.length !== 0) {\x0d\n            res = '';\x0d\n            lastSegmentLength = 0;\x0d\n            lastSlash = i;\x0d\n            dots = 0;\x0d\n            continue;\x0d\n          }\x0d\n        }\x0d\n        if (allowAboveRoot) {\x0d\n          res += res.length > 0 ? `${separator}..` : '..';\x0d\n          lastSegmentLength = 2;\x0d\n        }\x0d\n      } else {\x0d\n        if (res.length > 0)\x0d\n          res += `${separator}${StringPrototypeSlice(path\x2C lastSlash + 1\x2C i)}`;\x0d\n        else\x0d\n          res = StringPrototypeSlice(path\x2C lastSlash + 1\x2C i);\x0d\n        lastSegmentLength = i - lastSlash - 1;\x0d\n      }\x0d\n      lastSlash = i;\x0d\n      dots = 0;\x0d\n    } else if (code === CHAR_DOT && dots !== -1) {\x0d\n      ++dots;\x0d\n    } else {\x0d\n      dots = -1;\x0d\n    }\x0d\n  }\x0d\n  return res;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string} sep\x0d\n * @param {{\x0d\n *  dir?: string;\x0d\n *  root?: string;\x0d\n *  base?: string;\x0d\n *  name?: string;\x0d\n *  ext?: string;\x0d\n *  }} pathObject\x0d\n * @returns {string}\x0d\n */\x0d\nfunction _format(sep\x2C pathObject) {\x0d\n  validateObject(pathObject\x2C 'pathObject');\x0d\n  const dir = pathObject.dir || pathObject.root;\x0d\n  const base = pathObject.base ||\x0d\n    `${pathObject.name || ''}${pathObject.ext || ''}`;\x0d\n  if (!dir) {\x0d\n    return base;\x0d\n  }\x0d\n  return dir === pathObject.root ? `${dir}${base}` : `${dir}${sep}${base}`;\x0d\n}\x0d\n\x0d\nconst win32 = {\x0d\n  /**\x0d\n   * path.resolve([from ...]\x2C to)\x0d\n   * @param {...string} args\x0d\n   * @returns {string}\x0d\n   */\x0d\n  resolve(...args) {\x0d\n    let resolvedDevice = '';\x0d\n    let resolvedTail = '';\x0d\n    let resolvedAbsolute = false;\x0d\n\x0d\n    for (let i = args.length - 1; i >= -1; i--) {\x0d\n      let path;\x0d\n      if (i >= 0) {\x0d\n        path = args[i];\x0d\n        validateString(path\x2C 'path');\x0d\n\x0d\n        // Skip empty entries\x0d\n        if (path.length === 0) {\x0d\n          continue;\x0d\n        }\x0d\n      } else if (resolvedDevice.length === 0) {\x0d\n        path = process.cwd();\x0d\n      } else {\x0d\n        // Windows has the concept of drive-specific current working\x0d\n        // directories. If we've resolved a drive letter but not yet an\x0d\n        // absolute path\x2C get cwd for that drive\x2C or the process cwd if\x0d\n        // the drive cwd is not available. We're sure the device is not\x0d\n        // a UNC path at this points\x2C because UNC paths are always absolute.\x0d\n        path = process.env[`=${resolvedDevice}`] || process.cwd();\x0d\n\x0d\n        // Verify that a cwd was found and that it actually points\x0d\n        // to our drive. If not\x2C default to the drive's root.\x0d\n        if (path === undefined ||\x0d\n            (StringPrototypeToLowerCase(StringPrototypeSlice(path\x2C 0\x2C 2)) !==\x0d\n            StringPrototypeToLowerCase(resolvedDevice) &&\x0d\n            StringPrototypeCharCodeAt(path\x2C 2) === CHAR_BACKWARD_SLASH)) {\x0d\n          path = `${resolvedDevice}\\\\`;\x0d\n        }\x0d\n      }\x0d\n\x0d\n      const len = path.length;\x0d\n      let rootEnd = 0;\x0d\n      let device = '';\x0d\n      let isAbsolute = false;\x0d\n      const code = StringPrototypeCharCodeAt(path\x2C 0);\x0d\n\x0d\n      // Try to match a root\x0d\n      if (len === 1) {\x0d\n        if (isPathSeparator(code)) {\x0d\n          // `path` contains just a path separator\x0d\n          rootEnd = 1;\x0d\n          isAbsolute = true;\x0d\n        }\x0d\n      } else if (isPathSeparator(code)) {\x0d\n        // Possible UNC root\x0d\n\x0d\n        // If we started with a separator\x2C we know we at least have an\x0d\n        // absolute path of some kind (UNC or otherwise)\x0d\n        isAbsolute = true;\x0d\n\x0d\n        if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\x0d\n          // Matched double path separator at beginning\x0d\n          let j = 2;\x0d\n          let last = j;\x0d\n          // Match 1 or more non-path separators\x0d\n          while (j < len &&\x0d\n                 !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n            j++;\x0d\n          }\x0d\n          if (j < len && j !== last) {\x0d\n            const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\x0d\n            // Matched!\x0d\n            last = j;\x0d\n            // Match 1 or more path separators\x0d\n            while (j < len &&\x0d\n                   isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n              j++;\x0d\n            }\x0d\n            if (j < len && j !== last) {\x0d\n              // Matched!\x0d\n              last = j;\x0d\n              // Match 1 or more non-path separators\x0d\n              while (j < len &&\x0d\n                     !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n                j++;\x0d\n              }\x0d\n              if (j === len || j !== last) {\x0d\n                // We matched a UNC root\x0d\n                device =\x0d\n                  `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\x0d\n                rootEnd = j;\x0d\n              }\x0d\n            }\x0d\n          }\x0d\n        } else {\x0d\n          rootEnd = 1;\x0d\n        }\x0d\n      } else if (isWindowsDeviceRoot(code) &&\x0d\n                  StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\x0d\n        // Possible device root\x0d\n        device = StringPrototypeSlice(path\x2C 0\x2C 2);\x0d\n        rootEnd = 2;\x0d\n        if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\x0d\n          // Treat separator following drive name as an absolute path\x0d\n          // indicator\x0d\n          isAbsolute = true;\x0d\n          rootEnd = 3;\x0d\n        }\x0d\n      }\x0d\n\x0d\n      if (device.length > 0) {\x0d\n        if (resolvedDevice.length > 0) {\x0d\n          if (StringPrototypeToLowerCase(device) !==\x0d\n              StringPrototypeToLowerCase(resolvedDevice))\x0d\n            // This path points to another device so it is not applicable\x0d\n            continue;\x0d\n        } else {\x0d\n          resolvedDevice = device;\x0d\n        }\x0d\n      }\x0d\n\x0d\n      if (resolvedAbsolute) {\x0d\n        if (resolvedDevice.length > 0)\x0d\n          break;\x0d\n      } else {\x0d\n        resolvedTail =\x0d\n          `${StringPrototypeSlice(path\x2C rootEnd)}\\\\${resolvedTail}`;\x0d\n        resolvedAbsolute = isAbsolute;\x0d\n        if (isAbsolute && resolvedDevice.length > 0) {\x0d\n          break;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n\x0d\n    // At this point the path should be resolved to a full absolute path\x2C\x0d\n    // but handle relative paths to be safe (might happen when process.cwd()\x0d\n    // fails)\x0d\n\x0d\n    // Normalize the tail path\x0d\n    resolvedTail = normalizeString(resolvedTail\x2C !resolvedAbsolute\x2C '\\\\'\x2C\x0d\n                                   isPathSeparator);\x0d\n\x0d\n    return resolvedAbsolute ?\x0d\n      `${resolvedDevice}\\\\${resolvedTail}` :\x0d\n      `${resolvedDevice}${resolvedTail}` || '.';\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {string}\x0d\n   */\x0d\n  normalize(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n    const len = path.length;\x0d\n    if (len === 0)\x0d\n      return '.';\x0d\n    let rootEnd = 0;\x0d\n    let device;\x0d\n    let isAbsolute = false;\x0d\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\x0d\n\x0d\n    // Try to match a root\x0d\n    if (len === 1) {\x0d\n      // `path` contains just a single char\x2C exit early to avoid\x0d\n      // unnecessary work\x0d\n      return isPosixPathSeparator(code) ? '\\\\' : path;\x0d\n    }\x0d\n    if (isPathSeparator(code)) {\x0d\n      // Possible UNC root\x0d\n\x0d\n      // If we started with a separator\x2C we know we at least have an absolute\x0d\n      // path of some kind (UNC or otherwise)\x0d\n      isAbsolute = true;\x0d\n\x0d\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\x0d\n        // Matched double path separator at beginning\x0d\n        let j = 2;\x0d\n        let last = j;\x0d\n        // Match 1 or more non-path separators\x0d\n        while (j < len &&\x0d\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n          j++;\x0d\n        }\x0d\n        if (j < len && j !== last) {\x0d\n          const firstPart = StringPrototypeSlice(path\x2C last\x2C j);\x0d\n          // Matched!\x0d\n          last = j;\x0d\n          // Match 1 or more path separators\x0d\n          while (j < len &&\x0d\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n            j++;\x0d\n          }\x0d\n          if (j < len && j !== last) {\x0d\n            // Matched!\x0d\n            last = j;\x0d\n            // Match 1 or more non-path separators\x0d\n            while (j < len &&\x0d\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n              j++;\x0d\n            }\x0d\n            if (j === len) {\x0d\n              // We matched a UNC root only\x0d\n              // Return the normalized version of the UNC root since there\x0d\n              // is nothing left to process\x0d\n              return `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last)}\\\\`;\x0d\n            }\x0d\n            if (j !== last) {\x0d\n              // We matched a UNC root with leftovers\x0d\n              device =\x0d\n                `\\\\\\\\${firstPart}\\\\${StringPrototypeSlice(path\x2C last\x2C j)}`;\x0d\n              rootEnd = j;\x0d\n            }\x0d\n          }\x0d\n        }\x0d\n      } else {\x0d\n        rootEnd = 1;\x0d\n      }\x0d\n    } else if (isWindowsDeviceRoot(code) &&\x0d\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\x0d\n      // Possible device root\x0d\n      device = StringPrototypeSlice(path\x2C 0\x2C 2);\x0d\n      rootEnd = 2;\x0d\n      if (len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\x0d\n        // Treat separator following drive name as an absolute path\x0d\n        // indicator\x0d\n        isAbsolute = true;\x0d\n        rootEnd = 3;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    let tail = rootEnd < len ?\x0d\n      normalizeString(StringPrototypeSlice(path\x2C rootEnd)\x2C\x0d\n                      !isAbsolute\x2C '\\\\'\x2C isPathSeparator) :\x0d\n      '';\x0d\n    if (tail.length === 0 && !isAbsolute)\x0d\n      tail = '.';\x0d\n    if (tail.length > 0 &&\x0d\n        isPathSeparator(StringPrototypeCharCodeAt(path\x2C len - 1)))\x0d\n      tail += '\\\\';\x0d\n    if (device === undefined) {\x0d\n      return isAbsolute ? `\\\\${tail}` : tail;\x0d\n    }\x0d\n    return isAbsolute ? `${device}\\\\${tail}` : `${device}${tail}`;\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {boolean}\x0d\n   */\x0d\n  isAbsolute(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n    const len = path.length;\x0d\n    if (len === 0)\x0d\n      return false;\x0d\n\x0d\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\x0d\n    return isPathSeparator(code) ||\x0d\n      // Possible device root\x0d\n      (len > 2 &&\x0d\n      isWindowsDeviceRoot(code) &&\x0d\n      StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\x0d\n      isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)));\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {...string} args\x0d\n   * @returns {string}\x0d\n   */\x0d\n  join(...args) {\x0d\n    if (args.length === 0)\x0d\n      return '.';\x0d\n\x0d\n    let joined;\x0d\n    let firstPart;\x0d\n    for (let i = 0; i < args.length; ++i) {\x0d\n      const arg = args[i];\x0d\n      validateString(arg\x2C 'path');\x0d\n      if (arg.length > 0) {\x0d\n        if (joined === undefined)\x0d\n          joined = firstPart = arg;\x0d\n        else\x0d\n          joined += `\\\\${arg}`;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (joined === undefined)\x0d\n      return '.';\x0d\n\x0d\n    // Make sure that the joined path doesn't start with two slashes\x2C because\x0d\n    // normalize() will mistake it for a UNC path then.\x0d\n    //\x0d\n    // This step is skipped when it is very clear that the user actually\x0d\n    // intended to point at a UNC path. This is assumed when the first\x0d\n    // non-empty string arguments starts with exactly two slashes followed by\x0d\n    // at least one more non-slash character.\x0d\n    //\x0d\n    // Note that for normalize() to treat a path as a UNC path it needs to\x0d\n    // have at least 2 components\x2C so we don't filter for that here.\x0d\n    // This means that the user can use join to construct UNC paths from\x0d\n    // a server name and a share name; for example:\x0d\n    //   path.join('//server'\x2C 'share') -> '\\\\\\\\server\\\\share\\\\')\x0d\n    let needsReplace = true;\x0d\n    let slashCount = 0;\x0d\n    if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 0))) {\x0d\n      ++slashCount;\x0d\n      const firstLen = firstPart.length;\x0d\n      if (firstLen > 1 &&\x0d\n          isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 1))) {\x0d\n        ++slashCount;\x0d\n        if (firstLen > 2) {\x0d\n          if (isPathSeparator(StringPrototypeCharCodeAt(firstPart\x2C 2)))\x0d\n            ++slashCount;\x0d\n          else {\x0d\n            // We matched a UNC path in the first part\x0d\n            needsReplace = false;\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n    if (needsReplace) {\x0d\n      // Find any more consecutive slashes we need to replace\x0d\n      while (slashCount < joined.length &&\x0d\n             isPathSeparator(StringPrototypeCharCodeAt(joined\x2C slashCount))) {\x0d\n        slashCount++;\x0d\n      }\x0d\n\x0d\n      // Replace the slashes if needed\x0d\n      if (slashCount >= 2)\x0d\n        joined = `\\\\${StringPrototypeSlice(joined\x2C slashCount)}`;\x0d\n    }\x0d\n\x0d\n    return win32.normalize(joined);\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * It will solve the relative path from `from` to `to`\x2C for instance\x0d\n   * from = 'C:\\\\orandea\\\\test\\\\aaa'\x0d\n   * to = 'C:\\\\orandea\\\\impl\\\\bbb'\x0d\n   * The output of the function should be: '..\\\\..\\\\impl\\\\bbb'\x0d\n   * @param {string} from\x0d\n   * @param {string} to\x0d\n   * @returns {string}\x0d\n   */\x0d\n  relative(from\x2C to) {\x0d\n    validateString(from\x2C 'from');\x0d\n    validateString(to\x2C 'to');\x0d\n\x0d\n    if (from === to)\x0d\n      return '';\x0d\n\x0d\n    const fromOrig = win32.resolve(from);\x0d\n    const toOrig = win32.resolve(to);\x0d\n\x0d\n    if (fromOrig === toOrig)\x0d\n      return '';\x0d\n\x0d\n    from = StringPrototypeToLowerCase(fromOrig);\x0d\n    to = StringPrototypeToLowerCase(toOrig);\x0d\n\x0d\n    if (from === to)\x0d\n      return '';\x0d\n\x0d\n    // Trim any leading backslashes\x0d\n    let fromStart = 0;\x0d\n    while (fromStart < from.length &&\x0d\n           StringPrototypeCharCodeAt(from\x2C fromStart) === CHAR_BACKWARD_SLASH) {\x0d\n      fromStart++;\x0d\n    }\x0d\n    // Trim trailing backslashes (applicable to UNC paths only)\x0d\n    let fromEnd = from.length;\x0d\n    while (\x0d\n      fromEnd - 1 > fromStart &&\x0d\n      StringPrototypeCharCodeAt(from\x2C fromEnd - 1) === CHAR_BACKWARD_SLASH\x0d\n    ) {\x0d\n      fromEnd--;\x0d\n    }\x0d\n    const fromLen = fromEnd - fromStart;\x0d\n\x0d\n    // Trim any leading backslashes\x0d\n    let toStart = 0;\x0d\n    while (toStart < to.length &&\x0d\n           StringPrototypeCharCodeAt(to\x2C toStart) === CHAR_BACKWARD_SLASH) {\x0d\n      toStart++;\x0d\n    }\x0d\n    // Trim trailing backslashes (applicable to UNC paths only)\x0d\n    let toEnd = to.length;\x0d\n    while (toEnd - 1 > toStart &&\x0d\n           StringPrototypeCharCodeAt(to\x2C toEnd - 1) === CHAR_BACKWARD_SLASH) {\x0d\n      toEnd--;\x0d\n    }\x0d\n    const toLen = toEnd - toStart;\x0d\n\x0d\n    // Compare paths to find the longest common path from root\x0d\n    const length = fromLen < toLen ? fromLen : toLen;\x0d\n    let lastCommonSep = -1;\x0d\n    let i = 0;\x0d\n    for (; i < length; i++) {\x0d\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\x0d\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\x0d\n        break;\x0d\n      else if (fromCode === CHAR_BACKWARD_SLASH)\x0d\n        lastCommonSep = i;\x0d\n    }\x0d\n\x0d\n    // We found a mismatch before the first common path separator was seen\x2C so\x0d\n    // return the original `to`.\x0d\n    if (i !== length) {\x0d\n      if (lastCommonSep === -1)\x0d\n        return toOrig;\x0d\n    } else {\x0d\n      if (toLen > length) {\x0d\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) ===\x0d\n            CHAR_BACKWARD_SLASH) {\x0d\n          // We get here if `from` is the exact base path for `to`.\x0d\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo\\\\bar\\\\baz'\x0d\n          return StringPrototypeSlice(toOrig\x2C toStart + i + 1);\x0d\n        }\x0d\n        if (i === 2) {\x0d\n          // We get here if `from` is the device root.\x0d\n          // For example: from='C:\\\\'; to='C:\\\\foo'\x0d\n          return StringPrototypeSlice(toOrig\x2C toStart + i);\x0d\n        }\x0d\n      }\x0d\n      if (fromLen > length) {\x0d\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\x0d\n            CHAR_BACKWARD_SLASH) {\x0d\n          // We get here if `to` is the exact base path for `from`.\x0d\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\foo'\x0d\n          lastCommonSep = i;\x0d\n        } else if (i === 2) {\x0d\n          // We get here if `to` is the device root.\x0d\n          // For example: from='C:\\\\foo\\\\bar'; to='C:\\\\'\x0d\n          lastCommonSep = 3;\x0d\n        }\x0d\n      }\x0d\n      if (lastCommonSep === -1)\x0d\n        lastCommonSep = 0;\x0d\n    }\x0d\n\x0d\n    let out = '';\x0d\n    // Generate the relative path based on the path difference between `to` and\x0d\n    // `from`\x0d\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\x0d\n      if (i === fromEnd ||\x0d\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_BACKWARD_SLASH) {\x0d\n        out += out.length === 0 ? '..' : '\\\\..';\x0d\n      }\x0d\n    }\x0d\n\x0d\n    toStart += lastCommonSep;\x0d\n\x0d\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\x0d\n    // the common path parts\x0d\n    if (out.length > 0)\x0d\n      return `${out}${StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd)}`;\x0d\n\x0d\n    if (StringPrototypeCharCodeAt(toOrig\x2C toStart) === CHAR_BACKWARD_SLASH)\x0d\n      ++toStart;\x0d\n    return StringPrototypeSlice(toOrig\x2C toStart\x2C toEnd);\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {string}\x0d\n   */\x0d\n  toNamespacedPath(path) {\x0d\n    // Note: this will *probably* throw somewhere.\x0d\n    if (typeof path !== 'string' || path.length === 0)\x0d\n      return path;\x0d\n\x0d\n    const resolvedPath = win32.resolve(path);\x0d\n\x0d\n    if (resolvedPath.length <= 2)\x0d\n      return path;\x0d\n\x0d\n    if (StringPrototypeCharCodeAt(resolvedPath\x2C 0) === CHAR_BACKWARD_SLASH) {\x0d\n      // Possible UNC root\x0d\n      if (StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_BACKWARD_SLASH) {\x0d\n        const code = StringPrototypeCharCodeAt(resolvedPath\x2C 2);\x0d\n        if (code !== CHAR_QUESTION_MARK && code !== CHAR_DOT) {\x0d\n          // Matched non-long UNC root\x2C convert the path to a long UNC path\x0d\n          return `\\\\\\\\?\\\\UNC\\\\${StringPrototypeSlice(resolvedPath\x2C 2)}`;\x0d\n        }\x0d\n      }\x0d\n    } else if (\x0d\n      isWindowsDeviceRoot(StringPrototypeCharCodeAt(resolvedPath\x2C 0)) &&\x0d\n      StringPrototypeCharCodeAt(resolvedPath\x2C 1) === CHAR_COLON &&\x0d\n      StringPrototypeCharCodeAt(resolvedPath\x2C 2) === CHAR_BACKWARD_SLASH\x0d\n    ) {\x0d\n      // Matched device root\x2C convert the path to a long UNC path\x0d\n      return `\\\\\\\\?\\\\${resolvedPath}`;\x0d\n    }\x0d\n\x0d\n    return path;\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {string}\x0d\n   */\x0d\n  dirname(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n    const len = path.length;\x0d\n    if (len === 0)\x0d\n      return '.';\x0d\n    let rootEnd = -1;\x0d\n    let offset = 0;\x0d\n    const code = StringPrototypeCharCodeAt(path\x2C 0);\x0d\n\x0d\n    if (len === 1) {\x0d\n      // `path` contains just a path separator\x2C exit early to avoid\x0d\n      // unnecessary work or a dot.\x0d\n      return isPathSeparator(code) ? path : '.';\x0d\n    }\x0d\n\x0d\n    // Try to match a root\x0d\n    if (isPathSeparator(code)) {\x0d\n      // Possible UNC root\x0d\n\x0d\n      rootEnd = offset = 1;\x0d\n\x0d\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\x0d\n        // Matched double path separator at beginning\x0d\n        let j = 2;\x0d\n        let last = j;\x0d\n        // Match 1 or more non-path separators\x0d\n        while (j < len &&\x0d\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n          j++;\x0d\n        }\x0d\n        if (j < len && j !== last) {\x0d\n          // Matched!\x0d\n          last = j;\x0d\n          // Match 1 or more path separators\x0d\n          while (j < len &&\x0d\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n            j++;\x0d\n          }\x0d\n          if (j < len && j !== last) {\x0d\n            // Matched!\x0d\n            last = j;\x0d\n            // Match 1 or more non-path separators\x0d\n            while (j < len &&\x0d\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n              j++;\x0d\n            }\x0d\n            if (j === len) {\x0d\n              // We matched a UNC root only\x0d\n              return path;\x0d\n            }\x0d\n            if (j !== last) {\x0d\n              // We matched a UNC root with leftovers\x0d\n\x0d\n              // Offset by 1 to include the separator after the UNC root to\x0d\n              // treat it as a "normal root" on top of a (UNC) root\x0d\n              rootEnd = offset = j + 1;\x0d\n            }\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n    // Possible device root\x0d\n    } else if (isWindowsDeviceRoot(code) &&\x0d\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\x0d\n      rootEnd =\x0d\n        len > 2 && isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2)) ? 3 : 2;\x0d\n      offset = rootEnd;\x0d\n    }\x0d\n\x0d\n    let end = -1;\x0d\n    let matchedSlash = true;\x0d\n    for (let i = len - 1; i >= offset; --i) {\x0d\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\x0d\n        if (!matchedSlash) {\x0d\n          end = i;\x0d\n          break;\x0d\n        }\x0d\n      } else {\x0d\n        // We saw the first non-path separator\x0d\n        matchedSlash = false;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (end === -1) {\x0d\n      if (rootEnd === -1)\x0d\n        return '.';\x0d\n\x0d\n      end = rootEnd;\x0d\n    }\x0d\n    return StringPrototypeSlice(path\x2C 0\x2C end);\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @param {string} [ext]\x0d\n   * @returns {string}\x0d\n   */\x0d\n  basename(path\x2C ext) {\x0d\n    if (ext !== undefined)\x0d\n      validateString(ext\x2C 'ext');\x0d\n    validateString(path\x2C 'path');\x0d\n    let start = 0;\x0d\n    let end = -1;\x0d\n    let matchedSlash = true;\x0d\n\x0d\n    // Check for a drive letter prefix so as not to mistake the following\x0d\n    // path separator as an extra separator at the end of the path that can be\x0d\n    // disregarded\x0d\n    if (path.length >= 2 &&\x0d\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0)) &&\x0d\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\x0d\n      start = 2;\x0d\n    }\x0d\n\x0d\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\x0d\n      if (ext === path)\x0d\n        return '';\x0d\n      let extIdx = ext.length - 1;\x0d\n      let firstNonSlashEnd = -1;\x0d\n      for (let i = path.length - 1; i >= start; --i) {\x0d\n        const code = StringPrototypeCharCodeAt(path\x2C i);\x0d\n        if (isPathSeparator(code)) {\x0d\n          // If we reached a path separator that was not part of a set of path\x0d\n          // separators at the end of the string\x2C stop now\x0d\n          if (!matchedSlash) {\x0d\n            start = i + 1;\x0d\n            break;\x0d\n          }\x0d\n        } else {\x0d\n          if (firstNonSlashEnd === -1) {\x0d\n            // We saw the first non-path separator\x2C remember this index in case\x0d\n            // we need it if the extension ends up not matching\x0d\n            matchedSlash = false;\x0d\n            firstNonSlashEnd = i + 1;\x0d\n          }\x0d\n          if (extIdx >= 0) {\x0d\n            // Try to match the explicit extension\x0d\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\x0d\n              if (--extIdx === -1) {\x0d\n                // We matched the extension\x2C so mark this as the end of our path\x0d\n                // component\x0d\n                end = i;\x0d\n              }\x0d\n            } else {\x0d\n              // Extension does not match\x2C so our result is the entire path\x0d\n              // component\x0d\n              extIdx = -1;\x0d\n              end = firstNonSlashEnd;\x0d\n            }\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n\x0d\n      if (start === end)\x0d\n        end = firstNonSlashEnd;\x0d\n      else if (end === -1)\x0d\n        end = path.length;\x0d\n      return StringPrototypeSlice(path\x2C start\x2C end);\x0d\n    }\x0d\n    for (let i = path.length - 1; i >= start; --i) {\x0d\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C i))) {\x0d\n        // If we reached a path separator that was not part of a set of path\x0d\n        // separators at the end of the string\x2C stop now\x0d\n        if (!matchedSlash) {\x0d\n          start = i + 1;\x0d\n          break;\x0d\n        }\x0d\n      } else if (end === -1) {\x0d\n        // We saw the first non-path separator\x2C mark this as the end of our\x0d\n        // path component\x0d\n        matchedSlash = false;\x0d\n        end = i + 1;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (end === -1)\x0d\n      return '';\x0d\n    return StringPrototypeSlice(path\x2C start\x2C end);\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {string}\x0d\n   */\x0d\n  extname(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n    let start = 0;\x0d\n    let startDot = -1;\x0d\n    let startPart = 0;\x0d\n    let end = -1;\x0d\n    let matchedSlash = true;\x0d\n    // Track the state of characters (if any) we see before our first dot and\x0d\n    // after any path separator we find\x0d\n    let preDotState = 0;\x0d\n\x0d\n    // Check for a drive letter prefix so as not to mistake the following\x0d\n    // path separator as an extra separator at the end of the path that can be\x0d\n    // disregarded\x0d\n\x0d\n    if (path.length >= 2 &&\x0d\n        StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON &&\x0d\n        isWindowsDeviceRoot(StringPrototypeCharCodeAt(path\x2C 0))) {\x0d\n      start = startPart = 2;\x0d\n    }\x0d\n\x0d\n    for (let i = path.length - 1; i >= start; --i) {\x0d\n      const code = StringPrototypeCharCodeAt(path\x2C i);\x0d\n      if (isPathSeparator(code)) {\x0d\n        // If we reached a path separator that was not part of a set of path\x0d\n        // separators at the end of the string\x2C stop now\x0d\n        if (!matchedSlash) {\x0d\n          startPart = i + 1;\x0d\n          break;\x0d\n        }\x0d\n        continue;\x0d\n      }\x0d\n      if (end === -1) {\x0d\n        // We saw the first non-path separator\x2C mark this as the end of our\x0d\n        // extension\x0d\n        matchedSlash = false;\x0d\n        end = i + 1;\x0d\n      }\x0d\n      if (code === CHAR_DOT) {\x0d\n        // If this is our first dot\x2C mark it as the start of our extension\x0d\n        if (startDot === -1)\x0d\n          startDot = i;\x0d\n        else if (preDotState !== 1)\x0d\n          preDotState = 1;\x0d\n      } else if (startDot !== -1) {\x0d\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\x0d\n        // have a good chance at having a non-empty extension\x0d\n        preDotState = -1;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (startDot === -1 ||\x0d\n        end === -1 ||\x0d\n        // We saw a non-dot character immediately before the dot\x0d\n        preDotState === 0 ||\x0d\n        // The (right-most) trimmed path component is exactly '..'\x0d\n        (preDotState === 1 &&\x0d\n         startDot === end - 1 &&\x0d\n         startDot === startPart + 1)) {\x0d\n      return '';\x0d\n    }\x0d\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\x0d\n  }\x2C\x0d\n\x0d\n  format: FunctionPrototypeBind(_format\x2C null\x2C '\\\\')\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {{\x0d\n   *  dir: string;\x0d\n   *  root: string;\x0d\n   *  base: string;\x0d\n   *  name: string;\x0d\n   *  ext: string;\x0d\n   *  }}\x0d\n   */\x0d\n  parse(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n\x0d\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\x0d\n    if (path.length === 0)\x0d\n      return ret;\x0d\n\x0d\n    const len = path.length;\x0d\n    let rootEnd = 0;\x0d\n    let code = StringPrototypeCharCodeAt(path\x2C 0);\x0d\n\x0d\n    if (len === 1) {\x0d\n      if (isPathSeparator(code)) {\x0d\n        // `path` contains just a path separator\x2C exit early to avoid\x0d\n        // unnecessary work\x0d\n        ret.root = ret.dir = path;\x0d\n        return ret;\x0d\n      }\x0d\n      ret.base = ret.name = path;\x0d\n      return ret;\x0d\n    }\x0d\n    // Try to match a root\x0d\n    if (isPathSeparator(code)) {\x0d\n      // Possible UNC root\x0d\n\x0d\n      rootEnd = 1;\x0d\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 1))) {\x0d\n        // Matched double path separator at beginning\x0d\n        let j = 2;\x0d\n        let last = j;\x0d\n        // Match 1 or more non-path separators\x0d\n        while (j < len &&\x0d\n               !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n          j++;\x0d\n        }\x0d\n        if (j < len && j !== last) {\x0d\n          // Matched!\x0d\n          last = j;\x0d\n          // Match 1 or more path separators\x0d\n          while (j < len &&\x0d\n                 isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n            j++;\x0d\n          }\x0d\n          if (j < len && j !== last) {\x0d\n            // Matched!\x0d\n            last = j;\x0d\n            // Match 1 or more non-path separators\x0d\n            while (j < len &&\x0d\n                   !isPathSeparator(StringPrototypeCharCodeAt(path\x2C j))) {\x0d\n              j++;\x0d\n            }\x0d\n            if (j === len) {\x0d\n              // We matched a UNC root only\x0d\n              rootEnd = j;\x0d\n            } else if (j !== last) {\x0d\n              // We matched a UNC root with leftovers\x0d\n              rootEnd = j + 1;\x0d\n            }\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n    } else if (isWindowsDeviceRoot(code) &&\x0d\n               StringPrototypeCharCodeAt(path\x2C 1) === CHAR_COLON) {\x0d\n      // Possible device root\x0d\n      if (len <= 2) {\x0d\n        // `path` contains just a drive root\x2C exit early to avoid\x0d\n        // unnecessary work\x0d\n        ret.root = ret.dir = path;\x0d\n        return ret;\x0d\n      }\x0d\n      rootEnd = 2;\x0d\n      if (isPathSeparator(StringPrototypeCharCodeAt(path\x2C 2))) {\x0d\n        if (len === 3) {\x0d\n          // `path` contains just a drive root\x2C exit early to avoid\x0d\n          // unnecessary work\x0d\n          ret.root = ret.dir = path;\x0d\n          return ret;\x0d\n        }\x0d\n        rootEnd = 3;\x0d\n      }\x0d\n    }\x0d\n    if (rootEnd > 0)\x0d\n      ret.root = StringPrototypeSlice(path\x2C 0\x2C rootEnd);\x0d\n\x0d\n    let startDot = -1;\x0d\n    let startPart = rootEnd;\x0d\n    let end = -1;\x0d\n    let matchedSlash = true;\x0d\n    let i = path.length - 1;\x0d\n\x0d\n    // Track the state of characters (if any) we see before our first dot and\x0d\n    // after any path separator we find\x0d\n    let preDotState = 0;\x0d\n\x0d\n    // Get non-dir info\x0d\n    for (; i >= rootEnd; --i) {\x0d\n      code = StringPrototypeCharCodeAt(path\x2C i);\x0d\n      if (isPathSeparator(code)) {\x0d\n        // If we reached a path separator that was not part of a set of path\x0d\n        // separators at the end of the string\x2C stop now\x0d\n        if (!matchedSlash) {\x0d\n          startPart = i + 1;\x0d\n          break;\x0d\n        }\x0d\n        continue;\x0d\n      }\x0d\n      if (end === -1) {\x0d\n        // We saw the first non-path separator\x2C mark this as the end of our\x0d\n        // extension\x0d\n        matchedSlash = false;\x0d\n        end = i + 1;\x0d\n      }\x0d\n      if (code === CHAR_DOT) {\x0d\n        // If this is our first dot\x2C mark it as the start of our extension\x0d\n        if (startDot === -1)\x0d\n          startDot = i;\x0d\n        else if (preDotState !== 1)\x0d\n          preDotState = 1;\x0d\n      } else if (startDot !== -1) {\x0d\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\x0d\n        // have a good chance at having a non-empty extension\x0d\n        preDotState = -1;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (end !== -1) {\x0d\n      if (startDot === -1 ||\x0d\n          // We saw a non-dot character immediately before the dot\x0d\n          preDotState === 0 ||\x0d\n          // The (right-most) trimmed path component is exactly '..'\x0d\n          (preDotState === 1 &&\x0d\n           startDot === end - 1 &&\x0d\n           startDot === startPart + 1)) {\x0d\n        ret.base = ret.name = StringPrototypeSlice(path\x2C startPart\x2C end);\x0d\n      } else {\x0d\n        ret.name = StringPrototypeSlice(path\x2C startPart\x2C startDot);\x0d\n        ret.base = StringPrototypeSlice(path\x2C startPart\x2C end);\x0d\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\x0d\n      }\x0d\n    }\x0d\n\x0d\n    // If the directory is the root\x2C use the entire root as the `dir` including\x0d\n    // the trailing slash if any (`C:\\abc` -> `C:\\`). Otherwise\x2C strip out the\x0d\n    // trailing slash (`C:\\abc\\def` -> `C:\\abc`).\x0d\n    if (startPart > 0 && startPart !== rootEnd)\x0d\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\x0d\n    else\x0d\n      ret.dir = ret.root;\x0d\n\x0d\n    return ret;\x0d\n  }\x2C\x0d\n\x0d\n  sep: '\\\\'\x2C\x0d\n  delimiter: ';'\x2C\x0d\n  win32: null\x2C\x0d\n  posix: null\x0d\n};\x0d\n\x0d\nconst posixCwd = (() => {\x0d\n  if (platformIsWin32) {\x0d\n    // Converts Windows' backslash path separators to POSIX forward slashes\x0d\n    // and truncates any drive indicator\x0d\n    const regexp = /\\\\/g;\x0d\n    return () => {\x0d\n      const cwd = StringPrototypeReplace(process.cwd()\x2C regexp\x2C '/');\x0d\n      return StringPrototypeSlice(cwd\x2C StringPrototypeIndexOf(cwd\x2C '/'));\x0d\n    };\x0d\n  }\x0d\n\x0d\n  // We're already on POSIX\x2C no need for any transformations\x0d\n  return () => process.cwd();\x0d\n})();\x0d\n\x0d\nconst posix = {\x0d\n  /**\x0d\n   * path.resolve([from ...]\x2C to)\x0d\n   * @param {...string} args\x0d\n   * @returns {string}\x0d\n   */\x0d\n  resolve(...args) {\x0d\n    let resolvedPath = '';\x0d\n    let resolvedAbsolute = false;\x0d\n\x0d\n    for (let i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {\x0d\n      const path = i >= 0 ? args[i] : posixCwd();\x0d\n\x0d\n      validateString(path\x2C 'path');\x0d\n\x0d\n      // Skip empty entries\x0d\n      if (path.length === 0) {\x0d\n        continue;\x0d\n      }\x0d\n\x0d\n      resolvedPath = `${path}/${resolvedPath}`;\x0d\n      resolvedAbsolute =\x0d\n        StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\x0d\n    }\x0d\n\x0d\n    // At this point the path should be resolved to a full absolute path\x2C but\x0d\n    // handle relative paths to be safe (might happen when process.cwd() fails)\x0d\n\x0d\n    // Normalize the path\x0d\n    resolvedPath = normalizeString(resolvedPath\x2C !resolvedAbsolute\x2C '/'\x2C\x0d\n                                   isPosixPathSeparator);\x0d\n\x0d\n    if (resolvedAbsolute) {\x0d\n      return `/${resolvedPath}`;\x0d\n    }\x0d\n    return resolvedPath.length > 0 ? resolvedPath : '.';\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {string}\x0d\n   */\x0d\n  normalize(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n\x0d\n    if (path.length === 0)\x0d\n      return '.';\x0d\n\x0d\n    const isAbsolute =\x0d\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\x0d\n    const trailingSeparator =\x0d\n      StringPrototypeCharCodeAt(path\x2C path.length - 1) === CHAR_FORWARD_SLASH;\x0d\n\x0d\n    // Normalize the path\x0d\n    path = normalizeString(path\x2C !isAbsolute\x2C '/'\x2C isPosixPathSeparator);\x0d\n\x0d\n    if (path.length === 0) {\x0d\n      if (isAbsolute)\x0d\n        return '/';\x0d\n      return trailingSeparator ? './' : '.';\x0d\n    }\x0d\n    if (trailingSeparator)\x0d\n      path += '/';\x0d\n\x0d\n    return isAbsolute ? `/${path}` : path;\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {boolean}\x0d\n   */\x0d\n  isAbsolute(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n    return path.length > 0 &&\x0d\n           StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {...string} args\x0d\n   * @returns {string}\x0d\n   */\x0d\n  join(...args) {\x0d\n    if (args.length === 0)\x0d\n      return '.';\x0d\n    let joined;\x0d\n    for (let i = 0; i < args.length; ++i) {\x0d\n      const arg = args[i];\x0d\n      validateString(arg\x2C 'path');\x0d\n      if (arg.length > 0) {\x0d\n        if (joined === undefined)\x0d\n          joined = arg;\x0d\n        else\x0d\n          joined += `/${arg}`;\x0d\n      }\x0d\n    }\x0d\n    if (joined === undefined)\x0d\n      return '.';\x0d\n    return posix.normalize(joined);\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} from\x0d\n   * @param {string} to\x0d\n   * @returns {string}\x0d\n   */\x0d\n  relative(from\x2C to) {\x0d\n    validateString(from\x2C 'from');\x0d\n    validateString(to\x2C 'to');\x0d\n\x0d\n    if (from === to)\x0d\n      return '';\x0d\n\x0d\n    // Trim leading forward slashes.\x0d\n    from = posix.resolve(from);\x0d\n    to = posix.resolve(to);\x0d\n\x0d\n    if (from === to)\x0d\n      return '';\x0d\n\x0d\n    const fromStart = 1;\x0d\n    const fromEnd = from.length;\x0d\n    const fromLen = fromEnd - fromStart;\x0d\n    const toStart = 1;\x0d\n    const toLen = to.length - toStart;\x0d\n\x0d\n    // Compare paths to find the longest common path from root\x0d\n    const length = (fromLen < toLen ? fromLen : toLen);\x0d\n    let lastCommonSep = -1;\x0d\n    let i = 0;\x0d\n    for (; i < length; i++) {\x0d\n      const fromCode = StringPrototypeCharCodeAt(from\x2C fromStart + i);\x0d\n      if (fromCode !== StringPrototypeCharCodeAt(to\x2C toStart + i))\x0d\n        break;\x0d\n      else if (fromCode === CHAR_FORWARD_SLASH)\x0d\n        lastCommonSep = i;\x0d\n    }\x0d\n    if (i === length) {\x0d\n      if (toLen > length) {\x0d\n        if (StringPrototypeCharCodeAt(to\x2C toStart + i) === CHAR_FORWARD_SLASH) {\x0d\n          // We get here if `from` is the exact base path for `to`.\x0d\n          // For example: from='/foo/bar'; to='/foo/bar/baz'\x0d\n          return StringPrototypeSlice(to\x2C toStart + i + 1);\x0d\n        }\x0d\n        if (i === 0) {\x0d\n          // We get here if `from` is the root\x0d\n          // For example: from='/'; to='/foo'\x0d\n          return StringPrototypeSlice(to\x2C toStart + i);\x0d\n        }\x0d\n      } else if (fromLen > length) {\x0d\n        if (StringPrototypeCharCodeAt(from\x2C fromStart + i) ===\x0d\n            CHAR_FORWARD_SLASH) {\x0d\n          // We get here if `to` is the exact base path for `from`.\x0d\n          // For example: from='/foo/bar/baz'; to='/foo/bar'\x0d\n          lastCommonSep = i;\x0d\n        } else if (i === 0) {\x0d\n          // We get here if `to` is the root.\x0d\n          // For example: from='/foo/bar'; to='/'\x0d\n          lastCommonSep = 0;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n\x0d\n    let out = '';\x0d\n    // Generate the relative path based on the path difference between `to`\x0d\n    // and `from`.\x0d\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\x0d\n      if (i === fromEnd ||\x0d\n          StringPrototypeCharCodeAt(from\x2C i) === CHAR_FORWARD_SLASH) {\x0d\n        out += out.length === 0 ? '..' : '/..';\x0d\n      }\x0d\n    }\x0d\n\x0d\n    // Lastly\x2C append the rest of the destination (`to`) path that comes after\x0d\n    // the common path parts.\x0d\n    return `${out}${StringPrototypeSlice(to\x2C toStart + lastCommonSep)}`;\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {string}\x0d\n   */\x0d\n  toNamespacedPath(path) {\x0d\n    // Non-op on posix systems\x0d\n    return path;\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {string}\x0d\n   */\x0d\n  dirname(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n    if (path.length === 0)\x0d\n      return '.';\x0d\n    const hasRoot = StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\x0d\n    let end = -1;\x0d\n    let matchedSlash = true;\x0d\n    for (let i = path.length - 1; i >= 1; --i) {\x0d\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\x0d\n        if (!matchedSlash) {\x0d\n          end = i;\x0d\n          break;\x0d\n        }\x0d\n      } else {\x0d\n        // We saw the first non-path separator\x0d\n        matchedSlash = false;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (end === -1)\x0d\n      return hasRoot ? '/' : '.';\x0d\n    if (hasRoot && end === 1)\x0d\n      return '//';\x0d\n    return StringPrototypeSlice(path\x2C 0\x2C end);\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @param {string} [ext]\x0d\n   * @returns {string}\x0d\n   */\x0d\n  basename(path\x2C ext) {\x0d\n    if (ext !== undefined)\x0d\n      validateString(ext\x2C 'ext');\x0d\n    validateString(path\x2C 'path');\x0d\n\x0d\n    let start = 0;\x0d\n    let end = -1;\x0d\n    let matchedSlash = true;\x0d\n\x0d\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\x0d\n      if (ext === path)\x0d\n        return '';\x0d\n      let extIdx = ext.length - 1;\x0d\n      let firstNonSlashEnd = -1;\x0d\n      for (let i = path.length - 1; i >= 0; --i) {\x0d\n        const code = StringPrototypeCharCodeAt(path\x2C i);\x0d\n        if (code === CHAR_FORWARD_SLASH) {\x0d\n          // If we reached a path separator that was not part of a set of path\x0d\n          // separators at the end of the string\x2C stop now\x0d\n          if (!matchedSlash) {\x0d\n            start = i + 1;\x0d\n            break;\x0d\n          }\x0d\n        } else {\x0d\n          if (firstNonSlashEnd === -1) {\x0d\n            // We saw the first non-path separator\x2C remember this index in case\x0d\n            // we need it if the extension ends up not matching\x0d\n            matchedSlash = false;\x0d\n            firstNonSlashEnd = i + 1;\x0d\n          }\x0d\n          if (extIdx >= 0) {\x0d\n            // Try to match the explicit extension\x0d\n            if (code === StringPrototypeCharCodeAt(ext\x2C extIdx)) {\x0d\n              if (--extIdx === -1) {\x0d\n                // We matched the extension\x2C so mark this as the end of our path\x0d\n                // component\x0d\n                end = i;\x0d\n              }\x0d\n            } else {\x0d\n              // Extension does not match\x2C so our result is the entire path\x0d\n              // component\x0d\n              extIdx = -1;\x0d\n              end = firstNonSlashEnd;\x0d\n            }\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n\x0d\n      if (start === end)\x0d\n        end = firstNonSlashEnd;\x0d\n      else if (end === -1)\x0d\n        end = path.length;\x0d\n      return StringPrototypeSlice(path\x2C start\x2C end);\x0d\n    }\x0d\n    for (let i = path.length - 1; i >= 0; --i) {\x0d\n      if (StringPrototypeCharCodeAt(path\x2C i) === CHAR_FORWARD_SLASH) {\x0d\n        // If we reached a path separator that was not part of a set of path\x0d\n        // separators at the end of the string\x2C stop now\x0d\n        if (!matchedSlash) {\x0d\n          start = i + 1;\x0d\n          break;\x0d\n        }\x0d\n      } else if (end === -1) {\x0d\n        // We saw the first non-path separator\x2C mark this as the end of our\x0d\n        // path component\x0d\n        matchedSlash = false;\x0d\n        end = i + 1;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (end === -1)\x0d\n      return '';\x0d\n    return StringPrototypeSlice(path\x2C start\x2C end);\x0d\n  }\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {string}\x0d\n   */\x0d\n  extname(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n    let startDot = -1;\x0d\n    let startPart = 0;\x0d\n    let end = -1;\x0d\n    let matchedSlash = true;\x0d\n    // Track the state of characters (if any) we see before our first dot and\x0d\n    // after any path separator we find\x0d\n    let preDotState = 0;\x0d\n    for (let i = path.length - 1; i >= 0; --i) {\x0d\n      const code = StringPrototypeCharCodeAt(path\x2C i);\x0d\n      if (code === CHAR_FORWARD_SLASH) {\x0d\n        // If we reached a path separator that was not part of a set of path\x0d\n        // separators at the end of the string\x2C stop now\x0d\n        if (!matchedSlash) {\x0d\n          startPart = i + 1;\x0d\n          break;\x0d\n        }\x0d\n        continue;\x0d\n      }\x0d\n      if (end === -1) {\x0d\n        // We saw the first non-path separator\x2C mark this as the end of our\x0d\n        // extension\x0d\n        matchedSlash = false;\x0d\n        end = i + 1;\x0d\n      }\x0d\n      if (code === CHAR_DOT) {\x0d\n        // If this is our first dot\x2C mark it as the start of our extension\x0d\n        if (startDot === -1)\x0d\n          startDot = i;\x0d\n        else if (preDotState !== 1)\x0d\n          preDotState = 1;\x0d\n      } else if (startDot !== -1) {\x0d\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\x0d\n        // have a good chance at having a non-empty extension\x0d\n        preDotState = -1;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (startDot === -1 ||\x0d\n        end === -1 ||\x0d\n        // We saw a non-dot character immediately before the dot\x0d\n        preDotState === 0 ||\x0d\n        // The (right-most) trimmed path component is exactly '..'\x0d\n        (preDotState === 1 &&\x0d\n         startDot === end - 1 &&\x0d\n         startDot === startPart + 1)) {\x0d\n      return '';\x0d\n    }\x0d\n    return StringPrototypeSlice(path\x2C startDot\x2C end);\x0d\n  }\x2C\x0d\n\x0d\n  format: FunctionPrototypeBind(_format\x2C null\x2C '/')\x2C\x0d\n\x0d\n  /**\x0d\n   * @param {string} path\x0d\n   * @returns {{\x0d\n   *   dir: string;\x0d\n   *   root: string;\x0d\n   *   base: string;\x0d\n   *   name: string;\x0d\n   *   ext: string;\x0d\n   *   }}\x0d\n   */\x0d\n  parse(path) {\x0d\n    validateString(path\x2C 'path');\x0d\n\x0d\n    const ret = { root: ''\x2C dir: ''\x2C base: ''\x2C ext: ''\x2C name: '' };\x0d\n    if (path.length === 0)\x0d\n      return ret;\x0d\n    const isAbsolute =\x0d\n      StringPrototypeCharCodeAt(path\x2C 0) === CHAR_FORWARD_SLASH;\x0d\n    let start;\x0d\n    if (isAbsolute) {\x0d\n      ret.root = '/';\x0d\n      start = 1;\x0d\n    } else {\x0d\n      start = 0;\x0d\n    }\x0d\n    let startDot = -1;\x0d\n    let startPart = 0;\x0d\n    let end = -1;\x0d\n    let matchedSlash = true;\x0d\n    let i = path.length - 1;\x0d\n\x0d\n    // Track the state of characters (if any) we see before our first dot and\x0d\n    // after any path separator we find\x0d\n    let preDotState = 0;\x0d\n\x0d\n    // Get non-dir info\x0d\n    for (; i >= start; --i) {\x0d\n      const code = StringPrototypeCharCodeAt(path\x2C i);\x0d\n      if (code === CHAR_FORWARD_SLASH) {\x0d\n        // If we reached a path separator that was not part of a set of path\x0d\n        // separators at the end of the string\x2C stop now\x0d\n        if (!matchedSlash) {\x0d\n          startPart = i + 1;\x0d\n          break;\x0d\n        }\x0d\n        continue;\x0d\n      }\x0d\n      if (end === -1) {\x0d\n        // We saw the first non-path separator\x2C mark this as the end of our\x0d\n        // extension\x0d\n        matchedSlash = false;\x0d\n        end = i + 1;\x0d\n      }\x0d\n      if (code === CHAR_DOT) {\x0d\n        // If this is our first dot\x2C mark it as the start of our extension\x0d\n        if (startDot === -1)\x0d\n          startDot = i;\x0d\n        else if (preDotState !== 1)\x0d\n          preDotState = 1;\x0d\n      } else if (startDot !== -1) {\x0d\n        // We saw a non-dot and non-path separator before our dot\x2C so we should\x0d\n        // have a good chance at having a non-empty extension\x0d\n        preDotState = -1;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (end !== -1) {\x0d\n      const start = startPart === 0 && isAbsolute ? 1 : startPart;\x0d\n      if (startDot === -1 ||\x0d\n          // We saw a non-dot character immediately before the dot\x0d\n          preDotState === 0 ||\x0d\n          // The (right-most) trimmed path component is exactly '..'\x0d\n          (preDotState === 1 &&\x0d\n          startDot === end - 1 &&\x0d\n          startDot === startPart + 1)) {\x0d\n        ret.base = ret.name = StringPrototypeSlice(path\x2C start\x2C end);\x0d\n      } else {\x0d\n        ret.name = StringPrototypeSlice(path\x2C start\x2C startDot);\x0d\n        ret.base = StringPrototypeSlice(path\x2C start\x2C end);\x0d\n        ret.ext = StringPrototypeSlice(path\x2C startDot\x2C end);\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (startPart > 0)\x0d\n      ret.dir = StringPrototypeSlice(path\x2C 0\x2C startPart - 1);\x0d\n    else if (isAbsolute)\x0d\n      ret.dir = '/';\x0d\n\x0d\n    return ret;\x0d\n  }\x2C\x0d\n\x0d\n  sep: '/'\x2C\x0d\n  delimiter: ':'\x2C\x0d\n  win32: null\x2C\x0d\n  posix: null\x0d\n};\x0d\n\x0d\nposix.win32 = win32.win32 = win32;\x0d\nposix.posix = win32.posix = posix;\x0d\n\x0d\n// Legacy internal API\x2C docs-only deprecated: DEP0080\x0d\nwin32._makeLong = win32.toNamespacedPath;\x0d\nposix._makeLong = posix.toNamespacedPath;\x0d\n\x0d\nmodule.exports = platformIsWin32 ? win32 : posix;\x0d\n
code-source-info,0x1abee80b60e,41,4875,9786,C0O4875C3O4913C6O4941C9O4973C11O5005C15O5012C19O5019C21O5019C26O5044C28O5057C29O5063C34O5080C36O5091C40O5105C49O5105C54O5186C60O5193C65O5213C69O5267C75O5274C80O5292C84O5307C89O5307C96O5706C99O5721C110O5729C114O5724C123O5758C128O5758C133O5907C137O5947C142O5974C156O5974C163O5947C170O6025C174O6025C178O6008C185O6084C192O6084C200O6123C202O6119C207O6158C217O6234C222O6263C224O6286C227O6314C229O6341C237O6341C243O6416C245O6424C250O6442C253O6446C259O6534C262O6558C266O6602C269O6606C275O6802C277O6832C282O6852C290O6852C297O6836C303O6967C306O6992C307O7071C309O7065C319O7109C323O7109C330O7093C336O7161C341O7056C344O7190C346O7196C353O7207C358O7250C372O7250C378O7325C383O7411C385O7405C395O7450C399O7450C406O7434C412O7504C417O7396C420O7537C422O7543C429O7554C434O7608C439O7702C441O7696C451O7744C455O7744C462O7728C468O7800C473O7687C476O7837C478O7843C485O7856C490O7927C495O7962C508O7976C521O7976C531O8032C538O8119C543O8157C546O8161C554O8209C561O8209C569O8248C571O8244C576O8304C591O8313C597O8356C600O8378C602O8386C612O8409C620O8409C627O8393C633O8554C635O8584C638O8637C644O8644C649O8679C655O8686C660O8704C665O8708C672O8762C676O8762C680O8743C685O8894C689O8933C694O8987C698O9039C704O9046C709O9062C713O9094C719O9123C734O9163C739O9188C742O9228C746O9261C752O9268C757O9286C759O5027C764O4987C770O9529C775O9575C789O9544C795O9660C801O9696C811O9715C819O9742C823O9759C831O9781,,
code-creation,LazyCompile,10,177542,0x1abee80ec26,30,validateString node:internal/validators:118:24,0x147335fcf18,~
script-source,15,node:internal/validators,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeIncludes\x2C\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypeMap\x2C\x0d\n  NumberIsInteger\x2C\x0d\n  NumberMAX_SAFE_INTEGER\x2C\x0d\n  NumberMIN_SAFE_INTEGER\x2C\x0d\n  NumberParseInt\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  String\x2C\x0d\n  StringPrototypeToUpperCase\x2C\x0d\n  StringPrototypeTrim\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  hideStackFrames\x2C\x0d\n  codes: {\x0d\n    ERR_SOCKET_BAD_PORT\x2C\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_OUT_OF_RANGE\x2C\x0d\n    ERR_UNKNOWN_SIGNAL\x2C\x0d\n    ERR_INVALID_CALLBACK\x2C\x0d\n  }\x0d\n} = require('internal/errors');\x0d\nconst { normalizeEncoding } = require('internal/util');\x0d\nconst {\x0d\n  isAsyncFunction\x2C\x0d\n  isArrayBufferView\x0d\n} = require('internal/util/types');\x0d\nconst { signals } = internalBinding('constants').os;\x0d\n\x0d\nfunction isInt32(value) {\x0d\n  return value === (value | 0);\x0d\n}\x0d\n\x0d\nfunction isUint32(value) {\x0d\n  return value === (value >>> 0);\x0d\n}\x0d\n\x0d\nconst octalReg = /^[0-7]+$/;\x0d\nconst modeDesc = 'must be a 32-bit unsigned integer or an octal string';\x0d\n\x0d\n/**\x0d\n * Parse and validate values that will be converted into mode_t (the S_*\x0d\n * constants). Only valid numbers and octal strings are allowed. They could be\x0d\n * converted to 32-bit unsigned integers or non-negative signed integers in the\x0d\n * C++ land\x2C but any value higher than 0o777 will result in platform-specific\x0d\n * behaviors.\x0d\n *\x0d\n * @param {*} value Values to be validated\x0d\n * @param {string} name Name of the argument\x0d\n * @param {number} [def] If specified\x2C will be returned for invalid values\x0d\n * @returns {number}\x0d\n */\x0d\nfunction parseFileMode(value\x2C name\x2C def) {\x0d\n  value ??= def;\x0d\n  if (typeof value === 'string') {\x0d\n    if (!RegExpPrototypeTest(octalReg\x2C value)) {\x0d\n      throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C modeDesc);\x0d\n    }\x0d\n    value = NumberParseInt(value\x2C 8);\x0d\n  }\x0d\n\x0d\n  validateInt32(value\x2C name\x2C 0\x2C 2 ** 32 - 1);\x0d\n  return value;\x0d\n}\x0d\n\x0d\nconst validateInteger = hideStackFrames(\x0d\n  (value\x2C name\x2C min = NumberMIN_SAFE_INTEGER\x2C max = NumberMAX_SAFE_INTEGER) => {\x0d\n    if (typeof value !== 'number')\x0d\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\x0d\n    if (!NumberIsInteger(value))\x0d\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\x0d\n    if (value < min || value > max)\x0d\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\x0d\n  }\x0d\n);\x0d\n\x0d\nconst validateInt32 = hideStackFrames(\x0d\n  (value\x2C name\x2C min = -2147483648\x2C max = 2147483647) => {\x0d\n    // The defaults for min and max correspond to the limits of 32-bit integers.\x0d\n    if (!isInt32(value)) {\x0d\n      if (typeof value !== 'number') {\x0d\n        throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\x0d\n      }\x0d\n      if (!NumberIsInteger(value)) {\x0d\n        throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\x0d\n      }\x0d\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\x0d\n    }\x0d\n    if (value < min || value > max) {\x0d\n      throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && <= ${max}`\x2C value);\x0d\n    }\x0d\n  }\x0d\n);\x0d\n\x0d\nconst validateUint32 = hideStackFrames((value\x2C name\x2C positive) => {\x0d\n  if (!isUint32(value)) {\x0d\n    if (typeof value !== 'number') {\x0d\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\x0d\n    }\x0d\n    if (!NumberIsInteger(value)) {\x0d\n      throw new ERR_OUT_OF_RANGE(name\x2C 'an integer'\x2C value);\x0d\n    }\x0d\n    const min = positive ? 1 : 0;\x0d\n    // 2 ** 32 === 4294967296\x0d\n    throw new ERR_OUT_OF_RANGE(name\x2C `>= ${min} && < 4294967296`\x2C value);\x0d\n  }\x0d\n  if (positive && value === 0) {\x0d\n    throw new ERR_OUT_OF_RANGE(name\x2C '>= 1 && < 4294967296'\x2C value);\x0d\n  }\x0d\n});\x0d\n\x0d\nfunction validateString(value\x2C name) {\x0d\n  if (typeof value !== 'string')\x0d\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'string'\x2C value);\x0d\n}\x0d\n\x0d\nfunction validateNumber(value\x2C name) {\x0d\n  if (typeof value !== 'number')\x0d\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'number'\x2C value);\x0d\n}\x0d\n\x0d\nconst validateOneOf = hideStackFrames((value\x2C name\x2C oneOf) => {\x0d\n  if (!ArrayPrototypeIncludes(oneOf\x2C value)) {\x0d\n    const allowed = ArrayPrototypeJoin(\x0d\n      ArrayPrototypeMap(oneOf\x2C (v) =>\x0d\n        (typeof v === 'string' ? `'${v}'` : String(v)))\x2C\x0d\n      '\x2C ');\x0d\n    const reason = 'must be one of: ' + allowed;\x0d\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\x0d\n  }\x0d\n});\x0d\n\x0d\nfunction validateBoolean(value\x2C name) {\x0d\n  if (typeof value !== 'boolean')\x0d\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'boolean'\x2C value);\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {unknown} value\x0d\n * @param {string} name\x0d\n * @param {{\x0d\n *   allowArray?: boolean\x2C\x0d\n *   allowFunction?: boolean\x2C\x0d\n *   nullable?: boolean\x0d\n * }} [options]\x0d\n */\x0d\nconst validateObject = hideStackFrames(\x0d\n  (value\x2C name\x2C options) => {\x0d\n    const useDefaultOptions = options == null;\x0d\n    const allowArray = useDefaultOptions ? false : options.allowArray;\x0d\n    const allowFunction = useDefaultOptions ? false : options.allowFunction;\x0d\n    const nullable = useDefaultOptions ? false : options.nullable;\x0d\n    if ((!nullable && value === null) ||\x0d\n        (!allowArray && ArrayIsArray(value)) ||\x0d\n        (typeof value !== 'object' && (\x0d\n          !allowFunction || typeof value !== 'function'\x0d\n        ))) {\x0d\n      throw new ERR_INVALID_ARG_TYPE(name\x2C 'Object'\x2C value);\x0d\n    }\x0d\n  });\x0d\n\x0d\nconst validateArray = hideStackFrames((value\x2C name\x2C minLength = 0) => {\x0d\n  if (!ArrayIsArray(value)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Array'\x2C value);\x0d\n  }\x0d\n  if (value.length < minLength) {\x0d\n    const reason = `must be longer than ${minLength}`;\x0d\n    throw new ERR_INVALID_ARG_VALUE(name\x2C value\x2C reason);\x0d\n  }\x0d\n});\x0d\n\x0d\nfunction validateSignalName(signal\x2C name = 'signal') {\x0d\n  validateString(signal\x2C name);\x0d\n\x0d\n  if (signals[signal] === undefined) {\x0d\n    if (signals[StringPrototypeToUpperCase(signal)] !== undefined) {\x0d\n      throw new ERR_UNKNOWN_SIGNAL(signal +\x0d\n                                   ' (signals must use all capital letters)');\x0d\n    }\x0d\n\x0d\n    throw new ERR_UNKNOWN_SIGNAL(signal);\x0d\n  }\x0d\n}\x0d\n\x0d\nconst validateBuffer = hideStackFrames((buffer\x2C name = 'buffer') => {\x0d\n  if (!isArrayBufferView(buffer)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(name\x2C\x0d\n                                   ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\x0d\n                                   buffer);\x0d\n  }\x0d\n});\x0d\n\x0d\nfunction validateEncoding(data\x2C encoding) {\x0d\n  const normalizedEncoding = normalizeEncoding(encoding);\x0d\n  const length = data.length;\x0d\n\x0d\n  if (normalizedEncoding === 'hex' && length % 2 !== 0) {\x0d\n    throw new ERR_INVALID_ARG_VALUE('encoding'\x2C encoding\x2C\x0d\n                                    `is invalid for data of length ${length}`);\x0d\n  }\x0d\n}\x0d\n\x0d\n// Check that the port number is not NaN when coerced to a number\x2C\x0d\n// is an integer and that it falls within the legal range of port numbers.\x0d\nfunction validatePort(port\x2C name = 'Port'\x2C allowZero = true) {\x0d\n  if ((typeof port !== 'number' && typeof port !== 'string') ||\x0d\n      (typeof port === 'string' && StringPrototypeTrim(port).length === 0) ||\x0d\n      +port !== (+port >>> 0) ||\x0d\n      port > 0xFFFF ||\x0d\n      (port === 0 && !allowZero)) {\x0d\n    throw new ERR_SOCKET_BAD_PORT(name\x2C port\x2C allowZero);\x0d\n  }\x0d\n  return port | 0;\x0d\n}\x0d\n\x0d\nconst validateCallback = hideStackFrames((callback) => {\x0d\n  if (typeof callback !== 'function')\x0d\n    throw new ERR_INVALID_CALLBACK(callback);\x0d\n});\x0d\n\x0d\nconst validateAbortSignal = hideStackFrames((signal\x2C name) => {\x0d\n  if (signal !== undefined &&\x0d\n      (signal === null ||\x0d\n       typeof signal !== 'object' ||\x0d\n       !('aborted' in signal))) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'AbortSignal'\x2C signal);\x0d\n  }\x0d\n});\x0d\n\x0d\nconst validateFunction = hideStackFrames((value\x2C name) => {\x0d\n  if (typeof value !== 'function')\x0d\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\x0d\n});\x0d\n\x0d\nconst validatePlainFunction = hideStackFrames((value\x2C name) => {\x0d\n  if (typeof value !== 'function' || isAsyncFunction(value))\x0d\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'Function'\x2C value);\x0d\n});\x0d\n\x0d\nconst validateUndefined = hideStackFrames((value\x2C name) => {\x0d\n  if (value !== undefined)\x0d\n    throw new ERR_INVALID_ARG_TYPE(name\x2C 'undefined'\x2C value);\x0d\n});\x0d\n\x0d\nmodule.exports = {\x0d\n  isInt32\x2C\x0d\n  isUint32\x2C\x0d\n  parseFileMode\x2C\x0d\n  validateArray\x2C\x0d\n  validateBoolean\x2C\x0d\n  validateBuffer\x2C\x0d\n  validateEncoding\x2C\x0d\n  validateFunction\x2C\x0d\n  validateInt32\x2C\x0d\n  validateInteger\x2C\x0d\n  validateNumber\x2C\x0d\n  validateObject\x2C\x0d\n  validateOneOf\x2C\x0d\n  validatePlainFunction\x2C\x0d\n  validatePort\x2C\x0d\n  validateSignalName\x2C\x0d\n  validateString\x2C\x0d\n  validateUint32\x2C\x0d\n  validateUndefined\x2C\x0d\n  validateCallback\x2C\x0d\n  validateAbortSignal\x2C\x0d\n};\x0d\n
code-source-info,0x1abee80ec26,15,3534,3646,C0O3553C6O3589C22O3595C27O3589C29O3645,,
code-creation,LazyCompile,10,177985,0x1abee80f5c6,17,isPathSeparator node:path:52:25,0x394c9e0cf90,~
code-source-info,0x1abee80f5c6,41,1794,1876,C0O1806C2O1822C4O1818C11O1853C13O1849C16O1873,,
code-creation,LazyCompile,10,178029,0x1abee80f6c6,35,isWindowsDeviceRoot node:path:60:29,0x394c9e0d408,~
code-source-info,0x1abee80f6c6,41,1991,2136,C0O2003C2O2019C4O2016C11O2047C13O2044C20O2087C22O2084C29O2115C31O2112C34O2133,,
code-creation,LazyCompile,10,178087,0x1abee80f7e6,40,wrappedCwd node:internal/bootstrap/switches/does_own_process_state:124:20,0x147335fe5f0,~
script-source,94,node:internal/bootstrap/switches/does_own_process_state,'use strict';\x0d\n\x0d\nconst credentials = internalBinding('credentials');\x0d\nconst rawMethods = internalBinding('process_methods');\x0d\n\x0d\nprocess.abort = rawMethods.abort;\x0d\nprocess.umask = wrappedUmask;\x0d\nprocess.chdir = wrappedChdir;\x0d\nprocess.cwd = wrappedCwd;\x0d\n\x0d\nif (credentials.implementsPosixCredentials) {\x0d\n  const wrapped = wrapPosixCredentialSetters(credentials);\x0d\n\x0d\n  process.initgroups = wrapped.initgroups;\x0d\n  process.setgroups = wrapped.setgroups;\x0d\n  process.setegid = wrapped.setegid;\x0d\n  process.seteuid = wrapped.seteuid;\x0d\n  process.setgid = wrapped.setgid;\x0d\n  process.setuid = wrapped.setuid;\x0d\n}\x0d\n\x0d\n// ---- keep the attachment of the wrappers above so that it's easier to ----\x0d\n// ----              compare the setups side-by-side                    -----\x0d\n\x0d\nconst {\x0d\n  parseFileMode\x2C\x0d\n  validateArray\x2C\x0d\n  validateString\x0d\n} = require('internal/validators');\x0d\n\x0d\nfunction wrapPosixCredentialSetters(credentials) {\x0d\n  const {\x0d\n    codes: {\x0d\n      ERR_INVALID_ARG_TYPE\x2C\x0d\n      ERR_UNKNOWN_CREDENTIAL\x0d\n    }\x0d\n  } = require('internal/errors');\x0d\n  const {\x0d\n    validateUint32\x0d\n  } = require('internal/validators');\x0d\n\x0d\n  const {\x0d\n    initgroups: _initgroups\x2C\x0d\n    setgroups: _setgroups\x2C\x0d\n    setegid: _setegid\x2C\x0d\n    seteuid: _seteuid\x2C\x0d\n    setgid: _setgid\x2C\x0d\n    setuid: _setuid\x0d\n  } = credentials;\x0d\n\x0d\n  function initgroups(user\x2C extraGroup) {\x0d\n    validateId(user\x2C 'user');\x0d\n    validateId(extraGroup\x2C 'extraGroup');\x0d\n    // Result is 0 on success\x2C 1 if user is unknown\x2C 2 if group is unknown.\x0d\n    const result = _initgroups(user\x2C extraGroup);\x0d\n    if (result === 1) {\x0d\n      throw new ERR_UNKNOWN_CREDENTIAL('User'\x2C user);\x0d\n    } else if (result === 2) {\x0d\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C extraGroup);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  function setgroups(groups) {\x0d\n    validateArray(groups\x2C 'groups');\x0d\n    for (let i = 0; i < groups.length; i++) {\x0d\n      validateId(groups[i]\x2C `groups[${i}]`);\x0d\n    }\x0d\n    // Result is 0 on success. A positive integer indicates that the\x0d\n    // corresponding group was not found.\x0d\n    const result = _setgroups(groups);\x0d\n    if (result > 0) {\x0d\n      throw new ERR_UNKNOWN_CREDENTIAL('Group'\x2C groups[result - 1]);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  function wrapIdSetter(type\x2C method) {\x0d\n    return function(id) {\x0d\n      validateId(id\x2C 'id');\x0d\n      if (typeof id === 'number') id |= 0;\x0d\n      // Result is 0 on success\x2C 1 if credential is unknown.\x0d\n      const result = method(id);\x0d\n      if (result === 1) {\x0d\n        throw new ERR_UNKNOWN_CREDENTIAL(type\x2C id);\x0d\n      }\x0d\n    };\x0d\n  }\x0d\n\x0d\n  function validateId(id\x2C name) {\x0d\n    if (typeof id === 'number') {\x0d\n      validateUint32(id\x2C name);\x0d\n    } else if (typeof id !== 'string') {\x0d\n      throw new ERR_INVALID_ARG_TYPE(name\x2C ['number'\x2C 'string']\x2C id);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return {\x0d\n    initgroups\x2C\x0d\n    setgroups\x2C\x0d\n    setegid: wrapIdSetter('Group'\x2C _setegid)\x2C\x0d\n    seteuid: wrapIdSetter('User'\x2C _seteuid)\x2C\x0d\n    setgid: wrapIdSetter('Group'\x2C _setgid)\x2C\x0d\n    setuid: wrapIdSetter('User'\x2C _setuid)\x0d\n  };\x0d\n}\x0d\n\x0d\n// Cache the working directory to prevent lots of lookups. If the working\x0d\n// directory is changed by `chdir`\x2C it'll be updated.\x0d\nlet cachedCwd = '';\x0d\n\x0d\nfunction wrappedChdir(directory) {\x0d\n  validateString(directory\x2C 'directory');\x0d\n  rawMethods.chdir(directory);\x0d\n  // Mark cache that it requires an update.\x0d\n  cachedCwd = '';\x0d\n}\x0d\n\x0d\nfunction wrappedUmask(mask) {\x0d\n  if (mask !== undefined) {\x0d\n    mask = parseFileMode(mask\x2C 'mask');\x0d\n  }\x0d\n  return rawMethods.umask(mask);\x0d\n}\x0d\n\x0d\nfunction wrappedCwd() {\x0d\n  if (cachedCwd === '')\x0d\n    cachedCwd = rawMethods.cwd();\x0d\n  return cachedCwd;\x0d\n}\x0d\n
code-source-info,0x1abee80f7e6,94,3464,3552,C0O3472C7O3486C12O3499C17O3522C22O3522C29O3509C35O3532C39O3549,,
code-creation,LazyCompile,10,178394,0x1abee80fe4e,442,normalizeString node:path:66:25,0x394c9e0d458,~
code-source-info,0x1abee80fe4e,41,2226,4212,C0O2292C3O2323C5O2345C8O2363C10O2380C12O2399C14O2412C18O2404C23O2445C27O2438C32O2460C37O2467C45O2517C51O2547C53O2571C58O2609C64O2641C66O2661C69O2655C76O2673C83O2713C85O2722C90O2748C97O2755C104O2780C111O2802C114O2837C118O2844C122O2802C130O2853C132O2849C139O2878C142O2913C146O2920C150O2878C158O2929C160O2925C165O2960C172O2967C177O3010C182O3010C188O3067C190O3086C195O3111C198O3136C202O3196C215O3202C221O3304C225O3311C231O3317C234O3317C239O3315C243O3389C246O3417C248O3440C250O3476C256O3483C261O3505C264O3528C266O3564C269O3592C271O3615C273O3658C277O3702C283O3709C293O3718C308O3751C313O3818C319O3825C324O3841C326O3851C330O3863C335O3900C345O3863C363O3936C370O3979C380O3942C386O3997C388O4019C391O4031C395O4052C398O4074C402O4096C404O4109C406O4105C413O4126C418O4143C425O4172C428O2422C433O2386C439O4198C441O4209,,
code-creation,LazyCompile,10,178563,0x1abee81056e,63,addReadOnlyProcessAlias node:internal/bootstrap/pre_execution:120:33,0x1abee803200,~
code-source-info,0x1abee81056e,96,4131,4366,C16O4184C21O4184C26O4211C28O4229C36O4259C43O4325C49O4344C56O4229C62O4365,,
code-creation,LazyCompile,10,178626,0x1abee8106ee,82,getOptionValue node:internal/options:39:24,0x1abee805690,~
code-source-info,0x1abee8106ee,97,940,1190,C0O974C3O974C7O1020C15O1020C22O1071C30O1093C38O1093C43O1080C47O1071C53O1109C55O1134C60O1140C61O1164C66O1164C74O1179C81O1187,,
code-creation,LazyCompile,10,178680,0x1abee810a9e,33,getCLIOptionsFromBinding node:internal/options:18:34,0x1abee8055a0,~
code-source-info,0x1abee810a9e,97,514,620,C0O522C6O546C11O573C15O558C28O599C32O617,,
code-creation,LazyCompile,10,178975,0x1abee810c5e,46,setupTraceCategoryState node:internal/bootstrap/pre_execution:212:33,0x1abee8034a8,~
code-source-info,0x1abee810c5e,96,6691,6922,C0O6734C6O6734C11O6707C16O6807C22O6807C27O6778C32O6850C35O6875C40O6850C45O6921,,
code-creation,LazyCompile,10,179035,0x1abee810df6,77,toggleTraceCategoryState node:internal/process/per_thread:390:34,0x14121bd8c70,~
code-source-info,0x1abee810df6,30,11548,11855,C0O11573C4O11603C10O11639C16O11671C21O11715C26O11716C33O11660C39O11742C44O11763C49O11763C55O11783C61O11816C66O11837C71O11837C76O11854,,
code-creation,LazyCompile,10,179089,0x1abee810fa6,42,setupPerfHooks node:internal/bootstrap/pre_execution:218:24,0x1abee8034f8,~
code-source-info,0x1abee810fa6,96,6949,7072,C0O6957C6O6957C11O6993C16O6994C20O7018C26O7018C31O7048C36O7049C41O7071,,
code-creation,LazyCompile,10,179147,0x1abee811126,42,refreshTimeOrigin node:internal/perf/performance:178:27,0x13c5c2e9f20,~
script-source,74,node:internal/perf/performance,'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\x0d\n  }\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  EventTarget\x2C\x0d\n} = require('internal/event_target');\x0d\n\x0d\nconst { now } = require('internal/perf/utils');\x0d\n\x0d\nconst {\x0d\n  mark\x2C\x0d\n  measure\x2C\x0d\n  clearMarkTimings\x2C\x0d\n} = require('internal/perf/usertiming');\x0d\nconst {\x0d\n  clearEntriesFromBuffer\x2C\x0d\n  filterBufferMapByNameAndType\x2C\x0d\n} = require('internal/perf/observe');\x0d\n\x0d\nconst eventLoopUtilization = require('internal/perf/event_loop_utilization');\x0d\nconst nodeTiming = require('internal/perf/nodetiming');\x0d\nconst timerify = require('internal/perf/timerify');\x0d\nconst { customInspectSymbol: kInspect } = require('internal/util');\x0d\nconst { inspect } = require('util');\x0d\n\x0d\nconst {\x0d\n  getTimeOriginTimestamp\x0d\n} = internalBinding('performance');\x0d\n\x0d\nclass Performance extends EventTarget {\x0d\n  constructor() {\x0d\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    if (depth < 0) return this;\x0d\n\x0d\n    const opts = {\x0d\n      ...options\x2C\x0d\n      depth: options.depth == null ? null : options.depth - 1\x0d\n    };\x0d\n\x0d\n    return `Performance ${inspect({\x0d\n      nodeTiming: this.nodeTiming\x2C\x0d\n      timeOrigin: this.timeOrigin\x2C\x0d\n    }\x2C opts)}`;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction toJSON() {\x0d\n  return {\x0d\n    nodeTiming: this.nodeTiming\x2C\x0d\n    timeOrigin: this.timeOrigin\x2C\x0d\n    eventLoopUtilization: this.eventLoopUtilization()\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction clearMarks(name) {\x0d\n  if (name !== undefined) {\x0d\n    name = `${name}`;\x0d\n  }\x0d\n  clearMarkTimings(name);\x0d\n  clearEntriesFromBuffer('mark'\x2C name);\x0d\n}\x0d\n\x0d\nfunction clearMeasures(name) {\x0d\n  if (name !== undefined) {\x0d\n    name = `${name}`;\x0d\n  }\x0d\n  clearEntriesFromBuffer('measure'\x2C name);\x0d\n}\x0d\n\x0d\nfunction getEntries() {\x0d\n  return filterBufferMapByNameAndType();\x0d\n}\x0d\n\x0d\nfunction getEntriesByName(name) {\x0d\n  if (name !== undefined) {\x0d\n    name = `${name}`;\x0d\n  }\x0d\n  return filterBufferMapByNameAndType(name\x2C undefined);\x0d\n}\x0d\n\x0d\nfunction getEntriesByType(type) {\x0d\n  if (type !== undefined) {\x0d\n    type = `${type}`;\x0d\n  }\x0d\n  return filterBufferMapByNameAndType(undefined\x2C type);\x0d\n}\x0d\n\x0d\nclass InternalPerformance extends EventTarget {}\x0d\nInternalPerformance.prototype.constructor = Performance.prototype.constructor;\x0d\nObjectSetPrototypeOf(InternalPerformance.prototype\x2C Performance.prototype);\x0d\n\x0d\nObjectDefineProperties(Performance.prototype\x2C {\x0d\n  clearMarks: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: clearMarks\x2C\x0d\n  }\x2C\x0d\n  clearMeasures: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: clearMeasures\x2C\x0d\n  }\x2C\x0d\n  eventLoopUtilization: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: eventLoopUtilization\x2C\x0d\n  }\x2C\x0d\n  getEntries: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: getEntries\x2C\x0d\n  }\x2C\x0d\n  getEntriesByName: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: getEntriesByName\x2C\x0d\n  }\x2C\x0d\n  getEntriesByType: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: getEntriesByType\x2C\x0d\n  }\x2C\x0d\n  mark: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: mark\x2C\x0d\n  }\x2C\x0d\n  measure: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: measure\x2C\x0d\n  }\x2C\x0d\n  nodeTiming: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: nodeTiming\x2C\x0d\n  }\x2C\x0d\n  now: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: now\x2C\x0d\n  }\x2C\x0d\n  timerify: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    value: timerify\x2C\x0d\n  }\x2C\x0d\n  // This would be updated during pre-execution in case\x0d\n  // the process is launched from a snapshot.\x0d\n  // TODO(joyeecheung): we may want to warn about access to\x0d\n  // this during snapshot building.\x0d\n  timeOrigin: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x2C\x0d\n    value: getTimeOriginTimestamp()\x2C\x0d\n  }\x2C\x0d\n  toJSON: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x2C\x0d\n    value: toJSON\x2C\x0d\n  }\x0d\n});\x0d\n\x0d\nfunction refreshTimeOrigin() {\x0d\n  ObjectDefineProperty(Performance.prototype\x2C 'timeOrigin'\x2C {\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x2C\x0d\n    value: getTimeOriginTimestamp()\x2C\x0d\n  });\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  InternalPerformance\x2C\x0d\n  refreshTimeOrigin\x0d\n};\x0d\n
code-source-info,0x1abee811126,74,3932,4095,C0O3940C7O3961C10O3973C25O4060C28O4060C35O3940C41O4094,,
code-creation,LazyCompile,10,179444,0x1abee811836,19,refreshTimeOrigin node:internal/perf/utils:25:27,0x394c9e22298,~
script-source,46,node:internal/perf/utils,'use strict';\x0d\n\x0d\nconst binding = internalBinding('performance');\x0d\nconst {\x0d\n  milestones\x2C\x0d\n  getTimeOrigin\x2C\x0d\n} = binding;\x0d\n\x0d\n// TODO(joyeecheung): we may want to warn about access to\x0d\n// this during snapshot building.\x0d\nlet timeOrigin = getTimeOrigin();\x0d\n\x0d\nfunction now() {\x0d\n  const hr = process.hrtime();\x0d\n  return (hr[0] * 1000 + hr[1] / 1e6) - timeOrigin;\x0d\n}\x0d\n\x0d\nfunction getMilestoneTimestamp(milestoneIdx) {\x0d\n  const ns = milestones[milestoneIdx];\x0d\n  if (ns === -1)\x0d\n    return ns;\x0d\n  return ns / 1e6 - timeOrigin;\x0d\n}\x0d\n\x0d\nfunction refreshTimeOrigin() {\x0d\n  timeOrigin = getTimeOrigin();\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  now\x2C\x0d\n  getMilestoneTimestamp\x2C\x0d\n  refreshTimeOrigin\x0d\n};\x0d\n
code-source-info,0x1abee811836,46,549,589,C0O557C5O570C11O568C18O588,,
code-creation,LazyCompile,10,179537,0x1abee811aa6,62,setupInspectorHooks node:internal/bootstrap/pre_execution:223:29,0x1abee803548,~
code-source-info,0x1abee811aa6,96,7104,7670,C0O7453C6O7457C11O7482C17O7551C23O7551C28O7519C33O7534C38O7598C44O7598C49O7626C54O7627C61O7669,,
code-creation,Eval,10,179651,0x1abee811e56,5, node:internal/inspector_async_hook:1:1,0x1abee811ca0,~
script-source,98,node:internal/inspector_async_hook,'use strict';\x0d\n\x0d\nlet hook;\x0d\nlet config;\x0d\n\x0d\nconst {\x0d\n  SafeSet\x2C\x0d\n} = primordials;\x0d\n\x0d\nfunction lazyHookCreation() {\x0d\n  const inspector = internalBinding('inspector');\x0d\n  const { createHook } = require('async_hooks');\x0d\n  config = internalBinding('config');\x0d\n\x0d\n  hook = createHook({\x0d\n    init(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\x0d\n    // It's difficult to tell which tasks will be recurring and which won't\x2C\x0d\n    // therefore we mark all tasks as recurring. Based on the discussion\x0d\n    // in https://github.com/nodejs/node/pull/13870#discussion_r124515293\x2C\x0d\n    // this should be fine as long as we call asyncTaskCanceled() too.\x0d\n      const recurring = true;\x0d\n      if (type === 'PROMISE')\x0d\n        this.promiseIds.add(asyncId);\x0d\n      else\x0d\n        inspector.asyncTaskScheduled(type\x2C asyncId\x2C recurring);\x0d\n    }\x2C\x0d\n\x0d\n    before(asyncId) {\x0d\n      if (this.promiseIds.has(asyncId))\x0d\n        return;\x0d\n      inspector.asyncTaskStarted(asyncId);\x0d\n    }\x2C\x0d\n\x0d\n    after(asyncId) {\x0d\n      if (this.promiseIds.has(asyncId))\x0d\n        return;\x0d\n      inspector.asyncTaskFinished(asyncId);\x0d\n    }\x2C\x0d\n\x0d\n    destroy(asyncId) {\x0d\n      if (this.promiseIds.has(asyncId))\x0d\n        return this.promiseIds.delete(asyncId);\x0d\n      inspector.asyncTaskCanceled(asyncId);\x0d\n    }\x2C\x0d\n  });\x0d\n\x0d\n  hook.promiseIds = new SafeSet();\x0d\n}\x0d\n\x0d\nfunction enable() {\x0d\n  if (hook === undefined) lazyHookCreation();\x0d\n  if (config.bits < 64) {\x0d\n    // V8 Inspector stores task ids as (void*) pointers.\x0d\n    // async_hooks store ids as 64bit numbers.\x0d\n    // As a result\x2C we cannot reliably translate async_hook ids to V8 async_task\x0d\n    // ids on 32bit platforms.\x0d\n    process.emitWarning(\x0d\n      'Warning: Async stack traces in debugger are not available ' +\x0d\n      `on ${config.bits}bit platforms. The feature is disabled.`\x2C\x0d\n      {\x0d\n        code: 'INSPECTOR_ASYNC_STACK_TRACES_NOT_AVAILABLE'\x2C\x0d\n      });\x0d\n  } else {\x0d\n    hook.enable();\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction disable() {\x0d\n  if (hook === undefined) lazyHookCreation();\x0d\n  hook.disable();\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  enable\x2C\x0d\n  disable\x0d\n};\x0d\n
code-source-info,0x1abee811e56,98,0,2048,C0O0C4O2048,,
code-creation,Function,10,179781,0x1abee812076,79, node:internal/inspector_async_hook:1:1,0x1abee811dd0,~
code-source-info,0x1abee812076,98,0,2048,C0O0C42O21C43O21C45O32C46O32C48O54C54O2002C61O2024C67O2035C73O2017C78O2047,,
code-creation,LazyCompile,10,179875,0x1abee8126ee,69,setupWarningHandler node:internal/bootstrap/pre_execution:132:29,0x1abee803250,~
code-source-info,0x1abee8126ee,96,4398,4603,C0O4436C6O4436C11O4419C16O4476C24O4480C33O4525C38O4529C45O4546C50O4562C53O4570C61O4570C68O4602,,
code-creation,LazyCompile,10,180000,0x1abee81284e,20,addListener node:events:616:58,0x25ca272b5a0,~
script-source,23,node:events,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeIndexOf\x2C\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypeShift\x2C\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  ArrayPrototypeSplice\x2C\x0d\n  ArrayPrototypeUnshift\x2C\x0d\n  Boolean\x2C\x0d\n  Error\x2C\x0d\n  ErrorCaptureStackTrace\x2C\x0d\n  FunctionPrototypeBind\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  MathMin\x2C\x0d\n  NumberIsNaN\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectGetPrototypeOf\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  Promise\x2C\x0d\n  PromiseReject\x2C\x0d\n  PromiseResolve\x2C\x0d\n  ReflectApply\x2C\x0d\n  ReflectOwnKeys\x2C\x0d\n  String\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolFor\x2C\x0d\n  SymbolAsyncIterator\x2C\x0d\n} = primordials;\x0d\nconst kRejection = SymbolFor('nodejs.rejection');\x0d\nconst { inspect } = require('internal/util/inspect');\x0d\n\x0d\nlet spliceOne;\x0d\n\x0d\nconst {\x0d\n  AbortError\x2C\x0d\n  kEnhanceStackBeforeInspector\x2C\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_THIS\x2C\x0d\n    ERR_OUT_OF_RANGE\x2C\x0d\n    ERR_UNHANDLED_ERROR\x0d\n  }\x2C\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  validateAbortSignal\x2C\x0d\n  validateBoolean\x2C\x0d\n  validateFunction\x2C\x0d\n  validateString\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst kCapture = Symbol('kCapture');\x0d\nconst kErrorMonitor = Symbol('events.errorMonitor');\x0d\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\x0d\nconst kMaxEventTargetListenersWarned =\x0d\n  Symbol('events.maxEventTargetListenersWarned');\x0d\n\x0d\nlet EventEmitterAsyncResource;\x0d\n// The EventEmitterAsyncResource has to be initialized lazily because event.js\x0d\n// is loaded so early in the bootstrap process\x2C before async_hooks is available.\x0d\n//\x0d\n// This implementation was adapted straight from addaleax's\x0d\n// eventemitter-asyncresource MIT-licensed userland module.\x0d\n// https://github.com/addaleax/eventemitter-asyncresource\x0d\nfunction lazyEventEmitterAsyncResource() {\x0d\n  if (EventEmitterAsyncResource === undefined) {\x0d\n    const {\x0d\n      AsyncResource\x0d\n    } = require('async_hooks');\x0d\n\x0d\n    const kEventEmitter = Symbol('kEventEmitter');\x0d\n    const kAsyncResource = Symbol('kAsyncResource');\x0d\n    class EventEmitterReferencingAsyncResource extends AsyncResource {\x0d\n      /**\x0d\n       * @param {EventEmitter} ee\x0d\n       * @param {string} [type]\x0d\n       * @param {{\x0d\n       *   triggerAsyncId?: number\x2C\x0d\n       *   requireManualDestroy?: boolean\x2C\x0d\n       * }} [options]\x0d\n       */\x0d\n      constructor(ee\x2C type\x2C options) {\x0d\n        super(type\x2C options);\x0d\n        this[kEventEmitter] = ee;\x0d\n      }\x0d\n\x0d\n      /**\x0d\n       * @type {EventEmitter}\x0d\n       */\x0d\n      get eventEmitter() {\x0d\n        if (this[kEventEmitter] === undefined)\x0d\n          throw new ERR_INVALID_THIS('EventEmitterReferencingAsyncResource');\x0d\n        return this[kEventEmitter];\x0d\n      }\x0d\n    }\x0d\n\x0d\n    EventEmitterAsyncResource =\x0d\n      class EventEmitterAsyncResource extends EventEmitter {\x0d\n        /**\x0d\n         * @param {{\x0d\n         *   name?: string\x2C\x0d\n         *   triggerAsyncId?: number\x2C\x0d\n         *   requireManualDestroy?: boolean\x2C\x0d\n         * }} [options]\x0d\n         */\x0d\n        constructor(options = undefined) {\x0d\n          let name;\x0d\n          if (typeof options === 'string') {\x0d\n            name = options;\x0d\n            options = undefined;\x0d\n          } else {\x0d\n            if (new.target === EventEmitterAsyncResource) {\x0d\n              validateString(options?.name\x2C 'options.name');\x0d\n            }\x0d\n            name = options?.name || new.target.name;\x0d\n          }\x0d\n          super(options);\x0d\n\x0d\n          this[kAsyncResource] =\x0d\n            new EventEmitterReferencingAsyncResource(this\x2C name\x2C options);\x0d\n        }\x0d\n\x0d\n        /**\x0d\n         * @param {symbol\x2Cstring} event\x0d\n         * @param  {...any} args\x0d\n         * @returns {boolean}\x0d\n         */\x0d\n        emit(event\x2C ...args) {\x0d\n          if (this[kAsyncResource] === undefined)\x0d\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\x0d\n          const { asyncResource } = this;\x0d\n          ArrayPrototypeUnshift(args\x2C super.emit\x2C this\x2C event);\x0d\n          return ReflectApply(asyncResource.runInAsyncScope\x2C asyncResource\x2C\x0d\n                              args);\x0d\n        }\x0d\n\x0d\n        /**\x0d\n         * @returns {void}\x0d\n         */\x0d\n        emitDestroy() {\x0d\n          if (this[kAsyncResource] === undefined)\x0d\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\x0d\n          this.asyncResource.emitDestroy();\x0d\n        }\x0d\n\x0d\n        /**\x0d\n         * @type {number}\x0d\n         */\x0d\n        get asyncId() {\x0d\n          if (this[kAsyncResource] === undefined)\x0d\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\x0d\n          return this.asyncResource.asyncId();\x0d\n        }\x0d\n\x0d\n        /**\x0d\n         * @type {number}\x0d\n         */\x0d\n        get triggerAsyncId() {\x0d\n          if (this[kAsyncResource] === undefined)\x0d\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\x0d\n          return this.asyncResource.triggerAsyncId();\x0d\n        }\x0d\n\x0d\n        /**\x0d\n         * @type {EventEmitterReferencingAsyncResource}\x0d\n         */\x0d\n        get asyncResource() {\x0d\n          if (this[kAsyncResource] === undefined)\x0d\n            throw new ERR_INVALID_THIS('EventEmitterAsyncResource');\x0d\n          return this[kAsyncResource];\x0d\n        }\x0d\n      };\x0d\n  }\x0d\n  return EventEmitterAsyncResource;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Creates a new `EventEmitter` instance.\x0d\n * @param {{ captureRejections?: boolean; }} [opts]\x0d\n * @constructs {EventEmitter}\x0d\n */\x0d\nfunction EventEmitter(opts) {\x0d\n  EventEmitter.init.call(this\x2C opts);\x0d\n}\x0d\nmodule.exports = EventEmitter;\x0d\nmodule.exports.once = once;\x0d\nmodule.exports.on = on;\x0d\nmodule.exports.getEventListeners = getEventListeners;\x0d\n// Backwards-compat with node 0.10.x\x0d\nEventEmitter.EventEmitter = EventEmitter;\x0d\n\x0d\nEventEmitter.usingDomains = false;\x0d\n\x0d\nEventEmitter.captureRejectionSymbol = kRejection;\x0d\nObjectDefineProperty(EventEmitter\x2C 'captureRejections'\x2C {\x0d\n  get() {\x0d\n    return EventEmitter.prototype[kCapture];\x0d\n  }\x2C\x0d\n  set(value) {\x0d\n    validateBoolean(value\x2C 'EventEmitter.captureRejections');\x0d\n\x0d\n    EventEmitter.prototype[kCapture] = value;\x0d\n  }\x2C\x0d\n  enumerable: true\x0d\n});\x0d\n\x0d\nObjectDefineProperty(EventEmitter\x2C 'EventEmitterAsyncResource'\x2C {\x0d\n  enumerable: true\x2C\x0d\n  get: lazyEventEmitterAsyncResource\x2C\x0d\n  set: undefined\x2C\x0d\n  configurable: true\x2C\x0d\n});\x0d\n\x0d\nEventEmitter.errorMonitor = kErrorMonitor;\x0d\n\x0d\n// The default for captureRejections is false\x0d\nObjectDefineProperty(EventEmitter.prototype\x2C kCapture\x2C {\x0d\n  value: false\x2C\x0d\n  writable: true\x2C\x0d\n  enumerable: false\x0d\n});\x0d\n\x0d\nEventEmitter.prototype._events = undefined;\x0d\nEventEmitter.prototype._eventsCount = 0;\x0d\nEventEmitter.prototype._maxListeners = undefined;\x0d\n\x0d\n// By default EventEmitters will print a warning if more than 10 listeners are\x0d\n// added to it. This is a useful default which helps finding memory leaks.\x0d\nlet defaultMaxListeners = 10;\x0d\nlet isEventTarget;\x0d\n\x0d\nfunction checkListener(listener) {\x0d\n  validateFunction(listener\x2C 'listener');\x0d\n}\x0d\n\x0d\nObjectDefineProperty(EventEmitter\x2C 'defaultMaxListeners'\x2C {\x0d\n  enumerable: true\x2C\x0d\n  get: function() {\x0d\n    return defaultMaxListeners;\x0d\n  }\x2C\x0d\n  set: function(arg) {\x0d\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\x0d\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners'\x2C\x0d\n                                 'a non-negative number'\x2C\x0d\n                                 arg);\x0d\n    }\x0d\n    defaultMaxListeners = arg;\x0d\n  }\x0d\n});\x0d\n\x0d\nObjectDefineProperties(EventEmitter\x2C {\x0d\n  kMaxEventTargetListeners: {\x0d\n    value: kMaxEventTargetListeners\x2C\x0d\n    enumerable: false\x2C\x0d\n    configurable: false\x2C\x0d\n    writable: false\x2C\x0d\n  }\x2C\x0d\n  kMaxEventTargetListenersWarned: {\x0d\n    value: kMaxEventTargetListenersWarned\x2C\x0d\n    enumerable: false\x2C\x0d\n    configurable: false\x2C\x0d\n    writable: false\x2C\x0d\n  }\x0d\n});\x0d\n\x0d\n/**\x0d\n * Sets the max listeners.\x0d\n * @param {number} n\x0d\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\x0d\n * @returns {void}\x0d\n */\x0d\nEventEmitter.setMaxListeners =\x0d\n  function(n = defaultMaxListeners\x2C ...eventTargets) {\x0d\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\x0d\n      throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\x0d\n    if (eventTargets.length === 0) {\x0d\n      defaultMaxListeners = n;\x0d\n    } else {\x0d\n      if (isEventTarget === undefined)\x0d\n        isEventTarget = require('internal/event_target').isEventTarget;\x0d\n\x0d\n      for (let i = 0; i < eventTargets.length; i++) {\x0d\n        const target = eventTargets[i];\x0d\n        if (isEventTarget(target)) {\x0d\n          target[kMaxEventTargetListeners] = n;\x0d\n          target[kMaxEventTargetListenersWarned] = false;\x0d\n        } else if (typeof target.setMaxListeners === 'function') {\x0d\n          target.setMaxListeners(n);\x0d\n        } else {\x0d\n          throw new ERR_INVALID_ARG_TYPE(\x0d\n            'eventTargets'\x2C\x0d\n            ['EventEmitter'\x2C 'EventTarget']\x2C\x0d\n            target);\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n  };\x0d\n\x0d\nEventEmitter.init = function(opts) {\x0d\n\x0d\n  if (this._events === undefined ||\x0d\n      this._events === ObjectGetPrototypeOf(this)._events) {\x0d\n    this._events = ObjectCreate(null);\x0d\n    this._eventsCount = 0;\x0d\n  }\x0d\n\x0d\n  this._maxListeners = this._maxListeners || undefined;\x0d\n\x0d\n\x0d\n  if (opts?.captureRejections) {\x0d\n    validateBoolean(opts.captureRejections\x2C 'options.captureRejections');\x0d\n    this[kCapture] = Boolean(opts.captureRejections);\x0d\n  } else {\x0d\n    // Assigning the kCapture property directly saves an expensive\x0d\n    // prototype lookup in a very sensitive hot path.\x0d\n    this[kCapture] = EventEmitter.prototype[kCapture];\x0d\n  }\x0d\n};\x0d\n\x0d\nfunction addCatch(that\x2C promise\x2C type\x2C args) {\x0d\n  if (!that[kCapture]) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  // Handle Promises/A+ spec\x2C then could be a getter\x0d\n  // that throws on second use.\x0d\n  try {\x0d\n    const then = promise.then;\x0d\n\x0d\n    if (typeof then === 'function') {\x0d\n      then.call(promise\x2C undefined\x2C function(err) {\x0d\n        // The callback is called with nextTick to avoid a follow-up\x0d\n        // rejection from this promise.\x0d\n        process.nextTick(emitUnhandledRejectionOrErr\x2C that\x2C err\x2C type\x2C args);\x0d\n      });\x0d\n    }\x0d\n  } catch (err) {\x0d\n    that.emit('error'\x2C err);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction emitUnhandledRejectionOrErr(ee\x2C err\x2C type\x2C args) {\x0d\n  if (typeof ee[kRejection] === 'function') {\x0d\n    ee[kRejection](err\x2C type\x2C ...args);\x0d\n  } else {\x0d\n    // We have to disable the capture rejections mechanism\x2C otherwise\x0d\n    // we might end up in an infinite loop.\x0d\n    const prev = ee[kCapture];\x0d\n\x0d\n    // If the error handler throws\x2C it is not catchable and it\x0d\n    // will end up in 'uncaughtException'. We restore the previous\x0d\n    // value of kCapture in case the uncaughtException is present\x0d\n    // and the exception is handled.\x0d\n    try {\x0d\n      ee[kCapture] = false;\x0d\n      ee.emit('error'\x2C err);\x0d\n    } finally {\x0d\n      ee[kCapture] = prev;\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\n/**\x0d\n * Increases the max listeners of the event emitter.\x0d\n * @param {number} n\x0d\n * @returns {EventEmitter}\x0d\n */\x0d\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\x0d\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\x0d\n    throw new ERR_OUT_OF_RANGE('n'\x2C 'a non-negative number'\x2C n);\x0d\n  }\x0d\n  this._maxListeners = n;\x0d\n  return this;\x0d\n};\x0d\n\x0d\nfunction _getMaxListeners(that) {\x0d\n  if (that._maxListeners === undefined)\x0d\n    return EventEmitter.defaultMaxListeners;\x0d\n  return that._maxListeners;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Returns the current max listener value for the event emitter.\x0d\n * @returns {number}\x0d\n */\x0d\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\x0d\n  return _getMaxListeners(this);\x0d\n};\x0d\n\x0d\n// Returns the length and line number of the first sequence of `a` that fully\x0d\n// appears in `b` with a length of at least 4.\x0d\nfunction identicalSequenceRange(a\x2C b) {\x0d\n  for (let i = 0; i < a.length - 3; i++) {\x0d\n    // Find the first entry of b that matches the current entry of a.\x0d\n    const pos = ArrayPrototypeIndexOf(b\x2C a[i]);\x0d\n    if (pos !== -1) {\x0d\n      const rest = b.length - pos;\x0d\n      if (rest > 3) {\x0d\n        let len = 1;\x0d\n        const maxLen = MathMin(a.length - i\x2C rest);\x0d\n        // Count the number of consecutive entries.\x0d\n        while (maxLen > len && a[i + len] === b[pos + len]) {\x0d\n          len++;\x0d\n        }\x0d\n        if (len > 3) {\x0d\n          return [len\x2C i];\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return [0\x2C 0];\x0d\n}\x0d\n\x0d\nfunction enhanceStackTrace(err\x2C own) {\x0d\n  let ctorInfo = '';\x0d\n  try {\x0d\n    const { name } = this.constructor;\x0d\n    if (name !== 'EventEmitter')\x0d\n      ctorInfo = ` on ${name} instance`;\x0d\n  } catch {}\x0d\n  const sep = `\\nEmitted 'error' event${ctorInfo} at:\\n`;\x0d\n\x0d\n  const errStack = ArrayPrototypeSlice(\x0d\n    StringPrototypeSplit(err.stack\x2C '\\n')\x2C 1);\x0d\n  const ownStack = ArrayPrototypeSlice(\x0d\n    StringPrototypeSplit(own.stack\x2C '\\n')\x2C 1);\x0d\n\x0d\n  const { 0: len\x2C 1: off } = identicalSequenceRange(ownStack\x2C errStack);\x0d\n  if (len > 0) {\x0d\n    ArrayPrototypeSplice(ownStack\x2C off + 1\x2C len - 2\x2C\x0d\n                         '    [... lines matching original stack trace ...]');\x0d\n  }\x0d\n\x0d\n  return err.stack + sep + ArrayPrototypeJoin(ownStack\x2C '\\n');\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously calls each of the listeners registered\x0d\n * for the event.\x0d\n * @param {string | symbol} type\x0d\n * @param {...any} [args]\x0d\n * @returns {boolean}\x0d\n */\x0d\nEventEmitter.prototype.emit = function emit(type\x2C ...args) {\x0d\n  let doError = (type === 'error');\x0d\n\x0d\n  const events = this._events;\x0d\n  if (events !== undefined) {\x0d\n    if (doError && events[kErrorMonitor] !== undefined)\x0d\n      this.emit(kErrorMonitor\x2C ...args);\x0d\n    doError = (doError && events.error === undefined);\x0d\n  } else if (!doError)\x0d\n    return false;\x0d\n\x0d\n  // If there is no 'error' event listener then throw.\x0d\n  if (doError) {\x0d\n    let er;\x0d\n    if (args.length > 0)\x0d\n      er = args[0];\x0d\n    if (er instanceof Error) {\x0d\n      try {\x0d\n        const capture = {};\x0d\n        ErrorCaptureStackTrace(capture\x2C EventEmitter.prototype.emit);\x0d\n        ObjectDefineProperty(er\x2C kEnhanceStackBeforeInspector\x2C {\x0d\n          value: FunctionPrototypeBind(enhanceStackTrace\x2C this\x2C er\x2C capture)\x2C\x0d\n          configurable: true\x0d\n        });\x0d\n      } catch {}\x0d\n\x0d\n      // Note: The comments on the `throw` lines are intentional\x2C they show\x0d\n      // up in Node's output if this results in an unhandled exception.\x0d\n      throw er; // Unhandled 'error' event\x0d\n    }\x0d\n\x0d\n    let stringifiedEr;\x0d\n    try {\x0d\n      stringifiedEr = inspect(er);\x0d\n    } catch {\x0d\n      stringifiedEr = er;\x0d\n    }\x0d\n\x0d\n    // At least give some kind of context to the user\x0d\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\x0d\n    err.context = er;\x0d\n    throw err; // Unhandled 'error' event\x0d\n  }\x0d\n\x0d\n  const handler = events[type];\x0d\n\x0d\n  if (handler === undefined)\x0d\n    return false;\x0d\n\x0d\n  if (typeof handler === 'function') {\x0d\n    const result = handler.apply(this\x2C args);\x0d\n\x0d\n    // We check if result is undefined first because that\x0d\n    // is the most common case so we do not pay any perf\x0d\n    // penalty\x0d\n    if (result !== undefined && result !== null) {\x0d\n      addCatch(this\x2C result\x2C type\x2C args);\x0d\n    }\x0d\n  } else {\x0d\n    const len = handler.length;\x0d\n    const listeners = arrayClone(handler);\x0d\n    for (let i = 0; i < len; ++i) {\x0d\n      const result = listeners[i].apply(this\x2C args);\x0d\n\x0d\n      // We check if result is undefined first because that\x0d\n      // is the most common case so we do not pay any perf\x0d\n      // penalty.\x0d\n      // This code is duplicated because extracting it away\x0d\n      // would make it non-inlineable.\x0d\n      if (result !== undefined && result !== null) {\x0d\n        addCatch(this\x2C result\x2C type\x2C args);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return true;\x0d\n};\x0d\n\x0d\nfunction _addListener(target\x2C type\x2C listener\x2C prepend) {\x0d\n  let m;\x0d\n  let events;\x0d\n  let existing;\x0d\n\x0d\n  checkListener(listener);\x0d\n\x0d\n  events = target._events;\x0d\n  if (events === undefined) {\x0d\n    events = target._events = ObjectCreate(null);\x0d\n    target._eventsCount = 0;\x0d\n  } else {\x0d\n    // To avoid recursion in the case that type === "newListener"! Before\x0d\n    // adding it to the listeners\x2C first emit "newListener".\x0d\n    if (events.newListener !== undefined) {\x0d\n      target.emit('newListener'\x2C type\x2C\x0d\n                  listener.listener ?? listener);\x0d\n\x0d\n      // Re-assign `events` because a newListener handler could have caused the\x0d\n      // this._events to be assigned to a new object\x0d\n      events = target._events;\x0d\n    }\x0d\n    existing = events[type];\x0d\n  }\x0d\n\x0d\n  if (existing === undefined) {\x0d\n    // Optimize the case of one listener. Don't need the extra array object.\x0d\n    events[type] = listener;\x0d\n    ++target._eventsCount;\x0d\n  } else {\x0d\n    if (typeof existing === 'function') {\x0d\n      // Adding the second element\x2C need to change to array.\x0d\n      existing = events[type] =\x0d\n        prepend ? [listener\x2C existing] : [existing\x2C listener];\x0d\n      // If we've already got an array\x2C just append.\x0d\n    } else if (prepend) {\x0d\n      existing.unshift(listener);\x0d\n    } else {\x0d\n      existing.push(listener);\x0d\n    }\x0d\n\x0d\n    // Check for listener leak\x0d\n    m = _getMaxListeners(target);\x0d\n    if (m > 0 && existing.length > m && !existing.warned) {\x0d\n      existing.warned = true;\x0d\n      // No error code for this since it is a Warning\x0d\n      // eslint-disable-next-line no-restricted-syntax\x0d\n      const w = new Error('Possible EventEmitter memory leak detected. ' +\x0d\n                          `${existing.length} ${String(type)} listeners ` +\x0d\n                          `added to ${inspect(target\x2C { depth: -1 })}. Use ` +\x0d\n                          'emitter.setMaxListeners() to increase limit');\x0d\n      w.name = 'MaxListenersExceededWarning';\x0d\n      w.emitter = target;\x0d\n      w.type = type;\x0d\n      w.count = existing.length;\x0d\n      process.emitWarning(w);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return target;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Adds a listener to the event emitter.\x0d\n * @param {string | symbol} type\x0d\n * @param {Function} listener\x0d\n * @returns {EventEmitter}\x0d\n */\x0d\nEventEmitter.prototype.addListener = function addListener(type\x2C listener) {\x0d\n  return _addListener(this\x2C type\x2C listener\x2C false);\x0d\n};\x0d\n\x0d\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\x0d\n\x0d\n/**\x0d\n * Adds the `listener` function to the beginning of\x0d\n * the listeners array.\x0d\n * @param {string | symbol} type\x0d\n * @param {Function} listener\x0d\n * @returns {EventEmitter}\x0d\n */\x0d\nEventEmitter.prototype.prependListener =\x0d\n    function prependListener(type\x2C listener) {\x0d\n      return _addListener(this\x2C type\x2C listener\x2C true);\x0d\n    };\x0d\n\x0d\nfunction onceWrapper() {\x0d\n  if (!this.fired) {\x0d\n    this.target.removeListener(this.type\x2C this.wrapFn);\x0d\n    this.fired = true;\x0d\n    if (arguments.length === 0)\x0d\n      return this.listener.call(this.target);\x0d\n    return this.listener.apply(this.target\x2C arguments);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction _onceWrap(target\x2C type\x2C listener) {\x0d\n  const state = { fired: false\x2C wrapFn: undefined\x2C target\x2C type\x2C listener };\x0d\n  const wrapped = onceWrapper.bind(state);\x0d\n  wrapped.listener = listener;\x0d\n  state.wrapFn = wrapped;\x0d\n  return wrapped;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Adds a one-time `listener` function to the event emitter.\x0d\n * @param {string | symbol} type\x0d\n * @param {Function} listener\x0d\n * @returns {EventEmitter}\x0d\n */\x0d\nEventEmitter.prototype.once = function once(type\x2C listener) {\x0d\n  checkListener(listener);\x0d\n\x0d\n  this.on(type\x2C _onceWrap(this\x2C type\x2C listener));\x0d\n  return this;\x0d\n};\x0d\n\x0d\n/**\x0d\n * Adds a one-time `listener` function to the beginning of\x0d\n * the listeners array.\x0d\n * @param {string | symbol} type\x0d\n * @param {Function} listener\x0d\n * @returns {EventEmitter}\x0d\n */\x0d\nEventEmitter.prototype.prependOnceListener =\x0d\n    function prependOnceListener(type\x2C listener) {\x0d\n      checkListener(listener);\x0d\n\x0d\n      this.prependListener(type\x2C _onceWrap(this\x2C type\x2C listener));\x0d\n      return this;\x0d\n    };\x0d\n\x0d\n/**\x0d\n * Removes the specified `listener` from the listeners array.\x0d\n * @param {string | symbol} type\x0d\n * @param {Function} listener\x0d\n * @returns {EventEmitter}\x0d\n */\x0d\nEventEmitter.prototype.removeListener =\x0d\n    function removeListener(type\x2C listener) {\x0d\n      checkListener(listener);\x0d\n\x0d\n      const events = this._events;\x0d\n      if (events === undefined)\x0d\n        return this;\x0d\n\x0d\n      const list = events[type];\x0d\n      if (list === undefined)\x0d\n        return this;\x0d\n\x0d\n      if (list === listener || list.listener === listener) {\x0d\n        if (--this._eventsCount === 0)\x0d\n          this._events = ObjectCreate(null);\x0d\n        else {\x0d\n          delete events[type];\x0d\n          if (events.removeListener)\x0d\n            this.emit('removeListener'\x2C type\x2C list.listener || listener);\x0d\n        }\x0d\n      } else if (typeof list !== 'function') {\x0d\n        let position = -1;\x0d\n\x0d\n        for (let i = list.length - 1; i >= 0; i--) {\x0d\n          if (list[i] === listener || list[i].listener === listener) {\x0d\n            position = i;\x0d\n            break;\x0d\n          }\x0d\n        }\x0d\n\x0d\n        if (position < 0)\x0d\n          return this;\x0d\n\x0d\n        if (position === 0)\x0d\n          list.shift();\x0d\n        else {\x0d\n          if (spliceOne === undefined)\x0d\n            spliceOne = require('internal/util').spliceOne;\x0d\n          spliceOne(list\x2C position);\x0d\n        }\x0d\n\x0d\n        if (list.length === 1)\x0d\n          events[type] = list[0];\x0d\n\x0d\n        if (events.removeListener !== undefined)\x0d\n          this.emit('removeListener'\x2C type\x2C listener);\x0d\n      }\x0d\n\x0d\n      return this;\x0d\n    };\x0d\n\x0d\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\x0d\n\x0d\n/**\x0d\n * Removes all listeners from the event emitter. (Only\x0d\n * removes listeners for a specific event name if specified\x0d\n * as `type`).\x0d\n * @param {string | symbol} [type]\x0d\n * @returns {EventEmitter}\x0d\n */\x0d\nEventEmitter.prototype.removeAllListeners =\x0d\n    function removeAllListeners(type) {\x0d\n      const events = this._events;\x0d\n      if (events === undefined)\x0d\n        return this;\x0d\n\x0d\n      // Not listening for removeListener\x2C no need to emit\x0d\n      if (events.removeListener === undefined) {\x0d\n        if (arguments.length === 0) {\x0d\n          this._events = ObjectCreate(null);\x0d\n          this._eventsCount = 0;\x0d\n        } else if (events[type] !== undefined) {\x0d\n          if (--this._eventsCount === 0)\x0d\n            this._events = ObjectCreate(null);\x0d\n          else\x0d\n            delete events[type];\x0d\n        }\x0d\n        return this;\x0d\n      }\x0d\n\x0d\n      // Emit removeListener for all listeners on all events\x0d\n      if (arguments.length === 0) {\x0d\n        for (const key of ReflectOwnKeys(events)) {\x0d\n          if (key === 'removeListener') continue;\x0d\n          this.removeAllListeners(key);\x0d\n        }\x0d\n        this.removeAllListeners('removeListener');\x0d\n        this._events = ObjectCreate(null);\x0d\n        this._eventsCount = 0;\x0d\n        return this;\x0d\n      }\x0d\n\x0d\n      const listeners = events[type];\x0d\n\x0d\n      if (typeof listeners === 'function') {\x0d\n        this.removeListener(type\x2C listeners);\x0d\n      } else if (listeners !== undefined) {\x0d\n        // LIFO order\x0d\n        for (let i = listeners.length - 1; i >= 0; i--) {\x0d\n          this.removeListener(type\x2C listeners[i]);\x0d\n        }\x0d\n      }\x0d\n\x0d\n      return this;\x0d\n    };\x0d\n\x0d\nfunction _listeners(target\x2C type\x2C unwrap) {\x0d\n  const events = target._events;\x0d\n\x0d\n  if (events === undefined)\x0d\n    return [];\x0d\n\x0d\n  const evlistener = events[type];\x0d\n  if (evlistener === undefined)\x0d\n    return [];\x0d\n\x0d\n  if (typeof evlistener === 'function')\x0d\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\x0d\n\x0d\n  return unwrap ?\x0d\n    unwrapListeners(evlistener) : arrayClone(evlistener);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Returns a copy of the array of listeners for the event name\x0d\n * specified as `type`.\x0d\n * @param {string | symbol} type\x0d\n * @returns {Function[]}\x0d\n */\x0d\nEventEmitter.prototype.listeners = function listeners(type) {\x0d\n  return _listeners(this\x2C type\x2C true);\x0d\n};\x0d\n\x0d\n/**\x0d\n * Returns a copy of the array of listeners and wrappers for\x0d\n * the event name specified as `type`.\x0d\n * @param {string | symbol} type\x0d\n * @returns {Function[]}\x0d\n */\x0d\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\x0d\n  return _listeners(this\x2C type\x2C false);\x0d\n};\x0d\n\x0d\n/**\x0d\n * Returns the number of listeners listening to the event name\x0d\n * specified as `type`.\x0d\n * @deprecated since v3.2.0\x0d\n * @param {EventEmitter} emitter\x0d\n * @param {string | symbol} type\x0d\n * @returns {number}\x0d\n */\x0d\nEventEmitter.listenerCount = function(emitter\x2C type) {\x0d\n  if (typeof emitter.listenerCount === 'function') {\x0d\n    return emitter.listenerCount(type);\x0d\n  }\x0d\n  return FunctionPrototypeCall(listenerCount\x2C emitter\x2C type);\x0d\n};\x0d\n\x0d\nEventEmitter.prototype.listenerCount = listenerCount;\x0d\n\x0d\n/**\x0d\n * Returns the number of listeners listening to event name\x0d\n * specified as `type`.\x0d\n * @param {string | symbol} type\x0d\n * @returns {number}\x0d\n */\x0d\nfunction listenerCount(type) {\x0d\n  const events = this._events;\x0d\n\x0d\n  if (events !== undefined) {\x0d\n    const evlistener = events[type];\x0d\n\x0d\n    if (typeof evlistener === 'function') {\x0d\n      return 1;\x0d\n    } else if (evlistener !== undefined) {\x0d\n      return evlistener.length;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return 0;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Returns an array listing the events for which\x0d\n * the emitter has registered listeners.\x0d\n * @returns {any[]}\x0d\n */\x0d\nEventEmitter.prototype.eventNames = function eventNames() {\x0d\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\x0d\n};\x0d\n\x0d\nfunction arrayClone(arr) {\x0d\n  // At least since V8 8.3\x2C this implementation is faster than the previous\x0d\n  // which always used a simple for-loop\x0d\n  switch (arr.length) {\x0d\n    case 2: return [arr[0]\x2C arr[1]];\x0d\n    case 3: return [arr[0]\x2C arr[1]\x2C arr[2]];\x0d\n    case 4: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]];\x0d\n    case 5: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]];\x0d\n    case 6: return [arr[0]\x2C arr[1]\x2C arr[2]\x2C arr[3]\x2C arr[4]\x2C arr[5]];\x0d\n  }\x0d\n  return ArrayPrototypeSlice(arr);\x0d\n}\x0d\n\x0d\nfunction unwrapListeners(arr) {\x0d\n  const ret = arrayClone(arr);\x0d\n  for (let i = 0; i < ret.length; ++i) {\x0d\n    const orig = ret[i].listener;\x0d\n    if (typeof orig === 'function')\x0d\n      ret[i] = orig;\x0d\n  }\x0d\n  return ret;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Returns a copy of the array of listeners for the event name\x0d\n * specified as `type`.\x0d\n * @param {EventEmitter | EventTarget} emitterOrTarget\x0d\n * @param {string | symbol} type\x0d\n * @returns {Function[]}\x0d\n */\x0d\nfunction getEventListeners(emitterOrTarget\x2C type) {\x0d\n  // First check if EventEmitter\x0d\n  if (typeof emitterOrTarget.listeners === 'function') {\x0d\n    return emitterOrTarget.listeners(type);\x0d\n  }\x0d\n  // Require event target lazily to avoid always loading it\x0d\n  const { isEventTarget\x2C kEvents } = require('internal/event_target');\x0d\n  if (isEventTarget(emitterOrTarget)) {\x0d\n    const root = emitterOrTarget[kEvents].get(type);\x0d\n    const listeners = [];\x0d\n    let handler = root?.next;\x0d\n    while (handler?.listener !== undefined) {\x0d\n      const listener = handler.listener?.deref ?\x0d\n        handler.listener.deref() : handler.listener;\x0d\n      listeners.push(listener);\x0d\n      handler = handler.next;\x0d\n    }\x0d\n    return listeners;\x0d\n  }\x0d\n  throw new ERR_INVALID_ARG_TYPE('emitter'\x2C\x0d\n                                 ['EventEmitter'\x2C 'EventTarget']\x2C\x0d\n                                 emitterOrTarget);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Creates a `Promise` that is fulfilled when the emitter\x0d\n * emits the given event.\x0d\n * @param {EventEmitter} emitter\x0d\n * @param {string} name\x0d\n * @param {{ signal: AbortSignal; }} [options]\x0d\n * @returns {Promise}\x0d\n */\x0d\nasync function once(emitter\x2C name\x2C options = {}) {\x0d\n  const signal = options?.signal;\x0d\n  validateAbortSignal(signal\x2C 'options.signal');\x0d\n  if (signal?.aborted)\x0d\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\x0d\n  return new Promise((resolve\x2C reject) => {\x0d\n    const errorListener = (err) => {\x0d\n      emitter.removeListener(name\x2C resolver);\x0d\n      if (signal != null) {\x0d\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\x0d\n      }\x0d\n      reject(err);\x0d\n    };\x0d\n    const resolver = (...args) => {\x0d\n      if (typeof emitter.removeListener === 'function') {\x0d\n        emitter.removeListener('error'\x2C errorListener);\x0d\n      }\x0d\n      if (signal != null) {\x0d\n        eventTargetAgnosticRemoveListener(signal\x2C 'abort'\x2C abortListener);\x0d\n      }\x0d\n      resolve(args);\x0d\n    };\x0d\n    eventTargetAgnosticAddListener(emitter\x2C name\x2C resolver\x2C { once: true });\x0d\n    if (name !== 'error' && typeof emitter.once === 'function') {\x0d\n      emitter.once('error'\x2C errorListener);\x0d\n    }\x0d\n    function abortListener() {\x0d\n      eventTargetAgnosticRemoveListener(emitter\x2C name\x2C resolver);\x0d\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorListener);\x0d\n      reject(new AbortError(undefined\x2C { cause: signal?.reason }));\x0d\n    }\x0d\n    if (signal != null) {\x0d\n      eventTargetAgnosticAddListener(\x0d\n        signal\x2C 'abort'\x2C abortListener\x2C { once: true });\x0d\n    }\x0d\n  });\x0d\n}\x0d\n\x0d\nconst AsyncIteratorPrototype = ObjectGetPrototypeOf(\x0d\n  ObjectGetPrototypeOf(async function* () {}).prototype);\x0d\n\x0d\nfunction createIterResult(value\x2C done) {\x0d\n  return { value\x2C done };\x0d\n}\x0d\n\x0d\nfunction eventTargetAgnosticRemoveListener(emitter\x2C name\x2C listener\x2C flags) {\x0d\n  if (typeof emitter.removeListener === 'function') {\x0d\n    emitter.removeListener(name\x2C listener);\x0d\n  } else if (typeof emitter.removeEventListener === 'function') {\x0d\n    emitter.removeEventListener(name\x2C listener\x2C flags);\x0d\n  } else {\x0d\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction eventTargetAgnosticAddListener(emitter\x2C name\x2C listener\x2C flags) {\x0d\n  if (typeof emitter.on === 'function') {\x0d\n    if (flags?.once) {\x0d\n      emitter.once(name\x2C listener);\x0d\n    } else {\x0d\n      emitter.on(name\x2C listener);\x0d\n    }\x0d\n  } else if (typeof emitter.addEventListener === 'function') {\x0d\n    // EventTarget does not have `error` event semantics like Node\x0d\n    // EventEmitters\x2C we do not listen to `error` events here.\x0d\n    emitter.addEventListener(name\x2C (arg) => { listener(arg); }\x2C flags);\x0d\n  } else {\x0d\n    throw new ERR_INVALID_ARG_TYPE('emitter'\x2C 'EventEmitter'\x2C emitter);\x0d\n  }\x0d\n}\x0d\n\x0d\n/**\x0d\n * Returns an `AsyncIterator` that iterates `event` events.\x0d\n * @param {EventEmitter} emitter\x0d\n * @param {string | symbol} event\x0d\n * @param {{ signal: AbortSignal; }} [options]\x0d\n * @returns {AsyncIterator}\x0d\n */\x0d\nfunction on(emitter\x2C event\x2C options) {\x0d\n  const signal = options?.signal;\x0d\n  validateAbortSignal(signal\x2C 'options.signal');\x0d\n  if (signal?.aborted)\x0d\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\x0d\n\x0d\n  const unconsumedEvents = [];\x0d\n  const unconsumedPromises = [];\x0d\n  let error = null;\x0d\n  let finished = false;\x0d\n\x0d\n  const iterator = ObjectSetPrototypeOf({\x0d\n    next() {\x0d\n      // First\x2C we consume all unread events\x0d\n      const value = unconsumedEvents.shift();\x0d\n      if (value) {\x0d\n        return PromiseResolve(createIterResult(value\x2C false));\x0d\n      }\x0d\n\x0d\n      // Then we error\x2C if an error happened\x0d\n      // This happens one time if at all\x2C because after 'error'\x0d\n      // we stop listening\x0d\n      if (error) {\x0d\n        const p = PromiseReject(error);\x0d\n        // Only the first element errors\x0d\n        error = null;\x0d\n        return p;\x0d\n      }\x0d\n\x0d\n      // If the iterator is finished\x2C resolve to done\x0d\n      if (finished) {\x0d\n        return PromiseResolve(createIterResult(undefined\x2C true));\x0d\n      }\x0d\n\x0d\n      // Wait until an event happens\x0d\n      return new Promise(function(resolve\x2C reject) {\x0d\n        unconsumedPromises.push({ resolve\x2C reject });\x0d\n      });\x0d\n    }\x2C\x0d\n\x0d\n    return() {\x0d\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\x0d\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\x0d\n\x0d\n      if (signal) {\x0d\n        eventTargetAgnosticRemoveListener(\x0d\n          signal\x2C\x0d\n          'abort'\x2C\x0d\n          abortListener\x2C\x0d\n          { once: true });\x0d\n      }\x0d\n\x0d\n      finished = true;\x0d\n\x0d\n      for (const promise of unconsumedPromises) {\x0d\n        promise.resolve(createIterResult(undefined\x2C true));\x0d\n      }\x0d\n\x0d\n      return PromiseResolve(createIterResult(undefined\x2C true));\x0d\n    }\x2C\x0d\n\x0d\n    throw(err) {\x0d\n      if (!err || !(err instanceof Error)) {\x0d\n        throw new ERR_INVALID_ARG_TYPE('EventEmitter.AsyncIterator'\x2C\x0d\n                                       'Error'\x2C err);\x0d\n      }\x0d\n      error = err;\x0d\n      eventTargetAgnosticRemoveListener(emitter\x2C event\x2C eventHandler);\x0d\n      eventTargetAgnosticRemoveListener(emitter\x2C 'error'\x2C errorHandler);\x0d\n    }\x2C\x0d\n\x0d\n    [SymbolAsyncIterator]() {\x0d\n      return this;\x0d\n    }\x0d\n  }\x2C AsyncIteratorPrototype);\x0d\n\x0d\n  eventTargetAgnosticAddListener(emitter\x2C event\x2C eventHandler);\x0d\n  if (event !== 'error' && typeof emitter.on === 'function') {\x0d\n    emitter.on('error'\x2C errorHandler);\x0d\n  }\x0d\n\x0d\n  if (signal) {\x0d\n    eventTargetAgnosticAddListener(\x0d\n      signal\x2C\x0d\n      'abort'\x2C\x0d\n      abortListener\x2C\x0d\n      { once: true });\x0d\n  }\x0d\n\x0d\n  return iterator;\x0d\n\x0d\n  function abortListener() {\x0d\n    errorHandler(new AbortError(undefined\x2C { cause: signal?.reason }));\x0d\n  }\x0d\n\x0d\n  function eventHandler(...args) {\x0d\n    const promise = ArrayPrototypeShift(unconsumedPromises);\x0d\n    if (promise) {\x0d\n      promise.resolve(createIterResult(args\x2C false));\x0d\n    } else {\x0d\n      unconsumedEvents.push(args);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  function errorHandler(err) {\x0d\n    finished = true;\x0d\n\x0d\n    const toError = ArrayPrototypeShift(unconsumedPromises);\x0d\n\x0d\n    if (toError) {\x0d\n      toError.reject(err);\x0d\n    } else {\x0d\n      // The next time we call next()\x0d\n      error = err;\x0d\n    }\x0d\n\x0d\n    iterator.return();\x0d\n  }\x0d\n}\x0d\n
code-source-info,0x1abee81284e,23,18743,18817,C0O18765C14O18772C19O18814,,
code-creation,LazyCompile,10,181702,0x1abee814ebe,387,_addListener node:events:548:22,0x25ca272b500,~
code-source-info,0x1abee814ebe,23,16462,18537,C0O16505C2O16515C4O16530C6O16545C9O16545C13O16591C18O16603C20O16636C22O16662C27O16662C32O16660C39O16687C40O16707C46O16877C52O16920C60O16974C77O16920C82O17157C87O17178C89O17195C93O17213C97O17326C99O17339C103O17356C109O17365C115O17396C121O17503C129O17538C140O17549C149O17559C166O17572C175O17582C182O17527C193O17659C197O17690C202O17690C209O17739C214O17739C219O17801C222O17805C227O17836C228O17842C233O17858C240O17865C245O17882C251O17899C252O17915C256O18051C264O18149C278O18159C281O18159C295O18108C304O18226C307O18234C312O18226C327O18185C333O18265C339O18051C345O18349C347O18356C351O18396C353O18406C357O18423C359O18430C363O18464C367O18453C371O18479C374O18487C379O18487C384O18520C386O18534,,
code-creation,LazyCompile,10,181804,0x1abee8151f6,15,checkListener node:events:257:23,0x25ca272ae60,~
code-source-info,0x1abee8151f6,23,7863,7921,C0O7879C8O7879C14O7920,,
code-creation,LazyCompile,10,181845,0x1abee8152e6,30, node:internal/validators:236:42,0x147335fd3b0,~
code-source-info,0x1abee8152e6,15,7461,7580,C0O7483C6O7521C22O7527C27O7521C29O7579,,
code-creation,LazyCompile,10,181966,0x1abee815566,380,emit node:events:470:44,0x25ca272b440,~
code-source-info,0x1abee815566,23,14146,16436,C0O14146C8O14181C10O14187C14O14226C19O14238C21O14271C27O14293C29O14292C34O14335C41O14340C51O14335C56O14370C60O14399C68O14431C72O14450C73O14463C74O14525C78O14549C80O14567C86O14574C91O14586C92O14595C96O14605C98O14623C100O14612C108O14670C110O14683C120O14728C126O14738C132O14683C137O14754C145O14779C157O14829C174O14829C186O14754C197O15110C199O15110C200O15165C205O15198C211O15214C219O15212C220O15249C225O15350C232O15350C238O15395C240O15407C244O15418C246O15418C247O15482C249O15488C253O15501C255O15533C256O15546C257O15552C263O15617C268O15617C275O15776C281O15830C296O15830C303O15910C308O15941C311O15941C316O15980C318O15985C320O15985C325O16021C327O16030C332O16034C337O16034C344O16303C350O16359C365O16359C370O15994C375O15967C378O16421C379O16433,,
code-creation,LazyCompile,10,182103,0x1abee81590e,172,startListeningIfSignal node:internal/process/signal:22:32,0x1d4982bfe28,~
script-source,93,node:internal/process/signal,'use strict';\x0d\n\x0d\nconst {\x0d\n  FunctionPrototypeBind\x2C\x0d\n  SafeMap\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  errnoException\x2C\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst { signals } = internalBinding('constants').os;\x0d\n\x0d\nlet Signal;\x0d\nconst signalWraps = new SafeMap();\x0d\n\x0d\nfunction isSignal(event) {\x0d\n  return typeof event === 'string' && signals[event] !== undefined;\x0d\n}\x0d\n\x0d\n// Detect presence of a listener for the special signal types\x0d\nfunction startListeningIfSignal(type) {\x0d\n  if (isSignal(type) && !signalWraps.has(type)) {\x0d\n    if (Signal === undefined)\x0d\n      Signal = internalBinding('signal_wrap').Signal;\x0d\n    const wrap = new Signal();\x0d\n\x0d\n    wrap.unref();\x0d\n\x0d\n    wrap.onsignal = FunctionPrototypeBind(process.emit\x2C process\x2C type\x2C type);\x0d\n\x0d\n    const signum = signals[type];\x0d\n    const err = wrap.start(signum);\x0d\n    if (err) {\x0d\n      wrap.close();\x0d\n      throw errnoException(err\x2C 'uv_signal_start');\x0d\n    }\x0d\n\x0d\n    signalWraps.set(type\x2C wrap);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction stopListeningIfSignal(type) {\x0d\n  const wrap = signalWraps.get(type);\x0d\n  if (wrap !== undefined && process.listenerCount(type) === 0) {\x0d\n    wrap.close();\x0d\n    signalWraps.delete(type);\x0d\n  }\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  startListeningIfSignal\x2C\x0d\n  stopListeningIfSignal\x0d\n};\x0d\n
code-source-info,0x1abee81590e,93,450,944,C0O462C3O466C11O485C14O497C19O497C26O515C32O548C38O557C43O587C50O555C56O614C61O614C67O640C72O640C76O656C78O672C84O702C98O672C103O670C107O752C114O759C118O789C123O789C129O809C131O832C136O832C140O848C148O854C153O848C154O908C159O920C164O920C171O943,,
code-creation,LazyCompile,10,182242,0x1abee815cce,19,isSignal node:internal/process/signal:17:18,0x1d4982bfc70,~
code-source-info,0x1abee815cce,93,271,352,C0O284C8O320C13O327C17O335C18O349,,
code-creation,LazyCompile,10,182298,0x1abee815e6e,75,setupDebugEnv node:internal/bootstrap/pre_execution:184:23,0x1abee8033b8,~
code-source-info,0x1abee815e6e,96,5913,6128,C0O5921C6O5921C11O5954C19O5982C24O5986C29O5955C34O6002C42O6006C48O6051C54O6051C59O6088C64O6101C69O6102C74O6127,,
code-creation,LazyCompile,10,182391,0x1abee816206,159,initializeDebugEnv node:internal/util/debuglog:22:28,0x25ca2721528,~
script-source,22,node:internal/util/debuglog,'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  RegExp\x2C\x0d\n  RegExpPrototypeExec\x2C\x0d\n  SafeArrayIterator\x2C\x0d\n  StringPrototypeToLowerCase\x2C\x0d\n  StringPrototypeToUpperCase\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { inspect\x2C format\x2C formatWithOptions } = require('internal/util/inspect');\x0d\n\x0d\n// `debugImpls` and `testEnabled` are deliberately not initialized so any call\x0d\n// to `debuglog()` before `initializeDebugEnv()` is called will throw.\x0d\nlet debugImpls;\x0d\nlet testEnabled;\x0d\n\x0d\n\x0d\n// `debugEnv` is initial value of process.env.NODE_DEBUG\x0d\nfunction initializeDebugEnv(debugEnv) {\x0d\n  debugImpls = ObjectCreate(null);\x0d\n  if (debugEnv) {\x0d\n    // This is run before any user code\x2C it's OK not to use primordials.\x0d\n    debugEnv = debugEnv.replace(/[|\\\\{}()[\\]^$+?.]/g\x2C '\\\\$&')\x0d\n      .replaceAll('*'\x2C '.*')\x0d\n      .replaceAll('\x2C'\x2C '$|^');\x0d\n    const debugEnvRegex = new RegExp(`^${debugEnv}$`\x2C 'i');\x0d\n    testEnabled = (str) => RegExpPrototypeExec(debugEnvRegex\x2C str) !== null;\x0d\n  } else {\x0d\n    testEnabled = () => false;\x0d\n  }\x0d\n}\x0d\n\x0d\n// Emits warning when user sets\x0d\n// NODE_DEBUG=http or NODE_DEBUG=http2.\x0d\nfunction emitWarningIfNeeded(set) {\x0d\n  if ('HTTP' === set || 'HTTP2' === set) {\x0d\n    process.emitWarning('Setting the NODE_DEBUG environment variable ' +\x0d\n      'to \\'' + StringPrototypeToLowerCase(set) + '\\' can expose sensitive ' +\x0d\n      'data (such as passwords\x2C tokens and authentication headers) ' +\x0d\n      'in the resulting log.');\x0d\n  }\x0d\n}\x0d\n\x0d\nconst noop = () => {};\x0d\n\x0d\nfunction debuglogImpl(enabled\x2C set) {\x0d\n  if (debugImpls[set] === undefined) {\x0d\n    if (enabled) {\x0d\n      const pid = process.pid;\x0d\n      emitWarningIfNeeded(set);\x0d\n      debugImpls[set] = function debug(...args) {\x0d\n        const colors = process.stderr.hasColors && process.stderr.hasColors();\x0d\n        const msg = formatWithOptions({ colors }\x2C ...args);\x0d\n        const coloredPID = inspect(pid\x2C { colors });\x0d\n        process.stderr.write(format('%s %s: %s\\n'\x2C set\x2C coloredPID\x2C msg));\x0d\n      };\x0d\n    } else {\x0d\n      debugImpls[set] = noop;\x0d\n    }\x0d\n  }\x0d\n  return debugImpls[set];\x0d\n}\x0d\n\x0d\n// debuglogImpl depends on process.pid and process.env.NODE_DEBUG\x2C\x0d\n// so it needs to be called lazily in top scopes of internal modules\x0d\n// that may be loaded before these run time states are allowed to\x0d\n// be accessed.\x0d\nfunction debuglog(set\x2C cb) {\x0d\n  function init() {\x0d\n    set = StringPrototypeToUpperCase(set);\x0d\n    enabled = testEnabled(set);\x0d\n  }\x0d\n  let debug = (...args) => {\x0d\n    init();\x0d\n    // Only invokes debuglogImpl() when the debug function is\x0d\n    // called for the first time.\x0d\n    debug = debuglogImpl(enabled\x2C set);\x0d\n    if (typeof cb === 'function')\x0d\n      cb(debug);\x0d\n    switch (args.length) {\x0d\n      case 0: return debug();\x0d\n      case 1: return debug(args[0]);\x0d\n      case 2: return debug(args[0]\x2C args[1]);\x0d\n      default: return debug(...new SafeArrayIterator(args));\x0d\n    }\x0d\n  };\x0d\n  let enabled;\x0d\n  let test = () => {\x0d\n    init();\x0d\n    test = () => enabled;\x0d\n    return enabled;\x0d\n  };\x0d\n  const logger = (...args) => {\x0d\n    switch (args.length) {\x0d\n      case 0: return debug();\x0d\n      case 1: return debug(args[0]);\x0d\n      case 2: return debug(args[0]\x2C args[1]);\x0d\n      default: return debug(...new SafeArrayIterator(args));\x0d\n    }\x0d\n  };\x0d\n  ObjectDefineProperty(logger\x2C 'enabled'\x2C {\x0d\n    get() {\x0d\n      return test();\x0d\n    }\x2C\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x0d\n  });\x0d\n  return logger;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  debuglog\x2C\x0d\n  initializeDebugEnv\x0d\n};\x0d\n
code-source-info,0x1abee816206,22,567,1024,C0O583C7O596C14O594C20O619C31O734C44O734C51O779C62O780C69O809C80O810C88O861C100O876C116O861C121O861C123O900C132O912C144O990C151O1002C158O1023,,
new,MemoryChunk,0x29be72c0000,262144
code-creation,Function,11,182676,0x29be72c3080,588,getOptionValue node:internal/options:39:24,0x1abee805690,^
code-source-info,0x29be72c3080,97,940,1190,,,
code-creation,Function,11,182707,0x29be72c3380,224,isPathSeparator node:path:52:25,0x394c9e0cf90,^
code-source-info,0x29be72c3380,41,1794,1876,,,
code-creation,Function,11,182761,0x29be72c3500,3188,normalizeString node:path:66:25,0x394c9e0d458,^
code-source-info,0x29be72c3500,41,2226,4212,,,
code-creation,LazyCompile,10,182820,0x1abee816b16,49,setupStacktracePrinterOnSigint node:internal/bootstrap/pre_execution:163:40,0x1abee8032f0,~
code-source-info,0x1abee816b16,96,5456,5650,C0O5464C8O5469C14O5510C15O5517C16O5553C22O5553C27O5534C32O5605C38O5639C43O5639C48O5649,,
code-creation,LazyCompile,10,182887,0x1abee816d86,62,initializeReport node:internal/bootstrap/pre_execution:173:26,0x1abee803340,~
code-source-info,0x1abee816d86,96,5679,5887,C0O5679C8O5706C16O5706C21O5695C27O5745C42O5766C47O5841C55O5745C61O5886,,
code-creation,Eval,10,183048,0x1abee817306,5, node:internal/process/report:1:1,0x1abee817100,~
script-source,99,node:internal/process/report,'use strict';\x0d\nconst {\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n  ERR_SYNTHETIC\x0d\n} = require('internal/errors').codes;\x0d\nconst {\x0d\n  validateBoolean\x2C\x0d\n  validateObject\x2C\x0d\n  validateSignalName\x2C\x0d\n  validateString\x2C\x0d\n} = require('internal/validators');\x0d\nconst nr = internalBinding('report');\x0d\nconst {\x0d\n  JSONParse\x2C\x0d\n} = primordials;\x0d\nconst report = {\x0d\n  writeReport(file\x2C err) {\x0d\n    if (typeof file === 'object' && file !== null) {\x0d\n      err = file;\x0d\n      file = undefined;\x0d\n    } else if (file !== undefined && typeof file !== 'string') {\x0d\n      throw new ERR_INVALID_ARG_TYPE('file'\x2C 'String'\x2C file);\x0d\n    } else if (err === undefined) {\x0d\n      err = new ERR_SYNTHETIC();\x0d\n    } else {\x0d\n      validateObject(err\x2C 'err');\x0d\n    }\x0d\n\x0d\n    return nr.writeReport('JavaScript API'\x2C 'API'\x2C file\x2C err);\x0d\n  }\x2C\x0d\n  getReport(err) {\x0d\n    if (err === undefined)\x0d\n      err = new ERR_SYNTHETIC();\x0d\n    else\x0d\n      validateObject(err\x2C 'err');\x0d\n\x0d\n    return JSONParse(nr.getReport(err));\x0d\n  }\x2C\x0d\n  get directory() {\x0d\n    return nr.getDirectory();\x0d\n  }\x2C\x0d\n  set directory(dir) {\x0d\n    validateString(dir\x2C 'directory');\x0d\n    nr.setDirectory(dir);\x0d\n  }\x2C\x0d\n  get filename() {\x0d\n    return nr.getFilename();\x0d\n  }\x2C\x0d\n  set filename(name) {\x0d\n    validateString(name\x2C 'filename');\x0d\n    nr.setFilename(name);\x0d\n  }\x2C\x0d\n  get compact() {\x0d\n    return nr.getCompact();\x0d\n  }\x2C\x0d\n  set compact(b) {\x0d\n    validateBoolean(b\x2C 'compact');\x0d\n    nr.setCompact(b);\x0d\n  }\x2C\x0d\n  get signal() {\x0d\n    return nr.getSignal();\x0d\n  }\x2C\x0d\n  set signal(sig) {\x0d\n    validateSignalName(sig\x2C 'signal');\x0d\n    removeSignalHandler();\x0d\n    addSignalHandler(sig);\x0d\n    nr.setSignal(sig);\x0d\n  }\x2C\x0d\n  get reportOnFatalError() {\x0d\n    return nr.shouldReportOnFatalError();\x0d\n  }\x2C\x0d\n  set reportOnFatalError(trigger) {\x0d\n    validateBoolean(trigger\x2C 'trigger');\x0d\n\x0d\n    nr.setReportOnFatalError(trigger);\x0d\n  }\x2C\x0d\n  get reportOnSignal() {\x0d\n    return nr.shouldReportOnSignal();\x0d\n  }\x2C\x0d\n  set reportOnSignal(trigger) {\x0d\n    validateBoolean(trigger\x2C 'trigger');\x0d\n\x0d\n    nr.setReportOnSignal(trigger);\x0d\n    removeSignalHandler();\x0d\n    addSignalHandler();\x0d\n  }\x2C\x0d\n  get reportOnUncaughtException() {\x0d\n    return nr.shouldReportOnUncaughtException();\x0d\n  }\x2C\x0d\n  set reportOnUncaughtException(trigger) {\x0d\n    validateBoolean(trigger\x2C 'trigger');\x0d\n\x0d\n    nr.setReportOnUncaughtException(trigger);\x0d\n  }\x0d\n};\x0d\n\x0d\nfunction addSignalHandler(sig) {\x0d\n  if (nr.shouldReportOnSignal()) {\x0d\n    if (typeof sig !== 'string')\x0d\n      sig = nr.getSignal();\x0d\n\x0d\n    process.on(sig\x2C signalHandler);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction removeSignalHandler() {\x0d\n  const sig = nr.getSignal();\x0d\n\x0d\n  if (sig)\x0d\n    process.removeListener(sig\x2C signalHandler);\x0d\n}\x0d\n\x0d\nfunction signalHandler(sig) {\x0d\n  nr.writeReport(sig\x2C 'Signal'\x2C null\x2C '');\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  addSignalHandler\x2C\x0d\n  report\x0d\n};\x0d\n
code-source-info,0x1abee817306,99,0,2743,C0O0C4O2743,,
code-creation,Function,10,183222,0x1abee817e1e,315, node:internal/process/report:1:1,0x1abee817280,~
code-source-info,0x1abee817e1e,99,0,2743,C0O0C51O70C54O70C59O96C64O26C70O51C76O199C79O199C84O116C90O136C96O155C102O178C108O243C111O243C115O243C117O282C123O327C128O332C136O786C290O2688C297O2710C303O2731C309O2703C314O2742,,
code-creation,LazyCompile,10,183398,0x1abee819afe,21,initializeReportSignalHandlers node:internal/bootstrap/pre_execution:192:40,0x1abee803408,~
code-source-info,0x1abee819afe,96,6232,6332,C0O6269C6O6269C11O6248C16O6310C20O6331,,
code-creation,LazyCompile,10,183465,0x1abee819c46,57,addSignalHandler node:internal/process/report:97:26,0x1abee817338,~
code-source-info,0x1abee819c46,99,2318,2471,C0O2329C5O2336C10O2336C16O2367C22O2403C27O2412C32O2412C38O2432C41O2440C49O2440C56O2470,,
code-creation,LazyCompile,10,183527,0x1abee81a206,92,initializeHeapSnapshotSignalHandlers node:internal/bootstrap/pre_execution:198:46,0x1abee803458,~
code-source-info,0x1abee81a206,96,6381,6655,C0O6381C8O6404C18O6404C23O6450C25O6468C26O6475C27O6481C35O6481C40O6511C45O6512C50O6573C58O6573C63O6551C69O6593C74O6601C79O6604C84O6601C91O6654,,
code-creation,LazyCompile,10,183600,0x1abee81a496,138,setupChildProcessIpcChannel node:internal/bootstrap/pre_execution:328:37,0x1abee803628,~
code-source-info,0x1abee81a496,96,10525,11071,C0O10533C3O10545C8O10549C14O10588C20O10588C25O10634C33O10657C38O10661C46O10634C52O10688C53O10698C57O10688C61O10782C64O10797C73O10858C76O10866C81O10870C90O10918C93O10933C102O10977C108O10977C113O11001C118O11002C124O11042C127O11057C132O11042C137O11070,,
code-creation,LazyCompile,10,183737,0x1abee81a88e,455,initializePolicy node:internal/bootstrap/pre_execution:356:26,0x1abee8036c8,~
code-source-info,0x1abee81a88e,96,11381,13226,C0O11416C10O11416C15O11460C17O11491C21O11499C35O11499C41O11626C49O11626C55O11603C60O11618C65O11748C67O11766C75O11770C81O11785C87O11786C94O11827C100O11859C108O11841C116O11918C120O11940C126O11940C132O11918C138O11955C149O11971C153O11986C161O12000C167O12060C175O12060C180O12095C190O12095C197O12171C207O12171C212O12214C214O12268C222O12268C227O12347C235O12347C241O12315C246O12327C251O12397C257O12397C263O12448C269O12448C275O12508C277O12535C279O12559C283O12540C288O12653C290O12669C295O12602C300O12631C305O12696C311O12733C317O12733C322O12775C328O12775C334O12805C340O12825C344O12812C349O12846C356O12894C358O12924C360O12967C366O12989C376O12989C383O12967C389O12568C394O12522C397O13026C401O13054C415O13060C420O13054C421O13146C429O13146C435O13188C441O13212C447O13189C454O13225,,
code-creation,LazyCompile,10,183856,0x1abee81ac7e,63,initializeClusterIPC node:internal/bootstrap/pre_execution:347:30,0x1abee803678,~
code-source-info,0x1abee81ac7e,96,11104,11352,C0O11112C3O11124C10O11128C18O11143C23O11147C29O11186C35O11186C40O11219C45O11219C49O11310C52O11325C62O11351,,
code-creation,LazyCompile,10,183914,0x1abee81adee,27,initializeSourceMapsHandlers node:internal/bootstrap/pre_execution:451:38,0x1abee803808,~
code-source-info,0x1abee81adee,96,15007,15160,C0O15053C6O15053C11O15023C16O15105C21O15134C26O15159,,
code-creation,Eval,10,184157,0x1abee81b7f6,5, node:internal/source_map/source_map_cache:1:1,0x1abee81b490,~
script-source,100,node:internal/source_map/source_map_cache,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeMap\x2C\x0d\n  JSONParse\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ObjectGetOwnPropertyDescriptor\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeMap\x2C\x0d\n  StringPrototypeMatch\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n} = primordials;\x0d\n\x0d\nfunction ObjectGetValueSafe(obj\x2C key) {\x0d\n  const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\x0d\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'value') ? desc.value : undefined;\x0d\n}\x0d\n\x0d\n// See https://sourcemaps.info/spec.html for SourceMap V3 specification.\x0d\nconst { Buffer } = require('buffer');\x0d\nlet debug = require('internal/util/debuglog').debuglog('source_map'\x2C (fn) => {\x0d\n  debug = fn;\x0d\n});\x0d\nconst fs = require('fs');\x0d\nconst { getOptionValue } = require('internal/options');\x0d\nconst { IterableWeakMap } = require('internal/util/iterable_weak_map');\x0d\nconst {\x0d\n  normalizeReferrerURL\x2C\x0d\n} = require('internal/modules/cjs/helpers');\x0d\nconst { validateBoolean } = require('internal/validators');\x0d\n// Since the CJS module cache is mutable\x2C which leads to memory leaks when\x0d\n// modules are deleted\x2C we use a WeakMap so that the source map cache will\x0d\n// be purged automatically:\x0d\nconst cjsSourceMapCache = new IterableWeakMap();\x0d\n// The esm cache is not mutable\x2C so we can use a Map without memory concerns:\x0d\nconst esmSourceMapCache = new SafeMap();\x0d\nconst { fileURLToPath\x2C pathToFileURL\x2C URL } = require('internal/url');\x0d\nlet SourceMap;\x0d\n\x0d\nlet sourceMapsEnabled;\x0d\nfunction getSourceMapsEnabled() {\x0d\n  if (sourceMapsEnabled === undefined) {\x0d\n    setSourceMapsEnabled(getOptionValue('--enable-source-maps'));\x0d\n  }\x0d\n  return sourceMapsEnabled;\x0d\n}\x0d\n\x0d\nfunction setSourceMapsEnabled(val) {\x0d\n  validateBoolean(val\x2C 'val');\x0d\n\x0d\n  const {\x0d\n    setSourceMapsEnabled\x2C\x0d\n    setPrepareStackTraceCallback\x0d\n  } = internalBinding('errors');\x0d\n  setSourceMapsEnabled(val);\x0d\n  if (val) {\x0d\n    const {\x0d\n      prepareStackTrace\x0d\n    } = require('internal/source_map/prepare_stack_trace');\x0d\n    setPrepareStackTraceCallback(prepareStackTrace);\x0d\n  } else if (sourceMapsEnabled !== undefined) {\x0d\n    // Reset prepare stack trace callback only when disabling source maps.\x0d\n    const {\x0d\n      prepareStackTrace\x2C\x0d\n    } = require('internal/errors');\x0d\n    setPrepareStackTraceCallback(prepareStackTrace);\x0d\n  }\x0d\n\x0d\n  sourceMapsEnabled = val;\x0d\n}\x0d\n\x0d\nfunction maybeCacheSourceMap(filename\x2C content\x2C cjsModuleInstance) {\x0d\n  const sourceMapsEnabled = getSourceMapsEnabled();\x0d\n  if (!(process.env.NODE_V8_COVERAGE || sourceMapsEnabled)) return;\x0d\n  try {\x0d\n    filename = normalizeReferrerURL(filename);\x0d\n  } catch (err) {\x0d\n    // This is most likely an [eval]-wrapper\x2C which is currently not\x0d\n    // supported.\x0d\n    debug(err.stack);\x0d\n    return;\x0d\n  }\x0d\n  const match = StringPrototypeMatch(\x0d\n    content\x2C\x0d\n    /\\/[*/]#\\s+sourceMappingURL=(?<sourceMappingURL>[^\\s]+)/\x0d\n  );\x0d\n  if (match) {\x0d\n    const data = dataFromUrl(filename\x2C match.groups.sourceMappingURL);\x0d\n    const url = data ? null : match.groups.sourceMappingURL;\x0d\n    if (cjsModuleInstance) {\x0d\n      cjsSourceMapCache.set(cjsModuleInstance\x2C {\x0d\n        filename\x2C\x0d\n        lineLengths: lineLengths(content)\x2C\x0d\n        data\x2C\x0d\n        url\x0d\n      });\x0d\n    } else {\x0d\n      // If there is no cjsModuleInstance assume we are in a\x0d\n      // "modules/esm" context.\x0d\n      esmSourceMapCache.set(filename\x2C {\x0d\n        lineLengths: lineLengths(content)\x2C\x0d\n        data\x2C\x0d\n        url\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction dataFromUrl(sourceURL\x2C sourceMappingURL) {\x0d\n  try {\x0d\n    const url = new URL(sourceMappingURL);\x0d\n    switch (url.protocol) {\x0d\n      case 'data:':\x0d\n        return sourceMapFromDataUrl(sourceURL\x2C url.pathname);\x0d\n      default:\x0d\n        debug(`unknown protocol ${url.protocol}`);\x0d\n        return null;\x0d\n    }\x0d\n  } catch (err) {\x0d\n    debug(err.stack);\x0d\n    // If no scheme is present\x2C we assume we are dealing with a file path.\x0d\n    const mapURL = new URL(sourceMappingURL\x2C sourceURL).href;\x0d\n    return sourceMapFromFile(mapURL);\x0d\n  }\x0d\n}\x0d\n\x0d\n// Cache the length of each line in the file that a source map was extracted\x0d\n// from. This allows translation from byte offset V8 coverage reports\x2C\x0d\n// to line/column offset Source Map V3.\x0d\nfunction lineLengths(content) {\x0d\n  // We purposefully keep \\r as part of the line-length calculation\x2C in\x0d\n  // cases where there is a \\r\\n separator\x2C so that this can be taken into\x0d\n  // account in coverage calculations.\x0d\n  return ArrayPrototypeMap(StringPrototypeSplit(content\x2C /\\n|\\u2028|\\u2029/)\x2C (line) => {\x0d\n    return line.length;\x0d\n  });\x0d\n}\x0d\n\x0d\nfunction sourceMapFromFile(mapURL) {\x0d\n  try {\x0d\n    const content = fs.readFileSync(fileURLToPath(mapURL)\x2C 'utf8');\x0d\n    const data = JSONParse(content);\x0d\n    return sourcesToAbsolute(mapURL\x2C data);\x0d\n  } catch (err) {\x0d\n    debug(err.stack);\x0d\n    return null;\x0d\n  }\x0d\n}\x0d\n\x0d\n// data:[<mediatype>][;base64]\x2C<data> see:\x0d\n// https://tools.ietf.org/html/rfc2397#section-2\x0d\nfunction sourceMapFromDataUrl(sourceURL\x2C url) {\x0d\n  const { 0: format\x2C 1: data } = StringPrototypeSplit(url\x2C '\x2C');\x0d\n  const splitFormat = StringPrototypeSplit(format\x2C ';');\x0d\n  const contentType = splitFormat[0];\x0d\n  const base64 = splitFormat[splitFormat.length - 1] === 'base64';\x0d\n  if (contentType === 'application/json') {\x0d\n    const decodedData = base64 ?\x0d\n      Buffer.from(data\x2C 'base64').toString('utf8') : data;\x0d\n    try {\x0d\n      const parsedData = JSONParse(decodedData);\x0d\n      return sourcesToAbsolute(sourceURL\x2C parsedData);\x0d\n    } catch (err) {\x0d\n      debug(err.stack);\x0d\n      return null;\x0d\n    }\x0d\n  } else {\x0d\n    debug(`unknown content-type ${contentType}`);\x0d\n    return null;\x0d\n  }\x0d\n}\x0d\n\x0d\n// If the sources are not absolute URLs after prepending of the "sourceRoot"\x2C\x0d\n// the sources are resolved relative to the SourceMap (like resolving script\x0d\n// src in a html document).\x0d\nfunction sourcesToAbsolute(baseURL\x2C data) {\x0d\n  data.sources = data.sources.map((source) => {\x0d\n    source = (data.sourceRoot || '') + source;\x0d\n    return new URL(source\x2C baseURL).href;\x0d\n  });\x0d\n  // The sources array is now resolved to absolute URLs\x2C sourceRoot should\x0d\n  // be updated to noop.\x0d\n  data.sourceRoot = '';\x0d\n  return data;\x0d\n}\x0d\n\x0d\n// WARNING: The `sourceMapCacheToObject` and `appendCJSCache` run during\x0d\n// shutdown. In particular\x2C they also run when Workers are terminated\x2C making\x0d\n// it important that they do not call out to any user-provided code\x2C including\x0d\n// built-in prototypes that might have been tampered with.\x0d\n\x0d\n// Get serialized representation of source-map cache\x2C this is used\x0d\n// to persist a cache of source-maps to disk when NODE_V8_COVERAGE is enabled.\x0d\nfunction sourceMapCacheToObject() {\x0d\n  const obj = ObjectCreate(null);\x0d\n\x0d\n  for (const { 0: k\x2C 1: v } of esmSourceMapCache) {\x0d\n    obj[k] = v;\x0d\n  }\x0d\n\x0d\n  appendCJSCache(obj);\x0d\n\x0d\n  if (ObjectKeys(obj).length === 0) {\x0d\n    return undefined;\x0d\n  }\x0d\n  return obj;\x0d\n}\x0d\n\x0d\nfunction appendCJSCache(obj) {\x0d\n  for (const value of cjsSourceMapCache) {\x0d\n    obj[ObjectGetValueSafe(value\x2C 'filename')] = {\x0d\n      lineLengths: ObjectGetValueSafe(value\x2C 'lineLengths')\x2C\x0d\n      data: ObjectGetValueSafe(value\x2C 'data')\x2C\x0d\n      url: ObjectGetValueSafe(value\x2C 'url')\x0d\n    };\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction findSourceMap(sourceURL) {\x0d\n  if (!RegExpPrototypeTest(/^\\w+:\\/\\//\x2C sourceURL)) {\x0d\n    sourceURL = pathToFileURL(sourceURL).href;\x0d\n  }\x0d\n  if (!SourceMap) {\x0d\n    SourceMap = require('internal/source_map/source_map').SourceMap;\x0d\n  }\x0d\n  let sourceMap = esmSourceMapCache.get(sourceURL);\x0d\n  if (sourceMap === undefined) {\x0d\n    for (const value of cjsSourceMapCache) {\x0d\n      const filename = ObjectGetValueSafe(value\x2C 'filename');\x0d\n      if (sourceURL === filename) {\x0d\n        sourceMap = {\x0d\n          data: ObjectGetValueSafe(value\x2C 'data')\x0d\n        };\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n  if (sourceMap && sourceMap.data) {\x0d\n    return new SourceMap(sourceMap.data);\x0d\n  }\x0d\n  return undefined;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  findSourceMap\x2C\x0d\n  getSourceMapsEnabled\x2C\x0d\n  setSourceMapsEnabled\x2C\x0d\n  maybeCacheSourceMap\x2C\x0d\n  sourceMapCacheToObject\x2C\x0d\n};\x0d\n
code-source-info,0x1abee81b7f6,100,0,7905,C0O0C4O7905,,
code-creation,Function,10,184557,0x1abee81be6e,435, node:internal/source_map/source_map_cache:1:1,0x1abee81b770,~
code-source-info,0x1abee81be6e,100,0,7905,C0O0C152O28C158O50C164O64C170O81C176O96C182O131C188O165C194O189C199O201C205O226C211O547C217O547C222O536C228O579C234O579C239O612C252O613C258O579C260O678C266O678C270O678C272O721C278O721C283O702C289O779C295O779C300O759C305O862C311O862C316O835C322O932C328O932C333O912C339O1172C341O1172C346O1172C348O1301C350O1301C355O1301C357O1363C363O1363C368O1325C374O1340C380O1355C386O1393C387O1393C389O1411C390O1411C392O7762C399O7784C405O7802C411O7827C417O7852C423O7876C429O7777C434O7904,,
code-creation,LazyCompile,10,184735,0x1abee81cc56,82,debuglog node:internal/util/debuglog:71:18,0x25ca2721878,~
code-source-info,0x1abee81cc56,22,2302,3390,C0O2302C28O2432C32O2432C34O2878C35O2878C37O2901C41O2901C43O2994C48O3231C58O3252C63O3278C74O3231C79O3373C81O3387,,
code-creation,Eval,10,184896,0x1abee81d1d6,5, node:internal/util/iterable_weak_map:1:1,0x1abee81cf88,~
script-source,101,node:internal/util/iterable_weak_map,'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectFreeze\x2C\x0d\n  SafeFinalizationRegistry\x2C\x0d\n  SafeSet\x2C\x0d\n  SafeWeakMap\x2C\x0d\n  SafeWeakRef\x2C\x0d\n  SymbolIterator\x2C\x0d\n} = primordials;\x0d\n\x0d\n// This class is modified from the example code in the WeakRefs specification:\x0d\n// https://github.com/tc39/proposal-weakrefs\x0d\n// Licensed under ECMA's MIT-style license\x2C see:\x0d\n// https://github.com/tc39/ecma262/blob/HEAD/LICENSE.md\x0d\nclass IterableWeakMap {\x0d\n  #weakMap = new SafeWeakMap();\x0d\n  #refSet = new SafeSet();\x0d\n  #finalizationGroup = new SafeFinalizationRegistry(cleanup);\x0d\n\x0d\n  set(key\x2C value) {\x0d\n    const entry = this.#weakMap.get(key);\x0d\n    if (entry) {\x0d\n      // If there's already an entry for the object represented by "key"\x2C\x0d\n      // the value can be updated without creating a new WeakRef:\x0d\n      this.#weakMap.set(key\x2C { value\x2C ref: entry.ref });\x0d\n    } else {\x0d\n      const ref = new SafeWeakRef(key);\x0d\n      this.#weakMap.set(key\x2C { value\x2C ref });\x0d\n      this.#refSet.add(ref);\x0d\n      this.#finalizationGroup.register(key\x2C {\x0d\n        set: this.#refSet\x2C\x0d\n        ref\x0d\n      }\x2C ref);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  get(key) {\x0d\n    return this.#weakMap.get(key)?.value;\x0d\n  }\x0d\n\x0d\n  has(key) {\x0d\n    return this.#weakMap.has(key);\x0d\n  }\x0d\n\x0d\n  delete(key) {\x0d\n    const entry = this.#weakMap.get(key);\x0d\n    if (!entry) {\x0d\n      return false;\x0d\n    }\x0d\n    this.#weakMap.delete(key);\x0d\n    this.#refSet.delete(entry.ref);\x0d\n    this.#finalizationGroup.unregister(entry.ref);\x0d\n    return true;\x0d\n  }\x0d\n\x0d\n  [SymbolIterator]() {\x0d\n    const iterator = this.#refSet[SymbolIterator]();\x0d\n\x0d\n    const next = () => {\x0d\n      const result = iterator.next();\x0d\n      if (result.done) return result;\x0d\n      const key = result.value.deref();\x0d\n      if (key == null) return next();\x0d\n      const { value } = this.#weakMap.get(key);\x0d\n      return { done: false\x2C value };\x0d\n    };\x0d\n\x0d\n    return {\x0d\n      [SymbolIterator]() { return this; }\x2C\x0d\n      next\x2C\x0d\n    };\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction cleanup({ set\x2C ref }) {\x0d\n  set.delete(ref);\x0d\n}\x0d\n\x0d\nObjectFreeze(IterableWeakMap.prototype);\x0d\n\x0d\nmodule.exports = {\x0d\n  IterableWeakMap\x2C\x0d\n};\x0d\n
code-source-info,0x1abee81d1d6,101,0,2042,C0O0C4O2042,,
code-creation,Function,10,185031,0x1abee81d936,196, node:internal/util/iterable_weak_map:1:1,0x1abee81d150,~
code-source-info,0x1abee81d936,101,0,2042,C0O0C26O28C31O45C37O74C43O86C49O102C55O118C134O1448C168O1983C173O1954C177O1998C184O2020C190O2013C195O2041,,
code-creation,Function,10,185062,0x1abee81dab6,75,<instance_members_initializer> node:internal/util/iterable_weak_map:17:3,0x1abee81d460,~
code-source-info,0x1abee81dab6,101,415,534,C3O426C10O426C27O458C34O458C48O497C62O497C74O534,,
code-creation,Eval,10,185343,0x1abee81e7be,5, node:internal/modules/cjs/helpers:1:1,0x1abee81e508,~
script-source,102,node:internal/modules/cjs/helpers,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypeSome\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeSet\x2C\x0d\n  StringPrototypeCharCodeAt\x2C\x0d\n  StringPrototypeIncludes\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n} = primordials;\x0d\nconst {\x0d\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\x0d\n  ERR_UNKNOWN_BUILTIN_MODULE\x0d\n} = require('internal/errors').codes;\x0d\nconst { NativeModule } = require('internal/bootstrap/loaders');\x0d\n\x0d\nconst { validateString } = require('internal/validators');\x0d\nconst path = require('path');\x0d\nconst { pathToFileURL\x2C fileURLToPath\x2C URL } = require('internal/url');\x0d\n\x0d\nconst { getOptionValue } = require('internal/options');\x0d\nconst userConditions = getOptionValue('--conditions');\x0d\n\x0d\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\x0d\n  debug = fn;\x0d\n});\x0d\n\x0d\nconst noAddons = getOptionValue('--no-addons');\x0d\nconst addonConditions = noAddons ? [] : ['node-addons'];\x0d\n\x0d\n// TODO: Use this set when resolving pkg#exports conditions in loader.js.\x0d\nconst cjsConditions = new SafeSet([\x0d\n  'require'\x2C\x0d\n  'node'\x2C\x0d\n  ...addonConditions\x2C\x0d\n  ...userConditions\x2C\x0d\n]);\x0d\n\x0d\nfunction loadNativeModule(filename\x2C request) {\x0d\n  const mod = NativeModule.map.get(filename);\x0d\n  if (mod?.canBeRequiredByUsers) {\x0d\n    debug('load native module %s'\x2C request);\x0d\n    // compileForPublicLoader() throws if mod.canBeRequiredByUsers is false:\x0d\n    mod.compileForPublicLoader();\x0d\n    return mod;\x0d\n  }\x0d\n}\x0d\n\x0d\n// Invoke with makeRequireFunction(module) where |module| is the Module object\x0d\n// to use as the context for the require() function.\x0d\n// Use redirects to set up a mapping from a policy and restrict dependencies\x0d\nconst urlToFileCache = new SafeMap();\x0d\nfunction makeRequireFunction(mod\x2C redirects) {\x0d\n  const Module = mod.constructor;\x0d\n\x0d\n  let require;\x0d\n  if (redirects) {\x0d\n    const id = mod.filename || mod.id;\x0d\n    const conditions = cjsConditions;\x0d\n    const { resolve\x2C reaction } = redirects;\x0d\n    require = function require(specifier) {\x0d\n      let missing = true;\x0d\n      const destination = resolve(specifier\x2C conditions);\x0d\n      if (destination === true) {\x0d\n        missing = false;\x0d\n      } else if (destination) {\x0d\n        const href = destination.href;\x0d\n        if (destination.protocol === 'node:') {\x0d\n          const specifier = destination.pathname;\x0d\n          const mod = loadNativeModule(specifier\x2C href);\x0d\n          if (mod && mod.canBeRequiredByUsers) {\x0d\n            return mod.exports;\x0d\n          }\x0d\n          throw new ERR_UNKNOWN_BUILTIN_MODULE(specifier);\x0d\n        } else if (destination.protocol === 'file:') {\x0d\n          let filepath;\x0d\n          if (urlToFileCache.has(href)) {\x0d\n            filepath = urlToFileCache.get(href);\x0d\n          } else {\x0d\n            filepath = fileURLToPath(destination);\x0d\n            urlToFileCache.set(href\x2C filepath);\x0d\n          }\x0d\n          return mod.require(filepath);\x0d\n        }\x0d\n      }\x0d\n      if (missing) {\x0d\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\x0d\n          id\x2C\x0d\n          specifier\x2C\x0d\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C ')\x0d\n        ));\x0d\n      }\x0d\n      return mod.require(specifier);\x0d\n    };\x0d\n  } else {\x0d\n    require = function require(path) {\x0d\n      return mod.require(path);\x0d\n    };\x0d\n  }\x0d\n\x0d\n  function resolve(request\x2C options) {\x0d\n    validateString(request\x2C 'request');\x0d\n    return Module._resolveFilename(request\x2C mod\x2C false\x2C options);\x0d\n  }\x0d\n\x0d\n  require.resolve = resolve;\x0d\n\x0d\n  function paths(request) {\x0d\n    validateString(request\x2C 'request');\x0d\n    return Module._resolveLookupPaths(request\x2C mod);\x0d\n  }\x0d\n\x0d\n  resolve.paths = paths;\x0d\n\x0d\n  require.main = process.mainModule;\x0d\n\x0d\n  // Enable support to add extra extension types.\x0d\n  require.extensions = Module._extensions;\x0d\n\x0d\n  require.cache = Module._cache;\x0d\n\x0d\n  return require;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\x0d\n * because the buffer-to-string conversion in `fs.readFileSync()`\x0d\n * translates it to FEFF\x2C the UTF-16 BOM.\x0d\n */\x0d\nfunction stripBOM(content) {\x0d\n  if (StringPrototypeCharCodeAt(content) === 0xFEFF) {\x0d\n    content = StringPrototypeSlice(content\x2C 1);\x0d\n  }\x0d\n  return content;\x0d\n}\x0d\n\x0d\nfunction addBuiltinLibsToObject(object\x2C dummyModuleName) {\x0d\n  // Make built-in modules available directly (loaded lazily).\x0d\n  const Module = require('internal/modules/cjs/loader').Module;\x0d\n  const { builtinModules } = Module;\x0d\n\x0d\n  // To require built-in modules in user-land and ignore modules whose\x0d\n  // `canBeRequiredByUsers` is false. So we create a dummy module object and not\x0d\n  // use `require()` directly.\x0d\n  const dummyModule = new Module(dummyModuleName);\x0d\n\x0d\n  ArrayPrototypeForEach(builtinModules\x2C (name) => {\x0d\n    // Neither add underscored modules\x2C nor ones that contain slashes (e.g.\x2C\x0d\n    // 'fs/promises') or ones that are already defined.\x0d\n    if (StringPrototypeStartsWith(name\x2C '_') ||\x0d\n        StringPrototypeIncludes(name\x2C '/') ||\x0d\n        ObjectPrototypeHasOwnProperty(object\x2C name)) {\x0d\n      return;\x0d\n    }\x0d\n    // Goals of this mechanism are:\x0d\n    // - Lazy loading of built-in modules\x0d\n    // - Having all built-in modules available as non-enumerable properties\x0d\n    // - Allowing the user to re-assign these variables as if there were no\x0d\n    //   pre-existing globals with the same name.\x0d\n\x0d\n    const setReal = (val) => {\x0d\n      // Deleting the property before re-assigning it disables the\x0d\n      // getter/setter mechanism.\x0d\n      delete object[name];\x0d\n      object[name] = val;\x0d\n    };\x0d\n\x0d\n    ObjectDefineProperty(object\x2C name\x2C {\x0d\n      get: () => {\x0d\n        const lib = dummyModule.require(name);\x0d\n\x0d\n        // Disable the current getter/setter and set up a new\x0d\n        // non-enumerable property.\x0d\n        delete object[name];\x0d\n        ObjectDefineProperty(object\x2C name\x2C {\x0d\n          get: () => lib\x2C\x0d\n          set: setReal\x2C\x0d\n          configurable: true\x2C\x0d\n          enumerable: false\x0d\n        });\x0d\n\x0d\n        return lib;\x0d\n      }\x2C\x0d\n      set: setReal\x2C\x0d\n      configurable: true\x2C\x0d\n      enumerable: false\x0d\n    });\x0d\n  });\x0d\n}\x0d\n\x0d\nfunction normalizeReferrerURL(referrer) {\x0d\n  if (typeof referrer === 'string' && path.isAbsolute(referrer)) {\x0d\n    return pathToFileURL(referrer).href;\x0d\n  }\x0d\n  return new URL(referrer).href;\x0d\n}\x0d\n\x0d\n// For error messages only - used to check if ESM syntax is in use.\x0d\nfunction hasEsmSyntax(code) {\x0d\n  debug('Checking for ESM syntax');\x0d\n  const parser = require('internal/deps/acorn/acorn/dist/acorn').Parser;\x0d\n  let root;\x0d\n  try {\x0d\n    root = parser.parse(code\x2C { sourceType: 'module'\x2C ecmaVersion: 'latest' });\x0d\n  } catch {\x0d\n    return false;\x0d\n  }\x0d\n\x0d\n  return ArrayPrototypeSome(root.body\x2C (stmt) =>\x0d\n    stmt.type === 'ExportDefaultDeclaration' ||\x0d\n    stmt.type === 'ExportNamedDeclaration' ||\x0d\n    stmt.type === 'ImportDeclaration' ||\x0d\n    stmt.type === 'ExportAllDeclaration');\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  addBuiltinLibsToObject\x2C\x0d\n  cjsConditions\x2C\x0d\n  hasEsmSyntax\x2C\x0d\n  loadNativeModule\x2C\x0d\n  makeRequireFunction\x2C\x0d\n  normalizeReferrerURL\x2C\x0d\n  stripBOM\x2C\x0d\n};\x0d\n
code-source-info,0x1abee81e7be,102,0,6975,C0O0C4O6975,,
code-creation,Function,10,185699,0x1abee81ed3e,536, node:internal/modules/cjs/helpers:1:1,0x1abee81e738,~
code-source-info,0x1abee81ed3e,102,0,6975,C0O0C104O28C110O54C116O77C122O100C128O125C134O159C139O171C144O183C150O213C156O241C162O266C168O391C174O391C179O417C184O323C190O359C196O451C202O451C207O434C213O520C219O520C224O501C230O566C236O566C240O566C242O630C248O630C253O592C259O607C265O622C271O685C277O685C282O666C287O738C290O738C295O785C301O785C306O818C319O819C325O785C327O888C330O888C335O944C346O1077C353O1122C354O1122C410O1145C465O1077C470O1077C472O1721C474O1721C479O1721C481O6806C488O6828C494O6855C500O6873C506O6890C512O6911C518O6935C524O6960C530O6821C535O6974,,
code-creation,LazyCompile,10,185886,0x1abee81f97e,27,SafeSet node:internal/per_context/primordials:364:16,0x147335ca1b8,~
script-source,6,node:internal/per_context/primordials,'use strict';\x0d\n\x0d\n/* eslint-disable node-core/prefer-primordials */\x0d\n\x0d\n// This file subclasses and stores the JS builtins that come from the VM\x0d\n// so that Node.js's builtin modules do not need to later look these up from\x0d\n// the global proxy\x2C which can be mutated by users.\x0d\n\x0d\n// Use of primordials have sometimes a dramatic impact on performance\x2C please\x0d\n// benchmark all changes made in performance-sensitive areas of the codebase.\x0d\n// See: https://github.com/nodejs/node/pull/38248\x0d\n\x0d\nconst {\x0d\n  defineProperty: ReflectDefineProperty\x2C\x0d\n  getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor\x2C\x0d\n  ownKeys: ReflectOwnKeys\x2C\x0d\n} = Reflect;\x0d\n\x0d\n// `uncurryThis` is equivalent to `func => Function.prototype.call.bind(func)`.\x0d\n// It is using `bind.bind(call)` to avoid using `Function.prototype.bind`\x0d\n// and `Function.prototype.call` after it may have been mutated by users.\x0d\nconst { apply\x2C bind\x2C call } = Function.prototype;\x0d\nconst uncurryThis = bind.bind(call);\x0d\nprimordials.uncurryThis = uncurryThis;\x0d\n\x0d\n// `applyBind` is equivalent to `func => Function.prototype.apply.bind(func)`.\x0d\n// It is using `bind.bind(apply)` to avoid using `Function.prototype.bind`\x0d\n// and `Function.prototype.apply` after it may have been mutated by users.\x0d\nconst applyBind = bind.bind(apply);\x0d\nprimordials.applyBind = applyBind;\x0d\n\x0d\n// Methods that accept a variable number of arguments\x2C and thus it's useful to\x0d\n// also create `${prefix}${key}Apply`\x2C which uses `Function.prototype.apply`\x2C\x0d\n// instead of `Function.prototype.call`\x2C and thus doesn't require iterator\x0d\n// destructuring.\x0d\nconst varargsMethods = [\x0d\n  // 'ArrayPrototypeConcat' is omitted\x2C because it performs the spread\x0d\n  // on its own for arrays and array-likes with a truthy\x0d\n  // @@isConcatSpreadable symbol property.\x0d\n  'ArrayOf'\x2C\x0d\n  'ArrayPrototypePush'\x2C\x0d\n  'ArrayPrototypeUnshift'\x2C\x0d\n  // 'FunctionPrototypeCall' is omitted\x2C since there's 'ReflectApply'\x0d\n  // and 'FunctionPrototypeApply'.\x0d\n  'MathHypot'\x2C\x0d\n  'MathMax'\x2C\x0d\n  'MathMin'\x2C\x0d\n  'StringPrototypeConcat'\x2C\x0d\n  'TypedArrayOf'\x2C\x0d\n];\x0d\n\x0d\nfunction getNewKey(key) {\x0d\n  return typeof key === 'symbol' ?\x0d\n    `Symbol${key.description[7].toUpperCase()}${key.description.slice(8)}` :\x0d\n    `${key[0].toUpperCase()}${key.slice(1)}`;\x0d\n}\x0d\n\x0d\nfunction copyAccessor(dest\x2C prefix\x2C key\x2C { enumerable\x2C get\x2C set }) {\x0d\n  ReflectDefineProperty(dest\x2C `${prefix}Get${key}`\x2C {\x0d\n    value: uncurryThis(get)\x2C\x0d\n    enumerable\x0d\n  });\x0d\n  if (set !== undefined) {\x0d\n    ReflectDefineProperty(dest\x2C `${prefix}Set${key}`\x2C {\x0d\n      value: uncurryThis(set)\x2C\x0d\n      enumerable\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction copyPropsRenamed(src\x2C dest\x2C prefix) {\x0d\n  for (const key of ReflectOwnKeys(src)) {\x0d\n    const newKey = getNewKey(key);\x0d\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\x0d\n    if ('get' in desc) {\x0d\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\x0d\n    } else {\x0d\n      const name = `${prefix}${newKey}`;\x0d\n      ReflectDefineProperty(dest\x2C name\x2C desc);\x0d\n      if (varargsMethods.includes(name)) {\x0d\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\x0d\n          // `src` is bound as the `this` so that the static `this` points\x0d\n          // to the object it was defined on\x2C\x0d\n          // e.g.: `ArrayOfApply` gets a `this` of `Array`:\x0d\n          value: applyBind(desc.value\x2C src)\x2C\x0d\n        });\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction copyPropsRenamedBound(src\x2C dest\x2C prefix) {\x0d\n  for (const key of ReflectOwnKeys(src)) {\x0d\n    const newKey = getNewKey(key);\x0d\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\x0d\n    if ('get' in desc) {\x0d\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\x0d\n    } else {\x0d\n      const { value } = desc;\x0d\n      if (typeof value === 'function') {\x0d\n        desc.value = value.bind(src);\x0d\n      }\x0d\n\x0d\n      const name = `${prefix}${newKey}`;\x0d\n      ReflectDefineProperty(dest\x2C name\x2C desc);\x0d\n      if (varargsMethods.includes(name)) {\x0d\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\x0d\n          value: applyBind(value\x2C src)\x2C\x0d\n        });\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction copyPrototype(src\x2C dest\x2C prefix) {\x0d\n  for (const key of ReflectOwnKeys(src)) {\x0d\n    const newKey = getNewKey(key);\x0d\n    const desc = ReflectGetOwnPropertyDescriptor(src\x2C key);\x0d\n    if ('get' in desc) {\x0d\n      copyAccessor(dest\x2C prefix\x2C newKey\x2C desc);\x0d\n    } else {\x0d\n      const { value } = desc;\x0d\n      if (typeof value === 'function') {\x0d\n        desc.value = uncurryThis(value);\x0d\n      }\x0d\n\x0d\n      const name = `${prefix}${newKey}`;\x0d\n      ReflectDefineProperty(dest\x2C name\x2C desc);\x0d\n      if (varargsMethods.includes(name)) {\x0d\n        ReflectDefineProperty(dest\x2C `${name}Apply`\x2C {\x0d\n          value: applyBind(value)\x2C\x0d\n        });\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\n// Create copies of configurable value properties of the global object\x0d\n[\x0d\n  'Proxy'\x2C\x0d\n  'globalThis'\x2C\x0d\n].forEach((name) => {\x0d\n  // eslint-disable-next-line no-restricted-globals\x0d\n  primordials[name] = globalThis[name];\x0d\n});\x0d\n\x0d\n// Create copies of URI handling functions\x0d\n[\x0d\n  decodeURI\x2C\x0d\n  decodeURIComponent\x2C\x0d\n  encodeURI\x2C\x0d\n  encodeURIComponent\x2C\x0d\n].forEach((fn) => {\x0d\n  primordials[fn.name] = fn;\x0d\n});\x0d\n\x0d\n// Create copies of the namespace objects\x0d\n[\x0d\n  'JSON'\x2C\x0d\n  'Math'\x2C\x0d\n  'Proxy'\x2C\x0d\n  'Reflect'\x2C\x0d\n].forEach((name) => {\x0d\n  // eslint-disable-next-line no-restricted-globals\x0d\n  copyPropsRenamed(global[name]\x2C primordials\x2C name);\x0d\n});\x0d\n\x0d\n// Create copies of intrinsic objects\x0d\n[\x0d\n  'AggregateError'\x2C\x0d\n  'Array'\x2C\x0d\n  'ArrayBuffer'\x2C\x0d\n  'BigInt'\x2C\x0d\n  'BigInt64Array'\x2C\x0d\n  'BigUint64Array'\x2C\x0d\n  'Boolean'\x2C\x0d\n  'DataView'\x2C\x0d\n  'Date'\x2C\x0d\n  'Error'\x2C\x0d\n  'EvalError'\x2C\x0d\n  'FinalizationRegistry'\x2C\x0d\n  'Float32Array'\x2C\x0d\n  'Float64Array'\x2C\x0d\n  'Function'\x2C\x0d\n  'Int16Array'\x2C\x0d\n  'Int32Array'\x2C\x0d\n  'Int8Array'\x2C\x0d\n  'Map'\x2C\x0d\n  'Number'\x2C\x0d\n  'Object'\x2C\x0d\n  'RangeError'\x2C\x0d\n  'ReferenceError'\x2C\x0d\n  'RegExp'\x2C\x0d\n  'Set'\x2C\x0d\n  'String'\x2C\x0d\n  'Symbol'\x2C\x0d\n  'SyntaxError'\x2C\x0d\n  'TypeError'\x2C\x0d\n  'URIError'\x2C\x0d\n  'Uint16Array'\x2C\x0d\n  'Uint32Array'\x2C\x0d\n  'Uint8Array'\x2C\x0d\n  'Uint8ClampedArray'\x2C\x0d\n  'WeakMap'\x2C\x0d\n  'WeakRef'\x2C\x0d\n  'WeakSet'\x2C\x0d\n].forEach((name) => {\x0d\n  // eslint-disable-next-line no-restricted-globals\x0d\n  const original = global[name];\x0d\n  primordials[name] = original;\x0d\n  copyPropsRenamed(original\x2C primordials\x2C name);\x0d\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\x0d\n});\x0d\n\x0d\n// Create copies of intrinsic objects that require a valid `this` to call\x0d\n// static methods.\x0d\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\x0d\n[\x0d\n  'Promise'\x2C\x0d\n].forEach((name) => {\x0d\n  // eslint-disable-next-line no-restricted-globals\x0d\n  const original = global[name];\x0d\n  primordials[name] = original;\x0d\n  copyPropsRenamedBound(original\x2C primordials\x2C name);\x0d\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\x0d\n});\x0d\n\x0d\n// Create copies of abstract intrinsic objects that are not directly exposed\x0d\n// on the global object.\x0d\n// Refs: https://tc39.es/ecma262/#sec-%typedarray%-intrinsic-object\x0d\n[\x0d\n  { name: 'TypedArray'\x2C original: Reflect.getPrototypeOf(Uint8Array) }\x2C\x0d\n  { name: 'ArrayIterator'\x2C original: {\x0d\n    prototype: Reflect.getPrototypeOf(Array.prototype[Symbol.iterator]())\x2C\x0d\n  } }\x2C\x0d\n  { name: 'StringIterator'\x2C original: {\x0d\n    prototype: Reflect.getPrototypeOf(String.prototype[Symbol.iterator]())\x2C\x0d\n  } }\x2C\x0d\n].forEach(({ name\x2C original }) => {\x0d\n  primordials[name] = original;\x0d\n  // The static %TypedArray% methods require a valid `this`\x2C but can't be bound\x2C\x0d\n  // as they need a subclass constructor as the receiver:\x0d\n  copyPrototype(original\x2C primordials\x2C name);\x0d\n  copyPrototype(original.prototype\x2C primordials\x2C `${name}Prototype`);\x0d\n});\x0d\n\x0d\n/* eslint-enable node-core/prefer-primordials */\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  FinalizationRegistry\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  Map\x2C\x0d\n  ObjectFreeze\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  Promise\x2C\x0d\n  PromisePrototypeThen\x2C\x0d\n  Set\x2C\x0d\n  SymbolIterator\x2C\x0d\n  WeakMap\x2C\x0d\n  WeakRef\x2C\x0d\n  WeakSet\x2C\x0d\n} = primordials;\x0d\n\x0d\n// Because these functions are used by `makeSafe`\x2C which is exposed\x0d\n// on the `primordials` object\x2C it's important to use const references\x0d\n// to the primordials that they use:\x0d\nconst createSafeIterator = (factory\x2C next) => {\x0d\n  class SafeIterator {\x0d\n    constructor(iterable) {\x0d\n      this._iterator = factory(iterable);\x0d\n    }\x0d\n    next() {\x0d\n      return next(this._iterator);\x0d\n    }\x0d\n    [SymbolIterator]() {\x0d\n      return this;\x0d\n    }\x0d\n  }\x0d\n  ObjectSetPrototypeOf(SafeIterator.prototype\x2C null);\x0d\n  ObjectFreeze(SafeIterator.prototype);\x0d\n  ObjectFreeze(SafeIterator);\x0d\n  return SafeIterator;\x0d\n};\x0d\n\x0d\nprimordials.SafeArrayIterator = createSafeIterator(\x0d\n  primordials.ArrayPrototypeSymbolIterator\x2C\x0d\n  primordials.ArrayIteratorPrototypeNext\x0d\n);\x0d\nprimordials.SafeStringIterator = createSafeIterator(\x0d\n  primordials.StringPrototypeSymbolIterator\x2C\x0d\n  primordials.StringIteratorPrototypeNext\x0d\n);\x0d\n\x0d\nconst copyProps = (src\x2C dest) => {\x0d\n  ArrayPrototypeForEach(ReflectOwnKeys(src)\x2C (key) => {\x0d\n    if (!ReflectGetOwnPropertyDescriptor(dest\x2C key)) {\x0d\n      ReflectDefineProperty(\x0d\n        dest\x2C\x0d\n        key\x2C\x0d\n        ReflectGetOwnPropertyDescriptor(src\x2C key));\x0d\n    }\x0d\n  });\x0d\n};\x0d\n\x0d\n/**\x0d\n * @type {typeof primordials.makeSafe}\x0d\n */\x0d\nconst makeSafe = (unsafe\x2C safe) => {\x0d\n  if (SymbolIterator in unsafe.prototype) {\x0d\n    const dummy = new unsafe();\x0d\n    let next; // We can reuse the same `next` method.\x0d\n\x0d\n    ArrayPrototypeForEach(ReflectOwnKeys(unsafe.prototype)\x2C (key) => {\x0d\n      if (!ReflectGetOwnPropertyDescriptor(safe.prototype\x2C key)) {\x0d\n        const desc = ReflectGetOwnPropertyDescriptor(unsafe.prototype\x2C key);\x0d\n        if (\x0d\n          typeof desc.value === 'function' &&\x0d\n          desc.value.length === 0 &&\x0d\n          SymbolIterator in (FunctionPrototypeCall(desc.value\x2C dummy) ?? {})\x0d\n        ) {\x0d\n          const createIterator = uncurryThis(desc.value);\x0d\n          next ??= uncurryThis(createIterator(dummy).next);\x0d\n          const SafeIterator = createSafeIterator(createIterator\x2C next);\x0d\n          desc.value = function() {\x0d\n            return new SafeIterator(this);\x0d\n          };\x0d\n        }\x0d\n        ReflectDefineProperty(safe.prototype\x2C key\x2C desc);\x0d\n      }\x0d\n    });\x0d\n  } else {\x0d\n    copyProps(unsafe.prototype\x2C safe.prototype);\x0d\n  }\x0d\n  copyProps(unsafe\x2C safe);\x0d\n\x0d\n  ObjectSetPrototypeOf(safe.prototype\x2C null);\x0d\n  ObjectFreeze(safe.prototype);\x0d\n  ObjectFreeze(safe);\x0d\n  return safe;\x0d\n};\x0d\nprimordials.makeSafe = makeSafe;\x0d\n\x0d\n// Subclass the constructors because we need to use their prototype\x0d\n// methods later.\x0d\n// Defining the `constructor` is necessary here to avoid the default\x0d\n// constructor which uses the user-mutable `%ArrayIteratorPrototype%.next`.\x0d\nprimordials.SafeMap = makeSafe(\x0d\n  Map\x2C\x0d\n  class SafeMap extends Map {\x0d\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\x0d\n  }\x0d\n);\x0d\nprimordials.SafeWeakMap = makeSafe(\x0d\n  WeakMap\x2C\x0d\n  class SafeWeakMap extends WeakMap {\x0d\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\x0d\n  }\x0d\n);\x0d\n\x0d\nprimordials.SafeSet = makeSafe(\x0d\n  Set\x2C\x0d\n  class SafeSet extends Set {\x0d\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\x0d\n  }\x0d\n);\x0d\nprimordials.SafeWeakSet = makeSafe(\x0d\n  WeakSet\x2C\x0d\n  class SafeWeakSet extends WeakSet {\x0d\n    constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\x0d\n  }\x0d\n);\x0d\n\x0d\nprimordials.SafeFinalizationRegistry = makeSafe(\x0d\n  FinalizationRegistry\x2C\x0d\n  class SafeFinalizationRegistry extends FinalizationRegistry {\x0d\n    // eslint-disable-next-line no-useless-constructor\x0d\n    constructor(cleanupCallback) { super(cleanupCallback); }\x0d\n  }\x0d\n);\x0d\nprimordials.SafeWeakRef = makeSafe(\x0d\n  WeakRef\x2C\x0d\n  class SafeWeakRef extends WeakRef {\x0d\n    // eslint-disable-next-line no-useless-constructor\x0d\n    constructor(target) { super(target); }\x0d\n  }\x0d\n);\x0d\n\x0d\nconst SafePromise = makeSafe(\x0d\n  Promise\x2C\x0d\n  class SafePromise extends Promise {\x0d\n    // eslint-disable-next-line no-useless-constructor\x0d\n    constructor(executor) { super(executor); }\x0d\n  }\x0d\n);\x0d\n\x0d\nprimordials.PromisePrototypeCatch = (thisPromise\x2C onRejected) =>\x0d\n  PromisePrototypeThen(thisPromise\x2C undefined\x2C onRejected);\x0d\n\x0d\n/**\x0d\n * Attaches a callback that is invoked when the Promise is settled (fulfilled or\x0d\n * rejected). The resolved value cannot be modified from the callback.\x0d\n * Prefer using async functions when possible.\x0d\n * @param {Promise<any>} thisPromise\x0d\n * @param {() => void) | undefined | null} onFinally The callback to execute\x0d\n *        when the Promise is settled (fulfilled or rejected).\x0d\n * @returns {Promise} A Promise for the completion of the callback.\x0d\n */\x0d\nprimordials.SafePromisePrototypeFinally = (thisPromise\x2C onFinally) =>\x0d\n  // Wrapping on a new Promise is necessary to not expose the SafePromise\x0d\n  // prototype to user-land.\x0d\n  new Promise((a\x2C b) =>\x0d\n    new SafePromise((a\x2C b) => PromisePrototypeThen(thisPromise\x2C a\x2C b))\x0d\n      .finally(onFinally)\x0d\n      .then(a\x2C b)\x0d\n  );\x0d\n\x0d\nprimordials.AsyncIteratorPrototype =\x0d\n  primordials.ReflectGetPrototypeOf(\x0d\n    primordials.ReflectGetPrototypeOf(\x0d\n      async function* () {}).prototype);\x0d\n\x0d\nObjectSetPrototypeOf(primordials\x2C null);\x0d\nObjectFreeze(primordials);\x0d\n
code-source-info,0x1abee81f97e,6,10890,10907,C3O10896C7O10902C11O10896C26O10906,,
tick,0x7ff99731f273,186893,0,0x0,3,0x7ff7e78fdb40,0x1abee81ef0f,0x1abee802285,0x1abee801555,0x1abee81bfa5,0x1abee802285,0x1abee801555,0x1abee81adf4,0x1abee806730,0x1abee8012dd
code-creation,LazyCompile,10,186916,0x1abee8207be,27,SafeMap node:internal/per_context/primordials:351:16,0x147335ca030,~
code-source-info,0x1abee8207be,6,10550,10567,C3O10556C7O10562C11O10556C26O10566,,
code-creation,LazyCompile,10,186981,0x1abee820956,16,IterableWeakMap node:internal/util/iterable_weak_map:16:1,0x1abee81d258,~
code-source-info,0x1abee820956,101,388,388,C0O388C15O388,,
code-creation,LazyCompile,10,187024,0x1abee820cde,27,SafeWeakMap node:internal/per_context/primordials:357:16,0x147335ca0f0,~
code-source-info,0x1abee820cde,6,10727,10744,C3O10733C7O10739C11O10733C26O10743,,
code-creation,LazyCompile,10,187070,0x1abee820de6,27,SafeFinalizationRegistry node:internal/per_context/primordials:378:16,0x147335ca340,~
code-source-info,0x1abee820de6,6,11354,11399,C3O11374C7O11380C11O11374C26O11398,,
code-creation,LazyCompile,10,187215,0x1abee8215ce,492,initializeDeprecations node:internal/bootstrap/pre_execution:241:32,0x1abee803598,~
code-source-info,0x1abee8215ce,96,7901,10485,C0O7901C11O7931C19O7931C24O7917C29O7987C39O7987C44O8182C52O8182C57O8224C65O8224C70O8278C99O8270C127O8270C130O8614C141O8634C145O8677C156O8752C167O8844C178O8798C187O8662C196O8905C199O8632C203O8259C269O9189C277O9189C282O9168C287O9219C289O9248C304O9269C311O9391C315O9248C320O9427C324O9458C334O9494C344O9572C351O9476C356O9474C360O9661C370O9703C381O9685C386O9683C390O10050C394O10050C396O10062C407O10083C418O10113C426O10158C434O10062C439O10278C445O10278C447O10289C458O10310C469O10339C477O10383C485O10289C491O10484,,
code-creation,LazyCompile,10,187343,0x1abee821bfe,53,initializeWASI node:internal/bootstrap/pre_execution:405:24,0x1abee803718,~
code-source-info,0x1abee821bfe,96,13253,13464,C0O13286C6O13286C11O13269C16O13353C21O13357C29O13357C35O13373C37O13405C43O13405C47O13398C52O13463,,
code-creation,LazyCompile,10,187405,0x1abee821dfe,66,initializeCJSLoader node:internal/bootstrap/pre_execution:412:29,0x1abee803768,~
code-source-info,0x1abee821dfe,96,13496,13819,C0O13522C6O13522C11O13565C16O13570C20O13590C26O13629C31O13636C36O13636C40O13735C51O13757C56O13793C60O13750C65O13818,,
code-creation,Eval,10,188306,0x1abee823dae,5, node:internal/modules/cjs/loader:1:1,0x1abee8234c8,~
script-source,103,node:internal/modules/cjs/loader,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeConcat\x2C\x0d\n  ArrayPrototypeFilter\x2C\x0d\n  ArrayPrototypeIncludes\x2C\x0d\n  ArrayPrototypeIndexOf\x2C\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  ArrayPrototypeSplice\x2C\x0d\n  ArrayPrototypeUnshift\x2C\x0d\n  ArrayPrototypeUnshiftApply\x2C\x0d\n  Boolean\x2C\x0d\n  Error\x2C\x0d\n  JSONParse\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectFreeze\x2C\x0d\n  ObjectGetOwnPropertyDescriptor\x2C\x0d\n  ObjectGetPrototypeOf\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ObjectPrototype\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  Proxy\x2C\x0d\n  ReflectApply\x2C\x0d\n  ReflectSet\x2C\x0d\n  RegExpPrototypeExec\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeWeakMap\x2C\x0d\n  String\x2C\x0d\n  StringPrototypeCharAt\x2C\x0d\n  StringPrototypeCharCodeAt\x2C\x0d\n  StringPrototypeEndsWith\x2C\x0d\n  StringPrototypeLastIndexOf\x2C\x0d\n  StringPrototypeIndexOf\x2C\x0d\n  StringPrototypeMatch\x2C\x0d\n  StringPrototypeRepeat\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n} = primordials;\x0d\n\x0d\n// Map used to store CJS parsing data.\x0d\nconst cjsParseCache = new SafeWeakMap();\x0d\n\x0d\n// Set first due to cycle with ESM loader functions.\x0d\nmodule.exports = {\x0d\n  wrapSafe\x2C Module\x2C toRealPath\x2C readPackageScope\x2C cjsParseCache\x2C\x0d\n  get hasLoadedAnyUserCJSModule() { return hasLoadedAnyUserCJSModule; }\x0d\n};\x0d\n\x0d\nconst { NativeModule } = require('internal/bootstrap/loaders');\x0d\nconst {\x0d\n  maybeCacheSourceMap\x2C\x0d\n} = require('internal/source_map/source_map_cache');\x0d\nconst { pathToFileURL\x2C fileURLToPath\x2C isURLInstance } = require('internal/url');\x0d\nconst { deprecate } = require('internal/util');\x0d\nconst vm = require('vm');\x0d\nconst assert = require('internal/assert');\x0d\nconst fs = require('fs');\x0d\nconst internalFS = require('internal/fs/utils');\x0d\nconst path = require('path');\x0d\nconst { sep } = path;\x0d\nconst { internalModuleStat } = internalBinding('fs');\x0d\nconst packageJsonReader = require('internal/modules/package_json_reader');\x0d\nconst { safeGetenv } = internalBinding('credentials');\x0d\nconst {\x0d\n  cjsConditions\x2C\x0d\n  hasEsmSyntax\x2C\x0d\n  loadNativeModule\x2C\x0d\n  makeRequireFunction\x2C\x0d\n  normalizeReferrerURL\x2C\x0d\n  stripBOM\x2C\x0d\n} = require('internal/modules/cjs/helpers');\x0d\nconst { getOptionValue } = require('internal/options');\x0d\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\x0d\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\x0d\n// Do not eagerly grab .manifest\x2C it may be in TDZ\x0d\nconst policy = getOptionValue('--experimental-policy') ?\x0d\n  require('internal/process/policy') :\x0d\n  null;\x0d\n\x0d\n// Whether any user-provided CJS modules had been loaded (executed).\x0d\n// Used for internal assertions.\x0d\nlet hasLoadedAnyUserCJSModule = false;\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_INVALID_MODULE_SPECIFIER\x2C\x0d\n    ERR_REQUIRE_ESM\x2C\x0d\n    ERR_UNKNOWN_BUILTIN_MODULE\x2C\x0d\n  }\x2C\x0d\n  setArrowMessage\x2C\x0d\n} = require('internal/errors');\x0d\nconst { validateString } = require('internal/validators');\x0d\nconst pendingDeprecation = getOptionValue('--pending-deprecation');\x0d\n\x0d\nconst {\x0d\n  CHAR_FORWARD_SLASH\x2C\x0d\n  CHAR_BACKWARD_SLASH\x2C\x0d\n  CHAR_COLON\x0d\n} = require('internal/constants');\x0d\n\x0d\nconst {\x0d\n  isProxy\x0d\n} = require('internal/util/types');\x0d\n\x0d\nconst asyncESM = require('internal/process/esm_loader');\x0d\nconst { enrichCJSError } = require('internal/modules/esm/translators');\x0d\nconst { kEvaluated } = internalBinding('module_wrap');\x0d\nconst {\x0d\n  encodedSepRegEx\x2C\x0d\n  packageExportsResolve\x2C\x0d\n  packageImportsResolve\x0d\n} = require('internal/modules/esm/resolve');\x0d\n\x0d\nconst isWindows = process.platform === 'win32';\x0d\n\x0d\nconst relativeResolveCache = ObjectCreate(null);\x0d\n\x0d\nlet requireDepth = 0;\x0d\nlet statCache = null;\x0d\nlet isPreloading = false;\x0d\n\x0d\nfunction stat(filename) {\x0d\n  filename = path.toNamespacedPath(filename);\x0d\n  if (statCache !== null) {\x0d\n    const result = statCache.get(filename);\x0d\n    if (result !== undefined) return result;\x0d\n  }\x0d\n  const result = internalModuleStat(filename);\x0d\n  if (statCache !== null && result >= 0) {\x0d\n    // Only set cache when `internalModuleStat(filename)` succeeds.\x0d\n    statCache.set(filename\x2C result);\x0d\n  }\x0d\n  return result;\x0d\n}\x0d\n\x0d\nfunction updateChildren(parent\x2C child\x2C scan) {\x0d\n  const children = parent?.children;\x0d\n  if (children && !(scan && ArrayPrototypeIncludes(children\x2C child)))\x0d\n    ArrayPrototypePush(children\x2C child);\x0d\n}\x0d\n\x0d\nconst moduleParentCache = new SafeWeakMap();\x0d\nfunction Module(id = ''\x2C parent) {\x0d\n  this.id = id;\x0d\n  this.path = path.dirname(id);\x0d\n  this.exports = {};\x0d\n  moduleParentCache.set(this\x2C parent);\x0d\n  updateChildren(parent\x2C this\x2C false);\x0d\n  this.filename = null;\x0d\n  this.loaded = false;\x0d\n  this.children = [];\x0d\n}\x0d\n\x0d\nconst builtinModules = [];\x0d\nfor (const { 0: id\x2C 1: mod } of NativeModule.map) {\x0d\n  if (mod.canBeRequiredByUsers) {\x0d\n    ArrayPrototypePush(builtinModules\x2C id);\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectFreeze(builtinModules);\x0d\nModule.builtinModules = builtinModules;\x0d\n\x0d\nModule._cache = ObjectCreate(null);\x0d\nModule._pathCache = ObjectCreate(null);\x0d\nModule._extensions = ObjectCreate(null);\x0d\nlet modulePaths = [];\x0d\nModule.globalPaths = [];\x0d\n\x0d\nlet patched = false;\x0d\n\x0d\n// eslint-disable-next-line func-style\x0d\nlet wrap = function(script) {\x0d\n  return Module.wrapper[0] + script + Module.wrapper[1];\x0d\n};\x0d\n\x0d\nconst wrapper = [\x0d\n  '(function (exports\x2C require\x2C module\x2C __filename\x2C __dirname) { '\x2C\x0d\n  '\\n});'\x2C\x0d\n];\x0d\n\x0d\nlet wrapperProxy = new Proxy(wrapper\x2C {\x0d\n  set(target\x2C property\x2C value\x2C receiver) {\x0d\n    patched = true;\x0d\n    return ReflectSet(target\x2C property\x2C value\x2C receiver);\x0d\n  }\x2C\x0d\n\x0d\n  defineProperty(target\x2C property\x2C descriptor) {\x0d\n    patched = true;\x0d\n    return ObjectDefineProperty(target\x2C property\x2C descriptor);\x0d\n  }\x0d\n});\x0d\n\x0d\nObjectDefineProperty(Module\x2C 'wrap'\x2C {\x0d\n  get() {\x0d\n    return wrap;\x0d\n  }\x2C\x0d\n\x0d\n  set(value) {\x0d\n    patched = true;\x0d\n    wrap = value;\x0d\n  }\x0d\n});\x0d\n\x0d\nObjectDefineProperty(Module\x2C 'wrapper'\x2C {\x0d\n  get() {\x0d\n    return wrapperProxy;\x0d\n  }\x2C\x0d\n\x0d\n  set(value) {\x0d\n    patched = true;\x0d\n    wrapperProxy = value;\x0d\n  }\x0d\n});\x0d\n\x0d\nconst isPreloadingDesc = { get() { return isPreloading; } };\x0d\nObjectDefineProperty(Module.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\x0d\nObjectDefineProperty(NativeModule.prototype\x2C 'isPreloading'\x2C isPreloadingDesc);\x0d\n\x0d\nfunction getModuleParent() {\x0d\n  return moduleParentCache.get(this);\x0d\n}\x0d\n\x0d\nfunction setModuleParent(value) {\x0d\n  moduleParentCache.set(this\x2C value);\x0d\n}\x0d\n\x0d\nObjectDefineProperty(Module.prototype\x2C 'parent'\x2C {\x0d\n  get: pendingDeprecation ? deprecate(\x0d\n    getModuleParent\x2C\x0d\n    'module.parent is deprecated due to accuracy issues. Please use ' +\x0d\n      'require.main to find program entry point instead.'\x2C\x0d\n    'DEP0144'\x0d\n  ) : getModuleParent\x2C\x0d\n  set: pendingDeprecation ? deprecate(\x0d\n    setModuleParent\x2C\x0d\n    'module.parent is deprecated due to accuracy issues. Please use ' +\x0d\n      'require.main to find program entry point instead.'\x2C\x0d\n    'DEP0144'\x0d\n  ) : setModuleParent\x2C\x0d\n});\x0d\n\x0d\nlet debug = require('internal/util/debuglog').debuglog('module'\x2C (fn) => {\x0d\n  debug = fn;\x0d\n});\x0d\nModule._debug = deprecate(debug\x2C 'Module._debug is deprecated.'\x2C 'DEP0077');\x0d\n\x0d\n// Given a module name\x2C and a list of paths to test\x2C returns the first\x0d\n// matching file in the following precedence.\x0d\n//\x0d\n// require("a.<ext>")\x0d\n//   -> a.<ext>\x0d\n//\x0d\n// require("a")\x0d\n//   -> a\x0d\n//   -> a.<ext>\x0d\n//   -> a/index.<ext>\x0d\n\x0d\nconst packageJsonCache = new SafeMap();\x0d\n\x0d\nfunction readPackage(requestPath) {\x0d\n  const jsonPath = path.resolve(requestPath\x2C 'package.json');\x0d\n\x0d\n  const existing = packageJsonCache.get(jsonPath);\x0d\n  if (existing !== undefined) return existing;\x0d\n\x0d\n  const result = packageJsonReader.read(jsonPath);\x0d\n  const json = result.containsKeys === false ? '{}' : result.string;\x0d\n  if (json === undefined) {\x0d\n    packageJsonCache.set(jsonPath\x2C false);\x0d\n    return false;\x0d\n  }\x0d\n\x0d\n  try {\x0d\n    const parsed = JSONParse(json);\x0d\n    const filtered = {\x0d\n      name: parsed.name\x2C\x0d\n      main: parsed.main\x2C\x0d\n      exports: parsed.exports\x2C\x0d\n      imports: parsed.imports\x2C\x0d\n      type: parsed.type\x0d\n    };\x0d\n    packageJsonCache.set(jsonPath\x2C filtered);\x0d\n    return filtered;\x0d\n  } catch (e) {\x0d\n    e.path = jsonPath;\x0d\n    e.message = 'Error parsing ' + jsonPath + ': ' + e.message;\x0d\n    throw e;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readPackageScope(checkPath) {\x0d\n  const rootSeparatorIndex = StringPrototypeIndexOf(checkPath\x2C sep);\x0d\n  let separatorIndex;\x0d\n  do {\x0d\n    separatorIndex = StringPrototypeLastIndexOf(checkPath\x2C sep);\x0d\n    checkPath = StringPrototypeSlice(checkPath\x2C 0\x2C separatorIndex);\x0d\n    if (StringPrototypeEndsWith(checkPath\x2C sep + 'node_modules'))\x0d\n      return false;\x0d\n    const pjson = readPackage(checkPath + sep);\x0d\n    if (pjson) return {\x0d\n      data: pjson\x2C\x0d\n      path: checkPath\x2C\x0d\n    };\x0d\n  } while (separatorIndex > rootSeparatorIndex);\x0d\n  return false;\x0d\n}\x0d\n\x0d\nfunction tryPackage(requestPath\x2C exts\x2C isMain\x2C originalPath) {\x0d\n  const pkg = readPackage(requestPath)?.main;\x0d\n\x0d\n  if (!pkg) {\x0d\n    return tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\x0d\n  }\x0d\n\x0d\n  const filename = path.resolve(requestPath\x2C pkg);\x0d\n  let actual = tryFile(filename\x2C isMain) ||\x0d\n    tryExtensions(filename\x2C exts\x2C isMain) ||\x0d\n    tryExtensions(path.resolve(filename\x2C 'index')\x2C exts\x2C isMain);\x0d\n  if (actual === false) {\x0d\n    actual = tryExtensions(path.resolve(requestPath\x2C 'index')\x2C exts\x2C isMain);\x0d\n    if (!actual) {\x0d\n      // eslint-disable-next-line no-restricted-syntax\x0d\n      const err = new Error(\x0d\n        `Cannot find module '${filename}'. ` +\x0d\n        'Please verify that the package.json has a valid "main" entry'\x0d\n      );\x0d\n      err.code = 'MODULE_NOT_FOUND';\x0d\n      err.path = path.resolve(requestPath\x2C 'package.json');\x0d\n      err.requestPath = originalPath;\x0d\n      // TODO(BridgeAR): Add the requireStack as well.\x0d\n      throw err;\x0d\n    } else {\x0d\n      const jsonPath = path.resolve(requestPath\x2C 'package.json');\x0d\n      process.emitWarning(\x0d\n        `Invalid 'main' field in '${jsonPath}' of '${pkg}'. ` +\x0d\n          'Please either fix that or report it to the module author'\x2C\x0d\n        'DeprecationWarning'\x2C\x0d\n        'DEP0128'\x0d\n      );\x0d\n    }\x0d\n  }\x0d\n  return actual;\x0d\n}\x0d\n\x0d\n// In order to minimize unnecessary lstat() calls\x2C\x0d\n// this cache is a list of known-real paths.\x0d\n// Set to an empty Map to reset.\x0d\nconst realpathCache = new SafeMap();\x0d\n\x0d\n// Check if the file exists and is not a directory\x0d\n// if using --preserve-symlinks and isMain is false\x2C\x0d\n// keep symlinks intact\x2C otherwise resolve to the\x0d\n// absolute realpath.\x0d\nfunction tryFile(requestPath\x2C isMain) {\x0d\n  const rc = stat(requestPath);\x0d\n  if (rc !== 0) return;\x0d\n  if (preserveSymlinks && !isMain) {\x0d\n    return path.resolve(requestPath);\x0d\n  }\x0d\n  return toRealPath(requestPath);\x0d\n}\x0d\n\x0d\nfunction toRealPath(requestPath) {\x0d\n  return fs.realpathSync(requestPath\x2C {\x0d\n    [internalFS.realpathCacheKey]: realpathCache\x0d\n  });\x0d\n}\x0d\n\x0d\n// Given a path\x2C check if the file exists with any of the set extensions\x0d\nfunction tryExtensions(p\x2C exts\x2C isMain) {\x0d\n  for (let i = 0; i < exts.length; i++) {\x0d\n    const filename = tryFile(p + exts[i]\x2C isMain);\x0d\n\x0d\n    if (filename) {\x0d\n      return filename;\x0d\n    }\x0d\n  }\x0d\n  return false;\x0d\n}\x0d\n\x0d\n// Find the longest (possibly multi-dot) extension registered in\x0d\n// Module._extensions\x0d\nfunction findLongestRegisteredExtension(filename) {\x0d\n  const name = path.basename(filename);\x0d\n  let currentExtension;\x0d\n  let index;\x0d\n  let startIndex = 0;\x0d\n  while ((index = StringPrototypeIndexOf(name\x2C '.'\x2C startIndex)) !== -1) {\x0d\n    startIndex = index + 1;\x0d\n    if (index === 0) continue; // Skip dotfiles like .gitignore\x0d\n    currentExtension = StringPrototypeSlice(name\x2C index);\x0d\n    if (Module._extensions[currentExtension]) return currentExtension;\x0d\n  }\x0d\n  return '.js';\x0d\n}\x0d\n\x0d\nfunction trySelfParentPath(parent) {\x0d\n  if (!parent) return false;\x0d\n\x0d\n  if (parent.filename) {\x0d\n    return parent.filename;\x0d\n  } else if (parent.id === '<repl>' || parent.id === 'internal/preload') {\x0d\n    try {\x0d\n      return process.cwd() + path.sep;\x0d\n    } catch {\x0d\n      return false;\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction trySelf(parentPath\x2C request) {\x0d\n  if (!parentPath) return false;\x0d\n\x0d\n  const { data: pkg\x2C path: pkgPath } = readPackageScope(parentPath) || {};\x0d\n  if (!pkg || pkg.exports === undefined) return false;\x0d\n  if (typeof pkg.name !== 'string') return false;\x0d\n\x0d\n  let expansion;\x0d\n  if (request === pkg.name) {\x0d\n    expansion = '.';\x0d\n  } else if (StringPrototypeStartsWith(request\x2C `${pkg.name}/`)) {\x0d\n    expansion = '.' + StringPrototypeSlice(request\x2C pkg.name.length);\x0d\n  } else {\x0d\n    return false;\x0d\n  }\x0d\n\x0d\n  try {\x0d\n    return finalizeEsmResolution(packageExportsResolve(\x0d\n      pathToFileURL(pkgPath + '/package.json')\x2C expansion\x2C pkg\x2C\x0d\n      pathToFileURL(parentPath)\x2C cjsConditions)\x2C parentPath\x2C pkgPath);\x0d\n  } catch (e) {\x0d\n    if (e.code === 'ERR_MODULE_NOT_FOUND')\x0d\n      throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\x0d\n    throw e;\x0d\n  }\x0d\n}\x0d\n\x0d\n// This only applies to requests of a specific form:\x0d\n// 1. name/.*\x0d\n// 2. @scope/name/.*\x0d\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^./\\\\%][^/\\\\%]*)(\\/.*)?$/;\x0d\nfunction resolveExports(nmPath\x2C request) {\x0d\n  // The implementation's behavior is meant to mirror resolution in ESM.\x0d\n  const { 1: name\x2C 2: expansion = '' } =\x0d\n    StringPrototypeMatch(request\x2C EXPORTS_PATTERN) || [];\x0d\n  if (!name)\x0d\n    return;\x0d\n  const pkgPath = path.resolve(nmPath\x2C name);\x0d\n  const pkg = readPackage(pkgPath);\x0d\n  if (pkg?.exports != null) {\x0d\n    try {\x0d\n      return finalizeEsmResolution(packageExportsResolve(\x0d\n        pathToFileURL(pkgPath + '/package.json')\x2C '.' + expansion\x2C pkg\x2C null\x2C\x0d\n        cjsConditions)\x2C null\x2C pkgPath);\x0d\n    } catch (e) {\x0d\n      if (e.code === 'ERR_MODULE_NOT_FOUND')\x0d\n        throw createEsmNotFoundErr(request\x2C pkgPath + '/package.json');\x0d\n      throw e;\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nconst trailingSlashRegex = /(?:^|\\/)\\.?\\.$/;\x0d\nModule._findPath = function(request\x2C paths\x2C isMain) {\x0d\n  const absoluteRequest = path.isAbsolute(request);\x0d\n  if (absoluteRequest) {\x0d\n    paths = [''];\x0d\n  } else if (!paths || paths.length === 0) {\x0d\n    return false;\x0d\n  }\x0d\n\x0d\n  const cacheKey = request + '\\x00' + ArrayPrototypeJoin(paths\x2C '\\x00');\x0d\n  const entry = Module._pathCache[cacheKey];\x0d\n  if (entry)\x0d\n    return entry;\x0d\n\x0d\n  let exts;\x0d\n  let trailingSlash = request.length > 0 &&\x0d\n    StringPrototypeCharCodeAt(request\x2C request.length - 1) ===\x0d\n    CHAR_FORWARD_SLASH;\x0d\n  if (!trailingSlash) {\x0d\n    trailingSlash = RegExpPrototypeTest(trailingSlashRegex\x2C request);\x0d\n  }\x0d\n\x0d\n  // For each path\x0d\n  for (let i = 0; i < paths.length; i++) {\x0d\n    // Don't search further if path doesn't exist\x0d\n    const curPath = paths[i];\x0d\n    if (curPath && stat(curPath) < 1) continue;\x0d\n\x0d\n    if (!absoluteRequest) {\x0d\n      const exportsResolved = resolveExports(curPath\x2C request);\x0d\n      if (exportsResolved)\x0d\n        return exportsResolved;\x0d\n    }\x0d\n\x0d\n    const basePath = path.resolve(curPath\x2C request);\x0d\n    let filename;\x0d\n\x0d\n    const rc = stat(basePath);\x0d\n    if (!trailingSlash) {\x0d\n      if (rc === 0) {  // File.\x0d\n        if (!isMain) {\x0d\n          if (preserveSymlinks) {\x0d\n            filename = path.resolve(basePath);\x0d\n          } else {\x0d\n            filename = toRealPath(basePath);\x0d\n          }\x0d\n        } else if (preserveSymlinksMain) {\x0d\n          // For the main module\x2C we use the preserveSymlinksMain flag instead\x0d\n          // mainly for backward compatibility\x2C as the preserveSymlinks flag\x0d\n          // historically has not applied to the main module.  Most likely this\x0d\n          // was intended to keep .bin/ binaries working\x2C as following those\x0d\n          // symlinks is usually required for the imports in the corresponding\x0d\n          // files to resolve; that said\x2C in some use cases following symlinks\x0d\n          // causes bigger problems which is why the preserveSymlinksMain option\x0d\n          // is needed.\x0d\n          filename = path.resolve(basePath);\x0d\n        } else {\x0d\n          filename = toRealPath(basePath);\x0d\n        }\x0d\n      }\x0d\n\x0d\n      if (!filename) {\x0d\n        // Try it with each of the extensions\x0d\n        if (exts === undefined)\x0d\n          exts = ObjectKeys(Module._extensions);\x0d\n        filename = tryExtensions(basePath\x2C exts\x2C isMain);\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (!filename && rc === 1) {  // Directory.\x0d\n      // try it with each of the extensions at "index"\x0d\n      if (exts === undefined)\x0d\n        exts = ObjectKeys(Module._extensions);\x0d\n      filename = tryPackage(basePath\x2C exts\x2C isMain\x2C request);\x0d\n    }\x0d\n\x0d\n    if (filename) {\x0d\n      Module._pathCache[cacheKey] = filename;\x0d\n      return filename;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return false;\x0d\n};\x0d\n\x0d\n// 'node_modules' character codes reversed\x0d\nconst nmChars = [ 115\x2C 101\x2C 108\x2C 117\x2C 100\x2C 111\x2C 109\x2C 95\x2C 101\x2C 100\x2C 111\x2C 110 ];\x0d\nconst nmLen = nmChars.length;\x0d\nif (isWindows) {\x0d\n  // 'from' is the __dirname of the module.\x0d\n  Module._nodeModulePaths = function(from) {\x0d\n    // Guarantee that 'from' is absolute.\x0d\n    from = path.resolve(from);\x0d\n\x0d\n    // note: this approach *only* works when the path is guaranteed\x0d\n    // to be absolute.  Doing a fully-edge-case-correct path.split\x0d\n    // that works on both Windows and Posix is non-trivial.\x0d\n\x0d\n    // return root node_modules when path is 'D:\\\\'.\x0d\n    // path.resolve will make sure from.length >=3 in Windows.\x0d\n    if (StringPrototypeCharCodeAt(from\x2C from.length - 1) ===\x0d\n          CHAR_BACKWARD_SLASH &&\x0d\n        StringPrototypeCharCodeAt(from\x2C from.length - 2) === CHAR_COLON)\x0d\n      return [from + 'node_modules'];\x0d\n\x0d\n    const paths = [];\x0d\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\x0d\n      const code = StringPrototypeCharCodeAt(from\x2C i);\x0d\n      // The path segment separator check ('\\' and '/') was used to get\x0d\n      // node_modules path for every path segment.\x0d\n      // Use colon as an extra condition since we can get node_modules\x0d\n      // path for drive root like 'C:\\node_modules' and don't need to\x0d\n      // parse drive name.\x0d\n      if (code === CHAR_BACKWARD_SLASH ||\x0d\n          code === CHAR_FORWARD_SLASH ||\x0d\n          code === CHAR_COLON) {\x0d\n        if (p !== nmLen)\x0d\n          ArrayPrototypePush(\x0d\n            paths\x2C\x0d\n            StringPrototypeSlice(from\x2C 0\x2C last) + '\\\\node_modules'\x0d\n          );\x0d\n        last = i;\x0d\n        p = 0;\x0d\n      } else if (p !== -1) {\x0d\n        if (nmChars[p] === code) {\x0d\n          ++p;\x0d\n        } else {\x0d\n          p = -1;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n\x0d\n    return paths;\x0d\n  };\x0d\n} else { // posix\x0d\n  // 'from' is the __dirname of the module.\x0d\n  Module._nodeModulePaths = function(from) {\x0d\n    // Guarantee that 'from' is absolute.\x0d\n    from = path.resolve(from);\x0d\n    // Return early not only to avoid unnecessary work\x2C but to *avoid* returning\x0d\n    // an array of two items for a root: [ '//node_modules'\x2C '/node_modules' ]\x0d\n    if (from === '/')\x0d\n      return ['/node_modules'];\x0d\n\x0d\n    // note: this approach *only* works when the path is guaranteed\x0d\n    // to be absolute.  Doing a fully-edge-case-correct path.split\x0d\n    // that works on both Windows and Posix is non-trivial.\x0d\n    const paths = [];\x0d\n    for (let i = from.length - 1\x2C p = 0\x2C last = from.length; i >= 0; --i) {\x0d\n      const code = StringPrototypeCharCodeAt(from\x2C i);\x0d\n      if (code === CHAR_FORWARD_SLASH) {\x0d\n        if (p !== nmLen)\x0d\n          ArrayPrototypePush(\x0d\n            paths\x2C\x0d\n            StringPrototypeSlice(from\x2C 0\x2C last) + '/node_modules'\x0d\n          );\x0d\n        last = i;\x0d\n        p = 0;\x0d\n      } else if (p !== -1) {\x0d\n        if (nmChars[p] === code) {\x0d\n          ++p;\x0d\n        } else {\x0d\n          p = -1;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n\x0d\n    // Append /node_modules to handle root paths.\x0d\n    ArrayPrototypePush(paths\x2C '/node_modules');\x0d\n\x0d\n    return paths;\x0d\n  };\x0d\n}\x0d\n\x0d\nModule._resolveLookupPaths = function(request\x2C parent) {\x0d\n  if (NativeModule.canBeRequiredByUsers(request)) {\x0d\n    debug('looking for %j in []'\x2C request);\x0d\n    return null;\x0d\n  }\x0d\n\x0d\n  // Check for node modules paths.\x0d\n  if (StringPrototypeCharAt(request\x2C 0) !== '.' ||\x0d\n      (request.length > 1 &&\x0d\n      StringPrototypeCharAt(request\x2C 1) !== '.' &&\x0d\n      StringPrototypeCharAt(request\x2C 1) !== '/' &&\x0d\n      (!isWindows || StringPrototypeCharAt(request\x2C 1) !== '\\\\'))) {\x0d\n\x0d\n    let paths = modulePaths;\x0d\n    if (parent?.paths?.length) {\x0d\n      paths = ArrayPrototypeConcat(parent.paths\x2C paths);\x0d\n    }\x0d\n\x0d\n    debug('looking for %j in %j'\x2C request\x2C paths);\x0d\n    return paths.length > 0 ? paths : null;\x0d\n  }\x0d\n\x0d\n  // In REPL\x2C parent.filename is null.\x0d\n  if (!parent || !parent.id || !parent.filename) {\x0d\n    // Make require('./path/to/foo') work - normally the path is taken\x0d\n    // from realpath(__filename) but in REPL there is no filename\x0d\n    const mainPaths = ['.'];\x0d\n\x0d\n    debug('looking for %j in %j'\x2C request\x2C mainPaths);\x0d\n    return mainPaths;\x0d\n  }\x0d\n\x0d\n  debug('RELATIVE: requested: %s from parent.id %s'\x2C request\x2C parent.id);\x0d\n\x0d\n  const parentDir = [path.dirname(parent.filename)];\x0d\n  debug('looking for %j'\x2C parentDir);\x0d\n  return parentDir;\x0d\n};\x0d\n\x0d\nfunction emitCircularRequireWarning(prop) {\x0d\n  process.emitWarning(\x0d\n    `Accessing non-existent property '${String(prop)}' of module exports ` +\x0d\n    'inside circular dependency'\x0d\n  );\x0d\n}\x0d\n\x0d\n// A Proxy that can be used as the prototype of a module.exports object and\x0d\n// warns when non-existent properties are accessed.\x0d\nconst CircularRequirePrototypeWarningProxy = new Proxy({}\x2C {\x0d\n  get(target\x2C prop) {\x0d\n    // Allow __esModule access in any case because it is used in the output\x0d\n    // of transpiled code to determine whether something comes from an\x0d\n    // ES module\x2C and is not used as a regular key of `module.exports`.\x0d\n    if (prop in target || prop === '__esModule') return target[prop];\x0d\n    emitCircularRequireWarning(prop);\x0d\n    return undefined;\x0d\n  }\x2C\x0d\n\x0d\n  getOwnPropertyDescriptor(target\x2C prop) {\x0d\n    if (ObjectPrototypeHasOwnProperty(target\x2C prop) || prop === '__esModule')\x0d\n      return ObjectGetOwnPropertyDescriptor(target\x2C prop);\x0d\n    emitCircularRequireWarning(prop);\x0d\n    return undefined;\x0d\n  }\x0d\n});\x0d\n\x0d\nfunction getExportsForCircularRequire(module) {\x0d\n  if (module.exports &&\x0d\n      !isProxy(module.exports) &&\x0d\n      ObjectGetPrototypeOf(module.exports) === ObjectPrototype &&\x0d\n      // Exclude transpiled ES6 modules / TypeScript code because those may\x0d\n      // employ unusual patterns for accessing 'module.exports'. That should\x0d\n      // be okay because ES6 modules have a different approach to circular\x0d\n      // dependencies anyway.\x0d\n      !module.exports.__esModule) {\x0d\n    // This is later unset once the module is done loading.\x0d\n    ObjectSetPrototypeOf(\x0d\n      module.exports\x2C CircularRequirePrototypeWarningProxy);\x0d\n  }\x0d\n\x0d\n  return module.exports;\x0d\n}\x0d\n\x0d\n// Check the cache for the requested file.\x0d\n// 1. If a module already exists in the cache: return its exports object.\x0d\n// 2. If the module is native: call\x0d\n//    `NativeModule.prototype.compileForPublicLoader()` and return the exports.\x0d\n// 3. Otherwise\x2C create a new module for the file and save it to the cache.\x0d\n//    Then have it load  the file contents before returning its exports\x0d\n//    object.\x0d\nModule._load = function(request\x2C parent\x2C isMain) {\x0d\n  let relResolveCacheIdentifier;\x0d\n  if (parent) {\x0d\n    debug('Module._load REQUEST %s parent: %s'\x2C request\x2C parent.id);\x0d\n    // Fast path for (lazy loaded) modules in the same directory. The indirect\x0d\n    // caching is required to allow cache invalidation without changing the old\x0d\n    // cache key names.\x0d\n    relResolveCacheIdentifier = `${parent.path}\\x00${request}`;\x0d\n    const filename = relativeResolveCache[relResolveCacheIdentifier];\x0d\n    if (filename !== undefined) {\x0d\n      const cachedModule = Module._cache[filename];\x0d\n      if (cachedModule !== undefined) {\x0d\n        updateChildren(parent\x2C cachedModule\x2C true);\x0d\n        if (!cachedModule.loaded)\x0d\n          return getExportsForCircularRequire(cachedModule);\x0d\n        return cachedModule.exports;\x0d\n      }\x0d\n      delete relativeResolveCache[relResolveCacheIdentifier];\x0d\n    }\x0d\n  }\x0d\n\x0d\n  const filename = Module._resolveFilename(request\x2C parent\x2C isMain);\x0d\n  if (StringPrototypeStartsWith(filename\x2C 'node:')) {\x0d\n    // Slice 'node:' prefix\x0d\n    const id = StringPrototypeSlice(filename\x2C 5);\x0d\n\x0d\n    const module = loadNativeModule(id\x2C request);\x0d\n    if (!module?.canBeRequiredByUsers) {\x0d\n      throw new ERR_UNKNOWN_BUILTIN_MODULE(filename);\x0d\n    }\x0d\n\x0d\n    return module.exports;\x0d\n  }\x0d\n\x0d\n  const cachedModule = Module._cache[filename];\x0d\n  if (cachedModule !== undefined) {\x0d\n    updateChildren(parent\x2C cachedModule\x2C true);\x0d\n    if (!cachedModule.loaded) {\x0d\n      const parseCachedModule = cjsParseCache.get(cachedModule);\x0d\n      if (!parseCachedModule || parseCachedModule.loaded)\x0d\n        return getExportsForCircularRequire(cachedModule);\x0d\n      parseCachedModule.loaded = true;\x0d\n    } else {\x0d\n      return cachedModule.exports;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  const mod = loadNativeModule(filename\x2C request);\x0d\n  if (mod?.canBeRequiredByUsers) return mod.exports;\x0d\n\x0d\n  // Don't call updateChildren()\x2C Module constructor already does.\x0d\n  const module = cachedModule || new Module(filename\x2C parent);\x0d\n\x0d\n  if (isMain) {\x0d\n    process.mainModule = module;\x0d\n    module.id = '.';\x0d\n  }\x0d\n\x0d\n  Module._cache[filename] = module;\x0d\n  if (parent !== undefined) {\x0d\n    relativeResolveCache[relResolveCacheIdentifier] = filename;\x0d\n  }\x0d\n\x0d\n  let threw = true;\x0d\n  try {\x0d\n    module.load(filename);\x0d\n    threw = false;\x0d\n  } finally {\x0d\n    if (threw) {\x0d\n      delete Module._cache[filename];\x0d\n      if (parent !== undefined) {\x0d\n        delete relativeResolveCache[relResolveCacheIdentifier];\x0d\n        const children = parent?.children;\x0d\n        if (ArrayIsArray(children)) {\x0d\n          const index = ArrayPrototypeIndexOf(children\x2C module);\x0d\n          if (index !== -1) {\x0d\n            ArrayPrototypeSplice(children\x2C index\x2C 1);\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n    } else if (module.exports &&\x0d\n               !isProxy(module.exports) &&\x0d\n               ObjectGetPrototypeOf(module.exports) ===\x0d\n                 CircularRequirePrototypeWarningProxy) {\x0d\n      ObjectSetPrototypeOf(module.exports\x2C ObjectPrototype);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return module.exports;\x0d\n};\x0d\n\x0d\nModule._resolveFilename = function(request\x2C parent\x2C isMain\x2C options) {\x0d\n  if (StringPrototypeStartsWith(request\x2C 'node:') ||\x0d\n      NativeModule.canBeRequiredByUsers(request)) {\x0d\n    return request;\x0d\n  }\x0d\n\x0d\n  let paths;\x0d\n\x0d\n  if (typeof options === 'object' && options !== null) {\x0d\n    if (ArrayIsArray(options.paths)) {\x0d\n      const isRelative = StringPrototypeStartsWith(request\x2C './') ||\x0d\n          StringPrototypeStartsWith(request\x2C '../') ||\x0d\n          ((isWindows && StringPrototypeStartsWith(request\x2C '.\\\\')) ||\x0d\n          StringPrototypeStartsWith(request\x2C '..\\\\'));\x0d\n\x0d\n      if (isRelative) {\x0d\n        paths = options.paths;\x0d\n      } else {\x0d\n        const fakeParent = new Module(''\x2C null);\x0d\n\x0d\n        paths = [];\x0d\n\x0d\n        for (let i = 0; i < options.paths.length; i++) {\x0d\n          const path = options.paths[i];\x0d\n          fakeParent.paths = Module._nodeModulePaths(path);\x0d\n          const lookupPaths = Module._resolveLookupPaths(request\x2C fakeParent);\x0d\n\x0d\n          for (let j = 0; j < lookupPaths.length; j++) {\x0d\n            if (!ArrayPrototypeIncludes(paths\x2C lookupPaths[j]))\x0d\n              ArrayPrototypePush(paths\x2C lookupPaths[j]);\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n    } else if (options.paths === undefined) {\x0d\n      paths = Module._resolveLookupPaths(request\x2C parent);\x0d\n    } else {\x0d\n      throw new ERR_INVALID_ARG_VALUE('options.paths'\x2C options.paths);\x0d\n    }\x0d\n  } else {\x0d\n    paths = Module._resolveLookupPaths(request\x2C parent);\x0d\n  }\x0d\n\x0d\n  if (parent?.filename) {\x0d\n    if (request[0] === '#') {\x0d\n      const pkg = readPackageScope(parent.filename) || {};\x0d\n      if (pkg.data?.imports != null) {\x0d\n        try {\x0d\n          return finalizeEsmResolution(\x0d\n            packageImportsResolve(request\x2C pathToFileURL(parent.filename)\x2C\x0d\n                                  cjsConditions)\x2C parent.filename\x2C\x0d\n            pkg.path);\x0d\n        } catch (e) {\x0d\n          if (e.code === 'ERR_MODULE_NOT_FOUND')\x0d\n            throw createEsmNotFoundErr(request);\x0d\n          throw e;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // Try module self resolution first\x0d\n  const parentPath = trySelfParentPath(parent);\x0d\n  const selfResolved = trySelf(parentPath\x2C request);\x0d\n  if (selfResolved) {\x0d\n    const cacheKey = request + '\\x00' +\x0d\n         (paths.length === 1 ? paths[0] : ArrayPrototypeJoin(paths\x2C '\\x00'));\x0d\n    Module._pathCache[cacheKey] = selfResolved;\x0d\n    return selfResolved;\x0d\n  }\x0d\n\x0d\n  // Look up the filename first\x2C since that's the cache key.\x0d\n  const filename = Module._findPath(request\x2C paths\x2C isMain\x2C false);\x0d\n  if (filename) return filename;\x0d\n  const requireStack = [];\x0d\n  for (let cursor = parent;\x0d\n    cursor;\x0d\n    cursor = moduleParentCache.get(cursor)) {\x0d\n    ArrayPrototypePush(requireStack\x2C cursor.filename || cursor.id);\x0d\n  }\x0d\n  let message = `Cannot find module '${request}'`;\x0d\n  if (requireStack.length > 0) {\x0d\n    message = message + '\\nRequire stack:\\n- ' +\x0d\n              ArrayPrototypeJoin(requireStack\x2C '\\n- ');\x0d\n  }\x0d\n  // eslint-disable-next-line no-restricted-syntax\x0d\n  const err = new Error(message);\x0d\n  err.code = 'MODULE_NOT_FOUND';\x0d\n  err.requireStack = requireStack;\x0d\n  throw err;\x0d\n};\x0d\n\x0d\nfunction finalizeEsmResolution(resolved\x2C parentPath\x2C pkgPath) {\x0d\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved))\x0d\n    throw new ERR_INVALID_MODULE_SPECIFIER(\x0d\n      resolved\x2C 'must not include encoded "/" or "\\\\" characters'\x2C parentPath);\x0d\n  const filename = fileURLToPath(resolved);\x0d\n  const actual = tryFile(filename);\x0d\n  if (actual)\x0d\n    return actual;\x0d\n  const err = createEsmNotFoundErr(filename\x2C\x0d\n                                   path.resolve(pkgPath\x2C 'package.json'));\x0d\n  throw err;\x0d\n}\x0d\n\x0d\nfunction createEsmNotFoundErr(request\x2C path) {\x0d\n  // eslint-disable-next-line no-restricted-syntax\x0d\n  const err = new Error(`Cannot find module '${request}'`);\x0d\n  err.code = 'MODULE_NOT_FOUND';\x0d\n  if (path)\x0d\n    err.path = path;\x0d\n  // TODO(BridgeAR): Add the requireStack as well.\x0d\n  return err;\x0d\n}\x0d\n\x0d\n// Given a file name\x2C pass it to the proper extension handler.\x0d\nModule.prototype.load = function(filename) {\x0d\n  debug('load %j for module %j'\x2C filename\x2C this.id);\x0d\n\x0d\n  assert(!this.loaded);\x0d\n  this.filename = filename;\x0d\n  this.paths = Module._nodeModulePaths(path.dirname(filename));\x0d\n\x0d\n  const extension = findLongestRegisteredExtension(filename);\x0d\n  // allow .mjs to be overridden\x0d\n  if (StringPrototypeEndsWith(filename\x2C '.mjs') && !Module._extensions['.mjs'])\x0d\n    throw new ERR_REQUIRE_ESM(filename\x2C true);\x0d\n\x0d\n  Module._extensions[extension](this\x2C filename);\x0d\n  this.loaded = true;\x0d\n\x0d\n  const esmLoader = asyncESM.esmLoader;\x0d\n  // Create module entry at load time to snapshot exports correctly\x0d\n  const exports = this.exports;\x0d\n  // Preemptively cache\x0d\n  if ((module?.module === undefined ||\x0d\n       module.module.getStatus() < kEvaluated) &&\x0d\n      !esmLoader.cjsCache.has(this))\x0d\n    esmLoader.cjsCache.set(this\x2C exports);\x0d\n};\x0d\n\x0d\n\x0d\n// Loads a module at the given file path. Returns that module's\x0d\n// `exports` property.\x0d\nModule.prototype.require = function(id) {\x0d\n  validateString(id\x2C 'id');\x0d\n  if (id === '') {\x0d\n    throw new ERR_INVALID_ARG_VALUE('id'\x2C id\x2C\x0d\n                                    'must be a non-empty string');\x0d\n  }\x0d\n  requireDepth++;\x0d\n  try {\x0d\n    return Module._load(id\x2C this\x2C /* isMain */ false);\x0d\n  } finally {\x0d\n    requireDepth--;\x0d\n  }\x0d\n};\x0d\n\x0d\n\x0d\n// Resolved path to process.argv[1] will be lazily placed here\x0d\n// (needed for setting breakpoint when called with --inspect-brk)\x0d\nlet resolvedArgv;\x0d\nlet hasPausedEntry = false;\x0d\n\x0d\nfunction wrapSafe(filename\x2C content\x2C cjsModuleInstance) {\x0d\n  if (patched) {\x0d\n    const wrapper = Module.wrap(content);\x0d\n    return vm.runInThisContext(wrapper\x2C {\x0d\n      filename\x2C\x0d\n      lineOffset: 0\x2C\x0d\n      displayErrors: true\x2C\x0d\n      importModuleDynamically: async (specifier\x2C _\x2C importAssertions) => {\x0d\n        const loader = asyncESM.esmLoader;\x0d\n        return loader.import(specifier\x2C normalizeReferrerURL(filename)\x2C\x0d\n                             importAssertions);\x0d\n      }\x2C\x0d\n    });\x0d\n  }\x0d\n  try {\x0d\n    return vm.compileFunction(content\x2C [\x0d\n      'exports'\x2C\x0d\n      'require'\x2C\x0d\n      'module'\x2C\x0d\n      '__filename'\x2C\x0d\n      '__dirname'\x2C\x0d\n    ]\x2C {\x0d\n      filename\x2C\x0d\n      importModuleDynamically(specifier\x2C _\x2C importAssertions) {\x0d\n        const loader = asyncESM.esmLoader;\x0d\n        return loader.import(specifier\x2C normalizeReferrerURL(filename)\x2C\x0d\n                             importAssertions);\x0d\n      }\x2C\x0d\n    });\x0d\n  } catch (err) {\x0d\n    if (process.mainModule === cjsModuleInstance)\x0d\n      enrichCJSError(err\x2C content);\x0d\n    throw err;\x0d\n  }\x0d\n}\x0d\n\x0d\n// Run the file contents in the correct scope or sandbox. Expose\x0d\n// the correct helper variables (require\x2C module\x2C exports) to\x0d\n// the file.\x0d\n// Returns exception\x2C if any.\x0d\nModule.prototype._compile = function(content\x2C filename) {\x0d\n  let moduleURL;\x0d\n  let redirects;\x0d\n  if (policy?.manifest) {\x0d\n    moduleURL = pathToFileURL(filename);\x0d\n    redirects = policy.manifest.getDependencyMapper(moduleURL);\x0d\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\x0d\n  }\x0d\n\x0d\n  maybeCacheSourceMap(filename\x2C content\x2C this);\x0d\n  const compiledWrapper = wrapSafe(filename\x2C content\x2C this);\x0d\n\x0d\n  let inspectorWrapper = null;\x0d\n  if (getOptionValue('--inspect-brk') && process._eval == null) {\x0d\n    if (!resolvedArgv) {\x0d\n      // We enter the repl if we're not given a filename argument.\x0d\n      if (process.argv[1]) {\x0d\n        try {\x0d\n          resolvedArgv = Module._resolveFilename(process.argv[1]\x2C null\x2C false);\x0d\n        } catch {\x0d\n          // We only expect this codepath to be reached in the case of a\x0d\n          // preloaded module (it will fail earlier with the main entry)\x0d\n          assert(ArrayIsArray(getOptionValue('--require')));\x0d\n        }\x0d\n      } else {\x0d\n        resolvedArgv = 'repl';\x0d\n      }\x0d\n    }\x0d\n\x0d\n    // Set breakpoint on module start\x0d\n    if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) {\x0d\n      hasPausedEntry = true;\x0d\n      inspectorWrapper = internalBinding('inspector').callAndPauseOnStart;\x0d\n    }\x0d\n  }\x0d\n  const dirname = path.dirname(filename);\x0d\n  const require = makeRequireFunction(this\x2C redirects);\x0d\n  let result;\x0d\n  const exports = this.exports;\x0d\n  const thisValue = exports;\x0d\n  const module = this;\x0d\n  if (requireDepth === 0) statCache = new SafeMap();\x0d\n  if (inspectorWrapper) {\x0d\n    result = inspectorWrapper(compiledWrapper\x2C thisValue\x2C exports\x2C\x0d\n                              require\x2C module\x2C filename\x2C dirname);\x0d\n  } else {\x0d\n    result = ReflectApply(compiledWrapper\x2C thisValue\x2C\x0d\n                          [exports\x2C require\x2C module\x2C filename\x2C dirname]);\x0d\n  }\x0d\n  hasLoadedAnyUserCJSModule = true;\x0d\n  if (requireDepth === 0) statCache = null;\x0d\n  return result;\x0d\n};\x0d\n\x0d\n// Native extension for .js\x0d\nModule._extensions['.js'] = function(module\x2C filename) {\x0d\n  // If already analyzed the source\x2C then it will be cached.\x0d\n  const cached = cjsParseCache.get(module);\x0d\n  let content;\x0d\n  if (cached?.source) {\x0d\n    content = cached.source;\x0d\n    cached.source = undefined;\x0d\n  } else {\x0d\n    content = fs.readFileSync(filename\x2C 'utf8');\x0d\n  }\x0d\n  if (StringPrototypeEndsWith(filename\x2C '.js')) {\x0d\n    const pkg = readPackageScope(filename);\x0d\n    // Function require shouldn't be used in ES modules.\x0d\n    if (pkg?.data?.type === 'module') {\x0d\n      const parent = moduleParentCache.get(module);\x0d\n      const parentPath = parent?.filename;\x0d\n      const packageJsonPath = path.resolve(pkg.path\x2C 'package.json');\x0d\n      const usesEsm = hasEsmSyntax(content);\x0d\n      const err = new ERR_REQUIRE_ESM(filename\x2C usesEsm\x2C parentPath\x2C\x0d\n                                      packageJsonPath);\x0d\n      // Attempt to reconstruct the parent require frame.\x0d\n      if (Module._cache[parentPath]) {\x0d\n        let parentSource;\x0d\n        try {\x0d\n          parentSource = fs.readFileSync(parentPath\x2C 'utf8');\x0d\n        } catch {}\x0d\n        if (parentSource) {\x0d\n          const errLine = StringPrototypeSplit(\x0d\n            StringPrototypeSlice(err.stack\x2C StringPrototypeIndexOf(\x0d\n              err.stack\x2C '    at '))\x2C '\\n'\x2C 1)[0];\x0d\n          const { 1: line\x2C 2: col } =\x0d\n              RegExpPrototypeExec(/(\\d+):(\\d+)\\)/\x2C errLine) || [];\x0d\n          if (line && col) {\x0d\n            const srcLine = StringPrototypeSplit(parentSource\x2C '\\n')[line - 1];\x0d\n            const frame = `${parentPath}:${line}\\n${srcLine}\\n${\x0d\n              StringPrototypeRepeat(' '\x2C col - 1)}^\\n`;\x0d\n            setArrowMessage(err\x2C frame);\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n      throw err;\x0d\n    }\x0d\n  }\x0d\n  module._compile(content\x2C filename);\x0d\n};\x0d\n\x0d\n\x0d\n// Native extension for .json\x0d\nModule._extensions['.json'] = function(module\x2C filename) {\x0d\n  const content = fs.readFileSync(filename\x2C 'utf8');\x0d\n\x0d\n  if (policy?.manifest) {\x0d\n    const moduleURL = pathToFileURL(filename);\x0d\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\x0d\n  }\x0d\n\x0d\n  try {\x0d\n    module.exports = JSONParse(stripBOM(content));\x0d\n  } catch (err) {\x0d\n    err.message = filename + ': ' + err.message;\x0d\n    throw err;\x0d\n  }\x0d\n};\x0d\n\x0d\n\x0d\n// Native extension for .node\x0d\nModule._extensions['.node'] = function(module\x2C filename) {\x0d\n  if (policy?.manifest) {\x0d\n    const content = fs.readFileSync(filename);\x0d\n    const moduleURL = pathToFileURL(filename);\x0d\n    policy.manifest.assertIntegrity(moduleURL\x2C content);\x0d\n  }\x0d\n  // Be aware this doesn't use `content`\x0d\n  return process.dlopen(module\x2C path.toNamespacedPath(filename));\x0d\n};\x0d\n\x0d\nfunction createRequireFromPath(filename) {\x0d\n  // Allow a directory to be passed as the filename\x0d\n  const trailingSlash =\x0d\n    StringPrototypeEndsWith(filename\x2C '/') ||\x0d\n    (isWindows && StringPrototypeEndsWith(filename\x2C '\\\\'));\x0d\n\x0d\n  const proxyPath = trailingSlash ?\x0d\n    path.join(filename\x2C 'noop.js') :\x0d\n    filename;\x0d\n\x0d\n  const m = new Module(proxyPath);\x0d\n  m.filename = proxyPath;\x0d\n\x0d\n  m.paths = Module._nodeModulePaths(m.path);\x0d\n  return makeRequireFunction(m\x2C null);\x0d\n}\x0d\n\x0d\nconst createRequireError = 'must be a file URL object\x2C file URL string\x2C or ' +\x0d\n  'absolute path string';\x0d\n\x0d\nfunction createRequire(filename) {\x0d\n  let filepath;\x0d\n\x0d\n  if (isURLInstance(filename) ||\x0d\n      (typeof filename === 'string' && !path.isAbsolute(filename))) {\x0d\n    try {\x0d\n      filepath = fileURLToPath(filename);\x0d\n    } catch {\x0d\n      throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C\x0d\n                                      createRequireError);\x0d\n    }\x0d\n  } else if (typeof filename !== 'string') {\x0d\n    throw new ERR_INVALID_ARG_VALUE('filename'\x2C filename\x2C createRequireError);\x0d\n  } else {\x0d\n    filepath = filename;\x0d\n  }\x0d\n  return createRequireFromPath(filepath);\x0d\n}\x0d\n\x0d\nModule.createRequire = createRequire;\x0d\n\x0d\nModule._initPaths = function() {\x0d\n  const homeDir = isWindows ? process.env.USERPROFILE : safeGetenv('HOME');\x0d\n  const nodePath = isWindows ? process.env.NODE_PATH : safeGetenv('NODE_PATH');\x0d\n\x0d\n  // process.execPath is $PREFIX/bin/node except on Windows where it is\x0d\n  // $PREFIX\\node.exe where $PREFIX is the root of the Node.js installation.\x0d\n  const prefixDir = isWindows ?\x0d\n    path.resolve(process.execPath\x2C '..') :\x0d\n    path.resolve(process.execPath\x2C '..'\x2C '..');\x0d\n\x0d\n  const paths = [path.resolve(prefixDir\x2C 'lib'\x2C 'node')];\x0d\n\x0d\n  if (homeDir) {\x0d\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_libraries'));\x0d\n    ArrayPrototypeUnshift(paths\x2C path.resolve(homeDir\x2C '.node_modules'));\x0d\n  }\x0d\n\x0d\n  if (nodePath) {\x0d\n    ArrayPrototypeUnshiftApply(paths\x2C ArrayPrototypeFilter(\x0d\n      StringPrototypeSplit(nodePath\x2C path.delimiter)\x2C\x0d\n      Boolean\x0d\n    ));\x0d\n  }\x0d\n\x0d\n  modulePaths = paths;\x0d\n\x0d\n  // Clone as a shallow copy\x2C for introspection.\x0d\n  Module.globalPaths = ArrayPrototypeSlice(modulePaths);\x0d\n};\x0d\n\x0d\nModule._preloadModules = function(requests) {\x0d\n  if (!ArrayIsArray(requests))\x0d\n    return;\x0d\n\x0d\n  isPreloading = true;\x0d\n\x0d\n  // Preloaded modules have a dummy parent module which is deemed to exist\x0d\n  // in the current working directory. This seeds the search path for\x0d\n  // preloaded modules.\x0d\n  const parent = new Module('internal/preload'\x2C null);\x0d\n  try {\x0d\n    parent.paths = Module._nodeModulePaths(process.cwd());\x0d\n  } catch (e) {\x0d\n    if (e.code !== 'ENOENT') {\x0d\n      isPreloading = false;\x0d\n      throw e;\x0d\n    }\x0d\n  }\x0d\n  for (let n = 0; n < requests.length; n++)\x0d\n    parent.require(requests[n]);\x0d\n  isPreloading = false;\x0d\n};\x0d\n\x0d\nModule.syncBuiltinESMExports = function syncBuiltinESMExports() {\x0d\n  for (const mod of NativeModule.map.values()) {\x0d\n    if (mod.canBeRequiredByUsers) {\x0d\n      mod.syncExports();\x0d\n    }\x0d\n  }\x0d\n};\x0d\n\x0d\n// Backwards compatibility\x0d\nModule.Module = Module;\x0d\n
code-source-info,0x1abee823dae,103,0,41352,C0O0C4O41352,,
code-creation,Function,10,190274,0x1abee825b4e,2547, node:internal/modules/cjs/loader:1:1,0x1abee823d28,~
code-source-info,0x1abee825b4e,103,0,41352,C0O0C446O1183C452O1200C458O1225C464O1250C470O1277C476O1303C482O1326C488O1349C494O1373C500O1398C506O1424C512O1455C518O1467C524O1477C530O1491C535O1508C541O1533C546O1550C552O1585C558O1610C564O1625C570O1645C576O1679C582O1704C587O1714C593O1731C599O1746C605O1770C611O1794C617O1806C622O1822C628O1833C634O1859C640O1889C646O1917C652O1948C658O1975C664O2000C670O2026C676O2051C682O2076C688O2186C690O2186C695O2186C697O2262C709O2284C715O2294C721O2302C727O2314C733O2332C763O2277C767O2452C771O2452C777O2435C783O2529C787O2529C793O2503C799O2635C803O2635C809O2587C815O2602C821O2617C827O2683C831O2683C837O2669C842O2721C846O2721C850O2721C852O2752C856O2752C860O2752C862O2792C866O2792C870O2792C872O2827C876O2827C880O2827C882O2871C886O2871C890O2871C892O2905C896O2897C902O2943C910O2943C916O2920C922O2993C926O2993C930O2993C932O3066C940O3066C946O3051C952O3230C956O3230C962O3110C968O3128C974O3145C980O3166C986O3190C992O3215C998O3299C1002O3299C1008O3280C1014O3354C1022O3354C1026O3354C1028O3423C1036O3423C1040O3423C1042O3535C1050O3535C1060O3580C1067O3535C1069O3765C1070O3765C1072O3944C1076O3944C1082O3944C1088O3800C1094O3828C1100O3863C1106O3885C1112O3922C1118O4000C1122O4000C1128O3981C1134O4060C1142O4060C1147O4178C1151O4178C1157O4115C1163O4138C1169O4162C1175O4236C1179O4236C1185O4223C1191O4288C1195O4288C1199O4288C1201O4356C1205O4356C1211O4337C1217O4425C1225O4425C1231O4410C1237O4542C1241O4542C1247O4469C1253O4489C1259O4515C1265O4604C1269O4612C1277O4621C1280O4604C1282O4666C1285O4666C1289O4666C1291O4708C1292O4708C1294O4728C1295O4728C1297O4754C1298O4754C1300O5420C1302O5420C1307O5420C1309O5728C1312O5778C1316O5778C1350O5760C1381O5749C1388O5756C1397O5796C1403O5825C1407O5825C1412O5733C1483O5876C1487O5907C1493O5929C1497O5950C1504O5966C1508O5964C1512O5987C1519O6007C1527O6005C1535O6028C1542O6049C1550O6047C1558O6088C1562O6088C1564O6093C1572O6112C1580O6135C1581O6135C1583O6196C1587O6196C1589O6296C1597O6415C1606O6429C1618O6561C1635O6405C1645O6405C1647O6706C1659O6727C1668O6748C1680O6785C1692O6706C1702O6851C1714O6872C1723O6896C1735O6941C1747O6851C1757O7040C1766O7042C1781O7077C1789O7105C1806O7077C1816O7152C1824O7186C1841O7152C1851O7388C1859O7416C1884O7447C1892O7572C1907O7468C1921O7656C1931O7681C1939O7806C1954O7702C1968O7890C1976O7388C1986O7927C1990O7927C2000O7960C2020O7961C2032O7927C2034O8011C2050O8027C2060O8025C2068O8353C2072O8353C2082O8353C2084O11246C2088O11246C2098O11246C2100O13959C2107O13959C2109O14756C2116O14756C2118O14775C2126O14792C2134O17553C2141O17553C2143O17631C2147O17639C2155O17631C2157O17648C2161O17713C2169O17737C2179O19367C2187O19391C2195O20575C2203O20602C2211O22198C2223O22217C2235O22603C2249O22198C2259O22198C2261O23923C2269O23936C2277O26958C2285O26982C2293O30944C2297O30951C2311O30966C2319O31908C2323O31915C2337O31933C2345O32388C2346O32388C2348O32424C2349O32424C2351O33659C2355O33666C2369O33685C2377O35622C2381O35629C2395O35648C2403O37440C2407O37447C2421O37468C2429O37886C2433O37893C2447O37914C2455O38754C2461O38804C2467O38754C2469O39410C2475O39431C2483O39451C2491O39469C2499O40468C2507O40491C2515O41101C2523O41130C2531O41327C2537O41341C2546O41351,,
code-creation,Eval,10,190790,0x1abee829b8e,5, node:internal/modules/package_json_reader:1:1,0x1abee8299e8,~
script-source,104,node:internal/modules/package_json_reader,'use strict';\x0d\n\x0d\nconst { SafeMap } = primordials;\x0d\nconst { internalModuleReadJSON } = internalBinding('fs');\x0d\nconst { pathToFileURL } = require('url');\x0d\nconst { toNamespacedPath } = require('path');\x0d\n\x0d\nconst cache = new SafeMap();\x0d\n\x0d\nlet manifest;\x0d\n\x0d\n/**\x0d\n *\x0d\n * @param {string} jsonPath\x0d\n */\x0d\nfunction read(jsonPath) {\x0d\n  if (cache.has(jsonPath)) {\x0d\n    return cache.get(jsonPath);\x0d\n  }\x0d\n\x0d\n  const { 0: string\x2C 1: containsKeys } = internalModuleReadJSON(\x0d\n    toNamespacedPath(jsonPath)\x0d\n  );\x0d\n  const result = { string\x2C containsKeys };\x0d\n  const { getOptionValue } = require('internal/options');\x0d\n  if (string !== undefined) {\x0d\n    if (manifest === undefined) {\x0d\n      manifest = getOptionValue('--experimental-policy') ?\x0d\n        require('internal/process/policy').manifest :\x0d\n        null;\x0d\n    }\x0d\n    if (manifest !== null) {\x0d\n      const jsonURL = pathToFileURL(jsonPath);\x0d\n      manifest.assertIntegrity(jsonURL\x2C string);\x0d\n    }\x0d\n  }\x0d\n  cache.set(jsonPath\x2C result);\x0d\n  return result;\x0d\n}\x0d\n\x0d\nmodule.exports = { read };\x0d\n
code-source-info,0x1abee829b8e,104,0,1024,C0O0C4O1024,,
code-creation,Function,10,190876,0x1abee829cde,113, node:internal/modules/package_json_reader:1:1,0x1abee829b08,~
code-source-info,0x1abee829cde,104,0,1024,C0O0C29O25C34O86C37O86C42O59C48O136C54O136C59O118C65O182C71O182C76O161C82O216C84O216C89O216C91O238C92O238C94O996C101O1015C107O1011C112O1023,,
code-creation,Eval,10,191056,0x1abee82a4ae,5, node:internal/process/esm_loader:1:1,0x1abee82a2b8,~
script-source,105,node:internal/process/esm_loader,'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectCreate\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING\x2C\x0d\n} = require('internal/errors').codes;\x0d\nconst { ESMLoader } = require('internal/modules/esm/loader');\x0d\nconst {\x0d\n  hasUncaughtExceptionCaptureCallback\x2C\x0d\n} = require('internal/process/execution');\x0d\nconst { pathToFileURL } = require('internal/url');\x0d\nconst {\x0d\n  getModuleFromWrap\x2C\x0d\n} = require('internal/vm/module');\x0d\n\x0d\nexports.initializeImportMetaObject = function(wrap\x2C meta) {\x0d\n  const { callbackMap } = internalBinding('module_wrap');\x0d\n  if (callbackMap.has(wrap)) {\x0d\n    const { initializeImportMeta } = callbackMap.get(wrap);\x0d\n    if (initializeImportMeta !== undefined) {\x0d\n      initializeImportMeta(meta\x2C getModuleFromWrap(wrap) || wrap);\x0d\n    }\x0d\n  }\x0d\n};\x0d\n\x0d\nexports.importModuleDynamicallyCallback =\x0d\nasync function importModuleDynamicallyCallback(wrap\x2C specifier\x2C assertions) {\x0d\n  const { callbackMap } = internalBinding('module_wrap');\x0d\n  if (callbackMap.has(wrap)) {\x0d\n    const { importModuleDynamically } = callbackMap.get(wrap);\x0d\n    if (importModuleDynamically !== undefined) {\x0d\n      return importModuleDynamically(\x0d\n        specifier\x2C getModuleFromWrap(wrap) || wrap\x2C assertions);\x0d\n    }\x0d\n  }\x0d\n  throw new ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING();\x0d\n};\x0d\n\x0d\nconst esmLoader = new ESMLoader();\x0d\n\x0d\nexports.esmLoader = esmLoader;\x0d\n\x0d\n/**\x0d\n * Causes side-effects: user-defined loader hooks are added to esmLoader.\x0d\n * @returns {void}\x0d\n */\x0d\nasync function initializeLoader() {\x0d\n  const { getOptionValue } = require('internal/options');\x0d\n  // customLoaders CURRENTLY can be only 1 (a string)\x0d\n  // Once chaining is implemented\x2C it will be string[]\x0d\n  const customLoaders = getOptionValue('--experimental-loader');\x0d\n\x0d\n  if (!customLoaders.length) return;\x0d\n\x0d\n  const { emitExperimentalWarning } = require('internal/util');\x0d\n  emitExperimentalWarning('--experimental-loader');\x0d\n\x0d\n  let cwd;\x0d\n  try {\x0d\n    cwd = process.cwd() + '/';\x0d\n  } catch {\x0d\n    cwd = 'file:///';\x0d\n  }\x0d\n\x0d\n  // A separate loader instance is necessary to avoid cross-contamination\x0d\n  // between internal Node.js and userland. For example\x2C a module with internal\x0d\n  // state (such as a counter) should be independent.\x0d\n  const internalEsmLoader = new ESMLoader();\x0d\n\x0d\n  // Importation must be handled by internal loader to avoid poluting userland\x0d\n  const exports = await internalEsmLoader.import(\x0d\n    customLoaders\x2C\x0d\n    pathToFileURL(cwd).href\x2C\x0d\n    ObjectCreate(null)\x2C\x0d\n  );\x0d\n\x0d\n  // Hooks must then be added to external/public loader\x0d\n  // (so they're triggered in userland)\x0d\n  await esmLoader.addCustomLoaders(exports);\x0d\n}\x0d\n\x0d\nexports.loadESM = async function loadESM(callback) {\x0d\n  try {\x0d\n    await initializeLoader();\x0d\n    await callback(esmLoader);\x0d\n  } catch (err) {\x0d\n    if (hasUncaughtExceptionCaptureCallback()) {\x0d\n      process._fatalException(err);\x0d\n      return;\x0d\n    }\x0d\n    internalBinding('errors').triggerUncaughtException(\x0d\n      err\x2C\x0d\n      true /* fromPromise */\x0d\n    );\x0d\n  }\x0d\n};\x0d\n
code-source-info,0x1abee82a4ae,105,0,2982,C0O0C4O2982,,
code-creation,Function,10,191272,0x1abee82a74e,182, node:internal/process/esm_loader:1:1,0x1abee82a428,~
code-source-info,0x1abee82a74e,105,0,2982,C0O0C44O28C50O119C56O119C61O145C66O74C72O176C78O176C83O162C89O270C95O270C100O228C106O336C112O336C117O318C123O397C129O397C134O373C140O431C144O466C148O777C152O817C156O1300C159O1300C164O1300C166O1320C168O1338C172O2612C176O2628C181O2981,,
code-creation,Eval,10,191667,0x1abee82b9ee,5, node:internal/modules/esm/loader:1:1,0x1abee82b590,~
script-source,106,node:internal/modules/esm/loader,'use strict';\x0d\n\x0d\n// This is needed to avoid cycles in esm/resolve <-> cjs/loader\x0d\nrequire('internal/modules/cjs/loader');\x0d\n\x0d\nconst {\x0d\n  Array\x2C\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  FunctionPrototypeBind\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  ObjectAssign\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  PromiseAll\x2C\x0d\n  RegExpPrototypeExec\x2C\x0d\n  SafeArrayIterator\x2C\x0d\n  SafeWeakMap\x2C\x0d\n  globalThis\x2C\x0d\n} = primordials;\x0d\nconst { MessageChannel } = require('internal/worker/io');\x0d\n\x0d\nconst {\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n  ERR_INVALID_ARG_VALUE\x2C\x0d\n  ERR_INVALID_MODULE_SPECIFIER\x2C\x0d\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x2C\x0d\n  ERR_INVALID_RETURN_VALUE\x2C\x0d\n  ERR_UNKNOWN_MODULE_FORMAT\x0d\n} = require('internal/errors').codes;\x0d\nconst { pathToFileURL\x2C isURLInstance } = require('internal/url');\x0d\nconst {\x0d\n  isAnyArrayBuffer\x2C\x0d\n  isArrayBufferView\x2C\x0d\n} = require('internal/util/types');\x0d\nconst ModuleMap = require('internal/modules/esm/module_map');\x0d\nconst ModuleJob = require('internal/modules/esm/module_job');\x0d\n\x0d\nconst {\x0d\n  defaultResolve\x2C\x0d\n  DEFAULT_CONDITIONS\x2C\x0d\n} = require('internal/modules/esm/resolve');\x0d\nconst {\x0d\n  initializeImportMeta\x0d\n} = require('internal/modules/esm/initialize_import_meta');\x0d\nconst { defaultLoad } = require('internal/modules/esm/load');\x0d\nconst { translators } = require(\x0d\n  'internal/modules/esm/translators');\x0d\nconst { getOptionValue } = require('internal/options');\x0d\n\x0d\n/**\x0d\n * An ESMLoader instance is used as the main entry point for loading ES modules.\x0d\n * Currently\x2C this is a singleton -- there is only one used for loading\x0d\n * the main module and everything in its dependency graph.\x0d\n */\x0d\nclass ESMLoader {\x0d\n  /**\x0d\n   * Prior to ESM loading. These are called once before any modules are started.\x0d\n   * @private\x0d\n   * @property {Function[]} globalPreloaders First-in-first-out list of\x0d\n   * preload hooks.\x0d\n   */\x0d\n  #globalPreloaders = [];\x0d\n\x0d\n  /**\x0d\n   * Phase 2 of 2 in ESM loading.\x0d\n   * @private\x0d\n   * @property {Function[]} loaders First-in-first-out list of loader hooks.\x0d\n   */\x0d\n  #loaders = [\x0d\n    defaultLoad\x2C\x0d\n  ];\x0d\n\x0d\n  /**\x0d\n   * Phase 1 of 2 in ESM loading.\x0d\n   * @private\x0d\n   * @property {Function[]} resolvers First-in-first-out list of resolver hooks\x0d\n   */\x0d\n  #resolvers = [\x0d\n    defaultResolve\x2C\x0d\n  ];\x0d\n\x0d\n  #importMetaInitializer = initializeImportMeta;\x0d\n\x0d\n  /**\x0d\n   * Map of already-loaded CJS modules to use\x0d\n   */\x0d\n  cjsCache = new SafeWeakMap();\x0d\n\x0d\n  /**\x0d\n   * The index for assigning unique URLs to anonymous module evaluation\x0d\n   */\x0d\n  evalIndex = 0;\x0d\n\x0d\n  /**\x0d\n   * Registry of loaded modules\x2C akin to `require.cache`\x0d\n   */\x0d\n  moduleMap = new ModuleMap();\x0d\n\x0d\n  /**\x0d\n   * Methods which translate input code or other information into ES modules\x0d\n   */\x0d\n  translators = translators;\x0d\n\x0d\n  static pluckHooks({\x0d\n    globalPreload\x2C\x0d\n    resolve\x2C\x0d\n    load\x2C\x0d\n    // obsolete hooks:\x0d\n    dynamicInstantiate\x2C\x0d\n    getFormat\x2C\x0d\n    getGlobalPreloadCode\x2C\x0d\n    getSource\x2C\x0d\n    transformSource\x2C\x0d\n  }) {\x0d\n    const obsoleteHooks = [];\x0d\n    const acceptedHooks = ObjectCreate(null);\x0d\n\x0d\n    if (getGlobalPreloadCode) {\x0d\n      globalPreload ??= getGlobalPreloadCode;\x0d\n\x0d\n      process.emitWarning(\x0d\n        'Loader hook "getGlobalPreloadCode" has been renamed to "globalPreload"'\x0d\n      );\x0d\n    }\x0d\n    if (dynamicInstantiate) ArrayPrototypePush(\x0d\n      obsoleteHooks\x2C\x0d\n      'dynamicInstantiate'\x0d\n    );\x0d\n    if (getFormat) ArrayPrototypePush(\x0d\n      obsoleteHooks\x2C\x0d\n      'getFormat'\x2C\x0d\n    );\x0d\n    if (getSource) ArrayPrototypePush(\x0d\n      obsoleteHooks\x2C\x0d\n      'getSource'\x2C\x0d\n    );\x0d\n    if (transformSource) ArrayPrototypePush(\x0d\n      obsoleteHooks\x2C\x0d\n      'transformSource'\x2C\x0d\n    );\x0d\n\x0d\n    if (obsoleteHooks.length) process.emitWarning(\x0d\n      `Obsolete loader hook(s) supplied and will be ignored: ${\x0d\n        ArrayPrototypeJoin(obsoleteHooks\x2C '\x2C ')\x0d\n      }`\x2C\x0d\n      'DeprecationWarning'\x2C\x0d\n    );\x0d\n\x0d\n    // Use .bind() to avoid giving access to the Loader instance when called.\x0d\n    if (globalPreload) {\x0d\n      acceptedHooks.globalPreloader =\x0d\n        FunctionPrototypeBind(globalPreload\x2C null);\x0d\n    }\x0d\n    if (resolve) {\x0d\n      acceptedHooks.resolver = FunctionPrototypeBind(resolve\x2C null);\x0d\n    }\x0d\n    if (load) {\x0d\n      acceptedHooks.loader = FunctionPrototypeBind(load\x2C null);\x0d\n    }\x0d\n\x0d\n    return acceptedHooks;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * Collect custom/user-defined hook(s). After all hooks have been collected\x2C\x0d\n   * calls global preload hook(s).\x0d\n   * @param {object | object[]} customLoaders A list of exports from\x0d\n   * user-defined loaders (as returned by ESMLoader.import()).\x0d\n   */\x0d\n  async addCustomLoaders(\x0d\n    customLoaders = []\x2C\x0d\n  ) {\x0d\n    if (!ArrayIsArray(customLoaders)) customLoaders = [customLoaders];\x0d\n\x0d\n    for (let i = 0; i < customLoaders.length; i++) {\x0d\n      const exports = customLoaders[i];\x0d\n      const {\x0d\n        globalPreloader\x2C\x0d\n        resolver\x2C\x0d\n        loader\x2C\x0d\n      } = ESMLoader.pluckHooks(exports);\x0d\n\x0d\n      if (globalPreloader) ArrayPrototypePush(\x0d\n        this.#globalPreloaders\x2C\x0d\n        FunctionPrototypeBind(globalPreloader\x2C null)\x2C // [1]\x0d\n      );\x0d\n      if (resolver) ArrayPrototypePush(\x0d\n        this.#resolvers\x2C\x0d\n        FunctionPrototypeBind(resolver\x2C null)\x2C // [1]\x0d\n      );\x0d\n      if (loader) ArrayPrototypePush(\x0d\n        this.#loaders\x2C\x0d\n        FunctionPrototypeBind(loader\x2C null)\x2C // [1]\x0d\n      );\x0d\n    }\x0d\n\x0d\n    // [1] ensure hook function is not bound to ESMLoader instance\x0d\n\x0d\n    this.preload();\x0d\n  }\x0d\n\x0d\n  async eval(\x0d\n    source\x2C\x0d\n    url = pathToFileURL(`${process.cwd()}/[eval${++this.evalIndex}]`).href\x0d\n  ) {\x0d\n    const evalInstance = (url) => {\x0d\n      const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\x0d\n      const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\x0d\n      callbackMap.set(module\x2C {\x0d\n        importModuleDynamically: (specifier\x2C { url }\x2C importAssertions) => {\x0d\n          return this.import(specifier\x2C url\x2C importAssertions);\x0d\n        }\x0d\n      });\x0d\n\x0d\n      return module;\x0d\n    };\x0d\n    const job = new ModuleJob(\x0d\n      this\x2C url\x2C undefined\x2C evalInstance\x2C false\x2C false);\x0d\n    this.moduleMap.set(url\x2C undefined\x2C job);\x0d\n    const { module } = await job.run();\x0d\n\x0d\n    return {\x0d\n      namespace: module.getNamespace()\x2C\x0d\n    };\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * Get a (possibly still pending) module job from the cache\x2C\x0d\n   * or create one and return its Promise.\x0d\n   * @param {string} specifier The string after `from` in an `import` statement\x2C\x0d\n   *                           or the first parameter of an `import()`\x0d\n   *                           expression\x0d\n   * @param {string | undefined} parentURL The URL of the module importing this\x0d\n   *                                     one\x2C unless this is the Node.js entry\x0d\n   *                                     point.\x0d\n   * @param {Record<string\x2C string>} importAssertions Validations for the\x0d\n   *                                                  module import.\x0d\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\x0d\n   */\x0d\n  async getModuleJob(specifier\x2C parentURL\x2C importAssertions) {\x0d\n    let importAssertionsForResolve;\x0d\n    if (this.#loaders.length !== 1) {\x0d\n      // We can skip cloning if there are no user provided loaders because\x0d\n      // the Node.js default resolve hook does not use import assertions.\x0d\n      importAssertionsForResolve =\x0d\n        ObjectAssign(ObjectCreate(null)\x2C importAssertions);\x0d\n    }\x0d\n    const { format\x2C url } =\x0d\n      await this.resolve(specifier\x2C parentURL\x2C importAssertionsForResolve);\x0d\n\x0d\n    let job = this.moduleMap.get(url\x2C importAssertions.type);\x0d\n\x0d\n    // CommonJS will set functions for lazy job evaluation.\x0d\n    if (typeof job === 'function') {\x0d\n      this.moduleMap.set(url\x2C undefined\x2C job = job());\x0d\n    }\x0d\n\x0d\n    if (job === undefined) {\x0d\n      job = this.#createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format);\x0d\n    }\x0d\n\x0d\n    return job;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * Create and cache an object representing a loaded module.\x0d\n   * @param {string} url The absolute URL that was resolved for this module\x0d\n   * @param {Record<string\x2C string>} importAssertions Validations for the\x0d\n   *                                                  module import.\x0d\n   * @param {string} [parentURL] The absolute URL of the module importing this\x0d\n   *                             one\x2C unless this is the Node.js entry point\x0d\n   * @param {string} [format] The format hint possibly returned by the\x0d\n   *                          `resolve` hook\x0d\n   * @returns {Promise<ModuleJob>} The (possibly pending) module job\x0d\n   */\x0d\n  #createModuleJob(url\x2C importAssertions\x2C parentURL\x2C format) {\x0d\n    const moduleProvider = async (url\x2C isMain) => {\x0d\n      const { format: finalFormat\x2C source } = await this.load(\x0d\n        url\x2C { format\x2C importAssertions });\x0d\n\x0d\n      const translator = translators.get(finalFormat);\x0d\n\x0d\n      if (!translator) {\x0d\n        throw new ERR_UNKNOWN_MODULE_FORMAT(finalFormat);\x0d\n      }\x0d\n\x0d\n      return FunctionPrototypeCall(translator\x2C this\x2C url\x2C source\x2C isMain);\x0d\n    };\x0d\n\x0d\n    const inspectBrk = (\x0d\n      parentURL === undefined &&\x0d\n      getOptionValue('--inspect-brk')\x0d\n    );\x0d\n\x0d\n    const job = new ModuleJob(\x0d\n      this\x2C\x0d\n      url\x2C\x0d\n      importAssertions\x2C\x0d\n      moduleProvider\x2C\x0d\n      parentURL === undefined\x2C\x0d\n      inspectBrk\x0d\n    );\x0d\n\x0d\n    this.moduleMap.set(url\x2C importAssertions.type\x2C job);\x0d\n\x0d\n    return job;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * This method is usually called indirectly as part of the loading processes.\x0d\n   * Internally\x2C it is used directly to add loaders. Use directly with caution.\x0d\n   *\x0d\n   * This method must NOT be renamed: it functions as a dynamic import on a\x0d\n   * loader module.\x0d\n   *\x0d\n   * @param {string | string[]} specifiers Path(s) to the module.\x0d\n   * @param {string} parentURL Path of the parent importing the module.\x0d\n   * @param {Record<string\x2C string>} importAssertions Validations for the\x0d\n   *                                                  module import.\x0d\n   * @returns {Promise<object | object[]>} A list of module export(s).\x0d\n   */\x0d\n  async import(specifiers\x2C parentURL\x2C importAssertions) {\x0d\n    const wasArr = ArrayIsArray(specifiers);\x0d\n    if (!wasArr) specifiers = [specifiers];\x0d\n\x0d\n    const count = specifiers.length;\x0d\n    const jobs = new Array(count);\x0d\n\x0d\n    for (let i = 0; i < count; i++) {\x0d\n      jobs[i] = this.getModuleJob(specifiers[i]\x2C parentURL\x2C importAssertions)\x0d\n        .then((job) => job.run())\x0d\n        .then(({ module }) => module.getNamespace());\x0d\n    }\x0d\n\x0d\n    const namespaces = await PromiseAll(new SafeArrayIterator(jobs));\x0d\n\x0d\n    return wasArr ?\x0d\n      namespaces :\x0d\n      namespaces[0];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * Provide source that is understood by one of Node's translators.\x0d\n   *\x0d\n   * The internals of this WILL change when chaining is implemented\x2C\x0d\n   * depending on the resolution/consensus from #36954\x0d\n   * @param {string} url The URL/path of the module to be loaded\x0d\n   * @param {object} context Metadata about the module\x0d\n   * @returns {object}\x0d\n   */\x0d\n  async load(url\x2C context = {}) {\x0d\n    const defaultLoader = this.#loaders[0];\x0d\n\x0d\n    const loader = this.#loaders.length === 1 ?\x0d\n      defaultLoader :\x0d\n      this.#loaders[1];\x0d\n    const loaded = await loader(url\x2C context\x2C defaultLoader);\x0d\n\x0d\n    if (typeof loaded !== 'object') {\x0d\n      throw new ERR_INVALID_RETURN_VALUE(\x0d\n        'object'\x2C\x0d\n        'loader load'\x2C\x0d\n        loaded\x2C\x0d\n      );\x0d\n    }\x0d\n\x0d\n    const {\x0d\n      format\x2C\x0d\n      source\x2C\x0d\n    } = loaded;\x0d\n\x0d\n    if (format == null) {\x0d\n      const dataUrl = RegExpPrototypeExec(\x0d\n        /^data:([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\x0d\n        url\x2C\x0d\n      );\x0d\n\x0d\n      throw new ERR_INVALID_MODULE_SPECIFIER(\x0d\n        url\x2C\x0d\n        dataUrl ? `has an unsupported MIME type "${dataUrl[1]}"` : ''\x0d\n      );\x0d\n    }\x0d\n\x0d\n    if (typeof format !== 'string') {\x0d\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\x0d\n        'string'\x2C\x0d\n        'loader resolve'\x2C\x0d\n        'format'\x2C\x0d\n        format\x2C\x0d\n      );\x0d\n    }\x0d\n\x0d\n    if (\x0d\n      source != null &&\x0d\n      typeof source !== 'string' &&\x0d\n      !isAnyArrayBuffer(source) &&\x0d\n      !isArrayBufferView(source)\x0d\n    ) throw ERR_INVALID_RETURN_PROPERTY_VALUE(\x0d\n      'string\x2C an ArrayBuffer\x2C or a TypedArray'\x2C\x0d\n      'loader load'\x2C\x0d\n      'source'\x2C\x0d\n      source\x0d\n    );\x0d\n\x0d\n    return {\x0d\n      format\x2C\x0d\n      source\x2C\x0d\n    };\x0d\n  }\x0d\n\x0d\n  preload() {\x0d\n    const count = this.#globalPreloaders.length;\x0d\n    if (!count) return;\x0d\n\x0d\n    for (let i = 0; i < count; i++) {\x0d\n      const channel = new MessageChannel();\x0d\n      const {\x0d\n        port1: insidePreload\x2C\x0d\n        port2: insideLoader\x2C\x0d\n      } = channel;\x0d\n\x0d\n      insidePreload.unref();\x0d\n      insideLoader.unref();\x0d\n\x0d\n      const preload = this.#globalPreloaders[i]({\x0d\n        port: insideLoader\x0d\n      });\x0d\n\x0d\n      if (preload == null) return;\x0d\n\x0d\n      if (typeof preload !== 'string') {\x0d\n        throw new ERR_INVALID_RETURN_VALUE(\x0d\n          'string'\x2C\x0d\n          'loader globalPreloadCode'\x2C\x0d\n          preload\x2C\x0d\n        );\x0d\n      }\x0d\n      const { compileFunction } = require('vm');\x0d\n      const preloadInit = compileFunction(\x0d\n        preload\x2C\x0d\n        ['getBuiltin'\x2C 'port'\x2C 'setImportMetaCallback']\x2C\x0d\n        {\x0d\n          filename: '<preload>'\x2C\x0d\n        }\x0d\n      );\x0d\n      const { NativeModule } = require('internal/bootstrap/loaders');\x0d\n      // We only allow replacing the importMetaInitializer during preload\x2C\x0d\n      // after preload is finished\x2C we disable the ability to replace it\x0d\n      //\x0d\n      // This exposes accidentally setting the initializer too late by\x0d\n      // throwing an error.\x0d\n      let finished = false;\x0d\n      let replacedImportMetaInitializer = false;\x0d\n      let next = this.#importMetaInitializer;\x0d\n      try {\x0d\n        // Calls the compiled preload source text gotten from the hook\x0d\n        // Since the parameters are named we use positional parameters\x0d\n        // see compileFunction above to cross reference the names\x0d\n        FunctionPrototypeCall(\x0d\n          preloadInit\x2C\x0d\n          globalThis\x2C\x0d\n          // Param getBuiltin\x0d\n          (builtinName) => {\x0d\n            if (NativeModule.canBeRequiredByUsers(builtinName)) {\x0d\n              return require(builtinName);\x0d\n            }\x0d\n            throw new ERR_INVALID_ARG_VALUE('builtinName'\x2C builtinName);\x0d\n          }\x2C\x0d\n          // Param port\x0d\n          insidePreload\x2C\x0d\n          // Param setImportMetaCallback\x0d\n          (fn) => {\x0d\n            if (finished || typeof fn !== 'function') {\x0d\n              throw new ERR_INVALID_ARG_TYPE('fn'\x2C fn);\x0d\n            }\x0d\n            replacedImportMetaInitializer = true;\x0d\n            const parent = next;\x0d\n            next = (meta\x2C context) => {\x0d\n              return fn(meta\x2C context\x2C parent);\x0d\n            };\x0d\n          });\x0d\n      } finally {\x0d\n        finished = true;\x0d\n        if (replacedImportMetaInitializer) {\x0d\n          this.#importMetaInitializer = next;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  importMetaInitialize(meta\x2C context) {\x0d\n    this.#importMetaInitializer(meta\x2C context);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * Resolve the location of the module.\x0d\n   *\x0d\n   * The internals of this WILL change when chaining is implemented\x2C\x0d\n   * depending on the resolution/consensus from #36954.\x0d\n   * @param {string} originalSpecifier The specified URL path of the module to\x0d\n   *                                   be resolved.\x0d\n   * @param {string} [parentURL] The URL path of the module's parent.\x0d\n   * @param {ImportAssertions} [importAssertions] Assertions from the import\x0d\n   *                                              statement or expression.\x0d\n   * @returns {{ url: string }}\x0d\n   */\x0d\n  async resolve(originalSpecifier\x2C parentURL\x2C\x0d\n                importAssertions = ObjectCreate(null)) {\x0d\n    const isMain = parentURL === undefined;\x0d\n\x0d\n    if (\x0d\n      !isMain &&\x0d\n      typeof parentURL !== 'string' &&\x0d\n      !isURLInstance(parentURL)\x0d\n    ) throw new ERR_INVALID_ARG_TYPE(\x0d\n      'parentURL'\x2C\x0d\n      ['string'\x2C 'URL']\x2C\x0d\n      parentURL\x2C\x0d\n    );\x0d\n\x0d\n    const conditions = DEFAULT_CONDITIONS;\x0d\n\x0d\n    const defaultResolver = this.#resolvers[0];\x0d\n\x0d\n    const resolver = this.#resolvers.length === 1 ?\x0d\n      defaultResolver :\x0d\n      this.#resolvers[1];\x0d\n    const resolution = await resolver(\x0d\n      originalSpecifier\x2C\x0d\n      {\x0d\n        conditions\x2C\x0d\n        importAssertions\x2C\x0d\n        parentURL\x2C\x0d\n      }\x2C\x0d\n      defaultResolver\x2C\x0d\n    );\x0d\n\x0d\n    if (typeof resolution !== 'object') {\x0d\n      throw new ERR_INVALID_RETURN_VALUE(\x0d\n        'object'\x2C\x0d\n        'loader resolve'\x2C\x0d\n        resolution\x2C\x0d\n      );\x0d\n    }\x0d\n\x0d\n    const { format\x2C url } = resolution;\x0d\n\x0d\n    if (\x0d\n      format != null &&\x0d\n      typeof format !== 'string'\x0d\n    ) {\x0d\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\x0d\n        'string'\x2C\x0d\n        'loader resolve'\x2C\x0d\n        'format'\x2C\x0d\n        format\x2C\x0d\n      );\x0d\n    }\x0d\n    if (typeof url !== 'string') {\x0d\n      throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\x0d\n        'string'\x2C\x0d\n        'loader resolve'\x2C\x0d\n        'url'\x2C\x0d\n        url\x2C\x0d\n      );\x0d\n    }\x0d\n\x0d\n    return {\x0d\n      format\x2C\x0d\n      url\x2C\x0d\n    };\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectSetPrototypeOf(ESMLoader.prototype\x2C null);\x0d\n\x0d\nexports.ESMLoader = ESMLoader;\x0d\n
code-source-info,0x1abee82b9ee,106,0,16909,C0O0C4O16909,,
code-creation,Function,10,192517,0x1abee82c22e,615, node:internal/modules/esm/loader:1:1,0x1abee82b968,~
code-source-info,0x1abee82c22e,106,0,16909,C0O0C113O82C119O82C123O136C129O146C135O163C141O186C147O209C153O235C159O261C165O278C171O295C176O320C182O335C188O359C194O381C200O397C206O455C212O455C217O436C223O682C229O682C234O708C239O500C245O525C251O551C257O584C263O622C269O651C275O758C281O758C286O725C292O740C298O840C304O840C309O795C315O816C321O891C327O891C331O891C333O954C339O954C343O954C345O1056C351O1056C356O1012C362O1031C368O1135C374O1135C379O1109C385O1216C391O1216C396O1200C402O1279C408O1279C413O1263C419O1356C425O1356C430O1337C595O16856C602O16825C607O16877C609O16895C614O16908,,
code-creation,Function,10,192589,0x1abee82c696,154,<instance_members_initializer> node:internal/modules/esm/loader:64:3,0x1abee82bd90,~
code-source-info,0x1abee82c696,106,1839,2722,C3O1859C17O2021C28O2028C45O2210C56O2217C73O2269C88O2368C95O2368C109O2491C119O2583C126O2583C140O2711C153O2722,,
code-creation,Eval,10,192776,0x1abee82dea6,5, node:internal/modules/esm/module_map:1:1,0x1abee82dcb8,~
script-source,107,node:internal/modules/esm/module_map,'use strict';\x0d\n\x0d\nconst ModuleJob = require('internal/modules/esm/module_job');\x0d\nconst { kImplicitAssertType } = require('internal/modules/esm/assert');\x0d\nconst {\x0d\n  ObjectCreate\x2C\x0d\n  SafeMap\x2C\x0d\n} = primordials;\x0d\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\x0d\n  debug = fn;\x0d\n});\x0d\nconst { ERR_INVALID_ARG_TYPE } = require('internal/errors').codes;\x0d\nconst { validateString } = require('internal/validators');\x0d\n\x0d\n// Tracks the state of the loader-level module cache\x0d\nclass ModuleMap extends SafeMap {\x0d\n  constructor(i) { super(i); } // eslint-disable-line no-useless-constructor\x0d\n  get(url\x2C type = kImplicitAssertType) {\x0d\n    validateString(url\x2C 'url');\x0d\n    validateString(type\x2C 'type');\x0d\n    return super.get(url)?.[type];\x0d\n  }\x0d\n  set(url\x2C type = kImplicitAssertType\x2C job) {\x0d\n    validateString(url\x2C 'url');\x0d\n    validateString(type\x2C 'type');\x0d\n    if (job instanceof ModuleJob !== true &&\x0d\n        typeof job !== 'function') {\x0d\n      throw new ERR_INVALID_ARG_TYPE('job'\x2C 'ModuleJob'\x2C job);\x0d\n    }\x0d\n    debug(`Storing ${url} (${\x0d\n      type === kImplicitAssertType ? 'implicit type' : type\x0d\n    }) in ModuleMap`);\x0d\n    const cachedJobsForUrl = super.get(url) ?? ObjectCreate(null);\x0d\n    cachedJobsForUrl[type] = job;\x0d\n    return super.set(url\x2C cachedJobsForUrl);\x0d\n  }\x0d\n  has(url\x2C type = kImplicitAssertType) {\x0d\n    validateString(url\x2C 'url');\x0d\n    validateString(type\x2C 'type');\x0d\n    return super.get(url)?.[type] !== undefined;\x0d\n  }\x0d\n}\x0d\nmodule.exports = ModuleMap;\x0d\n
code-source-info,0x1abee82dea6,107,0,1487,C0O0C4O1487,,
code-creation,Function,10,192877,0x1abee82e2de,175, node:internal/modules/esm/module_map:1:1,0x1abee82de20,~
code-source-info,0x1abee82e2de,107,0,1487,C0O0C23O35C26O35C30O35C32O112C35O112C40O88C46O164C52O181C57O221C60O221C65O254C78O255C84O221C86O335C89O335C94O361C99O310C105O397C108O397C113O378C123O510C167O1458C169O1473C174O1486,,
code-creation,Eval,10,193139,0x1abee82ee3e,5, node:internal/modules/esm/module_job:1:1,0x1abee82eb48,~
script-source,108,node:internal/modules/esm/module_job,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypeMap\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeSome\x2C\x0d\n  FunctionPrototype\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  PromiseAll\x2C\x0d\n  PromiseResolve\x2C\x0d\n  PromisePrototypeCatch\x2C\x0d\n  ReflectApply\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeArrayIterator\x2C\x0d\n  SafeSet\x2C\x0d\n  StringPrototypeIncludes\x2C\x0d\n  StringPrototypeMatch\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { ModuleWrap } = internalBinding('module_wrap');\x0d\n\x0d\nconst { decorateErrorStack } = require('internal/util');\x0d\nconst {\x0d\n  getSourceMapsEnabled\x2C\x0d\n} = require('internal/source_map/source_map_cache');\x0d\nconst assert = require('internal/assert');\x0d\nconst resolvedPromise = PromiseResolve();\x0d\n\x0d\nconst noop = FunctionPrototype;\x0d\n\x0d\nlet hasPausedEntry = false;\x0d\n\x0d\nconst CJSGlobalLike = [\x0d\n  'require'\x2C\x0d\n  'module'\x2C\x0d\n  'exports'\x2C\x0d\n  '__filename'\x2C\x0d\n  '__dirname'\x2C\x0d\n];\x0d\nconst isCommonJSGlobalLikeNotDefinedError = (errorMessage) =>\x0d\n  ArrayPrototypeSome(\x0d\n    CJSGlobalLike\x2C\x0d\n    (globalLike) => errorMessage === `${globalLike} is not defined`\x0d\n  );\x0d\n\x0d\n/* A ModuleJob tracks the loading of a single Module\x2C and the ModuleJobs of\x0d\n * its dependencies\x2C over time. */\x0d\nclass ModuleJob {\x0d\n  // `loader` is the Loader instance used for loading dependencies.\x0d\n  // `moduleProvider` is a function\x0d\n  constructor(loader\x2C url\x2C importAssertions = ObjectCreate(null)\x2C\x0d\n              moduleProvider\x2C isMain\x2C inspectBrk) {\x0d\n    this.loader = loader;\x0d\n    this.importAssertions = importAssertions;\x0d\n    this.isMain = isMain;\x0d\n    this.inspectBrk = inspectBrk;\x0d\n\x0d\n    this.module = undefined;\x0d\n    // Expose the promise to the ModuleWrap directly for linking below.\x0d\n    // `this.module` is also filled in below.\x0d\n    this.modulePromise = ReflectApply(moduleProvider\x2C loader\x2C [url\x2C isMain]);\x0d\n\x0d\n    // Wait for the ModuleWrap instance being linked with all dependencies.\x0d\n    const link = async () => {\x0d\n      this.module = await this.modulePromise;\x0d\n      assert(this.module instanceof ModuleWrap);\x0d\n\x0d\n      // Explicitly keeping track of dependency jobs is needed in order\x0d\n      // to flatten out the dependency graph below in `_instantiate()`\x2C\x0d\n      // so that circular dependencies can't cause a deadlock by two of\x0d\n      // these `link` callbacks depending on each other.\x0d\n      const dependencyJobs = [];\x0d\n      const promises = this.module.link(async (specifier\x2C assertions) => {\x0d\n        const jobPromise = this.loader.getModuleJob(specifier\x2C url\x2C assertions);\x0d\n        ArrayPrototypePush(dependencyJobs\x2C jobPromise);\x0d\n        const job = await jobPromise;\x0d\n        return job.modulePromise;\x0d\n      });\x0d\n\x0d\n      if (promises !== undefined)\x0d\n        await PromiseAll(new SafeArrayIterator(promises));\x0d\n\x0d\n      return PromiseAll(new SafeArrayIterator(dependencyJobs));\x0d\n    };\x0d\n    // Promise for the list of all dependencyJobs.\x0d\n    this.linked = link();\x0d\n    // This promise is awaited later anyway\x2C so silence\x0d\n    // 'unhandled rejection' warnings.\x0d\n    PromisePrototypeCatch(this.linked\x2C noop);\x0d\n\x0d\n    // instantiated == deep dependency jobs wrappers are instantiated\x2C\x0d\n    // and module wrapper is instantiated.\x0d\n    this.instantiated = undefined;\x0d\n  }\x0d\n\x0d\n  instantiate() {\x0d\n    if (this.instantiated === undefined) {\x0d\n      this.instantiated = this._instantiate();\x0d\n    }\x0d\n    return this.instantiated;\x0d\n  }\x0d\n\x0d\n  async _instantiate() {\x0d\n    const jobsInGraph = new SafeSet();\x0d\n    const addJobsToDependencyGraph = async (moduleJob) => {\x0d\n      if (jobsInGraph.has(moduleJob)) {\x0d\n        return;\x0d\n      }\x0d\n      jobsInGraph.add(moduleJob);\x0d\n      const dependencyJobs = await moduleJob.linked;\x0d\n      return PromiseAll(new SafeArrayIterator(\x0d\n        ArrayPrototypeMap(dependencyJobs\x2C addJobsToDependencyGraph)));\x0d\n    };\x0d\n    await addJobsToDependencyGraph(this);\x0d\n\x0d\n    try {\x0d\n      if (!hasPausedEntry && this.inspectBrk) {\x0d\n        hasPausedEntry = true;\x0d\n        const initWrapper = internalBinding('inspector').callAndPauseOnStart;\x0d\n        initWrapper(this.module.instantiate\x2C this.module);\x0d\n      } else {\x0d\n        this.module.instantiate();\x0d\n      }\x0d\n    } catch (e) {\x0d\n      decorateErrorStack(e);\x0d\n      // TODO(@bcoe): Add source map support to exception that occurs as result\x0d\n      // of missing named export. This is currently not possible because\x0d\n      // stack trace originates in module_job\x2C not the file itself. A hidden\x0d\n      // symbol with filename could be set in node_errors.cc to facilitate this.\x0d\n      if (!getSourceMapsEnabled() &&\x0d\n          StringPrototypeIncludes(e.message\x2C\x0d\n                                  ' does not provide an export named')) {\x0d\n        const splitStack = StringPrototypeSplit(e.stack\x2C '\\n');\x0d\n        const parentFileUrl = StringPrototypeReplace(\x0d\n          splitStack[0]\x2C\x0d\n          /:\\d+$/\x2C\x0d\n          ''\x0d\n        );\x0d\n        const { 1: childSpecifier\x2C 2: name } = StringPrototypeMatch(\x0d\n          e.message\x2C\x0d\n          /module '(.*)' does not provide an export named '(.+)'/);\x0d\n        const { url: childFileURL } = await this.loader.resolve(\x0d\n          childSpecifier\x2C parentFileUrl\x2C\x0d\n        );\x0d\n        let format;\x0d\n        try {\x0d\n          // This might throw for non-CommonJS modules because we aren't passing\x0d\n          // in the import assertions and some formats require them; but we only\x0d\n          // care about CommonJS for the purposes of this error message.\x0d\n          ({ format } =\x0d\n            await this.loader.load(childFileURL));\x0d\n        } catch {}\x0d\n\x0d\n        if (format === 'commonjs') {\x0d\n          const importStatement = splitStack[1];\x0d\n          // TODO(@ctavan): The original error stack only provides the single\x0d\n          // line which causes the error. For multi-line import statements we\x0d\n          // cannot generate an equivalent object destructuring assignment by\x0d\n          // just parsing the error stack.\x0d\n          const oneLineNamedImports = StringPrototypeMatch(importStatement\x2C /{.*}/);\x0d\n          const destructuringAssignment = oneLineNamedImports &&\x0d\n            StringPrototypeReplace(oneLineNamedImports\x2C /\\s+as\\s+/g\x2C ': ');\x0d\n          e.message = `Named export '${name}' not found. The requested module` +\x0d\n            ` '${childSpecifier}' is a CommonJS module\x2C which may not support` +\x0d\n            ' all module.exports as named exports.\\nCommonJS modules can ' +\x0d\n            'always be imported via the default export\x2C for example using:' +\x0d\n            `\\n\\nimport pkg from '${childSpecifier}';\\n${\x0d\n              destructuringAssignment ?\x0d\n                `const ${destructuringAssignment} = pkg;\\n` : ''}`;\x0d\n          const newStack = StringPrototypeSplit(e.stack\x2C '\\n');\x0d\n          newStack[3] = `SyntaxError: ${e.message}`;\x0d\n          e.stack = ArrayPrototypeJoin(newStack\x2C '\\n');\x0d\n        }\x0d\n      }\x0d\n      throw e;\x0d\n    }\x0d\n\x0d\n    for (const dependencyJob of jobsInGraph) {\x0d\n      // Calling `this.module.instantiate()` instantiates not only the\x0d\n      // ModuleWrap in this module\x2C but all modules in the graph.\x0d\n      dependencyJob.instantiated = resolvedPromise;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  async run() {\x0d\n    await this.instantiate();\x0d\n    const timeout = -1;\x0d\n    const breakOnSigint = false;\x0d\n    try {\x0d\n      await this.module.evaluate(timeout\x2C breakOnSigint);\x0d\n    } catch (e) {\x0d\n      if (e?.name === 'ReferenceError' &&\x0d\n          isCommonJSGlobalLikeNotDefinedError(e.message)) {\x0d\n        e.message += ' in ES module scope';\x0d\n\x0d\n        if (StringPrototypeStartsWith(e.message\x2C 'require ')) {\x0d\n          e.message += '\x2C you can use import instead';\x0d\n        }\x0d\n\x0d\n        const packageConfig =\x0d\n          StringPrototypeStartsWith(this.module.url\x2C 'file://') &&\x0d\n            RegExpPrototypeTest(/\\.js(\\?[^#]*)?(#.*)?$/\x2C this.module.url) &&\x0d\n            require('internal/modules/esm/resolve')\x0d\n              .getPackageScopeConfig(this.module.url);\x0d\n        if (packageConfig.type === 'module') {\x0d\n          e.message +=\x0d\n            '\\nThis file is being treated as an ES module because it has a ' +\x0d\n            `'.js' file extension and '${packageConfig.pjsonPath}' contains ` +\x0d\n            '"type": "module". To treat it as a CommonJS script\x2C rename it ' +\x0d\n            'to use the \\'.cjs\\' file extension.';\x0d\n        }\x0d\n      }\x0d\n      throw e;\x0d\n    }\x0d\n    return { module: this.module };\x0d\n  }\x0d\n}\x0d\nObjectSetPrototypeOf(ModuleJob.prototype\x2C null);\x0d\nmodule.exports = ModuleJob;\x0d\n
code-source-info,0x1abee82ee3e,108,0,8353,C0O0C4O8353,,
code-creation,Function,10,193548,0x1abee82f336,343, node:internal/modules/esm/module_job:1:1,0x1abee82edb8,~
code-source-info,0x1abee82f336,108,0,8353,C0O0C88O28C94O51C100O73C106O96C112O119C117O141C123O158C128O183C134O198C139O217C145O243C151O260C157O284C163O306C169O318C175O346C181O371C187O398C193O423C199O494C205O494C210O479C216O560C222O560C227O537C233O625C239O625C244O598C250O690C256O690C260O690C262O743C265O743C267O777C269O777C271O820C272O820C274O852C278O852C280O977C284O977C323O8305C330O8274C335O8324C337O8339C342O8352,,
code-creation,Eval,10,193789,0x1abee830f76,5, node:internal/modules/esm/assert:1:1,0x1abee830d80,~
script-source,109,node:internal/modules/esm/assert,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeFilter\x2C\x0d\n  ArrayPrototypeIncludes\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectValues\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n} = primordials;\x0d\nconst { validateString } = require('internal/validators');\x0d\n\x0d\nconst {\x0d\n  ERR_IMPORT_ASSERTION_TYPE_FAILED\x2C\x0d\n  ERR_IMPORT_ASSERTION_TYPE_MISSING\x2C\x0d\n  ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED\x2C\x0d\n} = require('internal/errors').codes;\x0d\n\x0d\n// The HTML spec has an implied default type of `'javascript'`.\x0d\nconst kImplicitAssertType = 'javascript';\x0d\n\x0d\n/**\x0d\n * Define a map of module formats to import assertion types (the value of\x0d\n * `type` in `assert { type: 'json' }`).\x0d\n * @type {Map<string\x2C string>}\x0d\n */\x0d\nconst formatTypeMap = {\x0d\n  '__proto__': null\x2C\x0d\n  'builtin': kImplicitAssertType\x2C\x0d\n  'commonjs': kImplicitAssertType\x2C\x0d\n  'json': 'json'\x2C\x0d\n  'module': kImplicitAssertType\x2C\x0d\n  'wasm': kImplicitAssertType\x2C // It's unclear whether the HTML spec will require an assertion type or not for Wasm; see https://github.com/WebAssembly/esm-integration/issues/42\x0d\n};\x0d\n\x0d\n/**\x0d\n * The HTML spec disallows the default type to be explicitly specified\x0d\n * (for now); so `import './file.js'` is okay but\x0d\n * `import './file.js' assert { type: 'javascript' }` throws.\x0d\n * @type {Array<string\x2C string>}\x0d\n */\x0d\nconst supportedAssertionTypes = ArrayPrototypeFilter(\x0d\n  ObjectValues(formatTypeMap)\x2C\x0d\n  (type) => type !== kImplicitAssertType);\x0d\n\x0d\n\x0d\n/**\x0d\n * Test a module's import assertions.\x0d\n * @param {string} url The URL of the imported module\x2C for error reporting.\x0d\n * @param {string} format One of Node's supported translators\x0d\n * @param {Record<string\x2C string>} importAssertions Validations for the\x0d\n *                                                  module import.\x0d\n * @returns {true}\x0d\n * @throws {TypeError} If the format and assertion type are incompatible.\x0d\n */\x0d\nfunction validateAssertions(url\x2C format\x2C\x0d\n                            importAssertions = ObjectCreate(null)) {\x0d\n  const validType = formatTypeMap[format];\x0d\n\x0d\n  switch (validType) {\x0d\n    case undefined:\x0d\n      // Ignore assertions for module formats we don't recognize\x2C to allow new\x0d\n      // formats in the future.\x0d\n      return true;\x0d\n\x0d\n    case kImplicitAssertType:\x0d\n      // This format doesn't allow an import assertion type\x2C so the property\x0d\n      // must not be set on the import assertions object.\x0d\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\x0d\n        return true;\x0d\n      }\x0d\n      return handleInvalidType(url\x2C importAssertions.type);\x0d\n\x0d\n    case importAssertions.type:\x0d\n      // The asserted type is the valid type for this format.\x0d\n      return true;\x0d\n\x0d\n    default:\x0d\n      // There is an expected type for this format\x2C but the value of\x0d\n      // `importAssertions.type` might not have been it.\x0d\n      if (!ObjectPrototypeHasOwnProperty(importAssertions\x2C 'type')) {\x0d\n        // `type` wasn't specified at all.\x0d\n        throw new ERR_IMPORT_ASSERTION_TYPE_MISSING(url\x2C validType);\x0d\n      }\x0d\n      handleInvalidType(url\x2C importAssertions.type);\x0d\n  }\x0d\n}\x0d\n\x0d\n/**\x0d\n * Throw the correct error depending on what's wrong with the type assertion.\x0d\n * @param {string} url The resolved URL for the module to be imported\x0d\n * @param {string} type The value of the import assertion `type` property\x0d\n */\x0d\nfunction handleInvalidType(url\x2C type) {\x0d\n  // `type` might have not been a string.\x0d\n  validateString(type\x2C 'type');\x0d\n\x0d\n  // `type` might not have been one of the types we understand.\x0d\n  if (!ArrayPrototypeIncludes(supportedAssertionTypes\x2C type)) {\x0d\n    throw new ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED(type);\x0d\n  }\x0d\n\x0d\n  // `type` was the wrong value for this format.\x0d\n  throw new ERR_IMPORT_ASSERTION_TYPE_FAILED(url\x2C type);\x0d\n}\x0d\n\x0d\n\x0d\nmodule.exports = {\x0d\n  kImplicitAssertType\x2C\x0d\n  validateAssertions\x2C\x0d\n};\x0d\n
code-source-info,0x1abee830f76,109,0,3734,C0O0C4O3734,,
code-creation,Function,10,193994,0x1abee83124e,201, node:internal/modules/esm/assert:1:1,0x1abee830ef0,~
code-source-info,0x1abee83124e,109,0,3734,C0O0C46O28C51O53C57O80C63O97C68O114C74O191C77O191C82O172C88O356C91O356C96O382C101O237C107O274C113O312C119O486C121O486C123O684C130O722C136O758C142O811C148O843C154O684C156O1280C159O1305C169O1280C174O1280C176O3663C183O3685C189O3709C195O3678C200O3733,,
code-creation,LazyCompile,10,194108,0x1abee83185e,9, node:internal/modules/esm/assert:43:3,0x1abee831048,~
code-source-info,0x1abee83185e,109,1337,1375,C0O1352C2O1356C4O1352C8O1375,,
code-creation,Eval,10,194869,0x1abee833226,5, node:internal/modules/esm/resolve:1:1,0x1abee832b10,~
script-source,110,node:internal/modules/esm/resolve,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypeShift\x2C\x0d\n  JSONParse\x2C\x0d\n  JSONStringify\x2C\x0d\n  ObjectFreeze\x2C\x0d\n  ObjectGetOwnPropertyNames\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  RegExp\x2C\x0d\n  RegExpPrototypeExec\x2C\x0d\n  RegExpPrototypeSymbolReplace\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeSet\x2C\x0d\n  String\x2C\x0d\n  StringPrototypeEndsWith\x2C\x0d\n  StringPrototypeIncludes\x2C\x0d\n  StringPrototypeIndexOf\x2C\x0d\n  StringPrototypeLastIndexOf\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n} = primordials;\x0d\nconst internalFS = require('internal/fs/utils');\x0d\nconst { NativeModule } = require('internal/bootstrap/loaders');\x0d\nconst {\x0d\n  realpathSync\x2C\x0d\n  statSync\x2C\x0d\n  Stats\x2C\x0d\n} = require('fs');\x0d\nconst { getOptionValue } = require('internal/options');\x0d\n// Do not eagerly grab .manifest\x2C it may be in TDZ\x0d\nconst policy = getOptionValue('--experimental-policy') ?\x0d\n  require('internal/process/policy') :\x0d\n  null;\x0d\nconst { sep\x2C relative\x2C resolve } = require('path');\x0d\nconst preserveSymlinks = getOptionValue('--preserve-symlinks');\x0d\nconst preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\x0d\nconst typeFlag = getOptionValue('--input-type');\x0d\nconst { URL\x2C pathToFileURL\x2C fileURLToPath } = require('internal/url');\x0d\nconst {\x0d\n  ERR_INPUT_TYPE_NOT_ALLOWED\x2C\x0d\n  ERR_INVALID_ARG_VALUE\x2C\x0d\n  ERR_INVALID_MODULE_SPECIFIER\x2C\x0d\n  ERR_INVALID_PACKAGE_CONFIG\x2C\x0d\n  ERR_INVALID_PACKAGE_TARGET\x2C\x0d\n  ERR_MANIFEST_DEPENDENCY_MISSING\x2C\x0d\n  ERR_MODULE_NOT_FOUND\x2C\x0d\n  ERR_PACKAGE_IMPORT_NOT_DEFINED\x2C\x0d\n  ERR_PACKAGE_PATH_NOT_EXPORTED\x2C\x0d\n  ERR_UNSUPPORTED_DIR_IMPORT\x2C\x0d\n  ERR_UNSUPPORTED_ESM_URL_SCHEME\x2C\x0d\n} = require('internal/errors').codes;\x0d\nconst { Module: CJSModule } = require('internal/modules/cjs/loader');\x0d\n\x0d\nconst packageJsonReader = require('internal/modules/package_json_reader');\x0d\nconst userConditions = getOptionValue('--conditions');\x0d\nconst noAddons = getOptionValue('--no-addons');\x0d\nconst addonConditions = noAddons ? [] : ['node-addons'];\x0d\n\x0d\nconst DEFAULT_CONDITIONS = ObjectFreeze([\x0d\n  'node'\x2C\x0d\n  'import'\x2C\x0d\n  ...addonConditions\x2C\x0d\n  ...userConditions\x2C\x0d\n]);\x0d\n\x0d\nconst DEFAULT_CONDITIONS_SET = new SafeSet(DEFAULT_CONDITIONS);\x0d\n\x0d\n/**\x0d\n * @typedef {string | string[] | Record<string\x2C unknown>} Exports\x0d\n * @typedef {'module' | 'commonjs'} PackageType\x0d\n * @typedef {{\x0d\n *   exports?: ExportConfig;\x0d\n *   name?: string;\x0d\n *   main?: string;\x0d\n *   type?: PackageType;\x0d\n * }} PackageConfig\x0d\n */\x0d\n\x0d\nconst emittedPackageWarnings = new SafeSet();\x0d\n\x0d\nfunction emitTrailingSlashPatternDeprecation(match\x2C pjsonUrl\x2C base) {\x0d\n  const pjsonPath = fileURLToPath(pjsonUrl);\x0d\n  if (emittedPackageWarnings.has(pjsonPath + '|' + match))\x0d\n    return;\x0d\n  emittedPackageWarnings.add(pjsonPath + '|' + match);\x0d\n  process.emitWarning(\x0d\n    `Use of deprecated trailing slash pattern mapping "${match}" in the ` +\x0d\n    `"exports" field module resolution of the package at ${pjsonPath}${\x0d\n      base ? ` imported from ${fileURLToPath(base)}` :\x0d\n        ''}. Mapping specifiers ending in "/" is no longer supported.`\x2C\x0d\n    'DeprecationWarning'\x2C\x0d\n    'DEP0155'\x0d\n  );\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {URL} url\x0d\n * @param {URL} packageJSONUrl\x0d\n * @param {string | URL | undefined} base\x0d\n * @param {string} main\x0d\n * @returns {void}\x0d\n */\x0d\nfunction emitLegacyIndexDeprecation(url\x2C packageJSONUrl\x2C base\x2C main) {\x0d\n  const format = defaultGetFormatWithoutErrors(url);\x0d\n  if (format !== 'module')\x0d\n    return;\x0d\n  const path = fileURLToPath(url);\x0d\n  const pkgPath = fileURLToPath(new URL('.'\x2C packageJSONUrl));\x0d\n  const basePath = fileURLToPath(base);\x0d\n  if (main)\x0d\n    process.emitWarning(\x0d\n      `Package ${pkgPath} has a "main" field set to ${JSONStringify(main)}\x2C ` +\x0d\n      `excluding the full filename and extension to the resolved file at "${\x0d\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${\x0d\n        basePath}.\\n Automatic extension resolution of the "main" field is ` +\x0d\n      'deprecated for ES modules.'\x2C\x0d\n      'DeprecationWarning'\x2C\x0d\n      'DEP0151'\x0d\n    );\x0d\n  else\x0d\n    process.emitWarning(\x0d\n      `No "main" or "exports" field defined in the package.json for ${pkgPath\x0d\n      } resolving the main entry point "${\x0d\n        StringPrototypeSlice(path\x2C pkgPath.length)}"\x2C imported from ${basePath\x0d\n      }.\\nDefault "index" lookups for the main are deprecated for ES modules.`\x2C\x0d\n      'DeprecationWarning'\x2C\x0d\n      'DEP0151'\x0d\n    );\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string[]} [conditions]\x0d\n * @returns {Set<string>}\x0d\n */\x0d\nfunction getConditionsSet(conditions) {\x0d\n  if (conditions !== undefined && conditions !== DEFAULT_CONDITIONS) {\x0d\n    if (!ArrayIsArray(conditions)) {\x0d\n      throw new ERR_INVALID_ARG_VALUE('conditions'\x2C conditions\x2C\x0d\n                                      'expected an array');\x0d\n    }\x0d\n    return new SafeSet(conditions);\x0d\n  }\x0d\n  return DEFAULT_CONDITIONS_SET;\x0d\n}\x0d\n\x0d\nconst realpathCache = new SafeMap();\x0d\nconst packageJSONCache = new SafeMap();  /* string -> PackageConfig */\x0d\n\x0d\n/**\x0d\n * @param {string | URL} path\x0d\n * @returns {import('fs').Stats}\x0d\n */\x0d\nconst tryStatSync =\x0d\n  (path) => statSync(path\x2C { throwIfNoEntry: false }) ?? new Stats();\x0d\n\x0d\n/**\x0d\n * @param {string} path\x0d\n * @param {string} specifier\x0d\n * @param {string | URL | undefined} base\x0d\n * @returns {PackageConfig}\x0d\n */\x0d\nfunction getPackageConfig(path\x2C specifier\x2C base) {\x0d\n  const existing = packageJSONCache.get(path);\x0d\n  if (existing !== undefined) {\x0d\n    return existing;\x0d\n  }\x0d\n  const source = packageJsonReader.read(path).string;\x0d\n  if (source === undefined) {\x0d\n    const packageConfig = {\x0d\n      pjsonPath: path\x2C\x0d\n      exists: false\x2C\x0d\n      main: undefined\x2C\x0d\n      name: undefined\x2C\x0d\n      type: 'none'\x2C\x0d\n      exports: undefined\x2C\x0d\n      imports: undefined\x2C\x0d\n    };\x0d\n    packageJSONCache.set(path\x2C packageConfig);\x0d\n    return packageConfig;\x0d\n  }\x0d\n\x0d\n  let packageJSON;\x0d\n  try {\x0d\n    packageJSON = JSONParse(source);\x0d\n  } catch (error) {\x0d\n    throw new ERR_INVALID_PACKAGE_CONFIG(\x0d\n      path\x2C\x0d\n      (base ? `"${specifier}" from ` : '') + fileURLToPath(base || specifier)\x2C\x0d\n      error.message\x0d\n    );\x0d\n  }\x0d\n\x0d\n  let { imports\x2C main\x2C name\x2C type } = packageJSON;\x0d\n  const { exports } = packageJSON;\x0d\n  if (typeof imports !== 'object' || imports === null) imports = undefined;\x0d\n  if (typeof main !== 'string') main = undefined;\x0d\n  if (typeof name !== 'string') name = undefined;\x0d\n  // Ignore unknown types for forwards compatibility\x0d\n  if (type !== 'module' && type !== 'commonjs') type = 'none';\x0d\n\x0d\n  const packageConfig = {\x0d\n    pjsonPath: path\x2C\x0d\n    exists: true\x2C\x0d\n    main\x2C\x0d\n    name\x2C\x0d\n    type\x2C\x0d\n    exports\x2C\x0d\n    imports\x2C\x0d\n  };\x0d\n  packageJSONCache.set(path\x2C packageConfig);\x0d\n  return packageConfig;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {URL | string} resolved\x0d\n * @returns {PackageConfig}\x0d\n */\x0d\nfunction getPackageScopeConfig(resolved) {\x0d\n  let packageJSONUrl = new URL('./package.json'\x2C resolved);\x0d\n  while (true) {\x0d\n    const packageJSONPath = packageJSONUrl.pathname;\x0d\n    if (StringPrototypeEndsWith(packageJSONPath\x2C 'node_modules/package.json'))\x0d\n      break;\x0d\n    const packageConfig = getPackageConfig(fileURLToPath(packageJSONUrl)\x2C\x0d\n                                           resolved);\x0d\n    if (packageConfig.exists) return packageConfig;\x0d\n\x0d\n    const lastPackageJSONUrl = packageJSONUrl;\x0d\n    packageJSONUrl = new URL('../package.json'\x2C packageJSONUrl);\x0d\n\x0d\n    // Terminates at root where ../package.json equals ../../package.json\x0d\n    // (can't just check "/package.json" for Windows support).\x0d\n    if (packageJSONUrl.pathname === lastPackageJSONUrl.pathname) break;\x0d\n  }\x0d\n  const packageJSONPath = fileURLToPath(packageJSONUrl);\x0d\n  const packageConfig = {\x0d\n    pjsonPath: packageJSONPath\x2C\x0d\n    exists: false\x2C\x0d\n    main: undefined\x2C\x0d\n    name: undefined\x2C\x0d\n    type: 'none'\x2C\x0d\n    exports: undefined\x2C\x0d\n    imports: undefined\x2C\x0d\n  };\x0d\n  packageJSONCache.set(packageJSONPath\x2C packageConfig);\x0d\n  return packageConfig;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string | URL} url\x0d\n * @returns {boolean}\x0d\n */\x0d\nfunction fileExists(url) {\x0d\n  return statSync(url\x2C { throwIfNoEntry: false })?.isFile() ?? false;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Legacy CommonJS main resolution:\x0d\n * 1. let M = pkg_url + (json main field)\x0d\n * 2. TRY(M\x2C M.js\x2C M.json\x2C M.node)\x0d\n * 3. TRY(M/index.js\x2C M/index.json\x2C M/index.node)\x0d\n * 4. TRY(pkg_url/index.js\x2C pkg_url/index.json\x2C pkg_url/index.node)\x0d\n * 5. NOT_FOUND\x0d\n * @param {URL} packageJSONUrl\x0d\n * @param {PackageConfig} packageConfig\x0d\n * @param {string | URL | undefined} base\x0d\n * @returns {URL}\x0d\n */\x0d\nfunction legacyMainResolve(packageJSONUrl\x2C packageConfig\x2C base) {\x0d\n  let guess;\x0d\n  if (packageConfig.main !== undefined) {\x0d\n    // Note: fs check redundances will be handled by Descriptor cache here.\x0d\n    if (fileExists(guess = new URL(`./${packageConfig.main}`\x2C\x0d\n                                   packageJSONUrl))) {\x0d\n      return guess;\x0d\n    } else if (fileExists(guess = new URL(`./${packageConfig.main}.js`\x2C\x0d\n                                          packageJSONUrl)));\x0d\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.json`\x2C\x0d\n                                        packageJSONUrl)));\x0d\n    else if (fileExists(guess = new URL(`./${packageConfig.main}.node`\x2C\x0d\n                                        packageJSONUrl)));\x0d\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.js`\x2C\x0d\n                                        packageJSONUrl)));\x0d\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.json`\x2C\x0d\n                                        packageJSONUrl)));\x0d\n    else if (fileExists(guess = new URL(`./${packageConfig.main}/index.node`\x2C\x0d\n                                        packageJSONUrl)));\x0d\n    else guess = undefined;\x0d\n    if (guess) {\x0d\n      emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C\x0d\n                                 packageConfig.main);\x0d\n      return guess;\x0d\n    }\x0d\n    // Fallthrough.\x0d\n  }\x0d\n  if (fileExists(guess = new URL('./index.js'\x2C packageJSONUrl)));\x0d\n  // So fs.\x0d\n  else if (fileExists(guess = new URL('./index.json'\x2C packageJSONUrl)));\x0d\n  else if (fileExists(guess = new URL('./index.node'\x2C packageJSONUrl)));\x0d\n  else guess = undefined;\x0d\n  if (guess) {\x0d\n    emitLegacyIndexDeprecation(guess\x2C packageJSONUrl\x2C base\x2C packageConfig.main);\x0d\n    return guess;\x0d\n  }\x0d\n  // Not found.\x0d\n  throw new ERR_MODULE_NOT_FOUND(\x0d\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C fileURLToPath(base));\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {URL} search\x0d\n * @returns {URL | undefined}\x0d\n */\x0d\nfunction resolveExtensionsWithTryExactName(search) {\x0d\n  if (fileExists(search)) return search;\x0d\n  return resolveExtensions(search);\x0d\n}\x0d\n\x0d\nconst extensions = ['.js'\x2C '.json'\x2C '.node'\x2C '.mjs'];\x0d\n\x0d\n/**\x0d\n * @param {URL} search\x0d\n * @returns {URL | undefined}\x0d\n */\x0d\nfunction resolveExtensions(search) {\x0d\n  for (let i = 0; i < extensions.length; i++) {\x0d\n    const extension = extensions[i];\x0d\n    const guess = new URL(`${search.pathname}${extension}`\x2C search);\x0d\n    if (fileExists(guess)) return guess;\x0d\n  }\x0d\n  return undefined;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {URL} search\x0d\n * @returns {URL | undefined}\x0d\n */\x0d\nfunction resolveDirectoryEntry(search) {\x0d\n  const dirPath = fileURLToPath(search);\x0d\n  const pkgJsonPath = resolve(dirPath\x2C 'package.json');\x0d\n  if (fileExists(pkgJsonPath)) {\x0d\n    const pkgJson = packageJsonReader.read(pkgJsonPath);\x0d\n    if (pkgJson.containsKeys) {\x0d\n      const { main } = JSONParse(pkgJson.string);\x0d\n      if (main != null) {\x0d\n        const mainUrl = pathToFileURL(resolve(dirPath\x2C main));\x0d\n        return resolveExtensionsWithTryExactName(mainUrl);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n  return resolveExtensions(new URL('index'\x2C search));\x0d\n}\x0d\n\x0d\nconst encodedSepRegEx = /%2F|%5C/i;\x0d\n/**\x0d\n * @param {URL} resolved\x0d\n * @param {string | URL | undefined} base\x0d\n * @param {boolean} preserveSymlinks\x0d\n * @returns {URL | undefined}\x0d\n */\x0d\nfunction finalizeResolution(resolved\x2C base\x2C preserveSymlinks) {\x0d\n  if (RegExpPrototypeTest(encodedSepRegEx\x2C resolved.pathname))\x0d\n    throw new ERR_INVALID_MODULE_SPECIFIER(\x0d\n      resolved.pathname\x2C 'must not include encoded "/" or "\\\\" characters'\x2C\x0d\n      fileURLToPath(base));\x0d\n\x0d\n  const path = fileURLToPath(resolved);\x0d\n  if (getOptionValue('--experimental-specifier-resolution') === 'node') {\x0d\n    let file = resolveExtensionsWithTryExactName(resolved);\x0d\n    if (file !== undefined) return file;\x0d\n    if (!StringPrototypeEndsWith(path\x2C '/')) {\x0d\n      file = resolveDirectoryEntry(new URL(`${resolved}/`));\x0d\n      if (file !== undefined) return file;\x0d\n    } else {\x0d\n      return resolveDirectoryEntry(resolved) || resolved;\x0d\n    }\x0d\n    throw new ERR_MODULE_NOT_FOUND(\x0d\n      resolved.pathname\x2C fileURLToPath(base)\x2C 'module');\x0d\n  }\x0d\n\x0d\n  const stats = tryStatSync(StringPrototypeEndsWith(path\x2C '/') ?\x0d\n    StringPrototypeSlice(path\x2C -1) : path);\x0d\n  if (stats.isDirectory()) {\x0d\n    const err = new ERR_UNSUPPORTED_DIR_IMPORT(path\x2C fileURLToPath(base));\x0d\n    err.url = String(resolved);\x0d\n    throw err;\x0d\n  } else if (!stats.isFile()) {\x0d\n    throw new ERR_MODULE_NOT_FOUND(\x0d\n      path || resolved.pathname\x2C base && fileURLToPath(base)\x2C 'module');\x0d\n  }\x0d\n\x0d\n  if (!preserveSymlinks) {\x0d\n    const real = realpathSync(path\x2C {\x0d\n      [internalFS.realpathCacheKey]: realpathCache\x0d\n    });\x0d\n    const { search\x2C hash } = resolved;\x0d\n    resolved =\x0d\n        pathToFileURL(real + (StringPrototypeEndsWith(path\x2C sep) ? '/' : ''));\x0d\n    resolved.search = search;\x0d\n    resolved.hash = hash;\x0d\n  }\x0d\n\x0d\n  return resolved;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string} specifier\x0d\n * @param {URL} packageJSONUrl\x0d\n * @param {string | URL | undefined} base\x0d\n */\x0d\nfunction throwImportNotDefined(specifier\x2C packageJSONUrl\x2C base) {\x0d\n  throw new ERR_PACKAGE_IMPORT_NOT_DEFINED(\x0d\n    specifier\x2C packageJSONUrl && fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C\x0d\n    fileURLToPath(base));\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string} subpath\x0d\n * @param {URL} packageJSONUrl\x0d\n * @param {string | URL | undefined} base\x0d\n */\x0d\nfunction throwExportsNotFound(subpath\x2C packageJSONUrl\x2C base) {\x0d\n  throw new ERR_PACKAGE_PATH_NOT_EXPORTED(\x0d\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C\x0d\n    base && fileURLToPath(base));\x0d\n}\x0d\n\x0d\n/**\x0d\n *\x0d\n * @param {string | URL} subpath\x0d\n * @param {URL} packageJSONUrl\x0d\n * @param {boolean} internal\x0d\n * @param {string | URL | undefined} base\x0d\n */\x0d\nfunction throwInvalidSubpath(subpath\x2C packageJSONUrl\x2C internal\x2C base) {\x0d\n  const reason = `request is not a valid subpath for the "${internal ?\x0d\n    'imports' : 'exports'}" resolution of ${fileURLToPath(packageJSONUrl)}`;\x0d\n  throw new ERR_INVALID_MODULE_SPECIFIER(subpath\x2C reason\x2C\x0d\n                                         base && fileURLToPath(base));\x0d\n}\x0d\n\x0d\nfunction throwInvalidPackageTarget(\x0d\n  subpath\x2C target\x2C packageJSONUrl\x2C internal\x2C base) {\x0d\n  if (typeof target === 'object' && target !== null) {\x0d\n    target = JSONStringify(target\x2C null\x2C '');\x0d\n  } else {\x0d\n    target = `${target}`;\x0d\n  }\x0d\n  throw new ERR_INVALID_PACKAGE_TARGET(\x0d\n    fileURLToPath(new URL('.'\x2C packageJSONUrl))\x2C subpath\x2C target\x2C\x0d\n    internal\x2C base && fileURLToPath(base));\x0d\n}\x0d\n\x0d\nconst invalidSegmentRegEx = /(^|\\\\|\\/)((\\.|%2e)(\\.|%2e)?|(n|%6e|%4e)(o|%6f|%4f)(d|%64|%44)(e|%65|%45)(_|%5f)(m|%6d|%4d)(o|%6f|%4f)(d|%64|%44)(u|%75|%55)(l|%6c|%4c)(e|%65|%45)(s|%73|%53))(\\\\|\\/|$)/i;\x0d\nconst invalidPackageNameRegEx = /^\\.|%|\\\\/;\x0d\nconst patternRegEx = /\\*/g;\x0d\n\x0d\nfunction resolvePackageTargetString(\x0d\n  target\x2C subpath\x2C match\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C conditions) {\x0d\n\x0d\n  if (subpath !== '' && !pattern && target[target.length - 1] !== '/')\x0d\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\x0d\n\x0d\n  if (!StringPrototypeStartsWith(target\x2C './')) {\x0d\n    if (internal && !StringPrototypeStartsWith(target\x2C '../') &&\x0d\n        !StringPrototypeStartsWith(target\x2C '/')) {\x0d\n      let isURL = false;\x0d\n      try {\x0d\n        new URL(target);\x0d\n        isURL = true;\x0d\n      } catch {}\x0d\n      if (!isURL) {\x0d\n        const exportTarget = pattern ?\x0d\n          RegExpPrototypeSymbolReplace(patternRegEx\x2C target\x2C () => subpath) :\x0d\n          target + subpath;\x0d\n        return packageResolve(\x0d\n          exportTarget\x2C packageJSONUrl\x2C conditions);\x0d\n      }\x0d\n    }\x0d\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\x0d\n  }\x0d\n\x0d\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C StringPrototypeSlice(target\x2C 2)))\x0d\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\x0d\n\x0d\n  const resolved = new URL(target\x2C packageJSONUrl);\x0d\n  const resolvedPath = resolved.pathname;\x0d\n  const packagePath = new URL('.'\x2C packageJSONUrl).pathname;\x0d\n\x0d\n  if (!StringPrototypeStartsWith(resolvedPath\x2C packagePath))\x0d\n    throwInvalidPackageTarget(match\x2C target\x2C packageJSONUrl\x2C internal\x2C base);\x0d\n\x0d\n  if (subpath === '') return resolved;\x0d\n\x0d\n  if (RegExpPrototypeTest(invalidSegmentRegEx\x2C subpath)) {\x0d\n    const request = pattern ?\x0d\n      StringPrototypeReplace(match\x2C '*'\x2C () => subpath) : match + subpath;\x0d\n    throwInvalidSubpath(request\x2C packageJSONUrl\x2C internal\x2C base);\x0d\n  }\x0d\n\x0d\n  if (pattern) {\x0d\n    return new URL(\x0d\n      RegExpPrototypeSymbolReplace(\x0d\n        patternRegEx\x2C\x0d\n        resolved.href\x2C\x0d\n        () => subpath\x0d\n      )\x0d\n    );\x0d\n  }\x0d\n\x0d\n  return new URL(subpath\x2C resolved);\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string} key\x0d\n * @returns {boolean}\x0d\n */\x0d\nfunction isArrayIndex(key) {\x0d\n  const keyNum = +key;\x0d\n  if (`${keyNum}` !== key) return false;\x0d\n  return keyNum >= 0 && keyNum < 0xFFFF_FFFF;\x0d\n}\x0d\n\x0d\nfunction resolvePackageTarget(packageJSONUrl\x2C target\x2C subpath\x2C packageSubpath\x2C\x0d\n                              base\x2C pattern\x2C internal\x2C conditions) {\x0d\n  if (typeof target === 'string') {\x0d\n    return resolvePackageTargetString(\x0d\n      target\x2C subpath\x2C packageSubpath\x2C packageJSONUrl\x2C base\x2C pattern\x2C internal\x2C\x0d\n      conditions);\x0d\n  } else if (ArrayIsArray(target)) {\x0d\n    if (target.length === 0)\x0d\n      return null;\x0d\n\x0d\n    let lastException;\x0d\n    for (let i = 0; i < target.length; i++) {\x0d\n      const targetItem = target[i];\x0d\n      let resolveResult;\x0d\n      try {\x0d\n        resolveResult = resolvePackageTarget(\x0d\n          packageJSONUrl\x2C targetItem\x2C subpath\x2C packageSubpath\x2C base\x2C pattern\x2C\x0d\n          internal\x2C conditions);\x0d\n      } catch (e) {\x0d\n        lastException = e;\x0d\n        if (e.code === 'ERR_INVALID_PACKAGE_TARGET')\x0d\n          continue;\x0d\n        throw e;\x0d\n      }\x0d\n      if (resolveResult === undefined)\x0d\n        continue;\x0d\n      if (resolveResult === null) {\x0d\n        lastException = null;\x0d\n        continue;\x0d\n      }\x0d\n      return resolveResult;\x0d\n    }\x0d\n    if (lastException === undefined || lastException === null)\x0d\n      return lastException;\x0d\n    throw lastException;\x0d\n  } else if (typeof target === 'object' && target !== null) {\x0d\n    const keys = ObjectGetOwnPropertyNames(target);\x0d\n    for (let i = 0; i < keys.length; i++) {\x0d\n      const key = keys[i];\x0d\n      if (isArrayIndex(key)) {\x0d\n        throw new ERR_INVALID_PACKAGE_CONFIG(\x0d\n          fileURLToPath(packageJSONUrl)\x2C base\x2C\x0d\n          '"exports" cannot contain numeric property keys.');\x0d\n      }\x0d\n    }\x0d\n    for (let i = 0; i < keys.length; i++) {\x0d\n      const key = keys[i];\x0d\n      if (key === 'default' || conditions.has(key)) {\x0d\n        const conditionalTarget = target[key];\x0d\n        const resolveResult = resolvePackageTarget(\x0d\n          packageJSONUrl\x2C conditionalTarget\x2C subpath\x2C packageSubpath\x2C base\x2C\x0d\n          pattern\x2C internal\x2C conditions);\x0d\n        if (resolveResult === undefined)\x0d\n          continue;\x0d\n        return resolveResult;\x0d\n      }\x0d\n    }\x0d\n    return undefined;\x0d\n  } else if (target === null) {\x0d\n    return null;\x0d\n  }\x0d\n  throwInvalidPackageTarget(packageSubpath\x2C target\x2C packageJSONUrl\x2C internal\x2C\x0d\n                            base);\x0d\n}\x0d\n\x0d\n/**\x0d\n *\x0d\n * @param {Exports} exports\x0d\n * @param {URL} packageJSONUrl\x0d\n * @param {string | URL | undefined} base\x0d\n * @returns {boolean}\x0d\n */\x0d\nfunction isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base) {\x0d\n  if (typeof exports === 'string' || ArrayIsArray(exports)) return true;\x0d\n  if (typeof exports !== 'object' || exports === null) return false;\x0d\n\x0d\n  const keys = ObjectGetOwnPropertyNames(exports);\x0d\n  let isConditionalSugar = false;\x0d\n  let i = 0;\x0d\n  for (let j = 0; j < keys.length; j++) {\x0d\n    const key = keys[j];\x0d\n    const curIsConditionalSugar = key === '' || key[0] !== '.';\x0d\n    if (i++ === 0) {\x0d\n      isConditionalSugar = curIsConditionalSugar;\x0d\n    } else if (isConditionalSugar !== curIsConditionalSugar) {\x0d\n      throw new ERR_INVALID_PACKAGE_CONFIG(\x0d\n        fileURLToPath(packageJSONUrl)\x2C base\x2C\x0d\n        '"exports" cannot contain some keys starting with \\'.\\' and some not.' +\x0d\n        ' The exports object must either be an object of package subpath keys' +\x0d\n        ' or an object of main entry condition name keys only.');\x0d\n    }\x0d\n  }\x0d\n  return isConditionalSugar;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {URL} packageJSONUrl\x0d\n * @param {string} packageSubpath\x0d\n * @param {PackageConfig} packageConfig\x0d\n * @param {string | URL | undefined} base\x0d\n * @param {Set<string>} conditions\x0d\n * @returns {URL}\x0d\n */\x0d\nfunction packageExportsResolve(\x0d\n  packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions) {\x0d\n  let exports = packageConfig.exports;\x0d\n  if (isConditionalExportsMainSugar(exports\x2C packageJSONUrl\x2C base))\x0d\n    exports = { '.': exports };\x0d\n\x0d\n  if (ObjectPrototypeHasOwnProperty(exports\x2C packageSubpath) &&\x0d\n      !StringPrototypeIncludes(packageSubpath\x2C '*') &&\x0d\n      !StringPrototypeEndsWith(packageSubpath\x2C '/')) {\x0d\n    const target = exports[packageSubpath];\x0d\n    const resolveResult = resolvePackageTarget(\x0d\n      packageJSONUrl\x2C target\x2C ''\x2C packageSubpath\x2C base\x2C false\x2C false\x2C conditions\x0d\n    );\x0d\n\x0d\n    if (resolveResult == null) {\x0d\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\x0d\n    }\x0d\n\x0d\n    return resolveResult;\x0d\n  }\x0d\n\x0d\n  let bestMatch = '';\x0d\n  let bestMatchSubpath;\x0d\n  const keys = ObjectGetOwnPropertyNames(exports);\x0d\n  for (let i = 0; i < keys.length; i++) {\x0d\n    const key = keys[i];\x0d\n    const patternIndex = StringPrototypeIndexOf(key\x2C '*');\x0d\n    if (patternIndex !== -1 &&\x0d\n        StringPrototypeStartsWith(packageSubpath\x2C\x0d\n                                  StringPrototypeSlice(key\x2C 0\x2C patternIndex))) {\x0d\n      // When this reaches EOL\x2C this can throw at the top of the whole function:\x0d\n      //\x0d\n      // if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\x0d\n      //   throwInvalidSubpath(packageSubpath)\x0d\n      //\x0d\n      // To match "imports" and the spec.\x0d\n      if (StringPrototypeEndsWith(packageSubpath\x2C '/'))\x0d\n        emitTrailingSlashPatternDeprecation(packageSubpath\x2C packageJSONUrl\x2C\x0d\n                                            base);\x0d\n      const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\x0d\n      if (packageSubpath.length >= key.length &&\x0d\n          StringPrototypeEndsWith(packageSubpath\x2C patternTrailer) &&\x0d\n          patternKeyCompare(bestMatch\x2C key) === 1 &&\x0d\n          StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\x0d\n        bestMatch = key;\x0d\n        bestMatchSubpath = StringPrototypeSlice(\x0d\n          packageSubpath\x2C patternIndex\x2C\x0d\n          packageSubpath.length - patternTrailer.length);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (bestMatch) {\x0d\n    const target = exports[bestMatch];\x0d\n    const resolveResult = resolvePackageTarget(\x0d\n      packageJSONUrl\x2C\x0d\n      target\x2C\x0d\n      bestMatchSubpath\x2C\x0d\n      bestMatch\x2C\x0d\n      base\x2C\x0d\n      true\x2C\x0d\n      false\x2C\x0d\n      conditions);\x0d\n\x0d\n    if (resolveResult == null) {\x0d\n      throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\x0d\n    }\x0d\n    return resolveResult;\x0d\n  }\x0d\n\x0d\n  throwExportsNotFound(packageSubpath\x2C packageJSONUrl\x2C base);\x0d\n}\x0d\n\x0d\nfunction patternKeyCompare(a\x2C b) {\x0d\n  const aPatternIndex = StringPrototypeIndexOf(a\x2C '*');\x0d\n  const bPatternIndex = StringPrototypeIndexOf(b\x2C '*');\x0d\n  const baseLenA = aPatternIndex === -1 ? a.length : aPatternIndex + 1;\x0d\n  const baseLenB = bPatternIndex === -1 ? b.length : bPatternIndex + 1;\x0d\n  if (baseLenA > baseLenB) return -1;\x0d\n  if (baseLenB > baseLenA) return 1;\x0d\n  if (aPatternIndex === -1) return 1;\x0d\n  if (bPatternIndex === -1) return -1;\x0d\n  if (a.length > b.length) return -1;\x0d\n  if (b.length > a.length) return 1;\x0d\n  return 0;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string} name\x0d\n * @param {string | URL | undefined} base\x0d\n * @param {Set<string>} conditions\x0d\n * @returns {URL}\x0d\n */\x0d\nfunction packageImportsResolve(name\x2C base\x2C conditions) {\x0d\n  if (name === '#' || StringPrototypeStartsWith(name\x2C '#/') ||\x0d\n      StringPrototypeEndsWith(name\x2C '/')) {\x0d\n    const reason = 'is not a valid internal imports specifier name';\x0d\n    throw new ERR_INVALID_MODULE_SPECIFIER(name\x2C reason\x2C fileURLToPath(base));\x0d\n  }\x0d\n  let packageJSONUrl;\x0d\n  const packageConfig = getPackageScopeConfig(base);\x0d\n  if (packageConfig.exists) {\x0d\n    packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\x0d\n    const imports = packageConfig.imports;\x0d\n    if (imports) {\x0d\n      if (ObjectPrototypeHasOwnProperty(imports\x2C name) &&\x0d\n          !StringPrototypeIncludes(name\x2C '*')) {\x0d\n        const resolveResult = resolvePackageTarget(\x0d\n          packageJSONUrl\x2C imports[name]\x2C ''\x2C name\x2C base\x2C false\x2C true\x2C conditions\x0d\n        );\x0d\n        if (resolveResult != null) {\x0d\n          return resolveResult;\x0d\n        }\x0d\n      } else {\x0d\n        let bestMatch = '';\x0d\n        let bestMatchSubpath;\x0d\n        const keys = ObjectGetOwnPropertyNames(imports);\x0d\n        for (let i = 0; i < keys.length; i++) {\x0d\n          const key = keys[i];\x0d\n          const patternIndex = StringPrototypeIndexOf(key\x2C '*');\x0d\n          if (patternIndex !== -1 &&\x0d\n              StringPrototypeStartsWith(name\x2C\x0d\n                                        StringPrototypeSlice(key\x2C 0\x2C\x0d\n                                                             patternIndex))) {\x0d\n            const patternTrailer = StringPrototypeSlice(key\x2C patternIndex + 1);\x0d\n            if (name.length >= key.length &&\x0d\n                StringPrototypeEndsWith(name\x2C patternTrailer) &&\x0d\n                patternKeyCompare(bestMatch\x2C key) === 1 &&\x0d\n                StringPrototypeLastIndexOf(key\x2C '*') === patternIndex) {\x0d\n              bestMatch = key;\x0d\n              bestMatchSubpath = StringPrototypeSlice(\x0d\n                name\x2C patternIndex\x2C name.length - patternTrailer.length);\x0d\n            }\x0d\n          }\x0d\n        }\x0d\n\x0d\n        if (bestMatch) {\x0d\n          const target = imports[bestMatch];\x0d\n          const resolveResult = resolvePackageTarget(packageJSONUrl\x2C target\x2C\x0d\n                                                     bestMatchSubpath\x2C\x0d\n                                                     bestMatch\x2C base\x2C true\x2C\x0d\n                                                     true\x2C conditions);\x0d\n          if (resolveResult != null) {\x0d\n            return resolveResult;\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n  throwImportNotDefined(name\x2C packageJSONUrl\x2C base);\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {URL} url\x0d\n * @returns {PackageType}\x0d\n */\x0d\nfunction getPackageType(url) {\x0d\n  const packageConfig = getPackageScopeConfig(url);\x0d\n  return packageConfig.type;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string} specifier\x0d\n * @param {string | URL | undefined} base\x0d\n * @returns {{ packageName: string\x2C packageSubpath: string\x2C isScoped: boolean }}\x0d\n */\x0d\nfunction parsePackageName(specifier\x2C base) {\x0d\n  let separatorIndex = StringPrototypeIndexOf(specifier\x2C '/');\x0d\n  let validPackageName = true;\x0d\n  let isScoped = false;\x0d\n  if (specifier[0] === '@') {\x0d\n    isScoped = true;\x0d\n    if (separatorIndex === -1 || specifier.length === 0) {\x0d\n      validPackageName = false;\x0d\n    } else {\x0d\n      separatorIndex = StringPrototypeIndexOf(\x0d\n        specifier\x2C '/'\x2C separatorIndex + 1);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  const packageName = separatorIndex === -1 ?\x0d\n    specifier : StringPrototypeSlice(specifier\x2C 0\x2C separatorIndex);\x0d\n\x0d\n  // Package name cannot have leading . and cannot have percent-encoding or\x0d\n  // \\\\ separators.\x0d\n  if (RegExpPrototypeExec(invalidPackageNameRegEx\x2C packageName) !== null)\x0d\n    validPackageName = false;\x0d\n\x0d\n  if (!validPackageName) {\x0d\n    throw new ERR_INVALID_MODULE_SPECIFIER(\x0d\n      specifier\x2C 'is not a valid package name'\x2C fileURLToPath(base));\x0d\n  }\x0d\n\x0d\n  const packageSubpath = '.' + (separatorIndex === -1 ? '' :\x0d\n    StringPrototypeSlice(specifier\x2C separatorIndex));\x0d\n\x0d\n  return { packageName\x2C packageSubpath\x2C isScoped };\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string} specifier\x0d\n * @param {string | URL | undefined} base\x0d\n * @param {Set<string>} conditions\x0d\n * @returns {resolved: URL\x2C format? : string}\x0d\n */\x0d\nfunction packageResolve(specifier\x2C base\x2C conditions) {\x0d\n  if (NativeModule.canBeRequiredByUsers(specifier))\x0d\n    return new URL('node:' + specifier);\x0d\n\x0d\n  const { packageName\x2C packageSubpath\x2C isScoped } =\x0d\n    parsePackageName(specifier\x2C base);\x0d\n\x0d\n  // ResolveSelf\x0d\n  const packageConfig = getPackageScopeConfig(base);\x0d\n  if (packageConfig.exists) {\x0d\n    const packageJSONUrl = pathToFileURL(packageConfig.pjsonPath);\x0d\n    if (packageConfig.name === packageName &&\x0d\n        packageConfig.exports !== undefined && packageConfig.exports !== null) {\x0d\n      return packageExportsResolve(\x0d\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  let packageJSONUrl =\x0d\n    new URL('./node_modules/' + packageName + '/package.json'\x2C base);\x0d\n  let packageJSONPath = fileURLToPath(packageJSONUrl);\x0d\n  let lastPath;\x0d\n  do {\x0d\n    const stat = tryStatSync(StringPrototypeSlice(packageJSONPath\x2C 0\x2C\x0d\n                                                  packageJSONPath.length - 13));\x0d\n    if (!stat.isDirectory()) {\x0d\n      lastPath = packageJSONPath;\x0d\n      packageJSONUrl = new URL((isScoped ?\x0d\n        '../../../../node_modules/' : '../../../node_modules/') +\x0d\n        packageName + '/package.json'\x2C packageJSONUrl);\x0d\n      packageJSONPath = fileURLToPath(packageJSONUrl);\x0d\n      continue;\x0d\n    }\x0d\n\x0d\n    // Package match.\x0d\n    const packageConfig = getPackageConfig(packageJSONPath\x2C specifier\x2C base);\x0d\n    if (packageConfig.exports !== undefined && packageConfig.exports !== null) {\x0d\n      return packageExportsResolve(\x0d\n        packageJSONUrl\x2C packageSubpath\x2C packageConfig\x2C base\x2C conditions);\x0d\n    }\x0d\n    if (packageSubpath === '.') {\x0d\n      return legacyMainResolve(\x0d\n        packageJSONUrl\x2C\x0d\n        packageConfig\x2C\x0d\n        base\x0d\n      );\x0d\n    }\x0d\n\x0d\n    return new URL(packageSubpath\x2C packageJSONUrl);\x0d\n    // Cross-platform root check.\x0d\n  } while (packageJSONPath.length !== lastPath.length);\x0d\n\x0d\n  // eslint can't handle the above code.\x0d\n  // eslint-disable-next-line no-unreachable\x0d\n  throw new ERR_MODULE_NOT_FOUND(packageName\x2C fileURLToPath(base));\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string} specifier\x0d\n * @returns {boolean}\x0d\n */\x0d\nfunction isBareSpecifier(specifier) {\x0d\n  return specifier[0] && specifier[0] !== '/' && specifier[0] !== '.';\x0d\n}\x0d\n\x0d\nfunction isRelativeSpecifier(specifier) {\x0d\n  if (specifier[0] === '.') {\x0d\n    if (specifier.length === 1 || specifier[1] === '/') return true;\x0d\n    if (specifier[1] === '.') {\x0d\n      if (specifier.length === 2 || specifier[2] === '/') return true;\x0d\n    }\x0d\n  }\x0d\n  return false;\x0d\n}\x0d\n\x0d\nfunction shouldBeTreatedAsRelativeOrAbsolutePath(specifier) {\x0d\n  if (specifier === '') return false;\x0d\n  if (specifier[0] === '/') return true;\x0d\n  return isRelativeSpecifier(specifier);\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {string} specifier\x0d\n * @param {string | URL | undefined} base\x0d\n * @param {Set<string>} conditions\x0d\n * @param {boolean} preserveSymlinks\x0d\n * @returns {url: URL\x2C format?: string}\x0d\n */\x0d\nfunction moduleResolve(specifier\x2C base\x2C conditions\x2C preserveSymlinks) {\x0d\n  // Order swapped from spec for minor perf gain.\x0d\n  // Ok since relative URLs cannot parse as URLs.\x0d\n  let resolved;\x0d\n  if (shouldBeTreatedAsRelativeOrAbsolutePath(specifier)) {\x0d\n    resolved = new URL(specifier\x2C base);\x0d\n  } else if (specifier[0] === '#') {\x0d\n    resolved = packageImportsResolve(specifier\x2C base\x2C conditions);\x0d\n  } else {\x0d\n    try {\x0d\n      resolved = new URL(specifier);\x0d\n    } catch {\x0d\n      resolved = packageResolve(specifier\x2C base\x2C conditions);\x0d\n    }\x0d\n  }\x0d\n  if (resolved.protocol !== 'file:') {\x0d\n    return resolved;\x0d\n  }\x0d\n  return finalizeResolution(resolved\x2C base\x2C preserveSymlinks);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Try to resolve an import as a CommonJS module\x0d\n * @param {string} specifier\x0d\n * @param {string} parentURL\x0d\n * @returns {boolean|string}\x0d\n */\x0d\nfunction resolveAsCommonJS(specifier\x2C parentURL) {\x0d\n  try {\x0d\n    const parent = fileURLToPath(parentURL);\x0d\n    const tmpModule = new CJSModule(parent\x2C null);\x0d\n    tmpModule.paths = CJSModule._nodeModulePaths(parent);\x0d\n\x0d\n    let found = CJSModule._resolveFilename(specifier\x2C tmpModule\x2C false);\x0d\n\x0d\n    // If it is a relative specifier return the relative path\x0d\n    // to the parent\x0d\n    if (isRelativeSpecifier(specifier)) {\x0d\n      found = relative(parent\x2C found);\x0d\n      // Add '.separator if the path does not start with '..separator'\x0d\n      // This should be a safe assumption because when loading\x0d\n      // esm modules there should be always a file specified so\x0d\n      // there should not be a specifier like '..' or '.'\x0d\n      if (!StringPrototypeStartsWith(found\x2C `..${sep}`)) {\x0d\n        found = `.${sep}${found}`;\x0d\n      }\x0d\n    } else if (isBareSpecifier(specifier)) {\x0d\n      // If it is a bare specifier return the relative path within the\x0d\n      // module\x0d\n      const pkg = StringPrototypeSplit(specifier\x2C '/')[0];\x0d\n      const index = StringPrototypeIndexOf(found\x2C pkg);\x0d\n      if (index !== -1) {\x0d\n        found = StringPrototypeSlice(found\x2C index);\x0d\n      }\x0d\n    }\x0d\n    // Normalize the path separator to give a valid suggestion\x0d\n    // on Windows\x0d\n    if (process.platform === 'win32') {\x0d\n      found = RegExpPrototypeSymbolReplace(new RegExp(`\\\\${sep}`\x2C 'g')\x2C\x0d\n                                           found\x2C '/');\x0d\n    }\x0d\n    return found;\x0d\n  } catch {\x0d\n    return false;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction throwIfUnsupportedURLProtocol(url) {\x0d\n  if (url.protocol !== 'file:' && url.protocol !== 'data:' &&\x0d\n      url.protocol !== 'node:') {\x0d\n    throw new ERR_UNSUPPORTED_ESM_URL_SCHEME(url);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction defaultResolve(specifier\x2C context = {}\x2C defaultResolveUnused) {\x0d\n  let { parentURL\x2C conditions } = context;\x0d\n  if (parentURL && policy?.manifest) {\x0d\n    const redirects = policy.manifest.getDependencyMapper(parentURL);\x0d\n    if (redirects) {\x0d\n      const { resolve\x2C reaction } = redirects;\x0d\n      const destination = resolve(specifier\x2C new SafeSet(conditions));\x0d\n      let missing = true;\x0d\n      if (destination === true) {\x0d\n        missing = false;\x0d\n      } else if (destination) {\x0d\n        const href = destination.href;\x0d\n        return { url: href };\x0d\n      }\x0d\n      if (missing) {\x0d\n        reaction(new ERR_MANIFEST_DEPENDENCY_MISSING(\x0d\n          parentURL\x2C\x0d\n          specifier\x2C\x0d\n          ArrayPrototypeJoin([...conditions]\x2C '\x2C '))\x0d\n        );\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  const isMain = parentURL === undefined;\x0d\n  if (isMain) {\x0d\n    parentURL = pathToFileURL(`${process.cwd()}/`).href;\x0d\n\x0d\n    // This is the initial entry point to the program\x2C and --input-type has\x0d\n    // been passed as an option; but --input-type can only be used with\x0d\n    // --eval\x2C --print or STDIN string input. It is not allowed with file\x0d\n    // input\x2C to avoid user confusion over how expansive the effect of the\x0d\n    // flag should be (i.e. entry point only\x2C package scope surrounding the\x0d\n    // entry point\x2C etc.).\x0d\n    if (typeFlag)\x0d\n      throw new ERR_INPUT_TYPE_NOT_ALLOWED();\x0d\n  }\x0d\n\x0d\n  conditions = getConditionsSet(conditions);\x0d\n  let url;\x0d\n  try {\x0d\n    url = moduleResolve(\x0d\n      specifier\x2C\x0d\n      parentURL\x2C\x0d\n      conditions\x2C\x0d\n      isMain ? preserveSymlinksMain : preserveSymlinks\x0d\n    );\x0d\n  } catch (error) {\x0d\n    // Try to give the user a hint of what would have been the\x0d\n    // resolved CommonJS module\x0d\n    if (error.code === 'ERR_MODULE_NOT_FOUND' ||\x0d\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT') {\x0d\n      if (StringPrototypeStartsWith(specifier\x2C 'file://')) {\x0d\n        specifier = fileURLToPath(specifier);\x0d\n      }\x0d\n      const found = resolveAsCommonJS(specifier\x2C parentURL);\x0d\n      if (found) {\x0d\n        // Modify the stack and message string to include the hint\x0d\n        const lines = StringPrototypeSplit(error.stack\x2C '\\n');\x0d\n        const hint = `Did you mean to import ${found}?`;\x0d\n        error.stack =\x0d\n          ArrayPrototypeShift(lines) + '\\n' +\x0d\n          hint + '\\n' +\x0d\n          ArrayPrototypeJoin(lines\x2C '\\n');\x0d\n        error.message += `\\n${hint}`;\x0d\n      }\x0d\n    }\x0d\n    throw error;\x0d\n  }\x0d\n\x0d\n  throwIfUnsupportedURLProtocol(url);\x0d\n\x0d\n  return {\x0d\n    url: `${url}`\x2C\x0d\n    format: defaultGetFormatWithoutErrors(url)\x2C\x0d\n  };\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  DEFAULT_CONDITIONS\x2C\x0d\n  defaultResolve\x2C\x0d\n  encodedSepRegEx\x2C\x0d\n  getPackageScopeConfig\x2C\x0d\n  getPackageType\x2C\x0d\n  packageExportsResolve\x2C\x0d\n  packageImportsResolve\x0d\n};\x0d\n\x0d\n// cycle\x0d\nconst {\x0d\n  defaultGetFormatWithoutErrors\x2C\x0d\n} = require('internal/modules/esm/get_format');\x0d\n
code-source-info,0x1abee833226,110,0,36398,C0O0C4O36398,,
code-creation,Function,10,196678,0x1abee8341d6,1098, node:internal/modules/esm/resolve:1:1,0x1abee8331a0,~
code-source-info,0x1abee8341d6,110,0,36398,C0O0C385O28C391O45C397O68C403O92C409O106C415O124C420O141C426O171C432O205C438O216C444O240C450O273C456O297C461O309C467O321C473O332C479O360C485O388C491O415C497O446C503O473C509O498C515O523C521O588C524O588C528O588C530O644C533O644C538O627C544O737C547O737C552O695C558O712C564O725C570O780C573O780C578O761C584O877C590O877C599O922C606O877C608O1004C611O1004C616O977C622O982C628O992C634O1047C640O1047C644O1047C646O1116C652O1116C656O1116C658O1178C664O1178C668O1178C670O1257C673O1257C678O1219C684O1224C690O1239C696O1644C699O1644C704O1670C709O1294C715O1325C721O1351C727O1384C733O1415C739O1446C745O1482C751O1507C757O1542C763O1576C769O1607C775O1709C778O1709C783O1695C789O1778C792O1778C796O1778C798O1851C804O1851C809O1901C815O1901C820O1957C831O2020C838O2065C839O2065C893O2088C944O2020C948O2020C950O2143C958O2143C963O2143C965O2473C968O2473C973O2473C975O4829C977O4829C982O4829C984O4870C986O4870C991O4870C993O5017C997O5017C999O10493C1003O10493C1005O11502C1009O11502C1011O14865C1015O14865C1017O15069C1021O15069C1023O15103C1027O15103C1029O36112C1036O36134C1042O36157C1048O36176C1054O36196C1060O36222C1066O36241C1072O36267C1078O36127C1082O36353C1085O36353C1090O36317C1097O36397,,
code-creation,Eval,10,197084,0x1abee8374ce,5, node:internal/modules/esm/get_format:1:1,0x1abee837288,~
script-source,111,node:internal/modules/esm/get_format,'use strict';\x0d\nconst {\x0d\n  ObjectAssign\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  RegExpPrototypeExec\x2C\x0d\n} = primordials;\x0d\nconst { extname } = require('path');\x0d\nconst { getOptionValue } = require('internal/options');\x0d\n\x0d\nconst experimentalJsonModules = getOptionValue('--experimental-json-modules');\x0d\nconst experimentalSpecifierResolution =\x0d\n  getOptionValue('--experimental-specifier-resolution');\x0d\nconst experimentalWasmModules = getOptionValue('--experimental-wasm-modules');\x0d\nconst { getPackageType } = require('internal/modules/esm/resolve');\x0d\nconst { URL\x2C fileURLToPath } = require('internal/url');\x0d\nconst { ERR_UNKNOWN_FILE_EXTENSION } = require('internal/errors').codes;\x0d\n\x0d\nconst extensionFormatMap = {\x0d\n  '__proto__': null\x2C\x0d\n  '.cjs': 'commonjs'\x2C\x0d\n  '.js': 'module'\x2C\x0d\n  '.mjs': 'module'\x0d\n};\x0d\n\x0d\nconst legacyExtensionFormatMap = {\x0d\n  '__proto__': null\x2C\x0d\n  '.cjs': 'commonjs'\x2C\x0d\n  '.js': 'commonjs'\x2C\x0d\n  '.json': 'commonjs'\x2C\x0d\n  '.mjs': 'module'\x2C\x0d\n  '.node': 'commonjs'\x0d\n};\x0d\n\x0d\nlet experimentalSpecifierResolutionWarned = false;\x0d\n\x0d\nif (experimentalWasmModules)\x0d\n  extensionFormatMap['.wasm'] = legacyExtensionFormatMap['.wasm'] = 'wasm';\x0d\n\x0d\nif (experimentalJsonModules)\x0d\n  extensionFormatMap['.json'] = legacyExtensionFormatMap['.json'] = 'json';\x0d\n\x0d\nconst protocolHandlers = ObjectAssign(ObjectCreate(null)\x2C {\x0d\n  'data:'(parsed) {\x0d\n    const { 1: mime } = RegExpPrototypeExec(\x0d\n      /^([^/]+\\/[^;\x2C]+)(?:[^\x2C]*?)(;base64)?\x2C/\x2C\x0d\n      parsed.pathname\x2C\x0d\n    ) || [\x2C null]; // eslint-disable-line no-sparse-arrays\x0d\n    const format = ({\x0d\n      '__proto__': null\x2C\x0d\n      'text/javascript': 'module'\x2C\x0d\n      'application/json': experimentalJsonModules ? 'json' : null\x2C\x0d\n      'application/wasm': experimentalWasmModules ? 'wasm' : null\x0d\n    })[mime] || null;\x0d\n\x0d\n    return format;\x0d\n  }\x2C\x0d\n  'file:': getFileProtocolModuleFormat\x2C\x0d\n  'node:'() { return 'builtin'; }\x2C\x0d\n});\x0d\n\x0d\nfunction getLegacyExtensionFormat(ext) {\x0d\n  if (\x0d\n    experimentalSpecifierResolution === 'node' &&\x0d\n    !experimentalSpecifierResolutionWarned\x0d\n  ) {\x0d\n    process.emitWarning(\x0d\n      'The Node.js specifier resolution in ESM is experimental.'\x2C\x0d\n      'ExperimentalWarning');\x0d\n    experimentalSpecifierResolutionWarned = true;\x0d\n  }\x0d\n  return legacyExtensionFormatMap[ext];\x0d\n}\x0d\n\x0d\nfunction getFileProtocolModuleFormat(url\x2C ignoreErrors) {\x0d\n  const ext = extname(url.pathname);\x0d\n  if (ext === '.js') {\x0d\n    return getPackageType(url) === 'module' ? 'module' : 'commonjs';\x0d\n  }\x0d\n\x0d\n  const format = extensionFormatMap[ext];\x0d\n  if (format) return format;\x0d\n  if (experimentalSpecifierResolution !== 'node') {\x0d\n    // Explicit undefined return indicates load hook should rerun format check\x0d\n    if (ignoreErrors)\x0d\n      return undefined;\x0d\n    throw new ERR_UNKNOWN_FILE_EXTENSION(ext\x2C fileURLToPath(url));\x0d\n  }\x0d\n  return getLegacyExtensionFormat(ext) ?? null;\x0d\n}\x0d\n\x0d\nfunction defaultGetFormatWithoutErrors(url\x2C context) {\x0d\n  const parsed = new URL(url);\x0d\n  if (!ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol))\x0d\n    return null;\x0d\n  return protocolHandlers[parsed.protocol](parsed\x2C true);\x0d\n}\x0d\n\x0d\nfunction defaultGetFormat(url\x2C context) {\x0d\n  const parsed = new URL(url);\x0d\n  return ObjectPrototypeHasOwnProperty(protocolHandlers\x2C parsed.protocol) ?\x0d\n    protocolHandlers[parsed.protocol](parsed\x2C false) :\x0d\n    null;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  defaultGetFormat\x2C\x0d\n  defaultGetFormatWithoutErrors\x2C\x0d\n  extensionFormatMap\x2C\x0d\n  legacyExtensionFormatMap\x2C\x0d\n};\x0d\n
code-source-info,0x1abee8374ce,111,0,3433,C0O0C4O3433,,
code-creation,Function,10,197311,0x1abee8379c6,340, node:internal/modules/esm/get_format:1:1,0x1abee837448,~
code-source-info,0x1abee8379c6,111,0,3433,C0O0C72O26C77O43C82O60C88O94C94O154C97O154C102O142C108O199C111O199C116O180C121O263C124O263C128O263C130O354C133O354C137O354C139O442C142O442C146O442C148O517C151O517C156O498C162O590C165O590C170O567C176O572C182O655C185O655C190O681C195O624C201O719C205O719C207O846C211O846C213O1034C214O1034C216O1044C220O1076C229O1140C235O1104C239O1153C243O1185C252O1249C258O1213C262O1287C264O1300C274O1325C284O1804C288O1836C296O1287C301O1287C303O3302C310O3324C316O3345C322O3379C328O3402C334O3317C339O3432,,
code-creation,Eval,10,197513,0x1abee8387ae,5, node:internal/modules/esm/initialize_import_meta:1:1,0x1abee838618,~
script-source,112,node:internal/modules/esm/initialize_import_meta,'use strict';\x0d\n\x0d\nconst { getOptionValue } = require('internal/options');\x0d\nconst experimentalImportMetaResolve =\x0d\ngetOptionValue('--experimental-import-meta-resolve');\x0d\nconst { PromisePrototypeThen\x2C PromiseReject } = primordials;\x0d\nconst asyncESM = require('internal/process/esm_loader');\x0d\n\x0d\nfunction createImportMetaResolve(defaultParentUrl) {\x0d\n  return async function resolve(specifier\x2C parentUrl = defaultParentUrl) {\x0d\n    return PromisePrototypeThen(\x0d\n      asyncESM.esmLoader.resolve(specifier\x2C parentUrl)\x2C\x0d\n      ({ url }) => url\x2C\x0d\n      (error) => (\x0d\n        error.code === 'ERR_UNSUPPORTED_DIR_IMPORT' ?\x0d\n          error.url : PromiseReject(error))\x0d\n    );\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction initializeImportMeta(meta\x2C context) {\x0d\n  const url = context.url;\x0d\n\x0d\n  // Alphabetical\x0d\n  if (experimentalImportMetaResolve)\x0d\n    meta.resolve = createImportMetaResolve(url);\x0d\n  meta.url = url;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  initializeImportMeta\x0d\n};\x0d\n
code-source-info,0x1abee8387ae,112,0,932,C0O0C4O932,,
code-creation,Function,10,197589,0x1abee838976,90, node:internal/modules/esm/initialize_import_meta:1:1,0x1abee838728,~
code-source-info,0x1abee838976,112,0,932,C0O0C28O44C31O44C36O25C41O113C44O113C48O113C50O176C56O198C62O247C65O247C69O247C71O884C78O906C84O899C89O931,,
code-creation,Eval,10,197714,0x1abee838e36,5, node:internal/modules/esm/load:1:1,0x1abee838cc0,~
script-source,113,node:internal/modules/esm/load,'use strict';\x0d\n\x0d\nconst { defaultGetFormat } = require('internal/modules/esm/get_format');\x0d\nconst { defaultGetSource } = require('internal/modules/esm/get_source');\x0d\nconst { validateAssertions } = require('internal/modules/esm/assert');\x0d\n\x0d\n/**\x0d\n * Node.js default load hook.\x0d\n * @param {string} url\x0d\n * @param {object} context\x0d\n * @returns {object}\x0d\n */\x0d\nasync function defaultLoad(url\x2C context) {\x0d\n  let {\x0d\n    format\x2C\x0d\n    source\x2C\x0d\n  } = context;\x0d\n  const { importAssertions } = context;\x0d\n\x0d\n  if (format == null) {\x0d\n    format = defaultGetFormat(url);\x0d\n  }\x0d\n\x0d\n  validateAssertions(url\x2C format\x2C importAssertions);\x0d\n\x0d\n  if (\x0d\n    format === 'builtin' ||\x0d\n    format === 'commonjs'\x0d\n  ) {\x0d\n    source = null;\x0d\n  } else if (source == null) {\x0d\n    source = await defaultGetSource(url\x2C { format });\x0d\n  }\x0d\n\x0d\n  return {\x0d\n    format\x2C\x0d\n    source\x2C\x0d\n  };\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  defaultLoad\x2C\x0d\n};\x0d\n
code-source-info,0x1abee838e36,113,0,891,C0O0C4O891,,
code-creation,Function,10,197799,0x1abee838f7e,80, node:internal/modules/esm/load:1:1,0x1abee838db0,~
code-source-info,0x1abee838f7e,113,0,891,C0O0C19O46C22O46C27O25C33O120C36O120C41O99C47O196C50O196C55O173C61O851C68O873C74O866C79O890,,
code-creation,Eval,10,197932,0x1abee83953e,5, node:internal/modules/esm/get_source:1:1,0x1abee839368,~
script-source,114,node:internal/modules/esm/get_source,'use strict';\x0d\n\x0d\nconst {\x0d\n  RegExpPrototypeExec\x2C\x0d\n  decodeURIComponent\x2C\x0d\n} = primordials;\x0d\nconst { getOptionValue } = require('internal/options');\x0d\n// Do not eagerly grab .manifest\x2C it may be in TDZ\x0d\nconst policy = getOptionValue('--experimental-policy') ?\x0d\n  require('internal/process/policy') :\x0d\n  null;\x0d\n\x0d\nconst { Buffer } = require('buffer');\x0d\n\x0d\nconst fs = require('internal/fs/promises').exports;\x0d\nconst { URL } = require('internal/url');\x0d\nconst {\x0d\n  ERR_INVALID_URL\x2C\x0d\n  ERR_INVALID_URL_SCHEME\x2C\x0d\n} = require('internal/errors').codes;\x0d\nconst readFileAsync = fs.readFile;\x0d\n\x0d\nconst DATA_URL_PATTERN = /^[^/]+\\/[^\x2C;]+(?:[^\x2C]*?)(;base64)?\x2C([\\s\\S]*)$/;\x0d\n\x0d\nasync function defaultGetSource(url\x2C { format } = {}\x2C defaultGetSource) {\x0d\n  const parsed = new URL(url);\x0d\n  let source;\x0d\n  if (parsed.protocol === 'file:') {\x0d\n    source = await readFileAsync(parsed);\x0d\n  } else if (parsed.protocol === 'data:') {\x0d\n    const match = RegExpPrototypeExec(DATA_URL_PATTERN\x2C parsed.pathname);\x0d\n    if (!match) {\x0d\n      throw new ERR_INVALID_URL(url);\x0d\n    }\x0d\n    const { 1: base64\x2C 2: body } = match;\x0d\n    source = Buffer.from(decodeURIComponent(body)\x2C base64 ? 'base64' : 'utf8');\x0d\n  } else {\x0d\n    throw new ERR_INVALID_URL_SCHEME(['file'\x2C 'data']);\x0d\n  }\x0d\n  if (policy?.manifest) {\x0d\n    policy.manifest.assertIntegrity(parsed\x2C source);\x0d\n  }\x0d\n  return source;\x0d\n}\x0d\nexports.defaultGetSource = defaultGetSource;\x0d\n
code-source-info,0x1abee83953e,114,0,1394,C0O0C4O1394,,
code-creation,Function,10,198030,0x1abee8396ae,169, node:internal/modules/esm/get_source:1:1,0x1abee8394b8,~
code-source-info,0x1abee8396ae,114,0,1394,C0O0C37O28C43O52C49O118C52O118C57O99C62O215C65O215C74O260C81O215C83O328C86O328C91O317C97O361C100O361C105O392C110O419C113O419C118O411C124O505C127O505C132O531C137O456C143O476C149O565C153O562C155O603C159O603C161O1348C163O1373C168O1393,,
code-creation,Eval,10,198783,0x1abee83ac76,5, node:internal/fs/promises:1:1,0x1abee83a468,~
script-source,115,node:internal/fs/promises,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypePush\x2C\x0d\n  Error\x2C\x0d\n  MathMax\x2C\x0d\n  MathMin\x2C\x0d\n  NumberIsSafeInteger\x2C\x0d\n  Promise\x2C\x0d\n  PromisePrototypeThen\x2C\x0d\n  PromiseResolve\x2C\x0d\n  PromiseReject\x2C\x0d\n  SafeArrayIterator\x2C\x0d\n  SafePromisePrototypeFinally\x2C\x0d\n  Symbol\x2C\x0d\n  Uint8Array\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  F_OK\x2C\x0d\n  O_SYMLINK\x2C\x0d\n  O_WRONLY\x2C\x0d\n  S_IFMT\x2C\x0d\n  S_IFREG\x0d\n} = internalBinding('constants').fs;\x0d\nconst binding = internalBinding('fs');\x0d\nconst { Buffer } = require('buffer');\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_FS_FILE_TOO_LARGE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_INVALID_STATE\x2C\x0d\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\x0d\n  }\x2C\x0d\n  AbortError\x2C\x0d\n  aggregateTwoErrors\x2C\x0d\n} = require('internal/errors');\x0d\nconst { isArrayBufferView } = require('internal/util/types');\x0d\nconst { rimrafPromises } = require('internal/fs/rimraf');\x0d\nconst {\x0d\n  constants: {\x0d\n    kIoMaxLength\x2C\x0d\n    kMaxUserId\x2C\x0d\n    kReadFileBufferLength\x2C\x0d\n    kReadFileUnknownBufferLength\x2C\x0d\n    kWriteFileMaxChunkSize\x2C\x0d\n  }\x2C\x0d\n  copyObject\x2C\x0d\n  emitRecursiveRmdirWarning\x2C\x0d\n  getDirents\x2C\x0d\n  getOptions\x2C\x0d\n  getStatsFromBinding\x2C\x0d\n  getValidatedPath\x2C\x0d\n  getValidMode\x2C\x0d\n  nullCheck\x2C\x0d\n  preprocessSymlinkDestination\x2C\x0d\n  stringToFlags\x2C\x0d\n  stringToSymlinkType\x2C\x0d\n  toUnixTimestamp\x2C\x0d\n  validateBufferArray\x2C\x0d\n  validateCpOptions\x2C\x0d\n  validateOffsetLengthRead\x2C\x0d\n  validateOffsetLengthWrite\x2C\x0d\n  validateRmOptions\x2C\x0d\n  validateRmdirOptions\x2C\x0d\n  validateStringAfterArrayBufferView\x2C\x0d\n  warnOnNonPortableTemplate\x2C\x0d\n} = require('internal/fs/utils');\x0d\nconst { opendir } = require('internal/fs/dir');\x0d\nconst {\x0d\n  parseFileMode\x2C\x0d\n  validateAbortSignal\x2C\x0d\n  validateBoolean\x2C\x0d\n  validateBuffer\x2C\x0d\n  validateEncoding\x2C\x0d\n  validateInteger\x2C\x0d\n  validateString\x2C\x0d\n} = require('internal/validators');\x0d\nconst pathModule = require('path');\x0d\nconst { lazyDOMException\x2C promisify } = require('internal/util');\x0d\nconst { EventEmitterMixin } = require('internal/event_target');\x0d\nconst { watch } = require('internal/fs/watchers');\x0d\nconst { isIterable } = require('internal/streams/utils');\x0d\nconst assert = require('internal/assert');\x0d\n\x0d\nconst kHandle = Symbol('kHandle');\x0d\nconst kFd = Symbol('kFd');\x0d\nconst kRefs = Symbol('kRefs');\x0d\nconst kClosePromise = Symbol('kClosePromise');\x0d\nconst kCloseResolve = Symbol('kCloseResolve');\x0d\nconst kCloseReject = Symbol('kCloseReject');\x0d\nconst kRef = Symbol('kRef');\x0d\nconst kUnref = Symbol('kUnref');\x0d\nconst kLocked = Symbol('kLocked');\x0d\n\x0d\nconst { kUsePromises } = binding;\x0d\nconst {\x0d\n  JSTransferable\x2C kDeserialize\x2C kTransfer\x2C kTransferList\x0d\n} = require('internal/worker/js_transferable');\x0d\n\x0d\nconst {\x0d\n  newReadableStreamFromStreamBase\x2C\x0d\n} = require('internal/webstreams/adapters');\x0d\n\x0d\nconst {\x0d\n  readableStreamCancel\x2C\x0d\n} = require('internal/webstreams/readablestream');\x0d\n\x0d\nconst getDirectoryEntriesPromise = promisify(getDirents);\x0d\nconst validateRmOptionsPromise = promisify(validateRmOptions);\x0d\n\x0d\nlet cpPromises;\x0d\nfunction lazyLoadCpPromises() {\x0d\n  return cpPromises ??= require('internal/fs/cp/cp').cpFn;\x0d\n}\x0d\n\x0d\n// Lazy loaded to avoid circular dependency.\x0d\nlet fsStreams;\x0d\nfunction lazyFsStreams() {\x0d\n  return fsStreams ??= require('internal/fs/streams');\x0d\n}\x0d\n\x0d\nclass FileHandle extends EventEmitterMixin(JSTransferable) {\x0d\n  /**\x0d\n   * @param {InternalFSBinding.FileHandle | undefined} filehandle\x0d\n   */\x0d\n  constructor(filehandle) {\x0d\n    super();\x0d\n    this[kHandle] = filehandle;\x0d\n    this[kFd] = filehandle ? filehandle.fd : -1;\x0d\n\x0d\n    this[kRefs] = 1;\x0d\n    this[kClosePromise] = null;\x0d\n  }\x0d\n\x0d\n  getAsyncId() {\x0d\n    return this[kHandle].getAsyncId();\x0d\n  }\x0d\n\x0d\n  get fd() {\x0d\n    return this[kFd];\x0d\n  }\x0d\n\x0d\n  appendFile(data\x2C options) {\x0d\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\x0d\n  }\x0d\n\x0d\n  chmod(mode) {\x0d\n    return fsCall(fchmod\x2C this\x2C mode);\x0d\n  }\x0d\n\x0d\n  chown(uid\x2C gid) {\x0d\n    return fsCall(fchown\x2C this\x2C uid\x2C gid);\x0d\n  }\x0d\n\x0d\n  datasync() {\x0d\n    return fsCall(fdatasync\x2C this);\x0d\n  }\x0d\n\x0d\n  sync() {\x0d\n    return fsCall(fsync\x2C this);\x0d\n  }\x0d\n\x0d\n  read(buffer\x2C offset\x2C length\x2C position) {\x0d\n    return fsCall(read\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\x0d\n  }\x0d\n\x0d\n  readv(buffers\x2C position) {\x0d\n    return fsCall(readv\x2C this\x2C buffers\x2C position);\x0d\n  }\x0d\n\x0d\n  readFile(options) {\x0d\n    return fsCall(readFile\x2C this\x2C options);\x0d\n  }\x0d\n\x0d\n  stat(options) {\x0d\n    return fsCall(fstat\x2C this\x2C options);\x0d\n  }\x0d\n\x0d\n  truncate(len = 0) {\x0d\n    return fsCall(ftruncate\x2C this\x2C len);\x0d\n  }\x0d\n\x0d\n  utimes(atime\x2C mtime) {\x0d\n    return fsCall(futimes\x2C this\x2C atime\x2C mtime);\x0d\n  }\x0d\n\x0d\n  write(buffer\x2C offset\x2C length\x2C position) {\x0d\n    return fsCall(write\x2C this\x2C buffer\x2C offset\x2C length\x2C position);\x0d\n  }\x0d\n\x0d\n  writev(buffers\x2C position) {\x0d\n    return fsCall(writev\x2C this\x2C buffers\x2C position);\x0d\n  }\x0d\n\x0d\n  writeFile(data\x2C options) {\x0d\n    return fsCall(writeFile\x2C this\x2C data\x2C options);\x0d\n  }\x0d\n\x0d\n  close = () => {\x0d\n    if (this[kFd] === -1) {\x0d\n      return PromiseResolve();\x0d\n    }\x0d\n\x0d\n    if (this[kClosePromise]) {\x0d\n      return this[kClosePromise];\x0d\n    }\x0d\n\x0d\n    this[kRefs]--;\x0d\n    if (this[kRefs] === 0) {\x0d\n      this[kFd] = -1;\x0d\n      this[kClosePromise] = SafePromisePrototypeFinally(\x0d\n        this[kHandle].close()\x2C\x0d\n        () => { this[kClosePromise] = undefined; }\x0d\n      );\x0d\n    } else {\x0d\n      this[kClosePromise] = SafePromisePrototypeFinally(\x0d\n        new Promise((resolve\x2C reject) => {\x0d\n          this[kCloseResolve] = resolve;\x0d\n          this[kCloseReject] = reject;\x0d\n        })\x2C () => {\x0d\n          this[kClosePromise] = undefined;\x0d\n          this[kCloseReject] = undefined;\x0d\n          this[kCloseResolve] = undefined;\x0d\n        }\x0d\n      );\x0d\n    }\x0d\n\x0d\n    this.emit('close');\x0d\n    return this[kClosePromise];\x0d\n  };\x0d\n\x0d\n  /**\x0d\n   * @typedef {import('../webstreams/readablestream').ReadableStream\x0d\n   * } ReadableStream\x0d\n   * @returns {ReadableStream}\x0d\n   */\x0d\n  readableWebStream() {\x0d\n    if (this[kFd] === -1)\x0d\n      throw new ERR_INVALID_STATE('The FileHandle is closed');\x0d\n    if (this[kClosePromise])\x0d\n      throw new ERR_INVALID_STATE('The FileHandle is closing');\x0d\n    if (this[kLocked])\x0d\n      throw new ERR_INVALID_STATE('The FileHandle is locked');\x0d\n    this[kLocked] = true;\x0d\n\x0d\n    const readable = newReadableStreamFromStreamBase(\x0d\n      this[kHandle]\x2C\x0d\n      undefined\x2C\x0d\n      { ondone: () => this[kUnref]() });\x0d\n\x0d\n    this[kRef]();\x0d\n    this.once('close'\x2C () => {\x0d\n      readableStreamCancel(readable);\x0d\n    });\x0d\n\x0d\n    return readable;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @typedef {import('./streams').ReadStream\x0d\n   * } ReadStream\x0d\n   * @param {{\x0d\n   *   encoding?: string;\x0d\n   *   autoClose?: boolean;\x0d\n   *   emitClose?: boolean;\x0d\n   *   start: number;\x0d\n   *   end?: number;\x0d\n   *   highWaterMark?: number;\x0d\n   *   }} [options]\x0d\n   * @returns {ReadStream}\x0d\n   */\x0d\n  createReadStream(options = undefined) {\x0d\n    const { ReadStream } = lazyFsStreams();\x0d\n    return new ReadStream(undefined\x2C { ...options\x2C fd: this });\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @typedef {import('./streams').WriteStream\x0d\n   * } WriteStream\x0d\n   * @param {{\x0d\n   *   encoding?: string;\x0d\n   *   autoClose?: boolean;\x0d\n   *   emitClose?: boolean;\x0d\n   *   start: number;\x0d\n   *   }} [options]\x0d\n   * @returns {WriteStream}\x0d\n   */\x0d\n  createWriteStream(options = undefined) {\x0d\n    const { WriteStream } = lazyFsStreams();\x0d\n    return new WriteStream(undefined\x2C { ...options\x2C fd: this });\x0d\n  }\x0d\n\x0d\n  [kTransfer]() {\x0d\n    if (this[kClosePromise] || this[kRefs] > 1) {\x0d\n      throw lazyDOMException('Cannot transfer FileHandle while in use'\x2C\x0d\n                             'DataCloneError');\x0d\n    }\x0d\n\x0d\n    const handle = this[kHandle];\x0d\n    this[kFd] = -1;\x0d\n    this[kHandle] = null;\x0d\n    this[kRefs] = 0;\x0d\n\x0d\n    return {\x0d\n      data: { handle }\x2C\x0d\n      deserializeInfo: 'internal/fs/promises:FileHandle'\x0d\n    };\x0d\n  }\x0d\n\x0d\n  [kTransferList]() {\x0d\n    return [ this[kHandle] ];\x0d\n  }\x0d\n\x0d\n  [kDeserialize]({ handle }) {\x0d\n    this[kHandle] = handle;\x0d\n    this[kFd] = handle.fd;\x0d\n  }\x0d\n\x0d\n  [kRef]() {\x0d\n    this[kRefs]++;\x0d\n  }\x0d\n\x0d\n  [kUnref]() {\x0d\n    this[kRefs]--;\x0d\n    if (this[kRefs] === 0) {\x0d\n      this[kFd] = -1;\x0d\n      PromisePrototypeThen(\x0d\n        this[kHandle].close()\x2C\x0d\n        this[kCloseResolve]\x2C\x0d\n        this[kCloseReject]\x0d\n      );\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nasync function handleFdClose(fileOpPromise\x2C closeFunc) {\x0d\n  return PromisePrototypeThen(\x0d\n    fileOpPromise\x2C\x0d\n    (result) => PromisePrototypeThen(closeFunc()\x2C () => result)\x2C\x0d\n    (opError) =>\x0d\n      PromisePrototypeThen(\x0d\n        closeFunc()\x2C\x0d\n        () => PromiseReject(opError)\x2C\x0d\n        (closeError) => PromiseReject(aggregateTwoErrors(closeError\x2C opError))\x0d\n      )\x0d\n  );\x0d\n}\x0d\n\x0d\nasync function fsCall(fn\x2C handle\x2C ...args) {\x0d\n  assert(handle[kRefs] !== undefined\x2C\x0d\n         'handle must be an instance of FileHandle');\x0d\n\x0d\n  if (handle.fd === -1) {\x0d\n    // eslint-disable-next-line no-restricted-syntax\x0d\n    const err = new Error('file closed');\x0d\n    err.code = 'EBADF';\x0d\n    err.syscall = fn.name;\x0d\n    throw err;\x0d\n  }\x0d\n\x0d\n  try {\x0d\n    handle[kRef]();\x0d\n    return await fn(handle\x2C ...new SafeArrayIterator(args));\x0d\n  } finally {\x0d\n    handle[kUnref]();\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction checkAborted(signal) {\x0d\n  if (signal?.aborted)\x0d\n    throw new AbortError(undefined\x2C { cause: signal?.reason });\x0d\n}\x0d\n\x0d\nasync function writeFileHandle(filehandle\x2C data\x2C signal\x2C encoding) {\x0d\n  checkAborted(signal);\x0d\n  if (isCustomIterable(data)) {\x0d\n    for await (const buf of data) {\x0d\n      checkAborted(signal);\x0d\n      const toWrite =\x0d\n        isArrayBufferView(buf) ? buf : Buffer.from(buf\x2C encoding || 'utf8');\x0d\n      let remaining = toWrite.byteLength;\x0d\n      while (remaining > 0) {\x0d\n        const writeSize = MathMin(kWriteFileMaxChunkSize\x2C remaining);\x0d\n        const { bytesWritten } = await write(\x0d\n          filehandle\x2C toWrite\x2C toWrite.byteLength - remaining\x2C writeSize);\x0d\n        remaining -= bytesWritten;\x0d\n        checkAborted(signal);\x0d\n      }\x0d\n    }\x0d\n    return;\x0d\n  }\x0d\n  data = new Uint8Array(data.buffer\x2C data.byteOffset\x2C data.byteLength);\x0d\n  let remaining = data.byteLength;\x0d\n  if (remaining === 0) return;\x0d\n  do {\x0d\n    checkAborted(signal);\x0d\n    const { bytesWritten } =\x0d\n      await write(filehandle\x2C data\x2C 0\x2C\x0d\n                  MathMin(kWriteFileMaxChunkSize\x2C data.byteLength));\x0d\n    remaining -= bytesWritten;\x0d\n    data = new Uint8Array(\x0d\n      data.buffer\x2C\x0d\n      data.byteOffset + bytesWritten\x2C\x0d\n      data.byteLength - bytesWritten\x0d\n    );\x0d\n  } while (remaining > 0);\x0d\n}\x0d\n\x0d\nasync function readFileHandle(filehandle\x2C options) {\x0d\n  const signal = options?.signal;\x0d\n\x0d\n  checkAborted(signal);\x0d\n\x0d\n  const statFields = await binding.fstat(filehandle.fd\x2C false\x2C kUsePromises);\x0d\n\x0d\n  checkAborted(signal);\x0d\n\x0d\n  let size;\x0d\n  if ((statFields[1/* mode */] & S_IFMT) === S_IFREG) {\x0d\n    size = statFields[8/* size */];\x0d\n  } else {\x0d\n    size = 0;\x0d\n  }\x0d\n\x0d\n  if (size > kIoMaxLength)\x0d\n    throw new ERR_FS_FILE_TOO_LARGE(size);\x0d\n\x0d\n  let endOfFile = false;\x0d\n  let totalRead = 0;\x0d\n  const noSize = size === 0;\x0d\n  const buffers = [];\x0d\n  const fullBuffer = noSize ? undefined : Buffer.allocUnsafeSlow(size);\x0d\n  do {\x0d\n    checkAborted(signal);\x0d\n    let buffer;\x0d\n    let offset;\x0d\n    let length;\x0d\n    if (noSize) {\x0d\n      buffer = Buffer.allocUnsafeSlow(kReadFileUnknownBufferLength);\x0d\n      offset = 0;\x0d\n      length = kReadFileUnknownBufferLength;\x0d\n    } else {\x0d\n      buffer = fullBuffer;\x0d\n      offset = totalRead;\x0d\n      length = MathMin(size - totalRead\x2C kReadFileBufferLength);\x0d\n    }\x0d\n\x0d\n    const bytesRead = (await binding.read(filehandle.fd\x2C buffer\x2C offset\x2C\x0d\n                                          length\x2C -1\x2C kUsePromises)) || 0;\x0d\n    totalRead += bytesRead;\x0d\n    endOfFile = bytesRead === 0 || totalRead === size;\x0d\n    if (noSize && bytesRead > 0) {\x0d\n      const isBufferFull = bytesRead === kReadFileUnknownBufferLength;\x0d\n      const chunkBuffer = isBufferFull ? buffer : buffer.slice(0\x2C bytesRead);\x0d\n      ArrayPrototypePush(buffers\x2C chunkBuffer);\x0d\n    }\x0d\n  } while (!endOfFile);\x0d\n\x0d\n  let result;\x0d\n  if (size > 0) {\x0d\n    result = totalRead === size ? fullBuffer : fullBuffer.slice(0\x2C totalRead);\x0d\n  } else {\x0d\n    result = buffers.length === 1 ? buffers[0] : Buffer.concat(buffers\x2C\x0d\n                                                               totalRead);\x0d\n  }\x0d\n\x0d\n  return options.encoding ? result.toString(options.encoding) : result;\x0d\n}\x0d\n\x0d\n// All of the functions are defined as async in order to ensure that errors\x0d\n// thrown cause promise rejections rather than being thrown synchronously.\x0d\nasync function access(path\x2C mode = F_OK) {\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  mode = getValidMode(mode\x2C 'access');\x0d\n  return binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C\x0d\n                        kUsePromises);\x0d\n}\x0d\n\x0d\nasync function cp(src\x2C dest\x2C options) {\x0d\n  options = validateCpOptions(options);\x0d\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\x0d\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\x0d\n  return lazyLoadCpPromises()(src\x2C dest\x2C options);\x0d\n}\x0d\n\x0d\nasync function copyFile(src\x2C dest\x2C mode) {\x0d\n  src = getValidatedPath(src\x2C 'src');\x0d\n  dest = getValidatedPath(dest\x2C 'dest');\x0d\n  mode = getValidMode(mode\x2C 'copyFile');\x0d\n  return binding.copyFile(pathModule.toNamespacedPath(src)\x2C\x0d\n                          pathModule.toNamespacedPath(dest)\x2C\x0d\n                          mode\x2C\x0d\n                          kUsePromises);\x0d\n}\x0d\n\x0d\n// Note that unlike fs.open() which uses numeric file descriptors\x2C\x0d\n// fsPromises.open() uses the fs.FileHandle class.\x0d\nasync function open(path\x2C flags\x2C mode) {\x0d\n  path = getValidatedPath(path);\x0d\n  const flagsNumber = stringToFlags(flags);\x0d\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\x0d\n  return new FileHandle(\x0d\n    await binding.openFileHandle(pathModule.toNamespacedPath(path)\x2C\x0d\n                                 flagsNumber\x2C mode\x2C kUsePromises));\x0d\n}\x0d\n\x0d\nasync function read(handle\x2C bufferOrOptions\x2C offset\x2C length\x2C position) {\x0d\n  let buffer = bufferOrOptions;\x0d\n  if (!isArrayBufferView(buffer)) {\x0d\n    if (bufferOrOptions === undefined) {\x0d\n      bufferOrOptions = {};\x0d\n    }\x0d\n    if (bufferOrOptions.buffer) {\x0d\n      buffer = bufferOrOptions.buffer;\x0d\n      validateBuffer(buffer);\x0d\n    } else {\x0d\n      buffer = Buffer.alloc(16384);\x0d\n    }\x0d\n    offset = bufferOrOptions.offset || 0;\x0d\n    length = bufferOrOptions.length ?? buffer.byteLength;\x0d\n    position = bufferOrOptions.position ?? null;\x0d\n  }\x0d\n\x0d\n  if (offset == null) {\x0d\n    offset = 0;\x0d\n  } else {\x0d\n    validateInteger(offset\x2C 'offset'\x2C 0);\x0d\n  }\x0d\n\x0d\n  length |= 0;\x0d\n\x0d\n  if (length === 0)\x0d\n    return { bytesRead: length\x2C buffer };\x0d\n\x0d\n  if (buffer.byteLength === 0) {\x0d\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\x0d\n                                    'is empty and cannot be written');\x0d\n  }\x0d\n\x0d\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\x0d\n\x0d\n  if (!NumberIsSafeInteger(position))\x0d\n    position = -1;\x0d\n\x0d\n  const bytesRead = (await binding.read(handle.fd\x2C buffer\x2C offset\x2C length\x2C\x0d\n                                        position\x2C kUsePromises)) || 0;\x0d\n\x0d\n  return { bytesRead\x2C buffer };\x0d\n}\x0d\n\x0d\nasync function readv(handle\x2C buffers\x2C position) {\x0d\n  validateBufferArray(buffers);\x0d\n\x0d\n  if (typeof position !== 'number')\x0d\n    position = null;\x0d\n\x0d\n  const bytesRead = (await binding.readBuffers(handle.fd\x2C buffers\x2C position\x2C\x0d\n                                               kUsePromises)) || 0;\x0d\n  return { bytesRead\x2C buffers };\x0d\n}\x0d\n\x0d\nasync function write(handle\x2C buffer\x2C offset\x2C length\x2C position) {\x0d\n  if (buffer?.byteLength === 0)\x0d\n    return { bytesWritten: 0\x2C buffer };\x0d\n\x0d\n  if (isArrayBufferView(buffer)) {\x0d\n    if (offset == null) {\x0d\n      offset = 0;\x0d\n    } else {\x0d\n      validateInteger(offset\x2C 'offset'\x2C 0);\x0d\n    }\x0d\n    if (typeof length !== 'number')\x0d\n      length = buffer.byteLength - offset;\x0d\n    if (typeof position !== 'number')\x0d\n      position = null;\x0d\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\x0d\n    const bytesWritten =\x0d\n      (await binding.writeBuffer(handle.fd\x2C buffer\x2C offset\x2C\x0d\n                                 length\x2C position\x2C kUsePromises)) || 0;\x0d\n    return { bytesWritten\x2C buffer };\x0d\n  }\x0d\n\x0d\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\x0d\n  validateEncoding(buffer\x2C length);\x0d\n  const bytesWritten = (await binding.writeString(handle.fd\x2C buffer\x2C offset\x2C\x0d\n                                                  length\x2C kUsePromises)) || 0;\x0d\n  return { bytesWritten\x2C buffer };\x0d\n}\x0d\n\x0d\nasync function writev(handle\x2C buffers\x2C position) {\x0d\n  validateBufferArray(buffers);\x0d\n\x0d\n  if (typeof position !== 'number')\x0d\n    position = null;\x0d\n\x0d\n  const bytesWritten = (await binding.writeBuffers(handle.fd\x2C buffers\x2C position\x2C\x0d\n                                                   kUsePromises)) || 0;\x0d\n  return { bytesWritten\x2C buffers };\x0d\n}\x0d\n\x0d\nasync function rename(oldPath\x2C newPath) {\x0d\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\x0d\n  newPath = getValidatedPath(newPath\x2C 'newPath');\x0d\n  return binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\x0d\n                        pathModule.toNamespacedPath(newPath)\x2C\x0d\n                        kUsePromises);\x0d\n}\x0d\n\x0d\nasync function truncate(path\x2C len = 0) {\x0d\n  const fd = await open(path\x2C 'r+');\x0d\n  return handleFdClose(ftruncate(fd\x2C len)\x2C fd.close);\x0d\n}\x0d\n\x0d\nasync function ftruncate(handle\x2C len = 0) {\x0d\n  validateInteger(len\x2C 'len');\x0d\n  len = MathMax(0\x2C len);\x0d\n  return binding.ftruncate(handle.fd\x2C len\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function rm(path\x2C options) {\x0d\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\x0d\n  options = await validateRmOptionsPromise(path\x2C options\x2C false);\x0d\n  return rimrafPromises(path\x2C options);\x0d\n}\x0d\n\x0d\nasync function rmdir(path\x2C options) {\x0d\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\x0d\n  options = validateRmdirOptions(options);\x0d\n\x0d\n  if (options.recursive) {\x0d\n    emitRecursiveRmdirWarning();\x0d\n    const stats = await stat(path);\x0d\n    if (stats.isDirectory()) {\x0d\n      return rimrafPromises(path\x2C options);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return binding.rmdir(path\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function fdatasync(handle) {\x0d\n  return binding.fdatasync(handle.fd\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function fsync(handle) {\x0d\n  return binding.fsync(handle.fd\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function mkdir(path\x2C options) {\x0d\n  if (typeof options === 'number' || typeof options === 'string') {\x0d\n    options = { mode: options };\x0d\n  }\x0d\n  const {\x0d\n    recursive = false\x2C\x0d\n    mode = 0o777\x0d\n  } = options || {};\x0d\n  path = getValidatedPath(path);\x0d\n  validateBoolean(recursive\x2C 'options.recursive');\x0d\n\x0d\n  return binding.mkdir(pathModule.toNamespacedPath(path)\x2C\x0d\n                       parseFileMode(mode\x2C 'mode'\x2C 0o777)\x2C recursive\x2C\x0d\n                       kUsePromises);\x0d\n}\x0d\n\x0d\nasync function readdir(path\x2C options) {\x0d\n  options = getOptions(options\x2C {});\x0d\n  path = getValidatedPath(path);\x0d\n  const result = await binding.readdir(pathModule.toNamespacedPath(path)\x2C\x0d\n                                       options.encoding\x2C\x0d\n                                       !!options.withFileTypes\x2C\x0d\n                                       kUsePromises);\x0d\n  return options.withFileTypes ?\x0d\n    getDirectoryEntriesPromise(path\x2C result) :\x0d\n    result;\x0d\n}\x0d\n\x0d\nasync function readlink(path\x2C options) {\x0d\n  options = getOptions(options\x2C {});\x0d\n  path = getValidatedPath(path\x2C 'oldPath');\x0d\n  return binding.readlink(pathModule.toNamespacedPath(path)\x2C\x0d\n                          options.encoding\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function symlink(target\x2C path\x2C type_) {\x0d\n  const type = (typeof type_ === 'string' ? type_ : null);\x0d\n  target = getValidatedPath(target\x2C 'target');\x0d\n  path = getValidatedPath(path);\x0d\n  return binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\x0d\n                         pathModule.toNamespacedPath(path)\x2C\x0d\n                         stringToSymlinkType(type)\x2C\x0d\n                         kUsePromises);\x0d\n}\x0d\n\x0d\nasync function fstat(handle\x2C options = { bigint: false }) {\x0d\n  const result = await binding.fstat(handle.fd\x2C options.bigint\x2C kUsePromises);\x0d\n  return getStatsFromBinding(result);\x0d\n}\x0d\n\x0d\nasync function lstat(path\x2C options = { bigint: false }) {\x0d\n  path = getValidatedPath(path);\x0d\n  const result = await binding.lstat(pathModule.toNamespacedPath(path)\x2C\x0d\n                                     options.bigint\x2C kUsePromises);\x0d\n  return getStatsFromBinding(result);\x0d\n}\x0d\n\x0d\nasync function stat(path\x2C options = { bigint: false }) {\x0d\n  path = getValidatedPath(path);\x0d\n  const result = await binding.stat(pathModule.toNamespacedPath(path)\x2C\x0d\n                                    options.bigint\x2C kUsePromises);\x0d\n  return getStatsFromBinding(result);\x0d\n}\x0d\n\x0d\nasync function link(existingPath\x2C newPath) {\x0d\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\x0d\n  newPath = getValidatedPath(newPath\x2C 'newPath');\x0d\n  return binding.link(pathModule.toNamespacedPath(existingPath)\x2C\x0d\n                      pathModule.toNamespacedPath(newPath)\x2C\x0d\n                      kUsePromises);\x0d\n}\x0d\n\x0d\nasync function unlink(path) {\x0d\n  path = getValidatedPath(path);\x0d\n  return binding.unlink(pathModule.toNamespacedPath(path)\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function fchmod(handle\x2C mode) {\x0d\n  mode = parseFileMode(mode\x2C 'mode');\x0d\n  return binding.fchmod(handle.fd\x2C mode\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function chmod(path\x2C mode) {\x0d\n  path = getValidatedPath(path);\x0d\n  mode = parseFileMode(mode\x2C 'mode');\x0d\n  return binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function lchmod(path\x2C mode) {\x0d\n  if (O_SYMLINK === undefined)\x0d\n    throw new ERR_METHOD_NOT_IMPLEMENTED('lchmod()');\x0d\n\x0d\n  const fd = await open(path\x2C O_WRONLY | O_SYMLINK);\x0d\n  return handleFdClose(fchmod(fd\x2C mode)\x2C fd.close);\x0d\n}\x0d\n\x0d\nasync function lchown(path\x2C uid\x2C gid) {\x0d\n  path = getValidatedPath(path);\x0d\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\x0d\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\x0d\n  return binding.lchown(pathModule.toNamespacedPath(path)\x2C\x0d\n                        uid\x2C gid\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function fchown(handle\x2C uid\x2C gid) {\x0d\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\x0d\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\x0d\n  return binding.fchown(handle.fd\x2C uid\x2C gid\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function chown(path\x2C uid\x2C gid) {\x0d\n  path = getValidatedPath(path);\x0d\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\x0d\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\x0d\n  return binding.chown(pathModule.toNamespacedPath(path)\x2C\x0d\n                       uid\x2C gid\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function utimes(path\x2C atime\x2C mtime) {\x0d\n  path = getValidatedPath(path);\x0d\n  return binding.utimes(pathModule.toNamespacedPath(path)\x2C\x0d\n                        toUnixTimestamp(atime)\x2C\x0d\n                        toUnixTimestamp(mtime)\x2C\x0d\n                        kUsePromises);\x0d\n}\x0d\n\x0d\nasync function futimes(handle\x2C atime\x2C mtime) {\x0d\n  atime = toUnixTimestamp(atime\x2C 'atime');\x0d\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\x0d\n  return binding.futimes(handle.fd\x2C atime\x2C mtime\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function lutimes(path\x2C atime\x2C mtime) {\x0d\n  path = getValidatedPath(path);\x0d\n  return binding.lutimes(pathModule.toNamespacedPath(path)\x2C\x0d\n                         toUnixTimestamp(atime)\x2C\x0d\n                         toUnixTimestamp(mtime)\x2C\x0d\n                         kUsePromises);\x0d\n}\x0d\n\x0d\nasync function realpath(path\x2C options) {\x0d\n  options = getOptions(options\x2C {});\x0d\n  path = getValidatedPath(path);\x0d\n  return binding.realpath(path\x2C options.encoding\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function mkdtemp(prefix\x2C options) {\x0d\n  options = getOptions(options\x2C {});\x0d\n\x0d\n  validateString(prefix\x2C 'prefix');\x0d\n  nullCheck(prefix);\x0d\n  warnOnNonPortableTemplate(prefix);\x0d\n  return binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C kUsePromises);\x0d\n}\x0d\n\x0d\nasync function writeFile(path\x2C data\x2C options) {\x0d\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\x0d\n  const flag = options.flag || 'w';\x0d\n\x0d\n  if (!isArrayBufferView(data) && !isCustomIterable(data)) {\x0d\n    validateStringAfterArrayBufferView(data\x2C 'data');\x0d\n    data = Buffer.from(data\x2C options.encoding || 'utf8');\x0d\n  }\x0d\n\x0d\n  validateAbortSignal(options.signal);\x0d\n  if (path instanceof FileHandle)\x0d\n    return writeFileHandle(path\x2C data\x2C options.signal\x2C options.encoding);\x0d\n\x0d\n  checkAborted(options.signal);\x0d\n\x0d\n  const fd = await open(path\x2C flag\x2C options.mode);\x0d\n  return handleFdClose(\x0d\n    writeFileHandle(fd\x2C data\x2C options.signal\x2C options.encoding)\x2C fd.close);\x0d\n}\x0d\n\x0d\nfunction isCustomIterable(obj) {\x0d\n  return isIterable(obj) && !isArrayBufferView(obj) && typeof obj !== 'string';\x0d\n}\x0d\n\x0d\nasync function appendFile(path\x2C data\x2C options) {\x0d\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\x0d\n  options = copyObject(options);\x0d\n  options.flag = options.flag || 'a';\x0d\n  return writeFile(path\x2C data\x2C options);\x0d\n}\x0d\n\x0d\nasync function readFile(path\x2C options) {\x0d\n  options = getOptions(options\x2C { flag: 'r' });\x0d\n  const flag = options.flag || 'r';\x0d\n\x0d\n  if (path instanceof FileHandle)\x0d\n    return readFileHandle(path\x2C options);\x0d\n\x0d\n  checkAborted(options.signal);\x0d\n\x0d\n  const fd = await open(path\x2C flag\x2C 0o666);\x0d\n  return handleFdClose(readFileHandle(fd\x2C options)\x2C fd.close);\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  exports: {\x0d\n    access\x2C\x0d\n    copyFile\x2C\x0d\n    cp\x2C\x0d\n    open\x2C\x0d\n    opendir: promisify(opendir)\x2C\x0d\n    rename\x2C\x0d\n    truncate\x2C\x0d\n    rm\x2C\x0d\n    rmdir\x2C\x0d\n    mkdir\x2C\x0d\n    readdir\x2C\x0d\n    readlink\x2C\x0d\n    symlink\x2C\x0d\n    lstat\x2C\x0d\n    stat\x2C\x0d\n    link\x2C\x0d\n    unlink\x2C\x0d\n    chmod\x2C\x0d\n    lchmod\x2C\x0d\n    lchown\x2C\x0d\n    chown\x2C\x0d\n    utimes\x2C\x0d\n    lutimes\x2C\x0d\n    realpath\x2C\x0d\n    mkdtemp\x2C\x0d\n    writeFile\x2C\x0d\n    appendFile\x2C\x0d\n    readFile\x2C\x0d\n    watch\x2C\x0d\n  }\x2C\x0d\n\x0d\n  FileHandle\x2C\x0d\n  kRef\x2C\x0d\n  kUnref\x2C\x0d\n};\x0d\n
code-source-info,0x1abee83ac76,115,0,25123,C0O0C4O25123,,
code-creation,Function,10,200047,0x1abee83d49e,1789, node:internal/fs/promises:1:1,0x1abee83abf0,~
code-source-info,0x1abee83d49e,115,0,25123,C0O0C514O28C520O51C526O61C532O73C538O85C544O109C550O121C556O146C562O165C568O183C574O205C580O237C585O248C591O352C595O352C601O380C607O292C613O301C619O315C625O328C631O339C637O402C641O402C645O402C647O445C655O445C661O434C667O649C675O649C681O649C687O492C693O520C699O548C705O572C711O609C717O624C723O708C731O708C737O686C743O768C751O768C757O749C763O1430C771O1430C777O1430C783O829C789O848C795O865C801O893C807O928C813O961C819O976C825O1006C830O1021C836O1036C842O1060C848O1081C854O1098C860O1112C866O1145C872O1163C878O1187C884O1207C890O1231C896O1253C902O1282C908O1312C913O1334C919O1359C925O1398C931O1481C939O1481C945O1469C950O1664C958O1664C964O1521C970O1539C976O1563C982O1583C988O1602C994O1623C1000O1643C1006O1716C1014O1716C1018O1716C1020O1774C1028O1774C1034O1742C1040O1760C1045O1831C1053O1831C1059O1809C1064O1884C1072O1884C1078O1874C1083O1941C1091O1941C1097O1926C1103O1992C1111O1992C1115O1992C1117O2039C1121O2039C1125O2039C1127O2071C1131O2071C1135O2071C1137O2101C1141O2101C1145O2101C1147O2141C1151O2141C1155O2141C1157O2189C1161O2189C1165O2189C1167O2236C1171O2236C1175O2236C1177O2274C1181O2274C1185O2274C1187O2306C1191O2306C1195O2306C1197O2341C1201O2341C1205O2341C1207O2388C1211O2371C1217O2469C1225O2469C1231O2409C1236O2425C1241O2439C1246O2450C1251O2565C1259O2565C1265O2527C1271O2647C1279O2647C1285O2620C1291O2732C1295O2732C1297O2789C1301O2789C1303O2826C1304O2826C1306O2987C1307O2987C1309O3113C1437O7131C1447O7551C1457O7612C1469O7708C1479O7749C1511O3088C1513O24643C1519O24674C1527O24681C1533O24694C1539O24709C1545O24718C1549O24738C1559O24763C1565O24776C1571O24791C1577O24800C1583O24812C1589O24824C1595O24838C1601O24853C1607O24867C1613O24879C1619O24890C1625O24901C1631O24914C1637O24926C1643O24939C1649O24952C1659O24964C1669O24977C1679O24991C1689O25006C1699O25020C1709O25036C1719O25053C1729O25068C1749O25086C1759O25101C1769O25110C1779O24658C1788O25122,,
code-creation,Function,10,200254,0x1abee83deee,27,<instance_members_initializer> node:internal/fs/promises:201:3,0x1abee83c2f0,~
code-source-info,0x1abee83deee,115,4672,5501,C0O4672C12O4680C26O5501,,
new,MemoryChunk,0x109c10c0000,262144
code-creation,Eval,10,200650,0x109c10c1c3e,5, node:internal/fs/rimraf:1:1,0x109c10c18d8,~
script-source,116,node:internal/fs/rimraf,// This file is a modified version of the rimraf module on npm. It has been\x0d\n// modified in the following ways:\x0d\n// - Use of the assert module has been replaced with core's error system.\x0d\n// - All code related to the glob dependency has been removed.\x0d\n// - Bring your own custom fs module is not currently supported.\x0d\n// - Some basic code cleanup.\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  Promise\x2C\x0d\n  SafeSet\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { Buffer } = require('buffer');\x0d\nconst fs = require('fs');\x0d\nconst {\x0d\n  chmod\x2C\x0d\n  chmodSync\x2C\x0d\n  lstat\x2C\x0d\n  lstatSync\x2C\x0d\n  readdir\x2C\x0d\n  readdirSync\x2C\x0d\n  rmdir\x2C\x0d\n  rmdirSync\x2C\x0d\n  stat\x2C\x0d\n  statSync\x2C\x0d\n  unlink\x2C\x0d\n  unlinkSync\x0d\n} = fs;\x0d\nconst { sep } = require('path');\x0d\nconst { setTimeout } = require('timers');\x0d\nconst { sleep } = require('internal/util');\x0d\nconst notEmptyErrorCodes = new SafeSet(['ENOTEMPTY'\x2C 'EEXIST'\x2C 'EPERM']);\x0d\nconst retryErrorCodes = new SafeSet(\x0d\n  ['EBUSY'\x2C 'EMFILE'\x2C 'ENFILE'\x2C 'ENOTEMPTY'\x2C 'EPERM']);\x0d\nconst isWindows = process.platform === 'win32';\x0d\nconst epermHandler = isWindows ? fixWinEPERM : _rmdir;\x0d\nconst epermHandlerSync = isWindows ? fixWinEPERMSync : _rmdirSync;\x0d\nconst readdirEncoding = 'buffer';\x0d\nconst separator = Buffer.from(sep);\x0d\n\x0d\n\x0d\nfunction rimraf(path\x2C options\x2C callback) {\x0d\n  let retries = 0;\x0d\n\x0d\n  _rimraf(path\x2C options\x2C function CB(err) {\x0d\n    if (err) {\x0d\n      if (retryErrorCodes.has(err.code) && retries < options.maxRetries) {\x0d\n        retries++;\x0d\n        const delay = retries * options.retryDelay;\x0d\n        return setTimeout(_rimraf\x2C delay\x2C path\x2C options\x2C CB);\x0d\n      }\x0d\n\x0d\n      // The file is already gone.\x0d\n      if (err.code === 'ENOENT')\x0d\n        err = null;\x0d\n    }\x0d\n\x0d\n    callback(err);\x0d\n  });\x0d\n}\x0d\n\x0d\n\x0d\nfunction _rimraf(path\x2C options\x2C callback) {\x0d\n  // SunOS lets the root user unlink directories. Use lstat here to make sure\x0d\n  // it's not a directory.\x0d\n  lstat(path\x2C (err\x2C stats) => {\x0d\n    if (err) {\x0d\n      if (err.code === 'ENOENT')\x0d\n        return callback(null);\x0d\n\x0d\n      // Windows can EPERM on stat.\x0d\n      if (isWindows && err.code === 'EPERM')\x0d\n        return fixWinEPERM(path\x2C options\x2C err\x2C callback);\x0d\n    } else if (stats.isDirectory()) {\x0d\n      return _rmdir(path\x2C options\x2C err\x2C callback);\x0d\n    }\x0d\n\x0d\n    unlink(path\x2C (err) => {\x0d\n      if (err) {\x0d\n        if (err.code === 'ENOENT')\x0d\n          return callback(null);\x0d\n        if (err.code === 'EISDIR')\x0d\n          return _rmdir(path\x2C options\x2C err\x2C callback);\x0d\n        if (err.code === 'EPERM') {\x0d\n          return epermHandler(path\x2C options\x2C err\x2C callback);\x0d\n        }\x0d\n      }\x0d\n\x0d\n      return callback(err);\x0d\n    });\x0d\n  });\x0d\n}\x0d\n\x0d\n\x0d\nfunction fixWinEPERM(path\x2C options\x2C originalErr\x2C callback) {\x0d\n  chmod(path\x2C 0o666\x2C (err) => {\x0d\n    if (err)\x0d\n      return callback(err.code === 'ENOENT' ? null : originalErr);\x0d\n\x0d\n    stat(path\x2C (err\x2C stats) => {\x0d\n      if (err)\x0d\n        return callback(err.code === 'ENOENT' ? null : originalErr);\x0d\n\x0d\n      if (stats.isDirectory())\x0d\n        _rmdir(path\x2C options\x2C originalErr\x2C callback);\x0d\n      else\x0d\n        unlink(path\x2C callback);\x0d\n    });\x0d\n  });\x0d\n}\x0d\n\x0d\n\x0d\nfunction _rmdir(path\x2C options\x2C originalErr\x2C callback) {\x0d\n  rmdir(path\x2C (err) => {\x0d\n    if (err) {\x0d\n      if (notEmptyErrorCodes.has(err.code))\x0d\n        return _rmchildren(path\x2C options\x2C callback);\x0d\n      if (err.code === 'ENOTDIR')\x0d\n        return callback(originalErr);\x0d\n    }\x0d\n\x0d\n    callback(err);\x0d\n  });\x0d\n}\x0d\n\x0d\n\x0d\nfunction _rmchildren(path\x2C options\x2C callback) {\x0d\n  const pathBuf = Buffer.from(path);\x0d\n\x0d\n  readdir(pathBuf\x2C readdirEncoding\x2C (err\x2C files) => {\x0d\n    if (err)\x0d\n      return callback(err);\x0d\n\x0d\n    let numFiles = files.length;\x0d\n\x0d\n    if (numFiles === 0)\x0d\n      return rmdir(path\x2C callback);\x0d\n\x0d\n    let done = false;\x0d\n\x0d\n    ArrayPrototypeForEach(files\x2C (child) => {\x0d\n      const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\x0d\n\x0d\n      rimraf(childPath\x2C options\x2C (err) => {\x0d\n        if (done)\x0d\n          return;\x0d\n\x0d\n        if (err) {\x0d\n          done = true;\x0d\n          return callback(err);\x0d\n        }\x0d\n\x0d\n        numFiles--;\x0d\n        if (numFiles === 0)\x0d\n          rmdir(path\x2C callback);\x0d\n      });\x0d\n    });\x0d\n  });\x0d\n}\x0d\n\x0d\n\x0d\nfunction rimrafPromises(path\x2C options) {\x0d\n  return new Promise((resolve\x2C reject) => {\x0d\n    rimraf(path\x2C options\x2C (err) => {\x0d\n      if (err)\x0d\n        return reject(err);\x0d\n\x0d\n      resolve();\x0d\n    });\x0d\n  });\x0d\n}\x0d\n\x0d\n\x0d\nfunction rimrafSync(path\x2C options) {\x0d\n  let stats;\x0d\n\x0d\n  try {\x0d\n    stats = lstatSync(path);\x0d\n  } catch (err) {\x0d\n    if (err.code === 'ENOENT')\x0d\n      return;\x0d\n\x0d\n    // Windows can EPERM on stat.\x0d\n    if (isWindows && err.code === 'EPERM')\x0d\n      fixWinEPERMSync(path\x2C options\x2C err);\x0d\n  }\x0d\n\x0d\n  try {\x0d\n    // SunOS lets the root user unlink directories.\x0d\n    if (stats?.isDirectory())\x0d\n      _rmdirSync(path\x2C options\x2C null);\x0d\n    else\x0d\n      _unlinkSync(path\x2C options);\x0d\n  } catch (err) {\x0d\n    if (err.code === 'ENOENT')\x0d\n      return;\x0d\n    if (err.code === 'EPERM')\x0d\n      return epermHandlerSync(path\x2C options\x2C err);\x0d\n    if (err.code !== 'EISDIR')\x0d\n      throw err;\x0d\n\x0d\n    _rmdirSync(path\x2C options\x2C err);\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nfunction _unlinkSync(path\x2C options) {\x0d\n  const tries = options.maxRetries + 1;\x0d\n\x0d\n  for (let i = 1; i <= tries; i++) {\x0d\n    try {\x0d\n      return unlinkSync(path);\x0d\n    } catch (err) {\x0d\n      // Only sleep if this is not the last try\x2C and the delay is greater\x0d\n      // than zero\x2C and an error was encountered that warrants a retry.\x0d\n      if (retryErrorCodes.has(err.code) &&\x0d\n          i < tries &&\x0d\n          options.retryDelay > 0) {\x0d\n        sleep(i * options.retryDelay);\x0d\n      } else if (err.code === 'ENOENT') {\x0d\n        // The file is already gone.\x0d\n        return;\x0d\n      } else if (i === tries) {\x0d\n        throw err;\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nfunction _rmdirSync(path\x2C options\x2C originalErr) {\x0d\n  try {\x0d\n    rmdirSync(path);\x0d\n  } catch (err) {\x0d\n    if (err.code === 'ENOENT')\x0d\n      return;\x0d\n    if (err.code === 'ENOTDIR') {\x0d\n      throw originalErr || err;\x0d\n    }\x0d\n\x0d\n    if (notEmptyErrorCodes.has(err.code)) {\x0d\n      // Removing failed. Try removing all children and then retrying the\x0d\n      // original removal. Windows has a habit of not closing handles promptly\x0d\n      // when files are deleted\x2C resulting in spurious ENOTEMPTY failures. Work\x0d\n      // around that issue by retrying on Windows.\x0d\n      const pathBuf = Buffer.from(path);\x0d\n\x0d\n      ArrayPrototypeForEach(readdirSync(pathBuf\x2C readdirEncoding)\x2C (child) => {\x0d\n        const childPath = Buffer.concat([pathBuf\x2C separator\x2C child]);\x0d\n\x0d\n        rimrafSync(childPath\x2C options);\x0d\n      });\x0d\n\x0d\n      const tries = options.maxRetries + 1;\x0d\n\x0d\n      for (let i = 1; i <= tries; i++) {\x0d\n        try {\x0d\n          return fs.rmdirSync(path);\x0d\n        } catch (err) {\x0d\n          // Only sleep if this is not the last try\x2C and the delay is greater\x0d\n          // than zero\x2C and an error was encountered that warrants a retry.\x0d\n          if (retryErrorCodes.has(err.code) &&\x0d\n              i < tries &&\x0d\n              options.retryDelay > 0) {\x0d\n            sleep(i * options.retryDelay);\x0d\n          } else if (err.code === 'ENOENT') {\x0d\n            // The file is already gone.\x0d\n            return;\x0d\n          } else if (i === tries) {\x0d\n            throw err;\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n\x0d\n    throw originalErr || err;\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nfunction fixWinEPERMSync(path\x2C options\x2C originalErr) {\x0d\n  try {\x0d\n    chmodSync(path\x2C 0o666);\x0d\n  } catch (err) {\x0d\n    if (err.code === 'ENOENT')\x0d\n      return;\x0d\n\x0d\n    throw originalErr;\x0d\n  }\x0d\n\x0d\n  let stats;\x0d\n\x0d\n  try {\x0d\n    stats = statSync(path\x2C { throwIfNoEntry: false });\x0d\n  } catch {\x0d\n    throw originalErr;\x0d\n  }\x0d\n\x0d\n  if (stats === undefined) return;\x0d\n\x0d\n  if (stats.isDirectory())\x0d\n    _rmdirSync(path\x2C options\x2C originalErr);\x0d\n  else\x0d\n    _unlinkSync(path\x2C options);\x0d\n}\x0d\n\x0d\n\x0d\nmodule.exports = { rimraf\x2C rimrafPromises\x2C rimrafSync };\x0d\n
code-source-info,0x109c10c1c3e,116,0,7763,C0O0C4O7763,,
code-creation,Function,10,201097,0x109c10c223e,409, node:internal/fs/rimraf:1:1,0x109c10c1bb8,~
code-source-info,0x109c10c223e,116,0,7763,C0O0C139O377C145O403C151O415C156O464C159O464C164O453C170O495C173O495C177O495C179O671C182O522C188O532C194O546C200O556C206O570C212O582C218O598C224O608C230O622C236O631C242O644C248O655C254O692C257O692C262O684C267O733C270O733C275O718C281O771C284O771C289O761C295O825C302O825C307O825C309O897C316O897C321O897C323O994C330O1003C333O986C335O1038C345O1038C347O1098C357O1098C359O1165C361O1165C363O1194C366O1201C371O1201C376O1194C378O7705C385O7724C391O7732C397O7748C403O7720C408O7762,,
code-creation,LazyCompile,10,201352,0x109c10c313e,188,from node:buffer:295:28,0x25ca27369e0,~
script-source,24,node:buffer,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  Array\x2C\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  Error\x2C\x0d\n  MathFloor\x2C\x0d\n  MathMin\x2C\x0d\n  MathTrunc\x2C\x0d\n  NumberIsNaN\x2C\x0d\n  NumberMAX_SAFE_INTEGER\x2C\x0d\n  NumberMIN_SAFE_INTEGER\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  StringPrototypeCharCodeAt\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeToLowerCase\x2C\x0d\n  StringPrototypeTrim\x2C\x0d\n  SymbolSpecies\x2C\x0d\n  SymbolToPrimitive\x2C\x0d\n  TypedArrayPrototypeGetByteLength\x2C\x0d\n  TypedArrayPrototypeFill\x2C\x0d\n  TypedArrayPrototypeSet\x2C\x0d\n  Uint8Array\x2C\x0d\n  Uint8ArrayPrototype\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  byteLengthUtf8\x2C\x0d\n  compare: _compare\x2C\x0d\n  compareOffset\x2C\x0d\n  createFromString\x2C\x0d\n  fill: bindingFill\x2C\x0d\n  indexOfBuffer\x2C\x0d\n  indexOfNumber\x2C\x0d\n  indexOfString\x2C\x0d\n  swap16: _swap16\x2C\x0d\n  swap32: _swap32\x2C\x0d\n  swap64: _swap64\x2C\x0d\n  kMaxLength\x2C\x0d\n  kStringMaxLength\x0d\n} = internalBinding('buffer');\x0d\nconst {\x0d\n  getOwnNonIndexProperties\x2C\x0d\n  propertyFilter: {\x0d\n    ALL_PROPERTIES\x2C\x0d\n    ONLY_ENUMERABLE\x0d\n  }\x2C\x0d\n} = internalBinding('util');\x0d\nconst {\x0d\n  customInspectSymbol\x2C\x0d\n  isInsideNodeModules\x2C\x0d\n  lazyDOMException\x2C\x0d\n  normalizeEncoding\x2C\x0d\n  kIsEncodingSymbol\x0d\n} = require('internal/util');\x0d\nconst {\x0d\n  isAnyArrayBuffer\x2C\x0d\n  isArrayBufferView\x2C\x0d\n  isUint8Array\x0d\n} = require('internal/util/types');\x0d\nconst {\x0d\n  inspect: utilInspect\x0d\n} = require('internal/util/inspect');\x0d\nconst { encodings } = internalBinding('string_decoder');\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_BUFFER_OUT_OF_BOUNDS\x2C\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_INVALID_BUFFER_SIZE\x2C\x0d\n    ERR_OUT_OF_RANGE\x2C\x0d\n    ERR_UNKNOWN_ENCODING\x0d\n  }\x2C\x0d\n  hideStackFrames\x0d\n} = require('internal/errors');\x0d\nconst {\x0d\n  validateArray\x2C\x0d\n  validateBuffer\x2C\x0d\n  validateNumber\x2C\x0d\n  validateInteger\x2C\x0d\n  validateString\x0d\n} = require('internal/validators');\x0d\n// Provide validateInteger() but with kMaxLength as the default maximum value.\x0d\nconst validateOffset = (value\x2C name\x2C min = 0\x2C max = kMaxLength) =>\x0d\n  validateInteger(value\x2C name\x2C min\x2C max);\x0d\n\x0d\nconst {\x0d\n  FastBuffer\x2C\x0d\n  markAsUntransferable\x2C\x0d\n  addBufferPrototypeMethods\x2C\x0d\n  createUnsafeBuffer\x0d\n} = require('internal/buffer');\x0d\n\x0d\nconst {\x0d\n  Blob\x2C\x0d\n  resolveObjectURL\x2C\x0d\n} = require('internal/blob');\x0d\n\x0d\nFastBuffer.prototype.constructor = Buffer;\x0d\nBuffer.prototype = FastBuffer.prototype;\x0d\naddBufferPrototypeMethods(Buffer.prototype);\x0d\n\x0d\nconst constants = ObjectDefineProperties({}\x2C {\x0d\n  MAX_LENGTH: {\x0d\n    value: kMaxLength\x2C\x0d\n    writable: false\x2C\x0d\n    enumerable: true\x0d\n  }\x2C\x0d\n  MAX_STRING_LENGTH: {\x0d\n    value: kStringMaxLength\x2C\x0d\n    writable: false\x2C\x0d\n    enumerable: true\x0d\n  }\x0d\n});\x0d\n\x0d\nBuffer.poolSize = 8 * 1024;\x0d\nlet poolSize\x2C poolOffset\x2C allocPool;\x0d\n\x0d\nconst encodingsMap = ObjectCreate(null);\x0d\nfor (let i = 0; i < encodings.length; ++i)\x0d\n  encodingsMap[encodings[i]] = i;\x0d\n\x0d\nfunction createPool() {\x0d\n  poolSize = Buffer.poolSize;\x0d\n  allocPool = createUnsafeBuffer(poolSize).buffer;\x0d\n  markAsUntransferable(allocPool);\x0d\n  poolOffset = 0;\x0d\n}\x0d\ncreatePool();\x0d\n\x0d\nfunction alignPool() {\x0d\n  // Ensure aligned slices\x0d\n  if (poolOffset & 0x7) {\x0d\n    poolOffset |= 0x7;\x0d\n    poolOffset++;\x0d\n  }\x0d\n}\x0d\n\x0d\nlet bufferWarningAlreadyEmitted = false;\x0d\nlet nodeModulesCheckCounter = 0;\x0d\nconst bufferWarning = 'Buffer() is deprecated due to security and usability ' +\x0d\n                      'issues. Please use the Buffer.alloc()\x2C ' +\x0d\n                      'Buffer.allocUnsafe()\x2C or Buffer.from() methods instead.';\x0d\n\x0d\nfunction showFlaggedDeprecation() {\x0d\n  if (bufferWarningAlreadyEmitted ||\x0d\n      ++nodeModulesCheckCounter > 10000 ||\x0d\n      (!require('internal/options').getOptionValue('--pending-deprecation') &&\x0d\n       isInsideNodeModules())) {\x0d\n    // We don't emit a warning\x2C because we either:\x0d\n    // - Already did so\x2C or\x0d\n    // - Already checked too many times whether a call is coming\x0d\n    //   from node_modules and want to stop slowing down things\x2C or\x0d\n    // - We aren't running with `--pending-deprecation` enabled\x2C\x0d\n    //   and the code is inside `node_modules`.\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  process.emitWarning(bufferWarning\x2C 'DeprecationWarning'\x2C 'DEP0005');\x0d\n  bufferWarningAlreadyEmitted = true;\x0d\n}\x0d\n\x0d\nfunction toInteger(n\x2C defaultVal) {\x0d\n  n = +n;\x0d\n  if (!NumberIsNaN(n) &&\x0d\n      n >= NumberMIN_SAFE_INTEGER &&\x0d\n      n <= NumberMAX_SAFE_INTEGER) {\x0d\n    return ((n % 1) === 0 ? n : MathFloor(n));\x0d\n  }\x0d\n  return defaultVal;\x0d\n}\x0d\n\x0d\nfunction _copy(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\x0d\n  if (!isUint8Array(source))\x0d\n    throw new ERR_INVALID_ARG_TYPE('source'\x2C ['Buffer'\x2C 'Uint8Array']\x2C source);\x0d\n  if (!isUint8Array(target))\x0d\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\x0d\n\x0d\n  if (targetStart === undefined) {\x0d\n    targetStart = 0;\x0d\n  } else {\x0d\n    targetStart = toInteger(targetStart\x2C 0);\x0d\n    if (targetStart < 0)\x0d\n      throw new ERR_OUT_OF_RANGE('targetStart'\x2C '>= 0'\x2C targetStart);\x0d\n  }\x0d\n\x0d\n  if (sourceStart === undefined) {\x0d\n    sourceStart = 0;\x0d\n  } else {\x0d\n    sourceStart = toInteger(sourceStart\x2C 0);\x0d\n    if (sourceStart < 0)\x0d\n      throw new ERR_OUT_OF_RANGE('sourceStart'\x2C '>= 0'\x2C sourceStart);\x0d\n  }\x0d\n\x0d\n  if (sourceEnd === undefined) {\x0d\n    sourceEnd = source.length;\x0d\n  } else {\x0d\n    sourceEnd = toInteger(sourceEnd\x2C 0);\x0d\n    if (sourceEnd < 0)\x0d\n      throw new ERR_OUT_OF_RANGE('sourceEnd'\x2C '>= 0'\x2C sourceEnd);\x0d\n  }\x0d\n\x0d\n  if (targetStart >= target.length || sourceStart >= sourceEnd)\x0d\n    return 0;\x0d\n\x0d\n  if (sourceStart > source.length) {\x0d\n    throw new ERR_OUT_OF_RANGE('sourceStart'\x2C\x0d\n                               `<= ${source.length}`\x2C\x0d\n                               sourceStart);\x0d\n  }\x0d\n\x0d\n  return _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\x0d\n}\x0d\n\x0d\nfunction _copyActual(source\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\x0d\n  if (sourceEnd - sourceStart > target.length - targetStart)\x0d\n    sourceEnd = sourceStart + target.length - targetStart;\x0d\n\x0d\n  let nb = sourceEnd - sourceStart;\x0d\n  const sourceLen = source.length - sourceStart;\x0d\n  if (nb > sourceLen)\x0d\n    nb = sourceLen;\x0d\n\x0d\n  if (sourceStart !== 0 || sourceEnd < source.length)\x0d\n    source = new Uint8Array(source.buffer\x2C source.byteOffset + sourceStart\x2C nb);\x0d\n\x0d\n  TypedArrayPrototypeSet(target\x2C source\x2C targetStart);\x0d\n\x0d\n  return nb;\x0d\n}\x0d\n\x0d\n/**\x0d\n * The Buffer() constructor is deprecated in documentation and should not be\x0d\n * used moving forward. Rather\x2C developers should use one of the three new\x0d\n * factory APIs: Buffer.from()\x2C Buffer.allocUnsafe() or Buffer.alloc() based on\x0d\n * their specific needs. There is no runtime deprecation because of the extent\x0d\n * to which the Buffer constructor is used in the ecosystem currently -- a\x0d\n * runtime deprecation would introduce too much breakage at this time. It's not\x0d\n * likely that the Buffer constructors would ever actually be removed.\x0d\n * Deprecation Code: DEP0005\x0d\n */\x0d\nfunction Buffer(arg\x2C encodingOrOffset\x2C length) {\x0d\n  showFlaggedDeprecation();\x0d\n  // Common case.\x0d\n  if (typeof arg === 'number') {\x0d\n    if (typeof encodingOrOffset === 'string') {\x0d\n      throw new ERR_INVALID_ARG_TYPE('string'\x2C 'string'\x2C arg);\x0d\n    }\x0d\n    return Buffer.alloc(arg);\x0d\n  }\x0d\n  return Buffer.from(arg\x2C encodingOrOffset\x2C length);\x0d\n}\x0d\n\x0d\nObjectDefineProperty(Buffer\x2C SymbolSpecies\x2C {\x0d\n  enumerable: false\x2C\x0d\n  configurable: true\x2C\x0d\n  get() { return FastBuffer; }\x0d\n});\x0d\n\x0d\n/**\x0d\n * Functionally equivalent to Buffer(arg\x2C encoding) but throws a TypeError\x0d\n * if value is a number.\x0d\n * Buffer.from(str[\x2C encoding])\x0d\n * Buffer.from(array)\x0d\n * Buffer.from(buffer)\x0d\n * Buffer.from(arrayBuffer[\x2C byteOffset[\x2C length]])\x0d\n */\x0d\nBuffer.from = function from(value\x2C encodingOrOffset\x2C length) {\x0d\n  if (typeof value === 'string')\x0d\n    return fromString(value\x2C encodingOrOffset);\x0d\n\x0d\n  if (typeof value === 'object' && value !== null) {\x0d\n    if (isAnyArrayBuffer(value))\x0d\n      return fromArrayBuffer(value\x2C encodingOrOffset\x2C length);\x0d\n\x0d\n    const valueOf = value.valueOf && value.valueOf();\x0d\n    if (valueOf != null &&\x0d\n        valueOf !== value &&\x0d\n        (typeof valueOf === 'string' || typeof valueOf === 'object')) {\x0d\n      return from(valueOf\x2C encodingOrOffset\x2C length);\x0d\n    }\x0d\n\x0d\n    const b = fromObject(value);\x0d\n    if (b)\x0d\n      return b;\x0d\n\x0d\n    if (typeof value[SymbolToPrimitive] === 'function') {\x0d\n      const primitive = value[SymbolToPrimitive]('string');\x0d\n      if (typeof primitive === 'string') {\x0d\n        return fromString(primitive\x2C encodingOrOffset);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  throw new ERR_INVALID_ARG_TYPE(\x0d\n    'first argument'\x2C\x0d\n    ['string'\x2C 'Buffer'\x2C 'ArrayBuffer'\x2C 'Array'\x2C 'Array-like Object']\x2C\x0d\n    value\x0d\n  );\x0d\n};\x0d\n\x0d\n// Identical to the built-in %TypedArray%.of()\x2C but avoids using the deprecated\x0d\n// Buffer() constructor. Must use arrow function syntax to avoid automatically\x0d\n// adding a `prototype` property and making the function a constructor.\x0d\n//\x0d\n// Refs: https://tc39.github.io/ecma262/#sec-%typedarray%.of\x0d\n// Refs: https://esdiscuss.org/topic/isconstructor#content-11\x0d\nconst of = (...items) => {\x0d\n  const newObj = createUnsafeBuffer(items.length);\x0d\n  for (let k = 0; k < items.length; k++)\x0d\n    newObj[k] = items[k];\x0d\n  return newObj;\x0d\n};\x0d\nBuffer.of = of;\x0d\n\x0d\nObjectSetPrototypeOf(Buffer\x2C Uint8Array);\x0d\n\x0d\n// The 'assertSize' method will remove itself from the callstack when an error\x0d\n// occurs. This is done simply to keep the internal details of the\x0d\n// implementation from bleeding out to users.\x0d\nconst assertSize = hideStackFrames((size) => {\x0d\n  validateNumber(size\x2C 'size');\x0d\n  if (!(size >= 0 && size <= kMaxLength)) {\x0d\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\x0d\n  }\x0d\n});\x0d\n\x0d\n/**\x0d\n * Creates a new filled Buffer instance.\x0d\n * alloc(size[\x2C fill[\x2C encoding]])\x0d\n */\x0d\nBuffer.alloc = function alloc(size\x2C fill\x2C encoding) {\x0d\n  assertSize(size);\x0d\n  if (fill !== undefined && fill !== 0 && size > 0) {\x0d\n    const buf = createUnsafeBuffer(size);\x0d\n    return _fill(buf\x2C fill\x2C 0\x2C buf.length\x2C encoding);\x0d\n  }\x0d\n  return new FastBuffer(size);\x0d\n};\x0d\n\x0d\n/**\x0d\n * Equivalent to Buffer(num)\x2C by default creates a non-zero-filled Buffer\x0d\n * instance. If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\x0d\n */\x0d\nBuffer.allocUnsafe = function allocUnsafe(size) {\x0d\n  assertSize(size);\x0d\n  return allocate(size);\x0d\n};\x0d\n\x0d\n/**\x0d\n * Equivalent to SlowBuffer(num)\x2C by default creates a non-zero-filled\x0d\n * Buffer instance that is not allocated off the pre-initialized pool.\x0d\n * If `--zero-fill-buffers` is set\x2C will zero-fill the buffer.\x0d\n */\x0d\nBuffer.allocUnsafeSlow = function allocUnsafeSlow(size) {\x0d\n  assertSize(size);\x0d\n  return createUnsafeBuffer(size);\x0d\n};\x0d\n\x0d\n// If --zero-fill-buffers command line argument is set\x2C a zero-filled\x0d\n// buffer is returned.\x0d\nfunction SlowBuffer(length) {\x0d\n  assertSize(length);\x0d\n  return createUnsafeBuffer(length);\x0d\n}\x0d\n\x0d\nObjectSetPrototypeOf(SlowBuffer.prototype\x2C Uint8ArrayPrototype);\x0d\nObjectSetPrototypeOf(SlowBuffer\x2C Uint8Array);\x0d\n\x0d\nfunction allocate(size) {\x0d\n  if (size <= 0) {\x0d\n    return new FastBuffer();\x0d\n  }\x0d\n  if (size < (Buffer.poolSize >>> 1)) {\x0d\n    if (size > (poolSize - poolOffset))\x0d\n      createPool();\x0d\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C size);\x0d\n    poolOffset += size;\x0d\n    alignPool();\x0d\n    return b;\x0d\n  }\x0d\n  return createUnsafeBuffer(size);\x0d\n}\x0d\n\x0d\nfunction fromStringFast(string\x2C ops) {\x0d\n  const length = ops.byteLength(string);\x0d\n\x0d\n  if (length >= (Buffer.poolSize >>> 1))\x0d\n    return createFromString(string\x2C ops.encodingVal);\x0d\n\x0d\n  if (length > (poolSize - poolOffset))\x0d\n    createPool();\x0d\n  let b = new FastBuffer(allocPool\x2C poolOffset\x2C length);\x0d\n  const actual = ops.write(b\x2C string\x2C 0\x2C length);\x0d\n  if (actual !== length) {\x0d\n    // byteLength() may overestimate. That's a rare case\x2C though.\x0d\n    b = new FastBuffer(allocPool\x2C poolOffset\x2C actual);\x0d\n  }\x0d\n  poolOffset += actual;\x0d\n  alignPool();\x0d\n  return b;\x0d\n}\x0d\n\x0d\nfunction fromString(string\x2C encoding) {\x0d\n  let ops;\x0d\n  if (typeof encoding !== 'string' || encoding.length === 0) {\x0d\n    if (string.length === 0)\x0d\n      return new FastBuffer();\x0d\n    ops = encodingOps.utf8;\x0d\n    encoding = undefined;\x0d\n  } else {\x0d\n    ops = getEncodingOps(encoding);\x0d\n    if (ops === undefined)\x0d\n      throw new ERR_UNKNOWN_ENCODING(encoding);\x0d\n    if (string.length === 0)\x0d\n      return new FastBuffer();\x0d\n  }\x0d\n  return fromStringFast(string\x2C ops);\x0d\n}\x0d\n\x0d\nfunction fromArrayBuffer(obj\x2C byteOffset\x2C length) {\x0d\n  // Convert byteOffset to integer\x0d\n  if (byteOffset === undefined) {\x0d\n    byteOffset = 0;\x0d\n  } else {\x0d\n    byteOffset = +byteOffset;\x0d\n    if (NumberIsNaN(byteOffset))\x0d\n      byteOffset = 0;\x0d\n  }\x0d\n\x0d\n  const maxLength = obj.byteLength - byteOffset;\x0d\n\x0d\n  if (maxLength < 0)\x0d\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\x0d\n\x0d\n  if (length === undefined) {\x0d\n    length = maxLength;\x0d\n  } else {\x0d\n    // Convert length to non-negative integer.\x0d\n    length = +length;\x0d\n    if (length > 0) {\x0d\n      if (length > maxLength)\x0d\n        throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\x0d\n    } else {\x0d\n      length = 0;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return new FastBuffer(obj\x2C byteOffset\x2C length);\x0d\n}\x0d\n\x0d\nfunction fromArrayLike(obj) {\x0d\n  if (obj.length <= 0)\x0d\n    return new FastBuffer();\x0d\n  if (obj.length < (Buffer.poolSize >>> 1)) {\x0d\n    if (obj.length > (poolSize - poolOffset))\x0d\n      createPool();\x0d\n    const b = new FastBuffer(allocPool\x2C poolOffset\x2C obj.length);\x0d\n    TypedArrayPrototypeSet(b\x2C obj\x2C 0);\x0d\n    poolOffset += obj.length;\x0d\n    alignPool();\x0d\n    return b;\x0d\n  }\x0d\n  return new FastBuffer(obj);\x0d\n}\x0d\n\x0d\nfunction fromObject(obj) {\x0d\n  if (obj.length !== undefined || isAnyArrayBuffer(obj.buffer)) {\x0d\n    if (typeof obj.length !== 'number') {\x0d\n      return new FastBuffer();\x0d\n    }\x0d\n    return fromArrayLike(obj);\x0d\n  }\x0d\n\x0d\n  if (obj.type === 'Buffer' && ArrayIsArray(obj.data)) {\x0d\n    return fromArrayLike(obj.data);\x0d\n  }\x0d\n}\x0d\n\x0d\n// Static methods\x0d\n\x0d\nBuffer.isBuffer = function isBuffer(b) {\x0d\n  return b instanceof Buffer;\x0d\n};\x0d\n\x0d\nBuffer.compare = function compare(buf1\x2C buf2) {\x0d\n  if (!isUint8Array(buf1)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE('buf1'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf1);\x0d\n  }\x0d\n\x0d\n  if (!isUint8Array(buf2)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE('buf2'\x2C ['Buffer'\x2C 'Uint8Array']\x2C buf2);\x0d\n  }\x0d\n\x0d\n  if (buf1 === buf2) {\x0d\n    return 0;\x0d\n  }\x0d\n\x0d\n  return _compare(buf1\x2C buf2);\x0d\n};\x0d\n\x0d\nBuffer.isEncoding = function isEncoding(encoding) {\x0d\n  return typeof encoding === 'string' && encoding.length !== 0 &&\x0d\n         normalizeEncoding(encoding) !== undefined;\x0d\n};\x0d\nBuffer[kIsEncodingSymbol] = Buffer.isEncoding;\x0d\n\x0d\nBuffer.concat = function concat(list\x2C length) {\x0d\n  validateArray(list\x2C 'list');\x0d\n\x0d\n  if (list.length === 0)\x0d\n    return new FastBuffer();\x0d\n\x0d\n  if (length === undefined) {\x0d\n    length = 0;\x0d\n    for (let i = 0; i < list.length; i++) {\x0d\n      if (list[i].length) {\x0d\n        length += list[i].length;\x0d\n      }\x0d\n    }\x0d\n  } else {\x0d\n    validateOffset(length\x2C 'length');\x0d\n  }\x0d\n\x0d\n  const buffer = Buffer.allocUnsafe(length);\x0d\n  let pos = 0;\x0d\n  for (let i = 0; i < list.length; i++) {\x0d\n    const buf = list[i];\x0d\n    if (!isUint8Array(buf)) {\x0d\n      // TODO(BridgeAR): This should not be of type ERR_INVALID_ARG_TYPE.\x0d\n      // Instead\x2C find the proper error code for this.\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        `list[${i}]`\x2C ['Buffer'\x2C 'Uint8Array']\x2C list[i]);\x0d\n    }\x0d\n    pos += _copyActual(buf\x2C buffer\x2C pos\x2C 0\x2C buf.length);\x0d\n  }\x0d\n\x0d\n  // Note: `length` is always equal to `buffer.length` at this point\x0d\n  if (pos < length) {\x0d\n    // Zero-fill the remaining bytes if the specified `length` was more than\x0d\n    // the actual total length\x2C i.e. if we have some remaining allocated bytes\x0d\n    // there were not initialized.\x0d\n    TypedArrayPrototypeFill(buffer\x2C 0\x2C pos\x2C length);\x0d\n  }\x0d\n\x0d\n  return buffer;\x0d\n};\x0d\n\x0d\nfunction base64ByteLength(str\x2C bytes) {\x0d\n  // Handle padding\x0d\n  if (StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\x0d\n    bytes--;\x0d\n  if (bytes > 1 && StringPrototypeCharCodeAt(str\x2C bytes - 1) === 0x3D)\x0d\n    bytes--;\x0d\n\x0d\n  // Base64 ratio: 3/4\x0d\n  return (bytes * 3) >>> 2;\x0d\n}\x0d\n\x0d\nconst encodingOps = {\x0d\n  utf8: {\x0d\n    encoding: 'utf8'\x2C\x0d\n    encodingVal: encodingsMap.utf8\x2C\x0d\n    byteLength: byteLengthUtf8\x2C\x0d\n    write: (buf\x2C string\x2C offset\x2C len) => buf.utf8Write(string\x2C offset\x2C len)\x2C\x0d\n    slice: (buf\x2C start\x2C end) => buf.utf8Slice(start\x2C end)\x2C\x0d\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\x0d\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf8\x2C dir)\x0d\n  }\x2C\x0d\n  ucs2: {\x0d\n    encoding: 'ucs2'\x2C\x0d\n    encodingVal: encodingsMap.utf16le\x2C\x0d\n    byteLength: (string) => string.length * 2\x2C\x0d\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\x0d\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\x0d\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\x0d\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\x0d\n  }\x2C\x0d\n  utf16le: {\x0d\n    encoding: 'utf16le'\x2C\x0d\n    encodingVal: encodingsMap.utf16le\x2C\x0d\n    byteLength: (string) => string.length * 2\x2C\x0d\n    write: (buf\x2C string\x2C offset\x2C len) => buf.ucs2Write(string\x2C offset\x2C len)\x2C\x0d\n    slice: (buf\x2C start\x2C end) => buf.ucs2Slice(start\x2C end)\x2C\x0d\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\x0d\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.utf16le\x2C dir)\x0d\n  }\x2C\x0d\n  latin1: {\x0d\n    encoding: 'latin1'\x2C\x0d\n    encodingVal: encodingsMap.latin1\x2C\x0d\n    byteLength: (string) => string.length\x2C\x0d\n    write: (buf\x2C string\x2C offset\x2C len) => buf.latin1Write(string\x2C offset\x2C len)\x2C\x0d\n    slice: (buf\x2C start\x2C end) => buf.latin1Slice(start\x2C end)\x2C\x0d\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\x0d\n      indexOfString(buf\x2C val\x2C byteOffset\x2C encodingsMap.latin1\x2C dir)\x0d\n  }\x2C\x0d\n  ascii: {\x0d\n    encoding: 'ascii'\x2C\x0d\n    encodingVal: encodingsMap.ascii\x2C\x0d\n    byteLength: (string) => string.length\x2C\x0d\n    write: (buf\x2C string\x2C offset\x2C len) => buf.asciiWrite(string\x2C offset\x2C len)\x2C\x0d\n    slice: (buf\x2C start\x2C end) => buf.asciiSlice(start\x2C end)\x2C\x0d\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\x0d\n      indexOfBuffer(buf\x2C\x0d\n                    fromStringFast(val\x2C encodingOps.ascii)\x2C\x0d\n                    byteOffset\x2C\x0d\n                    encodingsMap.ascii\x2C\x0d\n                    dir)\x0d\n  }\x2C\x0d\n  base64: {\x0d\n    encoding: 'base64'\x2C\x0d\n    encodingVal: encodingsMap.base64\x2C\x0d\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\x0d\n    write: (buf\x2C string\x2C offset\x2C len) => buf.base64Write(string\x2C offset\x2C len)\x2C\x0d\n    slice: (buf\x2C start\x2C end) => buf.base64Slice(start\x2C end)\x2C\x0d\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\x0d\n      indexOfBuffer(buf\x2C\x0d\n                    fromStringFast(val\x2C encodingOps.base64)\x2C\x0d\n                    byteOffset\x2C\x0d\n                    encodingsMap.base64\x2C\x0d\n                    dir)\x0d\n  }\x2C\x0d\n  base64url: {\x0d\n    encoding: 'base64url'\x2C\x0d\n    encodingVal: encodingsMap.base64url\x2C\x0d\n    byteLength: (string) => base64ByteLength(string\x2C string.length)\x2C\x0d\n    write: (buf\x2C string\x2C offset\x2C len) =>\x0d\n      buf.base64urlWrite(string\x2C offset\x2C len)\x2C\x0d\n    slice: (buf\x2C start\x2C end) => buf.base64urlSlice(start\x2C end)\x2C\x0d\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\x0d\n      indexOfBuffer(buf\x2C\x0d\n                    fromStringFast(val\x2C encodingOps.base64url)\x2C\x0d\n                    byteOffset\x2C\x0d\n                    encodingsMap.base64url\x2C\x0d\n                    dir)\x0d\n  }\x2C\x0d\n  hex: {\x0d\n    encoding: 'hex'\x2C\x0d\n    encodingVal: encodingsMap.hex\x2C\x0d\n    byteLength: (string) => string.length >>> 1\x2C\x0d\n    write: (buf\x2C string\x2C offset\x2C len) => buf.hexWrite(string\x2C offset\x2C len)\x2C\x0d\n    slice: (buf\x2C start\x2C end) => buf.hexSlice(start\x2C end)\x2C\x0d\n    indexOf: (buf\x2C val\x2C byteOffset\x2C dir) =>\x0d\n      indexOfBuffer(buf\x2C\x0d\n                    fromStringFast(val\x2C encodingOps.hex)\x2C\x0d\n                    byteOffset\x2C\x0d\n                    encodingsMap.hex\x2C\x0d\n                    dir)\x0d\n  }\x0d\n};\x0d\nfunction getEncodingOps(encoding) {\x0d\n  encoding += '';\x0d\n  switch (encoding.length) {\x0d\n    case 4:\x0d\n      if (encoding === 'utf8') return encodingOps.utf8;\x0d\n      if (encoding === 'ucs2') return encodingOps.ucs2;\x0d\n      encoding = StringPrototypeToLowerCase(encoding);\x0d\n      if (encoding === 'utf8') return encodingOps.utf8;\x0d\n      if (encoding === 'ucs2') return encodingOps.ucs2;\x0d\n      break;\x0d\n    case 5:\x0d\n      if (encoding === 'utf-8') return encodingOps.utf8;\x0d\n      if (encoding === 'ascii') return encodingOps.ascii;\x0d\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\x0d\n      encoding = StringPrototypeToLowerCase(encoding);\x0d\n      if (encoding === 'utf-8') return encodingOps.utf8;\x0d\n      if (encoding === 'ascii') return encodingOps.ascii;\x0d\n      if (encoding === 'ucs-2') return encodingOps.ucs2;\x0d\n      break;\x0d\n    case 7:\x0d\n      if (encoding === 'utf16le' ||\x0d\n          StringPrototypeToLowerCase(encoding) === 'utf16le')\x0d\n        return encodingOps.utf16le;\x0d\n      break;\x0d\n    case 8:\x0d\n      if (encoding === 'utf-16le' ||\x0d\n          StringPrototypeToLowerCase(encoding) === 'utf-16le')\x0d\n        return encodingOps.utf16le;\x0d\n      break;\x0d\n    case 6:\x0d\n      if (encoding === 'latin1' || encoding === 'binary')\x0d\n        return encodingOps.latin1;\x0d\n      if (encoding === 'base64') return encodingOps.base64;\x0d\n      encoding = StringPrototypeToLowerCase(encoding);\x0d\n      if (encoding === 'latin1' || encoding === 'binary')\x0d\n        return encodingOps.latin1;\x0d\n      if (encoding === 'base64') return encodingOps.base64;\x0d\n      break;\x0d\n    case 3:\x0d\n      if (encoding === 'hex' || StringPrototypeToLowerCase(encoding) === 'hex')\x0d\n        return encodingOps.hex;\x0d\n      break;\x0d\n    case 9:\x0d\n      if (encoding === 'base64url' ||\x0d\n          StringPrototypeToLowerCase(encoding) === 'base64url')\x0d\n        return encodingOps.base64url;\x0d\n      break;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction byteLength(string\x2C encoding) {\x0d\n  if (typeof string !== 'string') {\x0d\n    if (isArrayBufferView(string) || isAnyArrayBuffer(string)) {\x0d\n      return string.byteLength;\x0d\n    }\x0d\n\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'string'\x2C ['string'\x2C 'Buffer'\x2C 'ArrayBuffer']\x2C string\x0d\n    );\x0d\n  }\x0d\n\x0d\n  const len = string.length;\x0d\n  const mustMatch = (arguments.length > 2 && arguments[2] === true);\x0d\n  if (!mustMatch && len === 0)\x0d\n    return 0;\x0d\n\x0d\n  if (!encoding)\x0d\n    return (mustMatch ? -1 : byteLengthUtf8(string));\x0d\n\x0d\n  const ops = getEncodingOps(encoding);\x0d\n  if (ops === undefined)\x0d\n    return (mustMatch ? -1 : byteLengthUtf8(string));\x0d\n  return ops.byteLength(string);\x0d\n}\x0d\n\x0d\nBuffer.byteLength = byteLength;\x0d\n\x0d\n// For backwards compatibility.\x0d\nObjectDefineProperty(Buffer.prototype\x2C 'parent'\x2C {\x0d\n  enumerable: true\x2C\x0d\n  get() {\x0d\n    if (!(this instanceof Buffer))\x0d\n      return undefined;\x0d\n    return this.buffer;\x0d\n  }\x0d\n});\x0d\nObjectDefineProperty(Buffer.prototype\x2C 'offset'\x2C {\x0d\n  enumerable: true\x2C\x0d\n  get() {\x0d\n    if (!(this instanceof Buffer))\x0d\n      return undefined;\x0d\n    return this.byteOffset;\x0d\n  }\x0d\n});\x0d\n\x0d\nBuffer.prototype.copy =\x0d\n  function copy(target\x2C targetStart\x2C sourceStart\x2C sourceEnd) {\x0d\n    return _copy(this\x2C target\x2C targetStart\x2C sourceStart\x2C sourceEnd);\x0d\n  };\x0d\n\x0d\n// No need to verify that "buf.length <= MAX_UINT32" since it's a read-only\x0d\n// property of a typed array.\x0d\n// This behaves neither like String nor Uint8Array in that we set start/end\x0d\n// to their upper/lower bounds if the value passed is out of range.\x0d\nBuffer.prototype.toString = function toString(encoding\x2C start\x2C end) {\x0d\n  if (arguments.length === 0) {\x0d\n    return this.utf8Slice(0\x2C this.length);\x0d\n  }\x0d\n\x0d\n  const len = this.length;\x0d\n\x0d\n  if (start <= 0)\x0d\n    start = 0;\x0d\n  else if (start >= len)\x0d\n    return '';\x0d\n  else\x0d\n    start |= 0;\x0d\n\x0d\n  if (end === undefined || end > len)\x0d\n    end = len;\x0d\n  else\x0d\n    end |= 0;\x0d\n\x0d\n  if (end <= start)\x0d\n    return '';\x0d\n\x0d\n  if (encoding === undefined)\x0d\n    return this.utf8Slice(start\x2C end);\x0d\n\x0d\n  const ops = getEncodingOps(encoding);\x0d\n  if (ops === undefined)\x0d\n    throw new ERR_UNKNOWN_ENCODING(encoding);\x0d\n\x0d\n  return ops.slice(this\x2C start\x2C end);\x0d\n};\x0d\n\x0d\nBuffer.prototype.equals = function equals(otherBuffer) {\x0d\n  if (!isUint8Array(otherBuffer)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'otherBuffer'\x2C ['Buffer'\x2C 'Uint8Array']\x2C otherBuffer);\x0d\n  }\x0d\n\x0d\n  if (this === otherBuffer)\x0d\n    return true;\x0d\n\x0d\n  if (this.byteLength !== otherBuffer.byteLength)\x0d\n    return false;\x0d\n\x0d\n  return this.byteLength === 0 || _compare(this\x2C otherBuffer) === 0;\x0d\n};\x0d\n\x0d\nlet INSPECT_MAX_BYTES = 50;\x0d\n// Override how buffers are presented by util.inspect().\x0d\nBuffer.prototype[customInspectSymbol] = function inspect(recurseTimes\x2C ctx) {\x0d\n  const max = INSPECT_MAX_BYTES;\x0d\n  const actualMax = MathMin(max\x2C this.length);\x0d\n  const remaining = this.length - max;\x0d\n  let str = StringPrototypeTrim(StringPrototypeReplace(\x0d\n    this.hexSlice(0\x2C actualMax)\x2C /(.{2})/g\x2C '$1 '));\x0d\n  if (remaining > 0)\x0d\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\x0d\n  // Inspect special properties as well\x2C if possible.\x0d\n  if (ctx) {\x0d\n    let extras = false;\x0d\n    const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\x0d\n    const obj = ObjectCreate(null);\x0d\n    ArrayPrototypeForEach(getOwnNonIndexProperties(this\x2C filter)\x2C\x0d\n                          (key) => {\x0d\n                            extras = true;\x0d\n                            obj[key] = this[key];\x0d\n                          });\x0d\n    if (extras) {\x0d\n      if (this.length !== 0)\x0d\n        str += '\x2C ';\x0d\n      // '[Object: null prototype] {'.length === 26\x0d\n      // This is guarded with a test.\x0d\n      str += StringPrototypeSlice(utilInspect(obj\x2C {\x0d\n        ...ctx\x2C\x0d\n        breakLength: Infinity\x2C\x0d\n        compact: true\x0d\n      })\x2C 27\x2C -2);\x0d\n    }\x0d\n  }\x0d\n  return `<${this.constructor.name} ${str}>`;\x0d\n};\x0d\nBuffer.prototype.inspect = Buffer.prototype[customInspectSymbol];\x0d\n\x0d\nBuffer.prototype.compare = function compare(target\x2C\x0d\n                                            targetStart\x2C\x0d\n                                            targetEnd\x2C\x0d\n                                            sourceStart\x2C\x0d\n                                            sourceEnd) {\x0d\n  if (!isUint8Array(target)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE('target'\x2C ['Buffer'\x2C 'Uint8Array']\x2C target);\x0d\n  }\x0d\n  if (arguments.length === 1)\x0d\n    return _compare(this\x2C target);\x0d\n\x0d\n  if (targetStart === undefined)\x0d\n    targetStart = 0;\x0d\n  else\x0d\n    validateOffset(targetStart\x2C 'targetStart');\x0d\n\x0d\n  if (targetEnd === undefined)\x0d\n    targetEnd = target.length;\x0d\n  else\x0d\n    validateOffset(targetEnd\x2C 'targetEnd'\x2C 0\x2C target.length);\x0d\n\x0d\n  if (sourceStart === undefined)\x0d\n    sourceStart = 0;\x0d\n  else\x0d\n    validateOffset(sourceStart\x2C 'sourceStart');\x0d\n\x0d\n  if (sourceEnd === undefined)\x0d\n    sourceEnd = this.length;\x0d\n  else\x0d\n    validateOffset(sourceEnd\x2C 'sourceEnd'\x2C 0\x2C this.length);\x0d\n\x0d\n  if (sourceStart >= sourceEnd)\x0d\n    return (targetStart >= targetEnd ? 0 : -1);\x0d\n  if (targetStart >= targetEnd)\x0d\n    return 1;\x0d\n\x0d\n  return compareOffset(this\x2C target\x2C targetStart\x2C sourceStart\x2C targetEnd\x2C\x0d\n                       sourceEnd);\x0d\n};\x0d\n\x0d\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`\x2C\x0d\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\x0d\n//\x0d\n// Arguments:\x0d\n// - buffer - a Buffer to search\x0d\n// - val - a string\x2C Buffer\x2C or number\x0d\n// - byteOffset - an index into `buffer`; will be clamped to an int32\x0d\n// - encoding - an optional encoding\x2C relevant if val is a string\x0d\n// - dir - true for indexOf\x2C false for lastIndexOf\x0d\nfunction bidirectionalIndexOf(buffer\x2C val\x2C byteOffset\x2C encoding\x2C dir) {\x0d\n  validateBuffer(buffer);\x0d\n\x0d\n  if (typeof byteOffset === 'string') {\x0d\n    encoding = byteOffset;\x0d\n    byteOffset = undefined;\x0d\n  } else if (byteOffset > 0x7fffffff) {\x0d\n    byteOffset = 0x7fffffff;\x0d\n  } else if (byteOffset < -0x80000000) {\x0d\n    byteOffset = -0x80000000;\x0d\n  }\x0d\n  // Coerce to Number. Values like null and [] become 0.\x0d\n  byteOffset = +byteOffset;\x0d\n  // If the offset is undefined\x2C "foo"\x2C {}\x2C coerces to NaN\x2C search whole buffer.\x0d\n  if (NumberIsNaN(byteOffset)) {\x0d\n    byteOffset = dir ? 0 : (buffer.length || buffer.byteLength);\x0d\n  }\x0d\n  dir = !!dir;  // Cast to bool.\x0d\n\x0d\n  if (typeof val === 'number')\x0d\n    return indexOfNumber(buffer\x2C val >>> 0\x2C byteOffset\x2C dir);\x0d\n\x0d\n  let ops;\x0d\n  if (encoding === undefined)\x0d\n    ops = encodingOps.utf8;\x0d\n  else\x0d\n    ops = getEncodingOps(encoding);\x0d\n\x0d\n  if (typeof val === 'string') {\x0d\n    if (ops === undefined)\x0d\n      throw new ERR_UNKNOWN_ENCODING(encoding);\x0d\n    return ops.indexOf(buffer\x2C val\x2C byteOffset\x2C dir);\x0d\n  }\x0d\n\x0d\n  if (isUint8Array(val)) {\x0d\n    const encodingVal =\x0d\n      (ops === undefined ? encodingsMap.utf8 : ops.encodingVal);\x0d\n    return indexOfBuffer(buffer\x2C val\x2C byteOffset\x2C encodingVal\x2C dir);\x0d\n  }\x0d\n\x0d\n  throw new ERR_INVALID_ARG_TYPE(\x0d\n    'value'\x2C ['number'\x2C 'string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C val\x0d\n  );\x0d\n}\x0d\n\x0d\nBuffer.prototype.indexOf = function indexOf(val\x2C byteOffset\x2C encoding) {\x0d\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C true);\x0d\n};\x0d\n\x0d\nBuffer.prototype.lastIndexOf = function lastIndexOf(val\x2C byteOffset\x2C encoding) {\x0d\n  return bidirectionalIndexOf(this\x2C val\x2C byteOffset\x2C encoding\x2C false);\x0d\n};\x0d\n\x0d\nBuffer.prototype.includes = function includes(val\x2C byteOffset\x2C encoding) {\x0d\n  return this.indexOf(val\x2C byteOffset\x2C encoding) !== -1;\x0d\n};\x0d\n\x0d\n// Usage:\x0d\n//    buffer.fill(number[\x2C offset[\x2C end]])\x0d\n//    buffer.fill(buffer[\x2C offset[\x2C end]])\x0d\n//    buffer.fill(string[\x2C offset[\x2C end]][\x2C encoding])\x0d\nBuffer.prototype.fill = function fill(value\x2C offset\x2C end\x2C encoding) {\x0d\n  return _fill(this\x2C value\x2C offset\x2C end\x2C encoding);\x0d\n};\x0d\n\x0d\nfunction _fill(buf\x2C value\x2C offset\x2C end\x2C encoding) {\x0d\n  if (typeof value === 'string') {\x0d\n    if (offset === undefined || typeof offset === 'string') {\x0d\n      encoding = offset;\x0d\n      offset = 0;\x0d\n      end = buf.length;\x0d\n    } else if (typeof end === 'string') {\x0d\n      encoding = end;\x0d\n      end = buf.length;\x0d\n    }\x0d\n\x0d\n    const normalizedEncoding = normalizeEncoding(encoding);\x0d\n    if (normalizedEncoding === undefined) {\x0d\n      validateString(encoding\x2C 'encoding');\x0d\n      throw new ERR_UNKNOWN_ENCODING(encoding);\x0d\n    }\x0d\n\x0d\n    if (value.length === 0) {\x0d\n      // If value === '' default to zero.\x0d\n      value = 0;\x0d\n    } else if (value.length === 1) {\x0d\n      // Fast path: If `value` fits into a single byte\x2C use that numeric value.\x0d\n      if (normalizedEncoding === 'utf8') {\x0d\n        const code = StringPrototypeCharCodeAt(value\x2C 0);\x0d\n        if (code < 128) {\x0d\n          value = code;\x0d\n        }\x0d\n      } else if (normalizedEncoding === 'latin1') {\x0d\n        value = StringPrototypeCharCodeAt(value\x2C 0);\x0d\n      }\x0d\n    }\x0d\n  } else {\x0d\n    encoding = undefined;\x0d\n  }\x0d\n\x0d\n  if (offset === undefined) {\x0d\n    offset = 0;\x0d\n    end = buf.length;\x0d\n  } else {\x0d\n    validateOffset(offset\x2C 'offset');\x0d\n    // Invalid ranges are not set to a default\x2C so can range check early.\x0d\n    if (end === undefined) {\x0d\n      end = buf.length;\x0d\n    } else {\x0d\n      validateOffset(end\x2C 'end'\x2C 0\x2C buf.length);\x0d\n    }\x0d\n    if (offset >= end)\x0d\n      return buf;\x0d\n  }\x0d\n\x0d\n\x0d\n  if (typeof value === 'number') {\x0d\n    // OOB check\x0d\n    const byteLen = TypedArrayPrototypeGetByteLength(buf);\x0d\n    const fillLength = end - offset;\x0d\n    if (offset > end || fillLength + offset > byteLen)\x0d\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\x0d\n\x0d\n    TypedArrayPrototypeFill(buf\x2C value\x2C offset\x2C end);\x0d\n  } else {\x0d\n    const res = bindingFill(buf\x2C value\x2C offset\x2C end\x2C encoding);\x0d\n    if (res < 0) {\x0d\n      if (res === -1)\x0d\n        throw new ERR_INVALID_ARG_VALUE('value'\x2C value);\x0d\n      throw new ERR_BUFFER_OUT_OF_BOUNDS();\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return buf;\x0d\n}\x0d\n\x0d\nBuffer.prototype.write = function write(string\x2C offset\x2C length\x2C encoding) {\x0d\n  // Buffer#write(string);\x0d\n  if (offset === undefined) {\x0d\n    return this.utf8Write(string\x2C 0\x2C this.length);\x0d\n  }\x0d\n  // Buffer#write(string\x2C encoding)\x0d\n  if (length === undefined && typeof offset === 'string') {\x0d\n    encoding = offset;\x0d\n    length = this.length;\x0d\n    offset = 0;\x0d\n\x0d\n  // Buffer#write(string\x2C offset[\x2C length][\x2C encoding])\x0d\n  } else {\x0d\n    validateOffset(offset\x2C 'offset'\x2C 0\x2C this.length);\x0d\n\x0d\n    const remaining = this.length - offset;\x0d\n\x0d\n    if (length === undefined) {\x0d\n      length = remaining;\x0d\n    } else if (typeof length === 'string') {\x0d\n      encoding = length;\x0d\n      length = remaining;\x0d\n    } else {\x0d\n      validateOffset(length\x2C 'length'\x2C 0\x2C this.length);\x0d\n      if (length > remaining)\x0d\n        length = remaining;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (!encoding)\x0d\n    return this.utf8Write(string\x2C offset\x2C length);\x0d\n\x0d\n  const ops = getEncodingOps(encoding);\x0d\n  if (ops === undefined)\x0d\n    throw new ERR_UNKNOWN_ENCODING(encoding);\x0d\n  return ops.write(this\x2C string\x2C offset\x2C length);\x0d\n};\x0d\n\x0d\nBuffer.prototype.toJSON = function toJSON() {\x0d\n  if (this.length > 0) {\x0d\n    const data = new Array(this.length);\x0d\n    for (let i = 0; i < this.length; ++i)\x0d\n      data[i] = this[i];\x0d\n    return { type: 'Buffer'\x2C data };\x0d\n  }\x0d\n  return { type: 'Buffer'\x2C data: [] };\x0d\n};\x0d\n\x0d\nfunction adjustOffset(offset\x2C length) {\x0d\n  // Use Math.trunc() to convert offset to an integer value that can be larger\x0d\n  // than an Int32. Hence\x2C don't use offset | 0 or similar techniques.\x0d\n  offset = MathTrunc(offset);\x0d\n  if (offset === 0) {\x0d\n    return 0;\x0d\n  }\x0d\n  if (offset < 0) {\x0d\n    offset += length;\x0d\n    return offset > 0 ? offset : 0;\x0d\n  }\x0d\n  if (offset < length) {\x0d\n    return offset;\x0d\n  }\x0d\n  return NumberIsNaN(offset) ? 0 : length;\x0d\n}\x0d\n\x0d\nBuffer.prototype.slice = function slice(start\x2C end) {\x0d\n  const srcLength = this.length;\x0d\n  start = adjustOffset(start\x2C srcLength);\x0d\n  end = end !== undefined ? adjustOffset(end\x2C srcLength) : srcLength;\x0d\n  const newLength = end > start ? end - start : 0;\x0d\n  return new FastBuffer(this.buffer\x2C this.byteOffset + start\x2C newLength);\x0d\n};\x0d\n\x0d\nfunction swap(b\x2C n\x2C m) {\x0d\n  const i = b[n];\x0d\n  b[n] = b[m];\x0d\n  b[m] = i;\x0d\n}\x0d\n\x0d\nBuffer.prototype.swap16 = function swap16() {\x0d\n  // For Buffer.length < 128\x2C it's generally faster to\x0d\n  // do the swap in javascript. For larger buffers\x2C\x0d\n  // dropping down to the native code is faster.\x0d\n  const len = this.length;\x0d\n  if (len % 2 !== 0)\x0d\n    throw new ERR_INVALID_BUFFER_SIZE('16-bits');\x0d\n  if (len < 128) {\x0d\n    for (let i = 0; i < len; i += 2)\x0d\n      swap(this\x2C i\x2C i + 1);\x0d\n    return this;\x0d\n  }\x0d\n  return _swap16(this);\x0d\n};\x0d\n\x0d\nBuffer.prototype.swap32 = function swap32() {\x0d\n  // For Buffer.length < 192\x2C it's generally faster to\x0d\n  // do the swap in javascript. For larger buffers\x2C\x0d\n  // dropping down to the native code is faster.\x0d\n  const len = this.length;\x0d\n  if (len % 4 !== 0)\x0d\n    throw new ERR_INVALID_BUFFER_SIZE('32-bits');\x0d\n  if (len < 192) {\x0d\n    for (let i = 0; i < len; i += 4) {\x0d\n      swap(this\x2C i\x2C i + 3);\x0d\n      swap(this\x2C i + 1\x2C i + 2);\x0d\n    }\x0d\n    return this;\x0d\n  }\x0d\n  return _swap32(this);\x0d\n};\x0d\n\x0d\nBuffer.prototype.swap64 = function swap64() {\x0d\n  // For Buffer.length < 192\x2C it's generally faster to\x0d\n  // do the swap in javascript. For larger buffers\x2C\x0d\n  // dropping down to the native code is faster.\x0d\n  const len = this.length;\x0d\n  if (len % 8 !== 0)\x0d\n    throw new ERR_INVALID_BUFFER_SIZE('64-bits');\x0d\n  if (len < 192) {\x0d\n    for (let i = 0; i < len; i += 8) {\x0d\n      swap(this\x2C i\x2C i + 7);\x0d\n      swap(this\x2C i + 1\x2C i + 6);\x0d\n      swap(this\x2C i + 2\x2C i + 5);\x0d\n      swap(this\x2C i + 3\x2C i + 4);\x0d\n    }\x0d\n    return this;\x0d\n  }\x0d\n  return _swap64(this);\x0d\n};\x0d\n\x0d\nBuffer.prototype.toLocaleString = Buffer.prototype.toString;\x0d\n\x0d\nlet transcode;\x0d\nif (internalBinding('config').hasIntl) {\x0d\n  const {\x0d\n    icuErrName\x2C\x0d\n    transcode: _transcode\x0d\n  } = internalBinding('icu');\x0d\n\x0d\n  // Transcodes the Buffer from one encoding to another\x2C returning a new\x0d\n  // Buffer instance.\x0d\n  transcode = function transcode(source\x2C fromEncoding\x2C toEncoding) {\x0d\n    if (!isUint8Array(source)) {\x0d\n      throw new ERR_INVALID_ARG_TYPE('source'\x2C\x0d\n                                     ['Buffer'\x2C 'Uint8Array']\x2C source);\x0d\n    }\x0d\n    if (source.length === 0) return Buffer.alloc(0);\x0d\n\x0d\n    fromEncoding = normalizeEncoding(fromEncoding) || fromEncoding;\x0d\n    toEncoding = normalizeEncoding(toEncoding) || toEncoding;\x0d\n    const result = _transcode(source\x2C fromEncoding\x2C toEncoding);\x0d\n    if (typeof result !== 'number')\x0d\n      return result;\x0d\n\x0d\n    const code = icuErrName(result);\x0d\n    // eslint-disable-next-line no-restricted-syntax\x0d\n    const err = new Error(`Unable to transcode Buffer [${code}]`);\x0d\n    err.code = code;\x0d\n    err.errno = result;\x0d\n    throw err;\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction btoa(input) {\x0d\n  // The implementation here has not been performance optimized in any way and\x0d\n  // should not be.\x0d\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\x0d\n  input = `${input}`;\x0d\n  for (let n = 0; n < input.length; n++) {\x0d\n    if (input[n].charCodeAt(0) > 0xff)\x0d\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\x0d\n  }\x0d\n  const buf = Buffer.from(input\x2C 'latin1');\x0d\n  return buf.toString('base64');\x0d\n}\x0d\n\x0d\nconst kBase64Digits =\x0d\n  'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\x0d\n\x0d\nfunction atob(input) {\x0d\n  // The implementation here has not been performance optimized in any way and\x0d\n  // should not be.\x0d\n  // Refs: https://github.com/nodejs/node/pull/38433#issuecomment-828426932\x0d\n  input = `${input}`;\x0d\n  for (let n = 0; n < input.length; n++) {\x0d\n    if (!kBase64Digits.includes(input[n]))\x0d\n      throw lazyDOMException('Invalid character'\x2C 'InvalidCharacterError');\x0d\n  }\x0d\n  return Buffer.from(input\x2C 'base64').toString('latin1');\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  Blob\x2C\x0d\n  resolveObjectURL\x2C\x0d\n  Buffer\x2C\x0d\n  SlowBuffer\x2C\x0d\n  transcode\x2C\x0d\n  // Legacy\x0d\n  kMaxLength\x2C\x0d\n  kStringMaxLength\x2C\x0d\n  btoa\x2C\x0d\n  atob\x2C\x0d\n};\x0d\n\x0d\nObjectDefineProperties(module.exports\x2C {\x0d\n  constants: {\x0d\n    configurable: false\x2C\x0d\n    enumerable: true\x2C\x0d\n    value: constants\x0d\n  }\x2C\x0d\n  INSPECT_MAX_BYTES: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x2C\x0d\n    get() { return INSPECT_MAX_BYTES; }\x2C\x0d\n    set(val) { INSPECT_MAX_BYTES = val; }\x0d\n  }\x0d\n});\x0d\n
code-source-info,0x109c10c313e,24,8700,9683,C3O8739C9O8775C12O8782C17O8818C18O8824C28O8880C33O8884C39O8916C51O8923C56O8972C57O9002C63O9019C68O9019C73O9035C78O9075C95O9168C104O9175C109O9215C110O9240C113O9240C118O9264C120O9278C122O9287C123O9295C125O9312C127O9311C134O9374C136O9380C138O9379C145O9398C151O9417C155O9463C158O9470C163O9510C164O9537C182O9543C187O9537,,
tick,0x7ff99731fab3,203452,0,0x0,3,0x7ff7e78fdb40,0x109c10c23b1,0x1abee802285,0x1abee801555,0x1abee83d78d,0x1abee802285,0x1abee801555,0x1abee839712,0x1abee802285,0x1abee801555,0x1abee838fa2,0x1abee802285,0x1abee801555,0x1abee82c3b5,0x1abee802285,0x1abee801555,0x1abee82a79c,0x1abee802285,0x1abee801555,0x1abee825ff9,0x1abee802285,0x1abee801555,0x1abee821e04,0x1abee806742,0x1abee8012dd
code-creation,LazyCompile,10,203537,0x109c10c5b16,110,fromString node:buffer:431:20,0x25ca2736dc8,~
code-source-info,0x109c10c5b16,24,12887,13336,C0O12915C2O12923C8O12968C14O12975C19O13000C25O13007C30O13021C35O13028C40O13045C41O13051C46O13069C51O13080C56O13119C59O13125C64O13156C66O13186C73O13192C78O13186C79O13244C85O13251C90O13265C95O13272C100O13289C101O13298C104O13305C109O13333,,
code-creation,LazyCompile,10,203666,0x109c10c5cce,177,fromStringFast node:buffer:412:24,0x25ca2736d28,~
code-source-info,0x109c10c5cce,24,12324,12864,C0O12362C5O12362C11O12387C14O12409C18O12418C21O12398C26O12431C31O12467C36O12438C41O12480C42O12486C44O12500C49O12511C51O12509C54O12497C59O12529C62O12529C65O12554C72O12569C77O12580C85O12554C91O12623C110O12623C116O12655C118O12666C123O12752C130O12771C135O12782C143O12756C149O12811C156O12825C162O12822C168O12836C171O12836C174O12852C176O12861,,
code-creation,LazyCompile,10,203740,0x109c10c5ebe,36,FastBuffer node:internal/buffer:958:14,0x14121bcbb00,~
code-source-info,0x109c10c5ebe,25,27321,27412,C3O27365C7O27399C20O27365C35O27411,,
code-creation,LazyCompile,10,203784,0x109c10c5fbe,23,write node:buffer:592:12,0x25ca2737138,~
code-source-info,0x109c10c5fbe,24,17116,17180,C0O17150C17O17150C22O17180,,
code-creation,LazyCompile,10,203831,0x109c10c60ae,42,alignPool node:buffer:158:19,0x25ca2736760,~
code-source-info,0x109c10c60ae,24,4155,4265,C0O4191C4O4206C9O4220C19O4231C25O4244C34O4254C41O4264,,
code-creation,Eval,10,204314,0x109c10c6f1e,5, node:internal/webstreams/adapters:1:1,0x109c10c6b58,~
script-source,117,node:internal/webstreams/adapters,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeMap\x2C\x0d\n  PromiseAll\x2C\x0d\n  PromisePrototypeThen\x2C\x0d\n  PromisePrototypeFinally\x2C\x0d\n  PromiseResolve\x2C\x0d\n  Uint8Array\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  ReadableStream\x2C\x0d\n  isReadableStream\x2C\x0d\n} = require('internal/webstreams/readablestream');\x0d\n\x0d\nconst {\x0d\n  WritableStream\x2C\x0d\n  isWritableStream\x2C\x0d\n} = require('internal/webstreams/writablestream');\x0d\n\x0d\nconst {\x0d\n  CountQueuingStrategy\x2C\x0d\n} = require('internal/webstreams/queuingstrategies');\x0d\n\x0d\nconst {\x0d\n  Writable\x2C\x0d\n  Readable\x2C\x0d\n  Duplex\x2C\x0d\n  destroy\x2C\x0d\n} = require('stream');\x0d\n\x0d\nconst {\x0d\n  isDestroyed\x2C\x0d\n  isReadable\x2C\x0d\n  isReadableEnded\x2C\x0d\n  isWritable\x2C\x0d\n  isWritableEnded\x2C\x0d\n} = require('internal/streams/utils');\x0d\n\x0d\nconst {\x0d\n  Buffer\x2C\x0d\n} = require('buffer');\x0d\n\x0d\nconst {\x0d\n  errnoException\x2C\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_INVALID_STATE\x2C\x0d\n    ERR_STREAM_PREMATURE_CLOSE\x2C\x0d\n  }\x2C\x0d\n  AbortError\x2C\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  createDeferredPromise\x2C\x0d\n} = require('internal/util');\x0d\n\x0d\nconst {\x0d\n  validateBoolean\x2C\x0d\n  validateObject\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst {\x0d\n  WriteWrap\x2C\x0d\n  ShutdownWrap\x2C\x0d\n  kReadBytesOrError\x2C\x0d\n  kLastWriteWasAsync\x2C\x0d\n  streamBaseState\x2C\x0d\n} = internalBinding('stream_wrap');\x0d\n\x0d\nconst finished = require('internal/streams/end-of-stream');\x0d\n\x0d\nconst { UV_EOF } = internalBinding('uv');\x0d\n\x0d\n/**\x0d\n * @typedef {import('../../stream').Writable} Writable\x0d\n * @typedef {import('../../stream').Readable} Readable\x0d\n * @typedef {import('./writablestream').WritableStream} WritableStream\x0d\n * @typedef {import('./readablestream').ReadableStream} ReadableStream\x0d\n */\x0d\n\x0d\n/**\x0d\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\x0d\n */\x0d\n\x0d\n/**\x0d\n * @param {Writable} streamWritable\x0d\n * @returns {WritableStream}\x0d\n */\x0d\nfunction newWritableStreamFromStreamWritable(streamWritable) {\x0d\n  // Not using the internal/streams/utils isWritableNodeStream utility\x0d\n  // here because it will return false if streamWritable is a Duplex\x0d\n  // whose writable option is false. For a Duplex that is not writable\x2C\x0d\n  // we want it to pass this check but return a closed WritableStream.\x0d\n  if (typeof streamWritable?._writableState !== 'object') {\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'streamWritable'\x2C\x0d\n      'stream.Writable'\x2C\x0d\n      streamWritable);\x0d\n  }\x0d\n\x0d\n  if (isDestroyed(streamWritable) || !isWritable(streamWritable)) {\x0d\n    const writable = new WritableStream();\x0d\n    writable.close();\x0d\n    return writable;\x0d\n  }\x0d\n\x0d\n  const highWaterMark = streamWritable.writableHighWaterMark;\x0d\n  const strategy =\x0d\n    streamWritable.writableObjectMode ?\x0d\n      new CountQueuingStrategy({ highWaterMark }) :\x0d\n      { highWaterMark };\x0d\n\x0d\n  let controller;\x0d\n  let backpressurePromise;\x0d\n  let closed;\x0d\n\x0d\n  function onDrain() {\x0d\n    if (backpressurePromise !== undefined)\x0d\n      backpressurePromise.resolve();\x0d\n  }\x0d\n\x0d\n  const cleanup = finished(streamWritable\x2C (error) => {\x0d\n    if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\x0d\n      const err = new AbortError(undefined\x2C { cause: error });\x0d\n      error = err;\x0d\n    }\x0d\n\x0d\n    cleanup();\x0d\n    // This is a protection against non-standard\x2C legacy streams\x0d\n    // that happen to emit an error event again after finished is called.\x0d\n    streamWritable.on('error'\x2C () => {});\x0d\n    if (error != null) {\x0d\n      if (backpressurePromise !== undefined)\x0d\n        backpressurePromise.reject(error);\x0d\n      // If closed is not undefined\x2C the error is happening\x0d\n      // after the WritableStream close has already started.\x0d\n      // We need to reject it here.\x0d\n      if (closed !== undefined) {\x0d\n        closed.reject(error);\x0d\n        closed = undefined;\x0d\n      }\x0d\n      controller.error(error);\x0d\n      controller = undefined;\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    if (closed !== undefined) {\x0d\n      closed.resolve();\x0d\n      closed = undefined;\x0d\n      return;\x0d\n    }\x0d\n    controller.error(new AbortError());\x0d\n    controller = undefined;\x0d\n  });\x0d\n\x0d\n  streamWritable.on('drain'\x2C onDrain);\x0d\n\x0d\n  return new WritableStream({\x0d\n    start(c) { controller = c; }\x2C\x0d\n\x0d\n    async write(chunk) {\x0d\n      if (streamWritable.writableNeedDrain || !streamWritable.write(chunk)) {\x0d\n        backpressurePromise = createDeferredPromise();\x0d\n        return PromisePrototypeFinally(\x0d\n          backpressurePromise.promise\x2C () => {\x0d\n            backpressurePromise = undefined;\x0d\n          });\x0d\n      }\x0d\n    }\x2C\x0d\n\x0d\n    abort(reason) {\x0d\n      destroy(streamWritable\x2C reason);\x0d\n    }\x2C\x0d\n\x0d\n    close() {\x0d\n      if (closed === undefined && !isWritableEnded(streamWritable)) {\x0d\n        closed = createDeferredPromise();\x0d\n        streamWritable.end();\x0d\n        return closed.promise;\x0d\n      }\x0d\n\x0d\n      controller = undefined;\x0d\n      return PromiseResolve();\x0d\n    }\x2C\x0d\n  }\x2C strategy);\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {WritableStream} writableStream\x0d\n * @param {{\x0d\n *   decodeStrings? : boolean\x2C\x0d\n *   highWaterMark? : number\x2C\x0d\n *   objectMode? : boolean\x2C\x0d\n *   signal? : AbortSignal\x2C\x0d\n * }} [options]\x0d\n * @returns {Writable}\x0d\n */\x0d\nfunction newStreamWritableFromWritableStream(writableStream\x2C options = {}) {\x0d\n  if (!isWritableStream(writableStream)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'writableStream'\x2C\x0d\n      'WritableStream'\x2C\x0d\n      writableStream);\x0d\n  }\x0d\n\x0d\n  validateObject(options\x2C 'options');\x0d\n  const {\x0d\n    highWaterMark\x2C\x0d\n    decodeStrings = true\x2C\x0d\n    objectMode = false\x2C\x0d\n    signal\x2C\x0d\n  } = options;\x0d\n\x0d\n  validateBoolean(objectMode\x2C 'options.objectMode');\x0d\n  validateBoolean(decodeStrings\x2C 'options.decodeStrings');\x0d\n\x0d\n  const writer = writableStream.getWriter();\x0d\n  let closed = false;\x0d\n\x0d\n  const writable = new Writable({\x0d\n    highWaterMark\x2C\x0d\n    objectMode\x2C\x0d\n    decodeStrings\x2C\x0d\n    signal\x2C\x0d\n\x0d\n    writev(chunks\x2C callback) {\x0d\n      function done(error) {\x0d\n        try {\x0d\n          callback(error);\x0d\n        } catch (error) {\x0d\n          // In a next tick because this is happening within\x0d\n          // a promise context\x2C and if there are any errors\x0d\n          // thrown we don't want those to cause an unhandled\x0d\n          // rejection. Let's just escape the promise and\x0d\n          // handle it separately.\x0d\n          process.nextTick(() => destroy(writable\x2C error));\x0d\n        }\x0d\n      }\x0d\n\x0d\n      PromisePrototypeThen(\x0d\n        writer.ready\x2C\x0d\n        () => {\x0d\n          return PromisePrototypeThen(\x0d\n            PromiseAll(\x0d\n              ArrayPrototypeMap(\x0d\n                chunks\x2C\x0d\n                (chunk) => writer.write(chunk)))\x2C\x0d\n            done\x2C\x0d\n            done);\x0d\n        }\x2C\x0d\n        done);\x0d\n    }\x2C\x0d\n\x0d\n    write(chunk\x2C encoding\x2C callback) {\x0d\n      if (typeof chunk === 'string' && decodeStrings && !objectMode) {\x0d\n        chunk = Buffer.from(chunk\x2C encoding);\x0d\n        chunk = new Uint8Array(\x0d\n          chunk.buffer\x2C\x0d\n          chunk.byteOffset\x2C\x0d\n          chunk.byteLength);\x0d\n      }\x0d\n\x0d\n      function done(error) {\x0d\n        try {\x0d\n          callback(error);\x0d\n        } catch (error) {\x0d\n          destroy(writable\x2C error);\x0d\n        }\x0d\n      }\x0d\n\x0d\n      PromisePrototypeThen(\x0d\n        writer.ready\x2C\x0d\n        () => {\x0d\n          return PromisePrototypeThen(\x0d\n            writer.write(chunk)\x2C\x0d\n            done\x2C\x0d\n            done);\x0d\n        }\x2C\x0d\n        done);\x0d\n    }\x2C\x0d\n\x0d\n    destroy(error\x2C callback) {\x0d\n      function done() {\x0d\n        try {\x0d\n          callback(error);\x0d\n        } catch (error) {\x0d\n          // In a next tick because this is happening within\x0d\n          // a promise context\x2C and if there are any errors\x0d\n          // thrown we don't want those to cause an unhandled\x0d\n          // rejection. Let's just escape the promise and\x0d\n          // handle it separately.\x0d\n          process.nextTick(() => { throw error; });\x0d\n        }\x0d\n      }\x0d\n\x0d\n      if (!closed) {\x0d\n        if (error != null) {\x0d\n          PromisePrototypeThen(\x0d\n            writer.abort(error)\x2C\x0d\n            done\x2C\x0d\n            done);\x0d\n        } else {\x0d\n          PromisePrototypeThen(\x0d\n            writer.close()\x2C\x0d\n            done\x2C\x0d\n            done);\x0d\n        }\x0d\n        return;\x0d\n      }\x0d\n\x0d\n      done();\x0d\n    }\x2C\x0d\n\x0d\n    final(callback) {\x0d\n      function done(error) {\x0d\n        try {\x0d\n          callback(error);\x0d\n        } catch (error) {\x0d\n          // In a next tick because this is happening within\x0d\n          // a promise context\x2C and if there are any errors\x0d\n          // thrown we don't want those to cause an unhandled\x0d\n          // rejection. Let's just escape the promise and\x0d\n          // handle it separately.\x0d\n          process.nextTick(() => destroy(writable\x2C error));\x0d\n        }\x0d\n      }\x0d\n\x0d\n      if (!closed) {\x0d\n        PromisePrototypeThen(\x0d\n          writer.close()\x2C\x0d\n          done\x2C\x0d\n          done);\x0d\n      }\x0d\n    }\x2C\x0d\n  });\x0d\n\x0d\n  PromisePrototypeThen(\x0d\n    writer.closed\x2C\x0d\n    () => {\x0d\n      // If the WritableStream closes before the stream.Writable has been\x0d\n      // ended\x2C we signal an error on the stream.Writable.\x0d\n      closed = true;\x0d\n      if (!isWritableEnded(writable))\x0d\n        destroy(writable\x2C new ERR_STREAM_PREMATURE_CLOSE());\x0d\n    }\x2C\x0d\n    (error) => {\x0d\n      // If the WritableStream errors before the stream.Writable has been\x0d\n      // destroyed\x2C signal an error on the stream.Writable.\x0d\n      closed = true;\x0d\n      destroy(writable\x2C error);\x0d\n    });\x0d\n\x0d\n  return writable;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {Readable} streamReadable\x0d\n * @returns {ReadableStream}\x0d\n */\x0d\nfunction newReadableStreamFromStreamReadable(streamReadable) {\x0d\n  // Not using the internal/streams/utils isReadableNodeStream utility\x0d\n  // here because it will return false if streamReadable is a Duplex\x0d\n  // whose readable option is false. For a Duplex that is not readable\x2C\x0d\n  // we want it to pass this check but return a closed ReadableStream.\x0d\n  if (typeof streamReadable?._readableState !== 'object') {\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'streamReadable'\x2C\x0d\n      'stream.Readable'\x2C\x0d\n      streamReadable);\x0d\n  }\x0d\n\x0d\n  if (isDestroyed(streamReadable) || !isReadable(streamReadable)) {\x0d\n    const readable = new ReadableStream();\x0d\n    readable.cancel();\x0d\n    return readable;\x0d\n  }\x0d\n\x0d\n  const objectMode = streamReadable.readableObjectMode;\x0d\n  const highWaterMark = streamReadable.readableHighWaterMark;\x0d\n  // When not running in objectMode explicitly\x2C we just fall\x0d\n  // back to a minimal strategy that just specifies the highWaterMark\x0d\n  // and no size algorithm. Using a ByteLengthQueuingStrategy here\x0d\n  // is unnecessary.\x0d\n  const strategy =\x0d\n    objectMode ?\x0d\n      new CountQueuingStrategy({ highWaterMark }) :\x0d\n      { highWaterMark };\x0d\n\x0d\n  let controller;\x0d\n\x0d\n  function onData(chunk) {\x0d\n    // Copy the Buffer to detach it from the pool.\x0d\n    if (Buffer.isBuffer(chunk) && !objectMode)\x0d\n      chunk = new Uint8Array(chunk);\x0d\n    controller.enqueue(chunk);\x0d\n    if (controller.desiredSize <= 0)\x0d\n      streamReadable.pause();\x0d\n  }\x0d\n\x0d\n  streamReadable.pause();\x0d\n\x0d\n  const cleanup = finished(streamReadable\x2C (error) => {\x0d\n    if (error?.code === 'ERR_STREAM_PREMATURE_CLOSE') {\x0d\n      const err = new AbortError(undefined\x2C { cause: error });\x0d\n      error = err;\x0d\n    }\x0d\n\x0d\n    cleanup();\x0d\n    // This is a protection against non-standard\x2C legacy streams\x0d\n    // that happen to emit an error event again after finished is called.\x0d\n    streamReadable.on('error'\x2C () => {});\x0d\n    if (error)\x0d\n      return controller.error(error);\x0d\n    controller.close();\x0d\n  });\x0d\n\x0d\n  streamReadable.on('data'\x2C onData);\x0d\n\x0d\n  return new ReadableStream({\x0d\n    start(c) { controller = c; }\x2C\x0d\n\x0d\n    pull() { streamReadable.resume(); }\x2C\x0d\n\x0d\n    cancel(reason) {\x0d\n      destroy(streamReadable\x2C reason);\x0d\n    }\x2C\x0d\n  }\x2C strategy);\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {ReadableStream} readableStream\x0d\n * @param {{\x0d\n *   highWaterMark? : number\x2C\x0d\n *   encoding? : string\x2C\x0d\n *   objectMode? : boolean\x2C\x0d\n *   signal? : AbortSignal\x2C\x0d\n * }} [options]\x0d\n * @returns {Readable}\x0d\n */\x0d\nfunction newStreamReadableFromReadableStream(readableStream\x2C options = {}) {\x0d\n  if (!isReadableStream(readableStream)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'readableStream'\x2C\x0d\n      'ReadableStream'\x2C\x0d\n      readableStream);\x0d\n  }\x0d\n\x0d\n  validateObject(options\x2C 'options');\x0d\n  const {\x0d\n    highWaterMark\x2C\x0d\n    encoding\x2C\x0d\n    objectMode = false\x2C\x0d\n    signal\x2C\x0d\n  } = options;\x0d\n\x0d\n  if (encoding !== undefined && !Buffer.isEncoding(encoding))\x0d\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'options.encoding');\x0d\n  validateBoolean(objectMode\x2C 'options.objectMode');\x0d\n\x0d\n  const reader = readableStream.getReader();\x0d\n  let closed = false;\x0d\n\x0d\n  const readable = new Readable({\x0d\n    objectMode\x2C\x0d\n    highWaterMark\x2C\x0d\n    encoding\x2C\x0d\n    signal\x2C\x0d\n\x0d\n    read() {\x0d\n      PromisePrototypeThen(\x0d\n        reader.read()\x2C\x0d\n        (chunk) => {\x0d\n          if (chunk.done) {\x0d\n            // Value should always be undefined here.\x0d\n            readable.push(null);\x0d\n          } else {\x0d\n            readable.push(chunk.value);\x0d\n          }\x0d\n        }\x2C\x0d\n        (error) => destroy(readable\x2C error));\x0d\n    }\x2C\x0d\n\x0d\n    destroy(error\x2C callback) {\x0d\n      function done() {\x0d\n        try {\x0d\n          callback(error);\x0d\n        } catch (error) {\x0d\n          // In a next tick because this is happening within\x0d\n          // a promise context\x2C and if there are any errors\x0d\n          // thrown we don't want those to cause an unhandled\x0d\n          // rejection. Let's just escape the promise and\x0d\n          // handle it separately.\x0d\n          process.nextTick(() => { throw error; });\x0d\n        }\x0d\n      }\x0d\n\x0d\n      if (!closed) {\x0d\n        PromisePrototypeThen(\x0d\n          reader.cancel(error)\x2C\x0d\n          done\x2C\x0d\n          done);\x0d\n        return;\x0d\n      }\x0d\n      done();\x0d\n    }\x2C\x0d\n  });\x0d\n\x0d\n  PromisePrototypeThen(\x0d\n    reader.closed\x2C\x0d\n    () => {\x0d\n      closed = true;\x0d\n      if (!isReadableEnded(readable))\x0d\n        readable.push(null);\x0d\n    }\x2C\x0d\n    (error) => {\x0d\n      closed = true;\x0d\n      destroy(readable\x2C error);\x0d\n    });\x0d\n\x0d\n  return readable;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @typedef {import('./readablestream').ReadableWritablePair\x0d\n * } ReadableWritablePair\x0d\n * @typedef {import('../../stream').Duplex} Duplex\x0d\n */\x0d\n\x0d\n/**\x0d\n * @param {Duplex} duplex\x0d\n * @returns {ReadableWritablePair}\x0d\n */\x0d\nfunction newReadableWritablePairFromDuplex(duplex) {\x0d\n  // Not using the internal/streams/utils isWritableNodeStream and\x0d\n  // isReadableNodestream utilities here because they will return false\x0d\n  // if the duplex was created with writable or readable options set to\x0d\n  // false. Instead\x2C we'll check the readable and writable state after\x0d\n  // and return closed WritableStream or closed ReadableStream as\x0d\n  // necessary.\x0d\n  if (typeof duplex?._writableState !== 'object' ||\x0d\n      typeof duplex?._readableState !== 'object') {\x0d\n    throw new ERR_INVALID_ARG_TYPE('duplex'\x2C 'stream.Duplex'\x2C duplex);\x0d\n  }\x0d\n\x0d\n  if (isDestroyed(duplex)) {\x0d\n    const writable = new WritableStream();\x0d\n    const readable = new ReadableStream();\x0d\n    writable.close();\x0d\n    readable.cancel();\x0d\n    return { readable\x2C writable };\x0d\n  }\x0d\n\x0d\n  const writable =\x0d\n    isWritable(duplex) ?\x0d\n      newWritableStreamFromStreamWritable(duplex) :\x0d\n      new WritableStream();\x0d\n\x0d\n  if (!isWritable(duplex))\x0d\n    writable.close();\x0d\n\x0d\n  const readable =\x0d\n    isReadable(duplex) ?\x0d\n      newReadableStreamFromStreamReadable(duplex) :\x0d\n      new ReadableStream();\x0d\n\x0d\n  if (!isReadable(duplex))\x0d\n    readable.cancel();\x0d\n\x0d\n  return { writable\x2C readable };\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {ReadableWritablePair} pair\x0d\n * @param {{\x0d\n *   allowHalfOpen? : boolean\x2C\x0d\n *   decodeStrings? : boolean\x2C\x0d\n *   encoding? : string\x2C\x0d\n *   highWaterMark? : number\x2C\x0d\n *   objectMode? : boolean\x2C\x0d\n *   signal? : AbortSignal\x2C\x0d\n * }} [options]\x0d\n * @returns {Duplex}\x0d\n */\x0d\nfunction newStreamDuplexFromReadableWritablePair(pair = {}\x2C options = {}) {\x0d\n  validateObject(pair\x2C 'pair');\x0d\n  const {\x0d\n    readable: readableStream\x2C\x0d\n    writable: writableStream\x2C\x0d\n  } = pair;\x0d\n\x0d\n  if (!isReadableStream(readableStream)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'pair.readable'\x2C\x0d\n      'ReadableStream'\x2C\x0d\n      readableStream);\x0d\n  }\x0d\n  if (!isWritableStream(writableStream)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'pair.writable'\x2C\x0d\n      'WritableStream'\x2C\x0d\n      writableStream);\x0d\n  }\x0d\n\x0d\n  validateObject(options\x2C 'options');\x0d\n  const {\x0d\n    allowHalfOpen = false\x2C\x0d\n    objectMode = false\x2C\x0d\n    encoding\x2C\x0d\n    decodeStrings = true\x2C\x0d\n    highWaterMark\x2C\x0d\n    signal\x2C\x0d\n  } = options;\x0d\n\x0d\n  validateBoolean(objectMode\x2C 'options.objectMode');\x0d\n  if (encoding !== undefined && !Buffer.isEncoding(encoding))\x0d\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'options.encoding');\x0d\n\x0d\n  const writer = writableStream.getWriter();\x0d\n  const reader = readableStream.getReader();\x0d\n  let writableClosed = false;\x0d\n  let readableClosed = false;\x0d\n\x0d\n  const duplex = new Duplex({\x0d\n    allowHalfOpen\x2C\x0d\n    highWaterMark\x2C\x0d\n    objectMode\x2C\x0d\n    encoding\x2C\x0d\n    decodeStrings\x2C\x0d\n    signal\x2C\x0d\n\x0d\n    writev(chunks\x2C callback) {\x0d\n      function done(error) {\x0d\n        try {\x0d\n          callback(error);\x0d\n        } catch (error) {\x0d\n          // In a next tick because this is happening within\x0d\n          // a promise context\x2C and if there are any errors\x0d\n          // thrown we don't want those to cause an unhandled\x0d\n          // rejection. Let's just escape the promise and\x0d\n          // handle it separately.\x0d\n          process.nextTick(() => destroy(duplex\x2C error));\x0d\n        }\x0d\n      }\x0d\n\x0d\n      PromisePrototypeThen(\x0d\n        writer.ready\x2C\x0d\n        () => {\x0d\n          return PromisePrototypeThen(\x0d\n            PromiseAll(\x0d\n              ArrayPrototypeMap(\x0d\n                chunks\x2C\x0d\n                (chunk) => writer.write(chunk)))\x2C\x0d\n            done\x2C\x0d\n            done);\x0d\n        }\x2C\x0d\n        done);\x0d\n    }\x2C\x0d\n\x0d\n    write(chunk\x2C encoding\x2C callback) {\x0d\n      if (typeof chunk === 'string' && decodeStrings && !objectMode) {\x0d\n        chunk = Buffer.from(chunk\x2C encoding);\x0d\n        chunk = new Uint8Array(\x0d\n          chunk.buffer\x2C\x0d\n          chunk.byteOffset\x2C\x0d\n          chunk.byteLength);\x0d\n      }\x0d\n\x0d\n      function done(error) {\x0d\n        try {\x0d\n          callback(error);\x0d\n        } catch (error) {\x0d\n          destroy(duplex\x2C error);\x0d\n        }\x0d\n      }\x0d\n\x0d\n      PromisePrototypeThen(\x0d\n        writer.ready\x2C\x0d\n        () => {\x0d\n          return PromisePrototypeThen(\x0d\n            writer.write(chunk)\x2C\x0d\n            done\x2C\x0d\n            done);\x0d\n        }\x2C\x0d\n        done);\x0d\n    }\x2C\x0d\n\x0d\n    final(callback) {\x0d\n      function done(error) {\x0d\n        try {\x0d\n          callback(error);\x0d\n        } catch (error) {\x0d\n          // In a next tick because this is happening within\x0d\n          // a promise context\x2C and if there are any errors\x0d\n          // thrown we don't want those to cause an unhandled\x0d\n          // rejection. Let's just escape the promise and\x0d\n          // handle it separately.\x0d\n          process.nextTick(() => destroy(duplex\x2C error));\x0d\n        }\x0d\n      }\x0d\n\x0d\n      if (!writableClosed) {\x0d\n        PromisePrototypeThen(\x0d\n          writer.close()\x2C\x0d\n          done\x2C\x0d\n          done);\x0d\n      }\x0d\n    }\x2C\x0d\n\x0d\n    read() {\x0d\n      PromisePrototypeThen(\x0d\n        reader.read()\x2C\x0d\n        (chunk) => {\x0d\n          if (chunk.done) {\x0d\n            duplex.push(null);\x0d\n          } else {\x0d\n            duplex.push(chunk.value);\x0d\n          }\x0d\n        }\x2C\x0d\n        (error) => destroy(duplex\x2C error));\x0d\n    }\x2C\x0d\n\x0d\n    destroy(error\x2C callback) {\x0d\n      function done() {\x0d\n        try {\x0d\n          callback(error);\x0d\n        } catch (error) {\x0d\n          // In a next tick because this is happening within\x0d\n          // a promise context\x2C and if there are any errors\x0d\n          // thrown we don't want those to cause an unhandled\x0d\n          // rejection. Let's just escape the promise and\x0d\n          // handle it separately.\x0d\n          process.nextTick(() => { throw error; });\x0d\n        }\x0d\n      }\x0d\n\x0d\n      async function closeWriter() {\x0d\n        if (!writableClosed)\x0d\n          await writer.abort(error);\x0d\n      }\x0d\n\x0d\n      async function closeReader() {\x0d\n        if (!readableClosed)\x0d\n          await reader.cancel(error);\x0d\n      }\x0d\n\x0d\n      if (!writableClosed || !readableClosed) {\x0d\n        PromisePrototypeThen(\x0d\n          PromiseAll([\x0d\n            closeWriter()\x2C\x0d\n            closeReader()\x2C\x0d\n          ])\x2C\x0d\n          done\x2C\x0d\n          done);\x0d\n        return;\x0d\n      }\x0d\n\x0d\n      done();\x0d\n    }\x2C\x0d\n  });\x0d\n\x0d\n  PromisePrototypeThen(\x0d\n    writer.closed\x2C\x0d\n    () => {\x0d\n      writableClosed = true;\x0d\n      if (!isWritableEnded(duplex))\x0d\n        destroy(duplex\x2C new ERR_STREAM_PREMATURE_CLOSE());\x0d\n    }\x2C\x0d\n    (error) => {\x0d\n      writableClosed = true;\x0d\n      readableClosed = true;\x0d\n      destroy(duplex\x2C error);\x0d\n    });\x0d\n\x0d\n  PromisePrototypeThen(\x0d\n    reader.closed\x2C\x0d\n    () => {\x0d\n      readableClosed = true;\x0d\n      if (!isReadableEnded(duplex))\x0d\n        duplex.push(null);\x0d\n    }\x2C\x0d\n    (error) => {\x0d\n      writableClosed = true;\x0d\n      readableClosed = true;\x0d\n      destroy(duplex\x2C error);\x0d\n    });\x0d\n\x0d\n  return duplex;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @typedef {import('./queuingstrategies').QueuingStrategy} QueuingStrategy\x0d\n * @typedef {{}} StreamBase\x0d\n * @param {StreamBase} streamBase\x0d\n * @param {QueuingStrategy} strategy\x0d\n * @returns {WritableStream}\x0d\n */\x0d\nfunction newWritableStreamFromStreamBase(streamBase\x2C strategy) {\x0d\n  validateObject(streamBase\x2C 'streamBase');\x0d\n\x0d\n  let current;\x0d\n\x0d\n  function createWriteWrap(controller\x2C promise) {\x0d\n    const req = new WriteWrap();\x0d\n    req.handle = streamBase;\x0d\n    req.oncomplete = onWriteComplete;\x0d\n    req.async = false;\x0d\n    req.bytes = 0;\x0d\n    req.buffer = null;\x0d\n    req.controller = controller;\x0d\n    req.promise = promise;\x0d\n    return req;\x0d\n  }\x0d\n\x0d\n  function onWriteComplete(status) {\x0d\n    if (status < 0) {\x0d\n      const error = errnoException(status\x2C 'write'\x2C this.error);\x0d\n      this.promise.reject(error);\x0d\n      this.controller.error(error);\x0d\n      return;\x0d\n    }\x0d\n    this.promise.resolve();\x0d\n  }\x0d\n\x0d\n  function doWrite(chunk\x2C controller) {\x0d\n    const promise = createDeferredPromise();\x0d\n    let ret;\x0d\n    let req;\x0d\n    try {\x0d\n      req = createWriteWrap(controller\x2C promise);\x0d\n      ret = streamBase.writeBuffer(req\x2C chunk);\x0d\n      if (streamBaseState[kLastWriteWasAsync])\x0d\n        req.buffer = chunk;\x0d\n      req.async = !!streamBaseState[kLastWriteWasAsync];\x0d\n    } catch (error) {\x0d\n      promise.reject(error);\x0d\n    }\x0d\n\x0d\n    if (ret !== 0)\x0d\n      promise.reject(errnoException(ret\x2C 'write'\x2C req));\x0d\n    else if (!req.async)\x0d\n      promise.resolve();\x0d\n\x0d\n    return promise.promise;\x0d\n  }\x0d\n\x0d\n  return new WritableStream({\x0d\n    write(chunk\x2C controller) {\x0d\n      current = current !== undefined ?\x0d\n        PromisePrototypeThen(\x0d\n          current\x2C\x0d\n          () => doWrite(chunk\x2C controller)\x2C\x0d\n          (error) => controller.error(error)) :\x0d\n        doWrite(chunk\x2C controller);\x0d\n      return current;\x0d\n    }\x2C\x0d\n\x0d\n    close() {\x0d\n      const promise = createDeferredPromise();\x0d\n      const req = new ShutdownWrap();\x0d\n      req.oncomplete = () => promise.resolve();\x0d\n      const err = streamBase.shutdown(req);\x0d\n      if (err === 1)\x0d\n        promise.resolve();\x0d\n      return promise.promise;\x0d\n    }\x2C\x0d\n  }\x2C strategy);\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {StreamBase} streamBase\x0d\n * @param {QueuingStrategy} strategy\x0d\n * @returns {ReadableStream}\x0d\n */\x0d\nfunction newReadableStreamFromStreamBase(streamBase\x2C strategy\x2C options = {}) {\x0d\n  validateObject(streamBase\x2C 'streamBase');\x0d\n  validateObject(options\x2C 'options');\x0d\n\x0d\n  const {\x0d\n    ondone = () => {}\x2C\x0d\n  } = options;\x0d\n\x0d\n  if (typeof streamBase.onread === 'function')\x0d\n    throw new ERR_INVALID_STATE('StreamBase already has a consumer');\x0d\n\x0d\n  if (typeof ondone !== 'function')\x0d\n    throw new ERR_INVALID_ARG_TYPE('options.ondone'\x2C 'Function'\x2C ondone);\x0d\n\x0d\n  let controller;\x0d\n\x0d\n  streamBase.onread = (arrayBuffer) => {\x0d\n    const nread = streamBaseState[kReadBytesOrError];\x0d\n\x0d\n    if (nread === 0)\x0d\n      return;\x0d\n\x0d\n    try {\x0d\n      if (nread === UV_EOF) {\x0d\n        controller.close();\x0d\n        streamBase.readStop();\x0d\n        try {\x0d\n          ondone();\x0d\n        } catch (error) {\x0d\n          controller.error(error);\x0d\n        }\x0d\n        return;\x0d\n      }\x0d\n\x0d\n      controller.enqueue(arrayBuffer);\x0d\n\x0d\n      if (controller.desiredSize <= 0)\x0d\n        streamBase.readStop();\x0d\n    } catch (error) {\x0d\n      controller.error(error);\x0d\n      streamBase.readStop();\x0d\n    }\x0d\n  };\x0d\n\x0d\n  return new ReadableStream({\x0d\n    start(c) { controller = c; }\x2C\x0d\n\x0d\n    pull() {\x0d\n      streamBase.readStart();\x0d\n    }\x2C\x0d\n\x0d\n    cancel() {\x0d\n      const promise = createDeferredPromise();\x0d\n      try {\x0d\n        ondone();\x0d\n      } catch (error) {\x0d\n        promise.reject(error);\x0d\n        return promise.promise;\x0d\n      }\x0d\n      const req = new ShutdownWrap();\x0d\n      req.oncomplete = () => promise.resolve();\x0d\n      const err = streamBase.shutdown(req);\x0d\n      if (err === 1)\x0d\n        promise.resolve();\x0d\n      return promise.promise;\x0d\n    }\x2C\x0d\n  }\x2C strategy);\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  newWritableStreamFromStreamWritable\x2C\x0d\n  newReadableStreamFromStreamReadable\x2C\x0d\n  newStreamWritableFromWritableStream\x2C\x0d\n  newStreamReadableFromReadableStream\x2C\x0d\n  newReadableWritablePairFromDuplex\x2C\x0d\n  newStreamDuplexFromReadableWritablePair\x2C\x0d\n  newWritableStreamFromStreamBase\x2C\x0d\n  newReadableStreamFromStreamBase\x2C\x0d\n};\x0d\n
code-source-info,0x109c10c6f1e,117,0,24820,C0O0C4O24820,,
code-creation,Function,10,205586,0x109c10c781e,541, node:internal/webstreams/adapters:1:1,0x109c10c6e98,~
code-source-info,0x109c10c781e,117,0,24820,C0O0C162O28C168O50C174O65C180O90C186O118C192O137C198O223C201O223C206O181C212O200C218O326C221O326C226O284C232O303C238O414C241O414C246O387C252O529C255O529C260O478C266O491C272O504C278O515C284O650C287O650C292O562C298O578C304O593C310O613C316O628C322O712C325O712C330O699C336O911C339O911C344O745C355O778C361O805C367O833C373O857C379O894C385O981C388O981C393O953C399O1062C402O1062C407O1021C413O1041C419O1206C422O1206C427O1108C433O1122C439O1139C445O1161C451O1184C457O1258C460O1258C464O1258C466O1323C469O1323C474O1312C480O24482C487O24504C493O24544C499O24584C505O24624C511O24664C517O24702C523O24746C529O24782C535O24497C540O24819,,
code-creation,Eval,10,207114,0x109c10cd016,5, node:internal/webstreams/readablestream:1:1,0x109c10cc250,~
script-source,118,node:internal/webstreams/readablestream,'use strict';\x0d\n\x0d\n/* eslint-disable no-use-before-define */\x0d\n\x0d\nconst {\x0d\n  ArrayBuffer\x2C\x0d\n  ArrayBufferPrototypeSlice\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeShift\x2C\x0d\n  DataViewCtor\x2C\x0d\n  FunctionPrototypeBind\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  MathMin\x2C\x0d\n  NumberIsInteger\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  Promise\x2C\x0d\n  PromisePrototypeCatch\x2C\x0d\n  PromisePrototypeThen\x2C\x0d\n  PromiseResolve\x2C\x0d\n  PromiseReject\x2C\x0d\n  PromiseAll\x2C\x0d\n  ReflectConstruct\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolAsyncIterator\x2C\x0d\n  SymbolToStringTag\x2C\x0d\n  Uint8Array\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_STATE\x2C\x0d\n    ERR_INVALID_THIS\x2C\x0d\n  }\x2C\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  DOMException\x2C\x0d\n} = internalBinding('messaging');\x0d\n\x0d\nconst {\x0d\n  isArrayBufferView\x2C\x0d\n  isDataView\x2C\x0d\n} = require('internal/util/types');\x0d\n\x0d\nconst {\x0d\n  createDeferredPromise\x2C\x0d\n  customInspectSymbol: kInspect\x2C\x0d\n} = require('internal/util');\x0d\n\x0d\nconst {\x0d\n  serialize\x2C\x0d\n  deserialize\x2C\x0d\n} = require('v8');\x0d\n\x0d\nconst {\x0d\n  validateObject\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst {\x0d\n  kAborted\x2C\x0d\n} = require('internal/abort_controller');\x0d\n\x0d\nconst {\x0d\n  MessageChannel\x2C\x0d\n} = require('internal/worker/io');\x0d\n\x0d\nconst {\x0d\n  kDeserialize\x2C\x0d\n  kTransfer\x2C\x0d\n  kTransferList\x2C\x0d\n  makeTransferable\x2C\x0d\n} = require('internal/worker/js_transferable');\x0d\n\x0d\nconst {\x0d\n  queueMicrotask\x2C\x0d\n} = require('internal/process/task_queues');\x0d\n\x0d\nconst {\x0d\n  kIsDisturbed\x2C\x0d\n  kIsErrored\x2C\x0d\n  kIsReadable\x2C\x0d\n} = require('internal/streams/utils');\x0d\n\x0d\nconst {\x0d\n  ArrayBufferViewGetBuffer\x2C\x0d\n  ArrayBufferViewGetByteLength\x2C\x0d\n  ArrayBufferViewGetByteOffset\x2C\x0d\n  ArrayBufferGetByteLength\x2C\x0d\n  AsyncIterator\x2C\x0d\n  copyArrayBuffer\x2C\x0d\n  customInspect\x2C\x0d\n  dequeueValue\x2C\x0d\n  ensureIsPromise\x2C\x0d\n  enqueueValueWithSize\x2C\x0d\n  extractHighWaterMark\x2C\x0d\n  extractSizeAlgorithm\x2C\x0d\n  lazyTransfer\x2C\x0d\n  isBrandCheck\x2C\x0d\n  resetQueue\x2C\x0d\n  setPromiseHandled\x2C\x0d\n  transferArrayBuffer\x2C\x0d\n  nonOpCancel\x2C\x0d\n  nonOpPull\x2C\x0d\n  nonOpStart\x2C\x0d\n  kType\x2C\x0d\n  kState\x2C\x0d\n  kEnumerableProperty\x2C\x0d\n} = require('internal/webstreams/util');\x0d\n\x0d\nconst {\x0d\n  WritableStreamDefaultWriter\x2C\x0d\n\x0d\n  isWritableStream\x2C\x0d\n  isWritableStreamLocked\x2C\x0d\n  isWritableStreamDefaultController\x2C\x0d\n  isWritableStreamDefaultWriter\x2C\x0d\n\x0d\n  writableStreamAbort\x2C\x0d\n  writableStreamCloseQueuedOrInFlight\x2C\x0d\n  writableStreamDefaultWriterCloseWithErrorPropagation\x2C\x0d\n  writableStreamDefaultWriterRelease\x2C\x0d\n  writableStreamDefaultWriterWrite\x2C\x0d\n} = require('internal/webstreams/writablestream');\x0d\n\x0d\nconst assert = require('internal/assert');\x0d\n\x0d\nconst kCancel = Symbol('kCancel');\x0d\nconst kClose = Symbol('kClose');\x0d\nconst kChunk = Symbol('kChunk');\x0d\nconst kError = Symbol('kError');\x0d\nconst kPull = Symbol('kPull');\x0d\n\x0d\n/**\x0d\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\x0d\n * @typedef {import('./queuingstrategies').QueuingStrategy} QueuingStrategy\x0d\n * @typedef {import('./queuingstrategies').QueuingStrategySize\x0d\n * } QueuingStrategySize\x0d\n * @typedef {import('./writablestream').WritableStream} WritableStream\x0d\n */\x0d\n\x0d\n/**\x0d\n * @typedef {ReadableStreamDefaultController | ReadableByteStreamController\x0d\n * } ReadableStreamController\x0d\n */\x0d\n\x0d\n/**\x0d\n * @typedef {ReadableStreamDefaultReader | ReadableStreamBYOBReader\x0d\n * } ReadableStreamReader\x0d\n */\x0d\n\x0d\n/**\x0d\n * @callback UnderlyingSourceStartCallback\x0d\n * @param {ReadableStreamController} controller\x0d\n * @returns { any | Promise<void> }\x0d\n */\x0d\n\x0d\n/**\x0d\n * @callback UnderlyingSourcePullCallback\x0d\n * @param {ReadableStreamController} controller\x0d\n * @returns { Promise<void> }\x0d\n */\x0d\n\x0d\n/**\x0d\n * @callback UnderlyingSourceCancelCallback\x0d\n * @param {any} reason\x0d\n * @returns { Promise<void> }\x0d\n */\x0d\n\x0d\n/**\x0d\n * @typedef {{\x0d\n *   readable: ReadableStream\x2C\x0d\n *   writable: WritableStream\x2C\x0d\n * }} ReadableWritablePair\x0d\n */\x0d\n\x0d\n/**\x0d\n * @typedef {{\x0d\n *   preventClose? : boolean\x2C\x0d\n *   preventAbort? : boolean\x2C\x0d\n *   preventCancel? : boolean\x2C\x0d\n *   signal? : AbortSignal\x2C\x0d\n * }} StreamPipeOptions\x0d\n */\x0d\n\x0d\n/**\x0d\n * @typedef {{\x0d\n *   start? : UnderlyingSourceStartCallback\x2C\x0d\n *   pull? : UnderlyingSourcePullCallback\x2C\x0d\n *   cancel? : UnderlyingSourceCancelCallback\x2C\x0d\n *   type? : "bytes"\x2C\x0d\n *   autoAllocateChunkSize? : number\x0d\n * }} UnderlyingSource\x0d\n */\x0d\n\x0d\nclass ReadableStream {\x0d\n  [kType] = 'ReadableStream';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  /**\x0d\n   * @param {UnderlyingSource} [source]\x0d\n   * @param {QueuingStrategy} [strategy]\x0d\n   */\x0d\n  constructor(source = {}\x2C strategy = {}) {\x0d\n    if (source === null)\x0d\n      throw new ERR_INVALID_ARG_VALUE('source'\x2C 'Object'\x2C source);\x0d\n    this[kState] = {\x0d\n      disturbed: false\x2C\x0d\n      state: 'readable'\x2C\x0d\n      storedError: undefined\x2C\x0d\n      stream: undefined\x2C\x0d\n      transfer: {\x0d\n        writable: undefined\x2C\x0d\n        port1: undefined\x2C\x0d\n        port2: undefined\x2C\x0d\n        promise: undefined\x2C\x0d\n      }\x0d\n    };\x0d\n\x0d\n    // The spec requires handling of the strategy first\x0d\n    // here. Specifically\x2C if getting the size and\x0d\n    // highWaterMark from the strategy fail\x2C that has\x0d\n    // to trigger a throw before getting the details\x0d\n    // from the source. So be sure to keep these in\x0d\n    // this order.\x0d\n    const size = strategy?.size;\x0d\n    const highWaterMark = strategy?.highWaterMark;\x0d\n    const type = source.type;\x0d\n\x0d\n    if (`${type}` === 'bytes') {\x0d\n      if (size !== undefined)\x0d\n        throw new ERR_INVALID_ARG_VALUE.RangeError('strategy.size'\x2C size);\x0d\n      setupReadableByteStreamControllerFromSource(\x0d\n        this\x2C\x0d\n        source\x2C\x0d\n        extractHighWaterMark(highWaterMark\x2C 0));\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    if (type !== undefined)\x0d\n      throw new ERR_INVALID_ARG_VALUE('source.type'\x2C type);\x0d\n    setupReadableStreamDefaultControllerFromSource(\x0d\n      this\x2C\x0d\n      source\x2C\x0d\n      extractHighWaterMark(highWaterMark\x2C 1)\x2C\x0d\n      extractSizeAlgorithm(size));\x0d\n\x0d\n    // eslint-disable-next-line no-constructor-return\x0d\n    return makeTransferable(this);\x0d\n  }\x0d\n\x0d\n  get [kIsDisturbed]() {\x0d\n    return this[kState].disturbed;\x0d\n  }\x0d\n\x0d\n  get [kIsErrored]() {\x0d\n    return this[kState].state === 'errored';\x0d\n  }\x0d\n\x0d\n  get [kIsReadable]() {\x0d\n    return this[kState].state === 'readable';\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {boolean}\x0d\n   */\x0d\n  get locked() {\x0d\n    if (!isReadableStream(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStream');\x0d\n    return isReadableStreamLocked(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} [reason]\x0d\n   * @returns { Promise<void> }\x0d\n   */\x0d\n  cancel(reason = undefined) {\x0d\n    if (!isReadableStream(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStream'));\x0d\n    if (isReadableStreamLocked(this)) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError('ReadableStream is locked'));\x0d\n    }\x0d\n    return readableStreamCancel(this\x2C reason);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {{\x0d\n   *   mode? : "byob"\x0d\n   * }} [options]\x0d\n   * @returns {ReadableStreamReader}\x0d\n   */\x0d\n  getReader(options = {}) {\x0d\n    if (!isReadableStream(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStream');\x0d\n    validateObject(options\x2C 'options'\x2C { nullable: true\x2C allowFunction: true });\x0d\n    const mode = options?.mode;\x0d\n\x0d\n    if (mode === undefined)\x0d\n      return new ReadableStreamDefaultReader(this);\x0d\n\x0d\n    if (`${mode}` !== 'byob')\x0d\n      throw new ERR_INVALID_ARG_VALUE('options.mode'\x2C mode);\x0d\n    return new ReadableStreamBYOBReader(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {ReadableWritablePair} transform\x0d\n   * @param {StreamPipeOptions} [options]\x0d\n   * @returns {ReadableStream}\x0d\n   */\x0d\n  pipeThrough(transform\x2C options = {}) {\x0d\n    if (!isReadableStream(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStream');\x0d\n    const readable = transform?.readable;\x0d\n    if (!isReadableStream(readable)) {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'transform.readable'\x2C\x0d\n        'ReadableStream'\x2C\x0d\n        readable);\x0d\n    }\x0d\n    const writable = transform?.writable;\x0d\n    if (!isWritableStream(writable)) {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'transform.writable'\x2C\x0d\n        'WritableStream'\x2C\x0d\n        writable);\x0d\n    }\x0d\n\x0d\n    // The web platform tests require that these be handled one at a\x0d\n    // time and in a specific order. options can be null or undefined.\x0d\n    const preventAbort = options?.preventAbort;\x0d\n    const preventCancel = options?.preventCancel;\x0d\n    const preventClose = options?.preventClose;\x0d\n    const signal = options?.signal;\x0d\n\x0d\n    if (signal !== undefined && signal?.[kAborted] === undefined)\x0d\n      throw new ERR_INVALID_ARG_TYPE('options.signal'\x2C 'AbortSignal'\x2C signal);\x0d\n\x0d\n    if (isReadableStreamLocked(this))\x0d\n      throw new ERR_INVALID_STATE.TypeError('The ReadableStream is locked');\x0d\n    if (isWritableStreamLocked(writable))\x0d\n      throw new ERR_INVALID_STATE.TypeError('The WritableStream is locked');\x0d\n\x0d\n    const promise = readableStreamPipeTo(\x0d\n      this\x2C\x0d\n      writable\x2C\x0d\n      !!preventClose\x2C\x0d\n      !!preventAbort\x2C\x0d\n      !!preventCancel\x2C\x0d\n      signal);\x0d\n    setPromiseHandled(promise);\x0d\n\x0d\n    return readable;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {WritableStream} destination\x0d\n   * @param {StreamPipeOptions} [options]\x0d\n   * @returns {Promise<void>}\x0d\n   */\x0d\n  pipeTo(destination\x2C options = {}) {\x0d\n    try {\x0d\n      if (!isReadableStream(this))\x0d\n        throw new ERR_INVALID_THIS('ReadableStream');\x0d\n      if (!isWritableStream(destination)) {\x0d\n        throw new ERR_INVALID_ARG_TYPE(\x0d\n          'transform.writable'\x2C\x0d\n          'WritableStream'\x2C\x0d\n          destination);\x0d\n      }\x0d\n\x0d\n      const preventAbort = options?.preventAbort;\x0d\n      const preventCancel = options?.preventCancel;\x0d\n      const preventClose = options?.preventClose;\x0d\n      const signal = options?.signal;\x0d\n\x0d\n      if (signal !== undefined && signal?.[kAborted] === undefined)\x0d\n        throw new ERR_INVALID_ARG_TYPE('options.signal'\x2C 'AbortSignal'\x2C signal);\x0d\n\x0d\n      if (isReadableStreamLocked(this))\x0d\n        throw new ERR_INVALID_STATE.TypeError('The ReadableStream is locked');\x0d\n      if (isWritableStreamLocked(destination))\x0d\n        throw new ERR_INVALID_STATE.TypeError('The WritableStream is locked');\x0d\n\x0d\n      return readableStreamPipeTo(\x0d\n        this\x2C\x0d\n        destination\x2C\x0d\n        !!preventClose\x2C\x0d\n        !!preventAbort\x2C\x0d\n        !!preventCancel\x2C\x0d\n        signal);\x0d\n    } catch (error) {\x0d\n      return PromiseReject(error);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @returns {ReadableStream[]}\x0d\n   */\x0d\n  tee() {\x0d\n    if (!isReadableStream(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStream');\x0d\n    return readableStreamTee(this\x2C false);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {{\x0d\n   *   preventCancel? : boolean\x2C\x0d\n   * }} [options]\x0d\n   * @returns {AsyncIterable}\x0d\n   */\x0d\n  values(options = {}) {\x0d\n    if (!isReadableStream(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStream');\x0d\n    validateObject(options\x2C 'options');\x0d\n    const {\x0d\n      preventCancel = false\x2C\x0d\n    } = options;\x0d\n\x0d\n    const reader = new ReadableStreamDefaultReader(this);\x0d\n    let done = false;\x0d\n    let started = false;\x0d\n    let current;\x0d\n\x0d\n    // The nextSteps function is not an async function in order\x0d\n    // to make it more efficient. Because nextSteps explicitly\x0d\n    // creates a Promise and returns it in the common case\x2C\x0d\n    // making it an async function just causes two additional\x0d\n    // unnecessary Promise allocations to occur\x2C which just add\x0d\n    // cost.\x0d\n    function nextSteps() {\x0d\n      if (done)\x0d\n        return PromiseResolve({ done: true\x2C value: undefined });\x0d\n\x0d\n      if (reader[kState].stream === undefined) {\x0d\n        return PromiseReject(\x0d\n          new ERR_INVALID_STATE.TypeError(\x0d\n            'The reader is not bound to a ReadableStream'));\x0d\n      }\x0d\n      const promise = createDeferredPromise();\x0d\n\x0d\n      readableStreamDefaultReaderRead(reader\x2C {\x0d\n        [kChunk](chunk) {\x0d\n          current = undefined;\x0d\n          promise.resolve({ value: chunk\x2C done: false });\x0d\n        }\x2C\x0d\n        [kClose]() {\x0d\n          current = undefined;\x0d\n          done = true;\x0d\n          readableStreamReaderGenericRelease(reader);\x0d\n          promise.resolve({ done: true\x2C value: undefined });\x0d\n        }\x2C\x0d\n        [kError](error) {\x0d\n          current = undefined;\x0d\n          done = true;\x0d\n          readableStreamReaderGenericRelease(reader);\x0d\n          promise.reject(error);\x0d\n        }\x0d\n      });\x0d\n      return promise.promise;\x0d\n    }\x0d\n\x0d\n    async function returnSteps(value) {\x0d\n      if (done)\x0d\n        return { done: true\x2C value };\x0d\n      done = true;\x0d\n\x0d\n      if (reader[kState].stream === undefined) {\x0d\n        throw new ERR_INVALID_STATE.TypeError(\x0d\n          'The reader is not bound to a ReadableStream');\x0d\n      }\x0d\n      assert(!reader[kState].readRequests.length);\x0d\n      if (!preventCancel) {\x0d\n        const result = readableStreamReaderGenericCancel(reader\x2C value);\x0d\n        readableStreamReaderGenericRelease(reader);\x0d\n        await result;\x0d\n        return { done: true\x2C value };\x0d\n      }\x0d\n\x0d\n      readableStreamReaderGenericRelease(reader);\x0d\n      return { done: true\x2C value };\x0d\n    }\x0d\n\x0d\n    // TODO(@jasnell): Explore whether an async generator\x0d\n    // can be used here instead of a custom iterator object.\x0d\n    return ObjectSetPrototypeOf({\x0d\n      // Changing either of these functions (next or return)\x0d\n      // to async functions causes a failure in the streams\x0d\n      // Web Platform Tests that check for use of a modified\x0d\n      // Promise.prototype.then. Since the await keyword\x0d\n      // uses Promise.prototype.then\x2C it is open to prototype\x0d\n      // pollution\x2C which causes the test to fail. The other\x0d\n      // await uses here do not trigger that failure because\x0d\n      // the test that fails does not trigger those code paths.\x0d\n      next() {\x0d\n        // If this is the first read\x2C delay by one microtask\x0d\n        // to ensure that the controller has had an opportunity\x0d\n        // to properly start and perform the initial pull.\x0d\n        // TODO(@jasnell): The spec doesn't call this out so\x0d\n        // need to investigate if it's a bug in our impl or\x0d\n        // the spec.\x0d\n        if (!started) {\x0d\n          current = PromiseResolve();\x0d\n          started = true;\x0d\n        }\x0d\n        current = current !== undefined ?\x0d\n          PromisePrototypeThen(current\x2C nextSteps\x2C nextSteps) :\x0d\n          nextSteps();\x0d\n        return current;\x0d\n      }\x2C\x0d\n\x0d\n      return(error) {\x0d\n        return current ?\x0d\n          PromisePrototypeThen(\x0d\n            current\x2C\x0d\n            () => returnSteps(error)\x2C\x0d\n            () => returnSteps(error)) :\x0d\n          returnSteps(error);\x0d\n      }\x2C\x0d\n\x0d\n      [SymbolAsyncIterator]() { return this; }\x0d\n    }\x2C AsyncIterator);\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\x0d\n      locked: this.locked\x2C\x0d\n      state: this[kState].state\x2C\x0d\n      supportsBYOB:\x0d\n        this[kState].controller instanceof ReadableByteStreamController\x2C\x0d\n    });\x0d\n  }\x0d\n\x0d\n  [kTransfer]() {\x0d\n    if (!isReadableStream(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStream');\x0d\n    if (this.locked) {\x0d\n      this[kState].transfer.port1?.close();\x0d\n      this[kState].transfer.port1 = undefined;\x0d\n      this[kState].transfer.port2 = undefined;\x0d\n      throw new DOMException(\x0d\n        'Cannot transfer a locked ReadableStream'\x2C\x0d\n        'DataCloneError');\x0d\n    }\x0d\n\x0d\n    const {\x0d\n      writable\x2C\x0d\n      promise\x2C\x0d\n    } = lazyTransfer().newCrossRealmWritableSink(\x0d\n      this\x2C\x0d\n      this[kState].transfer.port1);\x0d\n\x0d\n    this[kState].transfer.writable = writable;\x0d\n    this[kState].transfer.promise = promise;\x0d\n\x0d\n    return {\x0d\n      data: { port: this[kState].transfer.port2 }\x2C\x0d\n      deserializeInfo:\x0d\n        'internal/webstreams/readablestream:TransferredReadableStream'\x0d\n    };\x0d\n  }\x0d\n\x0d\n  [kTransferList]() {\x0d\n    const { port1\x2C port2 } = new MessageChannel();\x0d\n    this[kState].transfer.port1 = port1;\x0d\n    this[kState].transfer.port2 = port2;\x0d\n    return [ port2 ];\x0d\n  }\x0d\n\x0d\n  [kDeserialize]({ port }) {\x0d\n    const transfer = lazyTransfer();\x0d\n    setupReadableStreamDefaultControllerFromSource(\x0d\n      this\x2C\x0d\n      new transfer.CrossRealmTransformReadableSource(port)\x2C\x0d\n      0\x2C () => 1);\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(ReadableStream.prototype\x2C {\x0d\n  [SymbolAsyncIterator]: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x2C\x0d\n    writable: true\x2C\x0d\n    value: ReadableStream.prototype.values\x2C\x0d\n  }\x2C\x0d\n  locked: kEnumerableProperty\x2C\x0d\n  cancel: kEnumerableProperty\x2C\x0d\n  getReader: kEnumerableProperty\x2C\x0d\n  pipeThrough: kEnumerableProperty\x2C\x0d\n  pipeTo: kEnumerableProperty\x2C\x0d\n  tee: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nfunction TransferredReadableStream() {\x0d\n  return makeTransferable(ReflectConstruct(\x0d\n    function() {\x0d\n      this[kType] = 'ReadableStream';\x0d\n      this[kState] = {\x0d\n        disturbed: false\x2C\x0d\n        state: 'readable'\x2C\x0d\n        storedError: undefined\x2C\x0d\n        stream: undefined\x2C\x0d\n        transfer: {\x0d\n          writable: undefined\x2C\x0d\n          port: undefined\x2C\x0d\n          promise: undefined\x2C\x0d\n        }\x0d\n      };\x0d\n    }\x2C\x0d\n    []\x2C ReadableStream));\x0d\n}\x0d\nTransferredReadableStream.prototype[kDeserialize] = () => {};\x0d\n\x0d\nclass ReadableStreamBYOBRequest {\x0d\n  [kType] = 'ReadableStreamBYOBRequest';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  constructor() {\x0d\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {ArrayBufferView}\x0d\n   */\x0d\n  get view() {\x0d\n    if (!isReadableStreamBYOBRequest(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\x0d\n    return this[kState].view;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {number} bytesWritten\x0d\n   */\x0d\n  respond(bytesWritten) {\x0d\n    if (!isReadableStreamBYOBRequest(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\x0d\n    const {\x0d\n      view\x2C\x0d\n      controller\x2C\x0d\n    } = this[kState];\x0d\n    if (controller === undefined) {\x0d\n      throw new ERR_INVALID_STATE.TypeError(\x0d\n        'This BYOB request has been invalidated');\x0d\n    }\x0d\n\x0d\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\x0d\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\x0d\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\x0d\n\x0d\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\x0d\n      throw new ERR_INVALID_STATE.TypeError(\x0d\n        'View ArrayBuffer is zero-length or detached');\x0d\n    }\x0d\n\x0d\n    readableByteStreamControllerRespond(controller\x2C bytesWritten);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {ArrayBufferView} view\x0d\n   */\x0d\n  respondWithNewView(view) {\x0d\n    if (!isReadableStreamBYOBRequest(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBRequest');\x0d\n    const {\x0d\n      controller\x2C\x0d\n    } = this[kState];\x0d\n\x0d\n    if (controller === undefined) {\x0d\n      throw new ERR_INVALID_STATE.TypeError(\x0d\n        'This BYOB request has been invalidated');\x0d\n    }\x0d\n\x0d\n    readableByteStreamControllerRespondWithNewView(controller\x2C view);\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\x0d\n      view: this.view\x2C\x0d\n      controller: this[kState].controller\x2C\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(ReadableStreamBYOBRequest.prototype\x2C {\x0d\n  view: kEnumerableProperty\x2C\x0d\n  respond: kEnumerableProperty\x2C\x0d\n  respondWithNewView: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nfunction createReadableStreamBYOBRequest(controller\x2C view) {\x0d\n  return ReflectConstruct(\x0d\n    function() {\x0d\n      this[kType] = 'ReadableStreamBYOBRequest';\x0d\n      this[kState] = {\x0d\n        controller\x2C\x0d\n        view\x2C\x0d\n      };\x0d\n    }\x2C\x0d\n    []\x2C\x0d\n    ReadableStreamBYOBRequest\x0d\n  );\x0d\n}\x0d\n\x0d\nclass DefaultReadRequest {\x0d\n  constructor() {\x0d\n    this[kState] = createDeferredPromise();\x0d\n  }\x0d\n\x0d\n  [kChunk](value) {\x0d\n    this[kState].resolve?.({ value\x2C done: false });\x0d\n  }\x0d\n\x0d\n  [kClose]() {\x0d\n    this[kState].resolve?.({ value: undefined\x2C done: true });\x0d\n  }\x0d\n\x0d\n  [kError](error) {\x0d\n    this[kState].reject?.(error);\x0d\n  }\x0d\n\x0d\n  get promise() { return this[kState].promise; }\x0d\n}\x0d\n\x0d\nclass ReadIntoRequest {\x0d\n  constructor() {\x0d\n    this[kState] = createDeferredPromise();\x0d\n  }\x0d\n\x0d\n  [kChunk](value) {\x0d\n    this[kState].resolve?.({ value\x2C done: false });\x0d\n  }\x0d\n\x0d\n  [kClose](value) {\x0d\n    this[kState].resolve?.({ value\x2C done: true });\x0d\n  }\x0d\n\x0d\n  [kError](error) {\x0d\n    this[kState].reject?.(error);\x0d\n  }\x0d\n\x0d\n  get promise() { return this[kState].promise; }\x0d\n}\x0d\n\x0d\nclass ReadableStreamDefaultReader {\x0d\n  [kType] = 'ReadableStreamDefaultReader';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  /**\x0d\n   * @param {ReadableStream} stream\x0d\n   */\x0d\n  constructor(stream) {\x0d\n    if (!isReadableStream(stream))\x0d\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'ReadableStream'\x2C stream);\x0d\n    this[kState] = {\x0d\n      readRequests: []\x2C\x0d\n      stream: undefined\x2C\x0d\n      close: {\x0d\n        promise: undefined\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      }\x2C\x0d\n    };\x0d\n    setupReadableStreamDefaultReader(this\x2C stream);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @returns {Promise<{\x0d\n   *   value : any\x2C\x0d\n   *   done : boolean\x0d\n   * }>}\x0d\n   */\x0d\n  read() {\x0d\n    if (!isReadableStreamDefaultReader(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\x0d\n    if (this[kState].stream === undefined) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError(\x0d\n          'The reader is not attached to a stream'));\x0d\n    }\x0d\n    const readRequest = new DefaultReadRequest();\x0d\n    readableStreamDefaultReaderRead(this\x2C readRequest);\x0d\n    return readRequest.promise;\x0d\n  }\x0d\n\x0d\n  releaseLock() {\x0d\n    if (!isReadableStreamDefaultReader(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStreamDefaultReader');\x0d\n    if (this[kState].stream === undefined)\x0d\n      return;\x0d\n    if (this[kState].readRequests.length) {\x0d\n      throw new ERR_INVALID_STATE.TypeError(\x0d\n        'Cannot release with pending read requests');\x0d\n    }\x0d\n    readableStreamReaderGenericRelease(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {Promise<void>}\x0d\n   */\x0d\n  get closed() {\x0d\n    if (!isReadableStreamDefaultReader(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\x0d\n    return this[kState].close.promise;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} reason\x0d\n   * @returns {Promise<void>}\x0d\n   */\x0d\n  cancel(reason = undefined) {\x0d\n    if (!isReadableStreamDefaultReader(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamDefaultReader'));\x0d\n    if (this[kState].stream === undefined) {\x0d\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\x0d\n        'The reader is not attached to a stream'));\x0d\n    }\x0d\n    return readableStreamReaderGenericCancel(this\x2C reason);\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\x0d\n      stream: this[kState].stream\x2C\x0d\n      readRequests: this[kState].readRequests.length\x2C\x0d\n      close: this[kState].close.promise\x2C\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(ReadableStreamDefaultReader.prototype\x2C {\x0d\n  closed: kEnumerableProperty\x2C\x0d\n  read: kEnumerableProperty\x2C\x0d\n  releaseLock: kEnumerableProperty\x2C\x0d\n  cancel: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nclass ReadableStreamBYOBReader {\x0d\n  [kType] = 'ReadableStreamBYOBReader';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  /**\x0d\n   * @param {ReadableStream} stream\x0d\n   */\x0d\n  constructor(stream) {\x0d\n    if (!isReadableStream(stream))\x0d\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'ReadableStream'\x2C stream);\x0d\n    this[kState] = {\x0d\n      stream: undefined\x2C\x0d\n      requestIntoRequests: []\x2C\x0d\n      close: {\x0d\n        promise: undefined\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      }\x2C\x0d\n    };\x0d\n    setupReadableStreamBYOBReader(this\x2C stream);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {ArrayBufferView} view\x0d\n   * @returns {Promise<{\x0d\n   *   view : ArrayBufferView\x2C\x0d\n   *   done : boolean\x2C\x0d\n   * }>}\x0d\n   */\x0d\n  read(view) {\x0d\n    if (!isReadableStreamBYOBReader(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\x0d\n    if (!isArrayBufferView(view)) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_ARG_TYPE(\x0d\n          'view'\x2C\x0d\n          [\x0d\n            'Buffer'\x2C\x0d\n            'TypedArray'\x2C\x0d\n            'DataView'\x2C\x0d\n          ]\x2C\x0d\n          view));\x0d\n    }\x0d\n    const viewByteLength = ArrayBufferViewGetByteLength(view);\x0d\n    const viewBuffer = ArrayBufferViewGetBuffer(view);\x0d\n    const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\x0d\n\x0d\n    if (viewByteLength === 0 || viewBufferByteLength === 0) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError(\x0d\n          'View ArrayBuffer is zero-length or detached'));\x0d\n    }\x0d\n    // Supposed to assert here that the view's buffer is not\x0d\n    // detached\x2C but there's no API available to use to check that.\x0d\n    if (this[kState].stream === undefined) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError(\x0d\n          'The reader is not attached to a stream'));\x0d\n    }\x0d\n    const readIntoRequest = new ReadIntoRequest();\x0d\n    readableStreamBYOBReaderRead(this\x2C view\x2C readIntoRequest);\x0d\n    return readIntoRequest.promise;\x0d\n  }\x0d\n\x0d\n  releaseLock() {\x0d\n    if (!isReadableStreamBYOBReader(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableStreamBYOBReader');\x0d\n    if (this[kState].stream === undefined)\x0d\n      return;\x0d\n    if (this[kState].readIntoRequests.length) {\x0d\n      throw new ERR_INVALID_STATE.TypeError(\x0d\n        'Cannot release with pending read requests');\x0d\n    }\x0d\n    readableStreamReaderGenericRelease(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {Promise<void>}\x0d\n   */\x0d\n  get closed() {\x0d\n    if (!isReadableStreamBYOBReader(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\x0d\n    return this[kState].close.promise;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} reason\x0d\n   * @returns {Promise<void>}\x0d\n   */\x0d\n  cancel(reason = undefined) {\x0d\n    if (!isReadableStreamBYOBReader(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('ReadableStreamBYOBReader'));\x0d\n    if (this[kState].stream === undefined) {\x0d\n      return PromiseReject(new ERR_INVALID_STATE.TypeError(\x0d\n        'The reader is not attached to a stream'));\x0d\n    }\x0d\n    return readableStreamReaderGenericCancel(this\x2C reason);\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\x0d\n      stream: this[kState].stream\x2C\x0d\n      requestIntoRequests: this[kState].requestIntoRequests.length\x2C\x0d\n      close: this[kState].close.promise\x2C\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(ReadableStreamBYOBReader.prototype\x2C {\x0d\n  closed: kEnumerableProperty\x2C\x0d\n  read: kEnumerableProperty\x2C\x0d\n  releaseLock: kEnumerableProperty\x2C\x0d\n  cancel: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nclass ReadableStreamDefaultController {\x0d\n  [kType] = 'ReadableStreamDefaultController';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  constructor() {\x0d\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {number}\x0d\n   */\x0d\n  get desiredSize() {\x0d\n    return readableStreamDefaultControllerGetDesiredSize(this);\x0d\n  }\x0d\n\x0d\n  close() {\x0d\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\x0d\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\x0d\n    readableStreamDefaultControllerClose(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} chunk\x0d\n   */\x0d\n  enqueue(chunk = undefined) {\x0d\n    if (!readableStreamDefaultControllerCanCloseOrEnqueue(this))\x0d\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\x0d\n    readableStreamDefaultControllerEnqueue(this\x2C chunk);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} error\x0d\n   */\x0d\n  error(error = undefined) {\x0d\n    readableStreamDefaultControllerError(this\x2C error);\x0d\n  }\x0d\n\x0d\n  [kCancel](reason) {\x0d\n    return readableStreamDefaultControllerCancelSteps(this\x2C reason);\x0d\n  }\x0d\n\x0d\n  [kPull](readRequest) {\x0d\n    readableStreamDefaultControllerPullSteps(this\x2C readRequest);\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C { });\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(ReadableStreamDefaultController.prototype\x2C {\x0d\n  desiredSize: kEnumerableProperty\x2C\x0d\n  close: kEnumerableProperty\x2C\x0d\n  enqueue: kEnumerableProperty\x2C\x0d\n  error: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nfunction createReadableStreamDefaultController() {\x0d\n  return ReflectConstruct(\x0d\n    function() {\x0d\n      this[kType] = 'ReadableStreamDefaultController';\x0d\n      this[kState] = {};\x0d\n    }\x2C\x0d\n    []\x2C\x0d\n    ReadableStreamDefaultController\x2C\x0d\n  );\x0d\n}\x0d\n\x0d\nclass ReadableByteStreamController {\x0d\n  [kType] = 'ReadableByteStreamController';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  constructor() {\x0d\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {ReadableStreamBYOBRequest}\x0d\n   */\x0d\n  get byobRequest() {\x0d\n    if (!isReadableByteStreamController(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\x0d\n    if (this[kState].byobRequest === null &&\x0d\n        this[kState].pendingPullIntos.length) {\x0d\n      const {\x0d\n        buffer\x2C\x0d\n        byteOffset\x2C\x0d\n        bytesFilled\x2C\x0d\n        byteLength\x2C\x0d\n      } = this[kState].pendingPullIntos[0];\x0d\n      const view =\x0d\n        new Uint8Array(\x0d\n          buffer\x2C\x0d\n          byteOffset + bytesFilled\x2C\x0d\n          byteLength - bytesFilled);\x0d\n      this[kState].byobRequest = createReadableStreamBYOBRequest(this\x2C view);\x0d\n    }\x0d\n    return this[kState].byobRequest;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {number}\x0d\n   */\x0d\n  get desiredSize() {\x0d\n    if (!isReadableByteStreamController(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\x0d\n    return readableByteStreamControllerGetDesiredSize(this);\x0d\n  }\x0d\n\x0d\n  close() {\x0d\n    if (!isReadableByteStreamController(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\x0d\n    if (this[kState].closeRequested)\x0d\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\x0d\n    if (this[kState].stream[kState].state !== 'readable')\x0d\n      throw new ERR_INVALID_STATE.TypeError('ReadableStream is already closed');\x0d\n    readableByteStreamControllerClose(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {ArrayBufferView} chunk\x0d\n   */\x0d\n  enqueue(chunk) {\x0d\n    if (!isReadableByteStreamController(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\x0d\n    if (!isArrayBufferView(chunk)) {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'chunk'\x2C\x0d\n        [\x0d\n          'Buffer'\x2C\x0d\n          'TypedArray'\x2C\x0d\n          'DataView'\x2C\x0d\n        ]\x2C\x0d\n        chunk);\x0d\n    }\x0d\n    const chunkByteLength = ArrayBufferViewGetByteLength(chunk);\x0d\n    const chunkByteOffset = ArrayBufferViewGetByteOffset(chunk);\x0d\n    const chunkBuffer = ArrayBufferViewGetBuffer(chunk);\x0d\n    const chunkBufferByteLength = ArrayBufferGetByteLength(chunkBuffer);\x0d\n    if (chunkByteLength === 0 || chunkBufferByteLength === 0) {\x0d\n      throw new ERR_INVALID_STATE.TypeError(\x0d\n        'chunk ArrayBuffer is zero-length or detached');\x0d\n    }\x0d\n    if (this[kState].closeRequested)\x0d\n      throw new ERR_INVALID_STATE.TypeError('Controller is already closed');\x0d\n    if (this[kState].stream[kState].state !== 'readable')\x0d\n      throw new ERR_INVALID_STATE.TypeError('ReadableStream is already closed');\x0d\n    readableByteStreamControllerEnqueue(\x0d\n      this\x2C\x0d\n      chunkBuffer\x2C\x0d\n      chunkByteLength\x2C\x0d\n      chunkByteOffset);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} error\x0d\n   */\x0d\n  error(error = undefined) {\x0d\n    if (!isReadableByteStreamController(this))\x0d\n      throw new ERR_INVALID_THIS('ReadableByteStreamController');\x0d\n    readableByteStreamControllerError(this\x2C error);\x0d\n  }\x0d\n\x0d\n  [kCancel](reason) {\x0d\n    return readableByteStreamControllerCancelSteps(this\x2C reason);\x0d\n  }\x0d\n\x0d\n  [kPull](readRequest) {\x0d\n    readableByteStreamControllerPullSteps(this\x2C readRequest);\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C { });\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(ReadableByteStreamController.prototype\x2C {\x0d\n  byobRequest: kEnumerableProperty\x2C\x0d\n  desiredSize: kEnumerableProperty\x2C\x0d\n  close: kEnumerableProperty\x2C\x0d\n  enqueue: kEnumerableProperty\x2C\x0d\n  error: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nfunction createReadableByteStreamController() {\x0d\n  return ReflectConstruct(\x0d\n    function() {\x0d\n      this[kType] = 'ReadableByteStreamController';\x0d\n      this[kState] = {};\x0d\n    }\x2C\x0d\n    []\x2C\x0d\n    ReadableByteStreamController\x2C\x0d\n  );\x0d\n}\x0d\n\x0d\nfunction createTeeReadableStream(start\x2C pull\x2C cancel) {\x0d\n  return ReflectConstruct(\x0d\n    function() {\x0d\n      this[kType] = 'ReadableStream';\x0d\n      this[kState] = {\x0d\n        disturbed: false\x2C\x0d\n        state: 'readable'\x2C\x0d\n        storedError: undefined\x2C\x0d\n        stream: undefined\x2C\x0d\n        transfer: {\x0d\n          writable: undefined\x2C\x0d\n          port: undefined\x2C\x0d\n          promise: undefined\x2C\x0d\n        }\x0d\n      };\x0d\n      setupReadableStreamDefaultControllerFromSource(\x0d\n        this\x2C\x0d\n        ObjectCreate(null\x2C {\x0d\n          start: { value: start }\x2C\x0d\n          pull: { value: pull }\x2C\x0d\n          cancel: { value: cancel }\x0d\n        })\x2C\x0d\n        1\x2C\x0d\n        () => 1);\x0d\n      return makeTransferable(this);\x0d\n    }\x2C []\x2C ReadableStream\x2C\x0d\n  );\x0d\n}\x0d\n\x0d\nconst isReadableStream =\x0d\n  isBrandCheck('ReadableStream');\x0d\nconst isReadableByteStreamController =\x0d\n  isBrandCheck('ReadableByteStreamController');\x0d\nconst isReadableStreamBYOBRequest =\x0d\n  isBrandCheck('ReadableStreamBYOBRequest');\x0d\nconst isReadableStreamDefaultReader =\x0d\n  isBrandCheck('ReadableStreamDefaultReader');\x0d\nconst isReadableStreamBYOBReader =\x0d\n  isBrandCheck('ReadableStreamBYOBReader');\x0d\n\x0d\n// ---- ReadableStream Implementation\x0d\n\x0d\nfunction readableStreamPipeTo(\x0d\n  source\x2C\x0d\n  dest\x2C\x0d\n  preventClose\x2C\x0d\n  preventAbort\x2C\x0d\n  preventCancel\x2C\x0d\n  signal) {\x0d\n\x0d\n  let reader;\x0d\n  let writer;\x0d\n  // Both of these can throw synchronously. We want to capture\x0d\n  // the error and return a rejected promise instead.\x0d\n  try {\x0d\n    reader = new ReadableStreamDefaultReader(source);\x0d\n    writer = new WritableStreamDefaultWriter(dest);\x0d\n  } catch (error) {\x0d\n    return PromiseReject(error);\x0d\n  }\x0d\n\x0d\n  source[kState].disturbed = true;\x0d\n\x0d\n  let shuttingDown = false;\x0d\n\x0d\n  if (signal !== undefined && signal?.[kAborted] === undefined) {\x0d\n    return PromiseReject(\x0d\n      new ERR_INVALID_ARG_TYPE(\x0d\n        'options.signal'\x2C\x0d\n        'AbortSignal'\x2C\x0d\n        signal));\x0d\n  }\x0d\n\x0d\n  const promise = createDeferredPromise();\x0d\n\x0d\n  let currentWrite = PromiseResolve();\x0d\n\x0d\n  // The error here can be undefined. The rejected arg\x0d\n  // tells us that the promise must be rejected even\x0d\n  // when error is undefine.\x0d\n  function finalize(rejected\x2C error) {\x0d\n    writableStreamDefaultWriterRelease(writer);\x0d\n    readableStreamReaderGenericRelease(reader);\x0d\n    if (signal !== undefined)\x0d\n      signal.removeEventListener('abort'\x2C abortAlgorithm);\x0d\n    if (rejected)\x0d\n      promise.reject(error);\x0d\n    else\x0d\n      promise.resolve();\x0d\n  }\x0d\n\x0d\n  async function waitForCurrentWrite() {\x0d\n    const write = currentWrite;\x0d\n    await write;\x0d\n    if (write !== currentWrite)\x0d\n      await waitForCurrentWrite();\x0d\n  }\x0d\n\x0d\n  function shutdownWithAnAction(action\x2C rejected\x2C originalError) {\x0d\n    if (shuttingDown) return;\x0d\n    shuttingDown = true;\x0d\n    if (dest[kState].state === 'writable' &&\x0d\n        !writableStreamCloseQueuedOrInFlight(dest)) {\x0d\n      PromisePrototypeThen(\x0d\n        waitForCurrentWrite()\x2C\x0d\n        complete\x2C\x0d\n        (error) => finalize(true\x2C error));\x0d\n      return;\x0d\n    }\x0d\n    complete();\x0d\n\x0d\n    function complete() {\x0d\n      PromisePrototypeThen(\x0d\n        action()\x2C\x0d\n        () => finalize(rejected\x2C originalError)\x2C\x0d\n        (error) => finalize(true\x2C error));\x0d\n    }\x0d\n  }\x0d\n\x0d\n  function shutdown(rejected\x2C error) {\x0d\n    if (shuttingDown) return;\x0d\n    shuttingDown = true;\x0d\n    if (dest[kState].state === 'writable' &&\x0d\n        !writableStreamCloseQueuedOrInFlight(dest)) {\x0d\n      PromisePrototypeThen(\x0d\n        waitForCurrentWrite()\x2C\x0d\n        () => finalize(rejected\x2C error)\x2C\x0d\n        (error) => finalize(true\x2C error));\x0d\n      return;\x0d\n    }\x0d\n    finalize(rejected\x2C error);\x0d\n  }\x0d\n\x0d\n  function abortAlgorithm() {\x0d\n    // Cannot use the AbortError class here. It must be a DOMException\x0d\n    const error = new DOMException('The operation was aborted'\x2C 'AbortError');\x0d\n    const actions = [];\x0d\n    if (!preventAbort) {\x0d\n      ArrayPrototypePush(\x0d\n        actions\x2C\x0d\n        () => {\x0d\n          if (dest[kState].state === 'writable')\x0d\n            return writableStreamAbort(dest\x2C error);\x0d\n          return PromiseResolve();\x0d\n        });\x0d\n    }\x0d\n    if (!preventCancel) {\x0d\n      ArrayPrototypePush(\x0d\n        actions\x2C\x0d\n        () => {\x0d\n          if (source[kState].state === 'readable')\x0d\n            return readableStreamCancel(source\x2C error);\x0d\n          return PromiseResolve();\x0d\n        });\x0d\n    }\x0d\n\x0d\n    shutdownWithAnAction(\x0d\n      async () => PromiseAll(actions.map((action) => action()))\x2C\x0d\n      true\x2C\x0d\n      error);\x0d\n  }\x0d\n\x0d\n  function watchErrored(stream\x2C promise\x2C action) {\x0d\n    if (stream[kState].state === 'errored')\x0d\n      action(stream[kState].storedError);\x0d\n    else\x0d\n      PromisePrototypeCatch(promise\x2C action);\x0d\n  }\x0d\n\x0d\n  function watchClosed(stream\x2C promise\x2C action) {\x0d\n    if (stream[kState].state === 'closed')\x0d\n      action();\x0d\n    else\x0d\n      PromisePrototypeThen(promise\x2C action\x2C () => {});\x0d\n  }\x0d\n\x0d\n  async function step() {\x0d\n    if (shuttingDown)\x0d\n      return true;\x0d\n    await writer[kState].ready.promise;\x0d\n    return new Promise((resolve\x2C reject) => {\x0d\n      readableStreamDefaultReaderRead(\x0d\n        reader\x2C\x0d\n        {\x0d\n          [kChunk](chunk) {\x0d\n            currentWrite = writableStreamDefaultWriterWrite(writer\x2C chunk);\x0d\n            setPromiseHandled(currentWrite);\x0d\n            resolve(false);\x0d\n          }\x2C\x0d\n          [kClose]: () => resolve(true)\x2C\x0d\n          [kError]: reject\x2C\x0d\n        });\x0d\n    });\x0d\n  }\x0d\n\x0d\n  async function run() {\x0d\n    // Run until step resolves as true\x0d\n    while (!await step()) {}\x0d\n  }\x0d\n\x0d\n  if (signal !== undefined) {\x0d\n    if (signal.aborted) {\x0d\n      abortAlgorithm();\x0d\n      return promise.promise;\x0d\n    }\x0d\n    signal.addEventListener('abort'\x2C abortAlgorithm\x2C { once: true });\x0d\n  }\x0d\n\x0d\n  setPromiseHandled(run());\x0d\n\x0d\n  watchErrored(source\x2C reader[kState].close.promise\x2C (error) => {\x0d\n    if (!preventAbort) {\x0d\n      return shutdownWithAnAction(\x0d\n        () => writableStreamAbort(dest\x2C error)\x2C\x0d\n        true\x2C\x0d\n        error);\x0d\n    }\x0d\n    shutdown(true\x2C error);\x0d\n  });\x0d\n\x0d\n  watchErrored(dest\x2C writer[kState].close.promise\x2C (error) => {\x0d\n    if (!preventCancel) {\x0d\n      return shutdownWithAnAction(\x0d\n        () => readableStreamCancel(source\x2C error)\x2C\x0d\n        true\x2C\x0d\n        error);\x0d\n    }\x0d\n    shutdown(true\x2C error);\x0d\n  });\x0d\n\x0d\n  watchClosed(source\x2C reader[kState].close.promise\x2C () => {\x0d\n    if (!preventClose) {\x0d\n      return shutdownWithAnAction(\x0d\n        () => writableStreamDefaultWriterCloseWithErrorPropagation(writer));\x0d\n    }\x0d\n    shutdown();\x0d\n  });\x0d\n\x0d\n  if (writableStreamCloseQueuedOrInFlight(dest) ||\x0d\n      dest[kState].state === 'closed') {\x0d\n    const error = new ERR_INVALID_STATE.TypeError(\x0d\n      'Destination WritableStream is closed');\x0d\n    if (!preventCancel) {\x0d\n      shutdownWithAnAction(\x0d\n        () => readableStreamCancel(source\x2C error)\x2C true\x2C error);\x0d\n    } else {\x0d\n      shutdown(true\x2C error);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return promise.promise;\x0d\n}\x0d\n\x0d\nfunction readableStreamTee(stream\x2C cloneForBranch2) {\x0d\n  const reader = new ReadableStreamDefaultReader(stream);\x0d\n  let reading = false;\x0d\n  let canceled1 = false;\x0d\n  let canceled2 = false;\x0d\n  let reason1;\x0d\n  let reason2;\x0d\n  let branch1;\x0d\n  let branch2;\x0d\n  const cancelPromise = createDeferredPromise();\x0d\n\x0d\n  async function pullAlgorithm() {\x0d\n    if (reading) return;\x0d\n    reading = true;\x0d\n    const readRequest = {\x0d\n      [kChunk](value) {\x0d\n        queueMicrotask(() => {\x0d\n          reading = false;\x0d\n          const value1 = value;\x0d\n          let value2 = value;\x0d\n          if (!canceled2 && cloneForBranch2) {\x0d\n            // Structured Clone\x0d\n            value2 = deserialize(serialize(value2));\x0d\n          }\x0d\n          if (!canceled1) {\x0d\n            readableStreamDefaultControllerEnqueue(\x0d\n              branch1[kState].controller\x2C\x0d\n              value1);\x0d\n          }\x0d\n          if (!canceled2) {\x0d\n            readableStreamDefaultControllerEnqueue(\x0d\n              branch2[kState].controller\x2C\x0d\n              value2);\x0d\n          }\x0d\n        });\x0d\n      }\x2C\x0d\n      [kClose]() {\x0d\n        // The `process.nextTick()` is not part of the spec.\x0d\n        // This approach was needed to avoid a race condition working with esm\x0d\n        // Further information\x2C see: https://github.com/nodejs/node/issues/39758\x0d\n        process.nextTick(() => {\x0d\n          reading = false;\x0d\n          if (!canceled1)\x0d\n            readableStreamDefaultControllerClose(branch1[kState].controller);\x0d\n          if (!canceled2)\x0d\n            readableStreamDefaultControllerClose(branch2[kState].controller);\x0d\n          if (!canceled1 || !canceled2)\x0d\n            cancelPromise.resolve();\x0d\n        });\x0d\n      }\x2C\x0d\n      [kError]() {\x0d\n        reading = false;\x0d\n      }\x2C\x0d\n    };\x0d\n    readableStreamDefaultReaderRead(reader\x2C readRequest);\x0d\n  }\x0d\n\x0d\n  function cancel1Algorithm(reason) {\x0d\n    canceled1 = true;\x0d\n    reason1 = reason;\x0d\n    if (canceled2) {\x0d\n      const compositeReason = [reason1\x2C reason2];\x0d\n      cancelPromise.resolve(readableStreamCancel(stream\x2C compositeReason));\x0d\n    }\x0d\n    return cancelPromise.promise;\x0d\n  }\x0d\n\x0d\n  function cancel2Algorithm(reason) {\x0d\n    canceled2 = true;\x0d\n    reason2 = reason;\x0d\n    if (canceled1) {\x0d\n      const compositeReason = [reason1\x2C reason2];\x0d\n      cancelPromise.resolve(readableStreamCancel(stream\x2C compositeReason));\x0d\n    }\x0d\n    return cancelPromise.promise;\x0d\n  }\x0d\n\x0d\n  branch1 =\x0d\n    createTeeReadableStream(nonOpStart\x2C pullAlgorithm\x2C cancel1Algorithm);\x0d\n  branch2 =\x0d\n    createTeeReadableStream(nonOpStart\x2C pullAlgorithm\x2C cancel2Algorithm);\x0d\n\x0d\n  PromisePrototypeCatch(\x0d\n    reader[kState].close.promise\x2C\x0d\n    (error) => {\x0d\n      readableStreamDefaultControllerError(branch1[kState].controller\x2C error);\x0d\n      readableStreamDefaultControllerError(branch2[kState].controller\x2C error);\x0d\n      if (!canceled1 || !canceled2)\x0d\n        cancelPromise.resolve();\x0d\n    });\x0d\n\x0d\n  return [branch1\x2C branch2];\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerConvertPullIntoDescriptor(desc) {\x0d\n  const {\x0d\n    buffer\x2C\x0d\n    bytesFilled\x2C\x0d\n    byteLength\x2C\x0d\n    byteOffset\x2C\x0d\n    ctor\x2C\x0d\n    elementSize\x2C\x0d\n  } = desc;\x0d\n  if (bytesFilled > byteLength)\x0d\n    throw new ERR_INVALID_STATE.RangeError('The buffer size is invalid');\x0d\n  assert(!(bytesFilled % elementSize));\x0d\n  const transferredBuffer = transferArrayBuffer(buffer);\x0d\n  return new ctor(transferredBuffer\x2C byteOffset\x2C bytesFilled / elementSize);\x0d\n}\x0d\n\x0d\nfunction isReadableStreamLocked(stream) {\x0d\n  return stream[kState].reader !== undefined;\x0d\n}\x0d\n\x0d\nfunction readableStreamCancel(stream\x2C reason) {\x0d\n  stream[kState].disturbed = true;\x0d\n  switch (stream[kState].state) {\x0d\n    case 'closed':\x0d\n      return PromiseResolve();\x0d\n    case 'errored':\x0d\n      return PromiseReject(stream[kState].storedError);\x0d\n  }\x0d\n  readableStreamClose(stream);\x0d\n  const {\x0d\n    reader\x2C\x0d\n  } = stream[kState];\x0d\n  if (reader !== undefined && readableStreamHasBYOBReader(stream)) {\x0d\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\x0d\n      reader[kState].readIntoRequests[n][kClose]();\x0d\n    reader[kState].readIntoRequests = [];\x0d\n  }\x0d\n\x0d\n  return PromisePrototypeThen(\x0d\n    ensureIsPromise(\x0d\n      stream[kState].controller[kCancel]\x2C\x0d\n      stream[kState].controller\x2C\x0d\n      reason)\x2C\x0d\n    () => {});\x0d\n}\x0d\n\x0d\nfunction readableStreamClose(stream) {\x0d\n  assert(stream[kState].state === 'readable');\x0d\n  stream[kState].state = 'closed';\x0d\n\x0d\n  const {\x0d\n    reader\x2C\x0d\n  } = stream[kState];\x0d\n\x0d\n  if (reader === undefined)\x0d\n    return;\x0d\n\x0d\n  reader[kState].close.resolve();\x0d\n\x0d\n  if (readableStreamHasDefaultReader(stream)) {\x0d\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\x0d\n      reader[kState].readRequests[n][kClose]();\x0d\n    reader[kState].readRequests = [];\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableStreamError(stream\x2C error) {\x0d\n  assert(stream[kState].state === 'readable');\x0d\n  stream[kState].state = 'errored';\x0d\n  stream[kState].storedError = error;\x0d\n\x0d\n  const {\x0d\n    reader\x0d\n  } = stream[kState];\x0d\n\x0d\n  if (reader === undefined)\x0d\n    return;\x0d\n\x0d\n  reader[kState].close.reject(error);\x0d\n  setPromiseHandled(reader[kState].close.promise);\x0d\n\x0d\n  if (readableStreamHasDefaultReader(stream)) {\x0d\n    for (let n = 0; n < reader[kState].readRequests.length; n++)\x0d\n      reader[kState].readRequests[n][kError](error);\x0d\n    reader[kState].readRequests = [];\x0d\n  } else {\x0d\n    assert(readableStreamHasBYOBReader(stream));\x0d\n    for (let n = 0; n < reader[kState].readIntoRequests.length; n++)\x0d\n      reader[kState].readIntoRequests[n][kError](error);\x0d\n    reader[kState].readIntoRequests = [];\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableStreamHasDefaultReader(stream) {\x0d\n  const {\x0d\n    reader\x2C\x0d\n  } = stream[kState];\x0d\n\x0d\n  if (reader === undefined)\x0d\n    return false;\x0d\n\x0d\n  return reader[kState] !== undefined &&\x0d\n         reader[kType] === 'ReadableStreamDefaultReader';\x0d\n}\x0d\n\x0d\nfunction readableStreamGetNumReadRequests(stream) {\x0d\n  assert(readableStreamHasDefaultReader(stream));\x0d\n  return stream[kState].reader[kState].readRequests.length;\x0d\n}\x0d\n\x0d\nfunction readableStreamHasBYOBReader(stream) {\x0d\n  const {\x0d\n    reader\x2C\x0d\n  } = stream[kState];\x0d\n\x0d\n  if (reader === undefined)\x0d\n    return false;\x0d\n\x0d\n  return reader[kState] !== undefined &&\x0d\n         reader[kType] === 'ReadableStreamBYOBReader';\x0d\n}\x0d\n\x0d\nfunction readableStreamGetNumReadIntoRequests(stream) {\x0d\n  assert(readableStreamHasBYOBReader(stream));\x0d\n  return stream[kState].reader[kState].readIntoRequests.length;\x0d\n}\x0d\n\x0d\nfunction readableStreamFulfillReadRequest(stream\x2C chunk\x2C done) {\x0d\n  assert(readableStreamHasDefaultReader(stream));\x0d\n  const {\x0d\n    reader\x2C\x0d\n  } = stream[kState];\x0d\n  assert(reader[kState].readRequests.length);\x0d\n  const readRequest = ArrayPrototypeShift(reader[kState].readRequests);\x0d\n\x0d\n  // TODO(@jasnell): It's not clear under what exact conditions done\x0d\n  // will be true here. The spec requires this check but none of the\x0d\n  // WPT's or other tests trigger it. Will need to investigate how to\x0d\n  // get coverage for this.\x0d\n  if (done)\x0d\n    readRequest[kClose]();\x0d\n  else\x0d\n    readRequest[kChunk](chunk);\x0d\n}\x0d\n\x0d\nfunction readableStreamFulfillReadIntoRequest(stream\x2C chunk\x2C done) {\x0d\n  assert(readableStreamHasBYOBReader(stream));\x0d\n  const {\x0d\n    reader\x2C\x0d\n  } = stream[kState];\x0d\n  assert(reader[kState].readIntoRequests.length);\x0d\n  const readIntoRequest = ArrayPrototypeShift(reader[kState].readIntoRequests);\x0d\n  if (done)\x0d\n    readIntoRequest[kClose](chunk);\x0d\n  else\x0d\n    readIntoRequest[kChunk](chunk);\x0d\n}\x0d\n\x0d\nfunction readableStreamAddReadRequest(stream\x2C readRequest) {\x0d\n  assert(readableStreamHasDefaultReader(stream));\x0d\n  assert(stream[kState].state === 'readable');\x0d\n  ArrayPrototypePush(stream[kState].reader[kState].readRequests\x2C readRequest);\x0d\n}\x0d\n\x0d\nfunction readableStreamAddReadIntoRequest(stream\x2C readIntoRequest) {\x0d\n  assert(readableStreamHasBYOBReader(stream));\x0d\n  assert(stream[kState].state !== 'errored');\x0d\n  ArrayPrototypePush(\x0d\n    stream[kState].reader[kState].readIntoRequests\x2C\x0d\n    readIntoRequest);\x0d\n}\x0d\n\x0d\nfunction readableStreamReaderGenericCancel(reader\x2C reason) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = reader[kState];\x0d\n  assert(stream !== undefined);\x0d\n  return readableStreamCancel(stream\x2C reason);\x0d\n}\x0d\n\x0d\nfunction readableStreamReaderGenericInitialize(reader\x2C stream) {\x0d\n  reader[kState].stream = stream;\x0d\n  stream[kState].reader = reader;\x0d\n  switch (stream[kState].state) {\x0d\n    case 'readable':\x0d\n      reader[kState].close = createDeferredPromise();\x0d\n      break;\x0d\n    case 'closed':\x0d\n      reader[kState].close = {\x0d\n        promise: PromiseResolve()\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      };\x0d\n      break;\x0d\n    case 'errored':\x0d\n      reader[kState].close = {\x0d\n        promise: PromiseReject(stream[kState].storedError)\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      };\x0d\n      setPromiseHandled(reader[kState].close.promise);\x0d\n      break;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableStreamReaderGenericRelease(reader) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = reader[kState];\x0d\n  assert(stream !== undefined);\x0d\n  assert(stream[kState].reader === reader);\x0d\n\x0d\n  if (stream[kState].state === 'readable') {\x0d\n    reader[kState].close.reject?.(\x0d\n      new ERR_INVALID_STATE.TypeError('Reader released'));\x0d\n  } else {\x0d\n    reader[kState].close = {\x0d\n      promise: PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError('Reader released'))\x2C\x0d\n      resolve: undefined\x2C\x0d\n      reject: undefined\x2C\x0d\n    };\x0d\n  }\x0d\n  setPromiseHandled(reader[kState].close.promise);\x0d\n  stream[kState].reader = undefined;\x0d\n  reader[kState].stream = undefined;\x0d\n}\x0d\n\x0d\nfunction readableStreamBYOBReaderRead(reader\x2C view\x2C readIntoRequest) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = reader[kState];\x0d\n  assert(stream !== undefined);\x0d\n  stream[kState].disturbed = true;\x0d\n  if (stream[kState].state === 'errored') {\x0d\n    readIntoRequest[kError](stream[kState].storedError);\x0d\n    return;\x0d\n  }\x0d\n  readableByteStreamControllerPullInto(\x0d\n    stream[kState].controller\x2C\x0d\n    view\x2C\x0d\n    readIntoRequest);\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultReaderRead(reader\x2C readRequest) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = reader[kState];\x0d\n  assert(stream !== undefined);\x0d\n  stream[kState].disturbed = true;\x0d\n  switch (stream[kState].state) {\x0d\n    case 'closed':\x0d\n      readRequest[kClose]();\x0d\n      break;\x0d\n    case 'errored':\x0d\n      readRequest[kError](stream[kState].storedError);\x0d\n      break;\x0d\n    case 'readable':\x0d\n      stream[kState].controller[kPull](readRequest);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction setupReadableStreamBYOBReader(reader\x2C stream) {\x0d\n  if (isReadableStreamLocked(stream))\x0d\n    throw new ERR_INVALID_STATE.TypeError('ReadableStream is locked');\x0d\n  const {\x0d\n    controller\x2C\x0d\n  } = stream[kState];\x0d\n  if (!isReadableByteStreamController(controller))\x0d\n    throw new ERR_INVALID_ARG_VALUE('stream'\x2C stream\x2C 'must be a byte stream');\x0d\n  readableStreamReaderGenericInitialize(reader\x2C stream);\x0d\n  reader[kState].readIntoRequests = [];\x0d\n}\x0d\n\x0d\nfunction setupReadableStreamDefaultReader(reader\x2C stream) {\x0d\n  if (isReadableStreamLocked(stream))\x0d\n    throw new ERR_INVALID_STATE.TypeError('ReadableStream is locked');\x0d\n  readableStreamReaderGenericInitialize(reader\x2C stream);\x0d\n  reader[kState].readRequests = [];\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerClose(controller) {\x0d\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\x0d\n    return;\x0d\n  controller[kState].closeRequested = true;\x0d\n  if (!controller[kState].queue.length) {\x0d\n    readableStreamDefaultControllerClearAlgorithms(controller);\x0d\n    readableStreamClose(controller[kState].stream);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerEnqueue(controller\x2C chunk) {\x0d\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller))\x0d\n    return;\x0d\n\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n\x0d\n  if (isReadableStreamLocked(stream) &&\x0d\n      readableStreamGetNumReadRequests(stream)) {\x0d\n    readableStreamFulfillReadRequest(stream\x2C chunk\x2C false);\x0d\n  } else {\x0d\n    try {\x0d\n      const chunkSize =\x0d\n        FunctionPrototypeCall(\x0d\n          controller[kState].sizeAlgorithm\x2C\x0d\n          undefined\x2C\x0d\n          chunk);\x0d\n      enqueueValueWithSize(controller\x2C chunk\x2C chunkSize);\x0d\n    } catch (error) {\x0d\n      readableStreamDefaultControllerError(controller\x2C error);\x0d\n      throw error;\x0d\n    }\x0d\n  }\x0d\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerHasBackpressure(controller) {\x0d\n  return !readableStreamDefaultControllerShouldCallPull(controller);\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerCanCloseOrEnqueue(controller) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  return !controller[kState].closeRequested &&\x0d\n         stream[kState].state === 'readable';\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerGetDesiredSize(controller) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n    highWaterMark\x2C\x0d\n    queueTotalSize\x2C\x0d\n  } = controller[kState];\x0d\n  switch (stream[kState].state) {\x0d\n    case 'errored': return null;\x0d\n    case 'closed': return 0;\x0d\n    default:\x0d\n      return highWaterMark - queueTotalSize;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerShouldCallPull(controller) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  if (!readableStreamDefaultControllerCanCloseOrEnqueue(controller) ||\x0d\n      !controller[kState].started)\x0d\n    return false;\x0d\n\x0d\n  if (isReadableStreamLocked(stream) &&\x0d\n      readableStreamGetNumReadRequests(stream)) {\x0d\n    return true;\x0d\n  }\x0d\n\x0d\n  const desiredSize = readableStreamDefaultControllerGetDesiredSize(controller);\x0d\n  assert(desiredSize !== null);\x0d\n\x0d\n  return desiredSize > 0;\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerCallPullIfNeeded(controller) {\x0d\n  if (!readableStreamDefaultControllerShouldCallPull(controller))\x0d\n    return;\x0d\n  if (controller[kState].pulling) {\x0d\n    controller[kState].pullAgain = true;\x0d\n    return;\x0d\n  }\x0d\n  assert(!controller[kState].pullAgain);\x0d\n  controller[kState].pulling = true;\x0d\n  PromisePrototypeThen(\x0d\n    ensureIsPromise(controller[kState].pullAlgorithm\x2C controller)\x2C\x0d\n    () => {\x0d\n      controller[kState].pulling = false;\x0d\n      if (controller[kState].pullAgain) {\x0d\n        controller[kState].pullAgain = false;\x0d\n        readableStreamDefaultControllerCallPullIfNeeded(controller);\x0d\n      }\x0d\n    }\x2C\x0d\n    (error) => readableStreamDefaultControllerError(controller\x2C error));\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerClearAlgorithms(controller) {\x0d\n  controller[kState].pullAlgorithm = undefined;\x0d\n  controller[kState].cancelAlgorithm = undefined;\x0d\n  controller[kState].sizeAlgorithm = undefined;\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerError(controller\x2C error) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  if (stream[kState].state === 'readable') {\x0d\n    resetQueue(controller);\x0d\n    readableStreamDefaultControllerClearAlgorithms(controller);\x0d\n    readableStreamError(stream\x2C error);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerCancelSteps(controller\x2C reason) {\x0d\n  resetQueue(controller);\x0d\n  const result = controller[kState].cancelAlgorithm(reason);\x0d\n  readableStreamDefaultControllerClearAlgorithms(controller);\x0d\n  return result;\x0d\n}\x0d\n\x0d\nfunction readableStreamDefaultControllerPullSteps(controller\x2C readRequest) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n    queue\x2C\x0d\n  } = controller[kState];\x0d\n  if (queue.length) {\x0d\n    const chunk = dequeueValue(controller);\x0d\n    if (controller[kState].closeRequested && !queue.length) {\x0d\n      readableStreamDefaultControllerClearAlgorithms(controller);\x0d\n      readableStreamClose(stream);\x0d\n    } else {\x0d\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\x0d\n    }\x0d\n    readRequest[kChunk](chunk);\x0d\n    return;\x0d\n  }\x0d\n  readableStreamAddReadRequest(stream\x2C readRequest);\x0d\n  readableStreamDefaultControllerCallPullIfNeeded(controller);\x0d\n}\x0d\n\x0d\nfunction setupReadableStreamDefaultController(\x0d\n  stream\x2C\x0d\n  controller\x2C\x0d\n  startAlgorithm\x2C\x0d\n  pullAlgorithm\x2C\x0d\n  cancelAlgorithm\x2C\x0d\n  highWaterMark\x2C\x0d\n  sizeAlgorithm) {\x0d\n  assert(stream[kState].controller === undefined);\x0d\n  controller[kState] = {\x0d\n    cancelAlgorithm\x2C\x0d\n    closeRequested: false\x2C\x0d\n    highWaterMark\x2C\x0d\n    pullAgain: false\x2C\x0d\n    pullAlgorithm\x2C\x0d\n    pulling: false\x2C\x0d\n    queue: []\x2C\x0d\n    queueTotalSize: 0\x2C\x0d\n    started: false\x2C\x0d\n    sizeAlgorithm\x2C\x0d\n    stream\x2C\x0d\n  };\x0d\n  stream[kState].controller = controller;\x0d\n\x0d\n  const startResult = startAlgorithm();\x0d\n\x0d\n  PromisePrototypeThen(\x0d\n    PromiseResolve(startResult)\x2C\x0d\n    () => {\x0d\n      controller[kState].started = true;\x0d\n      assert(!controller[kState].pulling);\x0d\n      assert(!controller[kState].pullAgain);\x0d\n      readableStreamDefaultControllerCallPullIfNeeded(controller);\x0d\n    }\x2C\x0d\n    (error) => readableStreamDefaultControllerError(controller\x2C error));\x0d\n}\x0d\n\x0d\nfunction setupReadableStreamDefaultControllerFromSource(\x0d\n  stream\x2C\x0d\n  source\x2C\x0d\n  highWaterMark\x2C\x0d\n  sizeAlgorithm) {\x0d\n  const controller = createReadableStreamDefaultController();\x0d\n  const start = source?.start;\x0d\n  const pull = source?.pull;\x0d\n  const cancel = source?.cancel;\x0d\n  const startAlgorithm = start ?\x0d\n    FunctionPrototypeBind(start\x2C source\x2C controller) :\x0d\n    nonOpStart;\x0d\n  const pullAlgorithm = pull ?\x0d\n    FunctionPrototypeBind(pull\x2C source\x2C controller) :\x0d\n    nonOpPull;\x0d\n\x0d\n  const cancelAlgorithm = cancel ?\x0d\n    FunctionPrototypeBind(cancel\x2C source) :\x0d\n    nonOpCancel;\x0d\n\x0d\n  setupReadableStreamDefaultController(\x0d\n    stream\x2C\x0d\n    controller\x2C\x0d\n    startAlgorithm\x2C\x0d\n    pullAlgorithm\x2C\x0d\n    cancelAlgorithm\x2C\x0d\n    highWaterMark\x2C\x0d\n    sizeAlgorithm);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerClose(controller) {\x0d\n  const {\x0d\n    closeRequested\x2C\x0d\n    pendingPullIntos\x2C\x0d\n    queueTotalSize\x2C\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n\x0d\n  if (closeRequested || stream[kState].state !== 'readable')\x0d\n    return;\x0d\n\x0d\n  if (queueTotalSize) {\x0d\n    controller[kState].closeRequested = true;\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (pendingPullIntos.length) {\x0d\n    const firstPendingPullInto = pendingPullIntos[0];\x0d\n    if (firstPendingPullInto.bytesFilled > 0) {\x0d\n      const error = new ERR_INVALID_STATE.TypeError('Partial read');\x0d\n      readableByteStreamControllerError(controller\x2C error);\x0d\n      throw error;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  readableByteStreamControllerClearAlgorithms(controller);\x0d\n  readableStreamClose(stream);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerCommitPullIntoDescriptor(stream\x2C desc) {\x0d\n  assert(stream[kState].state !== 'errored');\x0d\n  let done = false;\x0d\n  if (stream[kState].state === 'closed') {\x0d\n    desc.bytesFilled = 0;\x0d\n    done = true;\x0d\n  }\x0d\n\x0d\n  const filledView =\x0d\n    readableByteStreamControllerConvertPullIntoDescriptor(desc);\x0d\n\x0d\n  if (desc.type === 'default') {\x0d\n    readableStreamFulfillReadRequest(stream\x2C filledView\x2C done);\x0d\n  } else {\x0d\n    assert(desc.type === 'byob');\x0d\n    readableStreamFulfillReadIntoRequest(stream\x2C filledView\x2C done);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerInvalidateBYOBRequest(controller) {\x0d\n  if (controller[kState].byobRequest === null)\x0d\n    return;\x0d\n  controller[kState].byobRequest[kState].controller = undefined;\x0d\n  controller[kState].byobRequest[kState].view = null;\x0d\n  controller[kState].byobRequest = null;\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerClearAlgorithms(controller) {\x0d\n  controller[kState].pullAlgorithm = undefined;\x0d\n  controller[kState].cancelAlgorithm = undefined;\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerClearPendingPullIntos(controller) {\x0d\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\x0d\n  controller[kState].pendingPullIntos = [];\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerGetDesiredSize(controller) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n    highWaterMark\x2C\x0d\n    queueTotalSize\x2C\x0d\n  } = controller[kState];\x0d\n  switch (stream[kState].state) {\x0d\n    case 'errored': return null;\x0d\n    case 'closed': return 0;\x0d\n    default: return highWaterMark - queueTotalSize;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerShouldCallPull(controller) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  if (stream[kState].state !== 'readable' ||\x0d\n      controller[kState].closeRequested ||\x0d\n      !controller[kState].started) {\x0d\n    return false;\x0d\n  }\x0d\n  if (readableStreamHasDefaultReader(stream) &&\x0d\n      readableStreamGetNumReadRequests(stream) > 0) {\x0d\n    return true;\x0d\n  }\x0d\n\x0d\n  if (readableStreamHasBYOBReader(stream) &&\x0d\n      readableStreamGetNumReadIntoRequests(stream) > 0) {\x0d\n    return true;\x0d\n  }\x0d\n\x0d\n  const desiredSize = readableByteStreamControllerGetDesiredSize(controller);\x0d\n  assert(desiredSize !== null);\x0d\n\x0d\n  return desiredSize > 0;\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerHandleQueueDrain(controller) {\x0d\n  const {\x0d\n    closeRequested\x2C\x0d\n    queueTotalSize\x2C\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  assert(stream[kState].state === 'readable');\x0d\n  if (!queueTotalSize && closeRequested) {\x0d\n    readableByteStreamControllerClearAlgorithms(controller);\x0d\n    readableStreamClose(stream);\x0d\n    return;\x0d\n  }\x0d\n  readableByteStreamControllerCallPullIfNeeded(controller);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerPullInto(\x0d\n  controller\x2C\x0d\n  view\x2C\x0d\n  readIntoRequest) {\x0d\n  const {\x0d\n    closeRequested\x2C\x0d\n    stream\x2C\x0d\n    pendingPullIntos\x2C\x0d\n  } = controller[kState];\x0d\n  let elementSize = 1;\x0d\n  let ctor = DataViewCtor;\x0d\n  if (isArrayBufferView(view) && !isDataView(view)) {\x0d\n    elementSize = view.constructor.BYTES_PER_ELEMENT;\x0d\n    ctor = view.constructor;\x0d\n  }\x0d\n  const buffer = ArrayBufferViewGetBuffer(view);\x0d\n  const byteOffset = ArrayBufferViewGetByteOffset(view);\x0d\n  const byteLength = ArrayBufferViewGetByteLength(view);\x0d\n  const bufferByteLength = ArrayBufferGetByteLength(buffer);\x0d\n\x0d\n  let transferredBuffer;\x0d\n  try {\x0d\n    transferredBuffer = transferArrayBuffer(buffer);\x0d\n  } catch (error) {\x0d\n    readIntoRequest[kError](error);\x0d\n    return;\x0d\n  }\x0d\n  const desc = {\x0d\n    buffer: transferredBuffer\x2C\x0d\n    bufferByteLength\x2C\x0d\n    byteOffset\x2C\x0d\n    byteLength\x2C\x0d\n    bytesFilled: 0\x2C\x0d\n    elementSize\x2C\x0d\n    ctor\x2C\x0d\n    type: 'byob'\x2C\x0d\n  };\x0d\n  if (pendingPullIntos.length) {\x0d\n    ArrayPrototypePush(pendingPullIntos\x2C desc);\x0d\n    readableStreamAddReadIntoRequest(stream\x2C readIntoRequest);\x0d\n    return;\x0d\n  }\x0d\n  if (stream[kState].state === 'closed') {\x0d\n    const emptyView = new ctor(desc.buffer\x2C byteOffset\x2C 0);\x0d\n    readIntoRequest[kClose](emptyView);\x0d\n    return;\x0d\n  }\x0d\n  if (controller[kState].queueTotalSize) {\x0d\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(\x0d\n      controller\x2C\x0d\n      desc)) {\x0d\n      const filledView =\x0d\n        readableByteStreamControllerConvertPullIntoDescriptor(desc);\x0d\n      readableByteStreamControllerHandleQueueDrain(controller);\x0d\n      readIntoRequest[kChunk](filledView);\x0d\n      return;\x0d\n    }\x0d\n    if (closeRequested) {\x0d\n      const error = new ERR_INVALID_STATE.TypeError('ReadableStream closed');\x0d\n      readableByteStreamControllerError(controller\x2C error);\x0d\n      readIntoRequest[kError](error);\x0d\n      return;\x0d\n    }\x0d\n  }\x0d\n  ArrayPrototypePush(pendingPullIntos\x2C desc);\x0d\n  readableStreamAddReadIntoRequest(stream\x2C readIntoRequest);\x0d\n  readableByteStreamControllerCallPullIfNeeded(controller);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerRespondInternal(controller\x2C bytesWritten) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n    pendingPullIntos\x2C\x0d\n  } = controller[kState];\x0d\n  const desc = pendingPullIntos[0];\x0d\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\x0d\n  if (stream[kState].state === 'closed') {\x0d\n    if (bytesWritten)\x0d\n      throw new ERR_INVALID_STATE.TypeError(\x0d\n        'Controller is closed but view is not zero-length');\x0d\n    readableByteStreamControllerRespondInClosedState(controller\x2C desc);\x0d\n  } else {\x0d\n    assert(stream[kState].state === 'readable');\x0d\n    if (!bytesWritten)\x0d\n      throw new ERR_INVALID_STATE.TypeError('View cannot be zero-length');\x0d\n    readableByteStreamControllerRespondInReadableState(\x0d\n      controller\x2C\x0d\n      bytesWritten\x2C\x0d\n      desc);\x0d\n  }\x0d\n  readableByteStreamControllerCallPullIfNeeded(controller);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerRespond(controller\x2C bytesWritten) {\x0d\n  const {\x0d\n    pendingPullIntos\x2C\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  assert(pendingPullIntos.length);\x0d\n  const desc = pendingPullIntos[0];\x0d\n\x0d\n  if (stream[kState].state === 'closed') {\x0d\n    if (bytesWritten !== 0)\x0d\n      throw new ERR_INVALID_ARG_VALUE('bytesWritten'\x2C bytesWritten);\x0d\n  } else {\x0d\n    assert(stream[kState].state === 'readable');\x0d\n\x0d\n    if (!bytesWritten)\x0d\n      throw new ERR_INVALID_ARG_VALUE('bytesWritten'\x2C bytesWritten);\x0d\n\x0d\n    if ((desc.bytesFilled + bytesWritten) > desc.byteLength)\x0d\n      throw new ERR_INVALID_ARG_VALUE.RangeError('bytesWritten'\x2C bytesWritten);\x0d\n  }\x0d\n\x0d\n  desc.buffer = transferArrayBuffer(desc.buffer);\x0d\n\x0d\n  readableByteStreamControllerRespondInternal(controller\x2C bytesWritten);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerRespondInClosedState(controller\x2C desc) {\x0d\n  assert(!desc.bytesFilled);\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  if (readableStreamHasBYOBReader(stream)) {\x0d\n    while (readableStreamGetNumReadIntoRequests(stream) > 0) {\x0d\n      readableByteStreamControllerCommitPullIntoDescriptor(\x0d\n        stream\x2C\x0d\n        readableByteStreamControllerShiftPendingPullInto(controller));\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerFillHeadPullIntoDescriptor(\x0d\n  controller\x2C\x0d\n  size\x2C\x0d\n  desc) {\x0d\n  const {\x0d\n    pendingPullIntos\x2C\x0d\n    byobRequest\x2C\x0d\n  } = controller[kState];\x0d\n  assert(!pendingPullIntos.length || pendingPullIntos[0] === desc);\x0d\n  assert(byobRequest === null);\x0d\n  desc.bytesFilled += size;\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerEnqueue(\x0d\n  controller\x2C\x0d\n  buffer\x2C\x0d\n  byteLength\x2C\x0d\n  byteOffset) {\x0d\n  const {\x0d\n    closeRequested\x2C\x0d\n    pendingPullIntos\x2C\x0d\n    queue\x2C\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n\x0d\n  if (closeRequested || stream[kState].state !== 'readable')\x0d\n    return;\x0d\n\x0d\n  const transferredBuffer = transferArrayBuffer(buffer);\x0d\n\x0d\n  if (pendingPullIntos.length) {\x0d\n    const firstPendingPullInto = pendingPullIntos[0];\x0d\n\x0d\n    const pendingBufferByteLength =\x0d\n      ArrayBufferGetByteLength(firstPendingPullInto.buffer);\x0d\n    if (pendingBufferByteLength === 0) {\x0d\n      throw new ERR_INVALID_STATE.TypeError(\x0d\n        'Destination ArrayBuffer is zero-length or detached');\x0d\n    }\x0d\n\x0d\n    firstPendingPullInto.buffer =\x0d\n      transferArrayBuffer(firstPendingPullInto.buffer);\x0d\n  }\x0d\n\x0d\n  readableByteStreamControllerInvalidateBYOBRequest(controller);\x0d\n\x0d\n  if (readableStreamHasDefaultReader(stream)) {\x0d\n    if (!readableStreamGetNumReadRequests(stream)) {\x0d\n      readableByteStreamControllerEnqueueChunkToQueue(\x0d\n        controller\x2C\x0d\n        transferredBuffer\x2C\x0d\n        byteOffset\x2C\x0d\n        byteLength);\x0d\n    } else {\x0d\n      assert(!queue.length);\x0d\n      const transferredView =\x0d\n        new Uint8Array(transferredBuffer\x2C byteOffset\x2C byteLength);\x0d\n      readableStreamFulfillReadRequest(stream\x2C transferredView\x2C false);\x0d\n    }\x0d\n  } else if (readableStreamHasBYOBReader(stream)) {\x0d\n    readableByteStreamControllerEnqueueChunkToQueue(\x0d\n      controller\x2C\x0d\n      transferredBuffer\x2C\x0d\n      byteOffset\x2C\x0d\n      byteLength);\x0d\n    readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\x0d\n      controller);\x0d\n  } else {\x0d\n    assert(!isReadableStreamLocked(stream));\x0d\n    readableByteStreamControllerEnqueueChunkToQueue(\x0d\n      controller\x2C\x0d\n      transferredBuffer\x2C\x0d\n      byteOffset\x2C\x0d\n      byteLength);\x0d\n  }\x0d\n  readableByteStreamControllerCallPullIfNeeded(controller);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerEnqueueChunkToQueue(\x0d\n  controller\x2C\x0d\n  buffer\x2C\x0d\n  byteOffset\x2C\x0d\n  byteLength) {\x0d\n  ArrayPrototypePush(\x0d\n    controller[kState].queue\x2C\x0d\n    {\x0d\n      buffer\x2C\x0d\n      byteOffset\x2C\x0d\n      byteLength\x2C\x0d\n    });\x0d\n  controller[kState].queueTotalSize += byteLength;\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerFillPullIntoDescriptorFromQueue(\x0d\n  controller\x2C\x0d\n  desc) {\x0d\n  const {\x0d\n    buffer\x2C\x0d\n    byteLength\x2C\x0d\n    byteOffset\x2C\x0d\n    bytesFilled\x2C\x0d\n    elementSize\x2C\x0d\n  } = desc;\x0d\n  const currentAlignedBytes = bytesFilled - (bytesFilled % elementSize);\x0d\n  const maxBytesToCopy = MathMin(\x0d\n    controller[kState].queueTotalSize\x2C\x0d\n    byteLength - bytesFilled);\x0d\n  const maxBytesFilled = bytesFilled + maxBytesToCopy;\x0d\n  const maxAlignedBytes = maxBytesFilled - (maxBytesFilled % elementSize);\x0d\n  let totalBytesToCopyRemaining = maxBytesToCopy;\x0d\n  let ready = false;\x0d\n  if (maxAlignedBytes > currentAlignedBytes) {\x0d\n    totalBytesToCopyRemaining = maxAlignedBytes - bytesFilled;\x0d\n    ready = true;\x0d\n  }\x0d\n  const {\x0d\n    queue\x2C\x0d\n  } = controller[kState];\x0d\n\x0d\n  while (totalBytesToCopyRemaining) {\x0d\n    const headOfQueue = queue[0];\x0d\n    const bytesToCopy = MathMin(\x0d\n      totalBytesToCopyRemaining\x2C\x0d\n      headOfQueue.byteLength);\x0d\n    const destStart = byteOffset + desc.bytesFilled;\x0d\n    const arrayBufferByteLength = ArrayBufferGetByteLength(buffer);\x0d\n    if (arrayBufferByteLength - destStart < bytesToCopy) {\x0d\n      throw new ERR_INVALID_STATE.RangeError(\x0d\n        'view ArrayBuffer size is invalid');\x0d\n    }\x0d\n    assert(arrayBufferByteLength - destStart >= bytesToCopy);\x0d\n    copyArrayBuffer(\x0d\n      buffer\x2C\x0d\n      destStart\x2C\x0d\n      headOfQueue.buffer\x2C\x0d\n      headOfQueue.byteOffset\x2C\x0d\n      bytesToCopy);\x0d\n    if (headOfQueue.byteLength === bytesToCopy) {\x0d\n      ArrayPrototypeShift(queue);\x0d\n    } else {\x0d\n      headOfQueue.byteOffset += bytesToCopy;\x0d\n      headOfQueue.byteLength -= bytesToCopy;\x0d\n    }\x0d\n    controller[kState].queueTotalSize -= bytesToCopy;\x0d\n    readableByteStreamControllerFillHeadPullIntoDescriptor(\x0d\n      controller\x2C\x0d\n      bytesToCopy\x2C\x0d\n      desc);\x0d\n    totalBytesToCopyRemaining -= bytesToCopy;\x0d\n  }\x0d\n\x0d\n  if (!ready) {\x0d\n    assert(!controller[kState].queueTotalSize);\x0d\n    assert(desc.bytesFilled > 0);\x0d\n    assert(desc.bytesFilled < elementSize);\x0d\n  }\x0d\n  return ready;\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(\x0d\n  controller) {\x0d\n  const {\x0d\n    closeRequested\x2C\x0d\n    pendingPullIntos\x2C\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  assert(!closeRequested);\x0d\n  while (pendingPullIntos.length) {\x0d\n    if (!controller[kState].queueTotalSize)\x0d\n      return;\x0d\n    const desc = pendingPullIntos[0];\x0d\n    if (readableByteStreamControllerFillPullIntoDescriptorFromQueue(\x0d\n      controller\x2C\x0d\n      desc)) {\x0d\n      readableByteStreamControllerShiftPendingPullInto(controller);\x0d\n      readableByteStreamControllerCommitPullIntoDescriptor(stream\x2C desc);\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerRespondInReadableState(\x0d\n  controller\x2C\x0d\n  bytesWritten\x2C\x0d\n  desc) {\x0d\n  const {\x0d\n    buffer\x2C\x0d\n    bytesFilled\x2C\x0d\n    byteLength\x2C\x0d\n  } = desc;\x0d\n\x0d\n  if (bytesFilled + bytesWritten > byteLength)\x0d\n    throw new ERR_INVALID_STATE.RangeError('The buffer size is invalid');\x0d\n\x0d\n  readableByteStreamControllerFillHeadPullIntoDescriptor(\x0d\n    controller\x2C\x0d\n    bytesWritten\x2C\x0d\n    desc);\x0d\n\x0d\n  if (desc.bytesFilled < desc.elementSize)\x0d\n    return;\x0d\n\x0d\n  readableByteStreamControllerShiftPendingPullInto(controller);\x0d\n\x0d\n  const remainderSize = desc.bytesFilled % desc.elementSize;\x0d\n\x0d\n  if (remainderSize) {\x0d\n    const end = desc.byteOffset + desc.bytesFilled;\x0d\n    const start = end - remainderSize;\x0d\n    const remainder =\x0d\n      ArrayBufferPrototypeSlice(\x0d\n        buffer\x2C\x0d\n        start\x2C\x0d\n        end);\x0d\n    readableByteStreamControllerEnqueueChunkToQueue(\x0d\n      controller\x2C\x0d\n      remainder\x2C\x0d\n      0\x2C\x0d\n      ArrayBufferGetByteLength(remainder));\x0d\n  }\x0d\n  desc.bytesFilled -= remainderSize;\x0d\n  readableByteStreamControllerCommitPullIntoDescriptor(\x0d\n    controller[kState].stream\x2C\x0d\n    desc);\x0d\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerRespondWithNewView(controller\x2C view) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n    pendingPullIntos\x2C\x0d\n  } = controller[kState];\x0d\n  assert(pendingPullIntos.length);\x0d\n\x0d\n  const desc = pendingPullIntos[0];\x0d\n  assert(stream[kState].state !== 'errored');\x0d\n\x0d\n  if (!isArrayBufferView(view)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'view'\x2C\x0d\n      [\x0d\n        'Buffer'\x2C\x0d\n        'TypedArray'\x2C\x0d\n        'DataView'\x2C\x0d\n      ]\x2C\x0d\n      view);\x0d\n  }\x0d\n  const viewByteLength = ArrayBufferViewGetByteLength(view);\x0d\n  const viewByteOffset = ArrayBufferViewGetByteOffset(view);\x0d\n  const viewBuffer = ArrayBufferViewGetBuffer(view);\x0d\n  const viewBufferByteLength = ArrayBufferGetByteLength(viewBuffer);\x0d\n\x0d\n  const {\x0d\n    byteOffset\x2C\x0d\n    byteLength\x2C\x0d\n    bytesFilled\x2C\x0d\n    bufferByteLength\x2C\x0d\n  } = desc;\x0d\n\x0d\n  if (byteOffset + bytesFilled !== viewByteOffset)\x0d\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\x0d\n\x0d\n  if (bytesFilled + viewByteOffset > byteLength)\x0d\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\x0d\n\x0d\n  if (bufferByteLength !== viewBufferByteLength)\x0d\n    throw new ERR_INVALID_ARG_VALUE.RangeError('view'\x2C view);\x0d\n\x0d\n  desc.buffer = transferArrayBuffer(viewBuffer);\x0d\n\x0d\n  readableByteStreamControllerRespondInternal(controller\x2C viewByteLength);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerShiftPendingPullInto(controller) {\x0d\n  assert(controller[kState].byobRequest === null);\x0d\n  return ArrayPrototypeShift(controller[kState].pendingPullIntos);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerCallPullIfNeeded(controller) {\x0d\n  if (!readableByteStreamControllerShouldCallPull(controller))\x0d\n    return;\x0d\n  if (controller[kState].pulling) {\x0d\n    controller[kState].pullAgain = true;\x0d\n    return;\x0d\n  }\x0d\n  assert(!controller[kState].pullAgain);\x0d\n  controller[kState].pulling = true;\x0d\n  PromisePrototypeThen(\x0d\n    ensureIsPromise(controller[kState].pullAlgorithm\x2C controller)\x2C\x0d\n    () => {\x0d\n      controller[kState].pulling = false;\x0d\n      if (controller[kState].pullAgain) {\x0d\n        controller[kState].pullAgain = false;\x0d\n        readableByteStreamControllerCallPullIfNeeded(controller);\x0d\n      }\x0d\n    }\x2C\x0d\n    (error) => readableByteStreamControllerError(controller\x2C error));\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerError(controller\x2C error) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  if (stream[kState].state !== 'readable')\x0d\n    return;\x0d\n  readableByteStreamControllerClearPendingPullIntos(controller);\x0d\n  resetQueue(controller);\x0d\n  readableByteStreamControllerClearAlgorithms(controller);\x0d\n  readableStreamError(stream\x2C error);\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerCancelSteps(controller\x2C reason) {\x0d\n  readableByteStreamControllerClearPendingPullIntos(controller);\x0d\n  resetQueue(controller);\x0d\n  const result = controller[kState].cancelAlgorithm(reason);\x0d\n  readableByteStreamControllerClearAlgorithms(controller);\x0d\n  return result;\x0d\n}\x0d\n\x0d\nfunction readableByteStreamControllerPullSteps(controller\x2C readRequest) {\x0d\n  const {\x0d\n    pendingPullIntos\x2C\x0d\n    queue\x2C\x0d\n    queueTotalSize\x2C\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  assert(readableStreamHasDefaultReader(stream));\x0d\n  if (queueTotalSize) {\x0d\n    assert(!readableStreamGetNumReadRequests(stream));\x0d\n    const {\x0d\n      buffer\x2C\x0d\n      byteOffset\x2C\x0d\n      byteLength\x2C\x0d\n    } = ArrayPrototypeShift(queue);\x0d\n    controller[kState].queueTotalSize -= byteLength;\x0d\n    readableByteStreamControllerHandleQueueDrain(controller);\x0d\n    const view = new Uint8Array(buffer\x2C byteOffset\x2C byteLength);\x0d\n    readRequest[kChunk](view);\x0d\n    return;\x0d\n  }\x0d\n  const {\x0d\n    autoAllocateChunkSize\x2C\x0d\n  } = controller[kState];\x0d\n  if (autoAllocateChunkSize !== undefined) {\x0d\n    try {\x0d\n      const buffer = new ArrayBuffer(autoAllocateChunkSize);\x0d\n      ArrayPrototypePush(\x0d\n        pendingPullIntos\x2C\x0d\n        {\x0d\n          buffer\x2C\x0d\n          byteOffset: 0\x2C\x0d\n          byteLength: autoAllocateChunkSize\x2C\x0d\n          bytesFilled: 0\x2C\x0d\n          elementSize: 1\x2C\x0d\n          ctor: Uint8Array\x2C\x0d\n          type: 'default'\x2C\x0d\n        });\x0d\n    } catch (error) {\x0d\n      readRequest[kError](error);\x0d\n      return;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  readableStreamAddReadRequest(stream\x2C readRequest);\x0d\n  readableByteStreamControllerCallPullIfNeeded(controller);\x0d\n}\x0d\n\x0d\nfunction setupReadableByteStreamController(\x0d\n  stream\x2C\x0d\n  controller\x2C\x0d\n  startAlgorithm\x2C\x0d\n  pullAlgorithm\x2C\x0d\n  cancelAlgorithm\x2C\x0d\n  highWaterMark\x2C\x0d\n  autoAllocateChunkSize) {\x0d\n  assert(stream[kState].controller === undefined);\x0d\n  if (autoAllocateChunkSize !== undefined) {\x0d\n    assert(NumberIsInteger(autoAllocateChunkSize));\x0d\n    assert(autoAllocateChunkSize > 0);\x0d\n  }\x0d\n  controller[kState] = {\x0d\n    byobRequest: null\x2C\x0d\n    closeRequested: false\x2C\x0d\n    pullAgain: false\x2C\x0d\n    pulling: false\x2C\x0d\n    started: false\x2C\x0d\n    stream\x2C\x0d\n    queue: []\x2C\x0d\n    queueTotalSize: 0\x2C\x0d\n    highWaterMark\x2C\x0d\n    pullAlgorithm\x2C\x0d\n    cancelAlgorithm\x2C\x0d\n    autoAllocateChunkSize\x2C\x0d\n    pendingPullIntos: []\x2C\x0d\n  };\x0d\n  stream[kState].controller = controller;\x0d\n\x0d\n  const startResult = startAlgorithm();\x0d\n\x0d\n  PromisePrototypeThen(\x0d\n    PromiseResolve(startResult)\x2C\x0d\n    () => {\x0d\n      controller[kState].started = true;\x0d\n      assert(!controller[kState].pulling);\x0d\n      assert(!controller[kState].pullAgain);\x0d\n      readableByteStreamControllerCallPullIfNeeded(controller);\x0d\n    }\x2C\x0d\n    (error) => readableByteStreamControllerError(controller\x2C error));\x0d\n}\x0d\n\x0d\nfunction setupReadableByteStreamControllerFromSource(\x0d\n  stream\x2C\x0d\n  source\x2C\x0d\n  highWaterMark) {\x0d\n  const controller = createReadableByteStreamController();\x0d\n  const start = source?.start;\x0d\n  const pull = source?.pull;\x0d\n  const cancel = source?.cancel;\x0d\n  const autoAllocateChunkSize = source?.autoAllocateChunkSize;\x0d\n  const startAlgorithm = start ?\x0d\n    FunctionPrototypeBind(start\x2C source\x2C controller) :\x0d\n    nonOpStart;\x0d\n  const pullAlgorithm = pull ?\x0d\n    FunctionPrototypeBind(pull\x2C source\x2C controller) :\x0d\n    nonOpPull;\x0d\n  const cancelAlgorithm = cancel ?\x0d\n    FunctionPrototypeBind(cancel\x2C source) :\x0d\n    nonOpCancel;\x0d\n\x0d\n  if (autoAllocateChunkSize === 0) {\x0d\n    throw new ERR_INVALID_ARG_VALUE(\x0d\n      'source.autoAllocateChunkSize'\x2C\x0d\n      autoAllocateChunkSize);\x0d\n  }\x0d\n  setupReadableByteStreamController(\x0d\n    stream\x2C\x0d\n    controller\x2C\x0d\n    startAlgorithm\x2C\x0d\n    pullAlgorithm\x2C\x0d\n    cancelAlgorithm\x2C\x0d\n    highWaterMark\x2C\x0d\n    autoAllocateChunkSize);\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  ReadableStream\x2C\x0d\n  ReadableStreamDefaultReader\x2C\x0d\n  ReadableStreamBYOBReader\x2C\x0d\n  ReadableStreamBYOBRequest\x2C\x0d\n  ReadableByteStreamController\x2C\x0d\n  ReadableStreamDefaultController\x2C\x0d\n  TransferredReadableStream\x2C\x0d\n\x0d\n  // Exported Brand Checks\x0d\n  isReadableStream\x2C\x0d\n  isReadableByteStreamController\x2C\x0d\n  isReadableStreamBYOBRequest\x2C\x0d\n  isReadableStreamDefaultReader\x2C\x0d\n  isReadableStreamBYOBReader\x2C\x0d\n  isWritableStreamDefaultWriter\x2C\x0d\n  isWritableStreamDefaultController\x2C\x0d\n\x0d\n  readableStreamPipeTo\x2C\x0d\n  readableStreamTee\x2C\x0d\n  readableByteStreamControllerConvertPullIntoDescriptor\x2C\x0d\n  isReadableStreamLocked\x2C\x0d\n  readableStreamCancel\x2C\x0d\n  readableStreamClose\x2C\x0d\n  readableStreamError\x2C\x0d\n  readableStreamHasDefaultReader\x2C\x0d\n  readableStreamGetNumReadRequests\x2C\x0d\n  readableStreamHasBYOBReader\x2C\x0d\n  readableStreamGetNumReadIntoRequests\x2C\x0d\n  readableStreamFulfillReadRequest\x2C\x0d\n  readableStreamFulfillReadIntoRequest\x2C\x0d\n  readableStreamAddReadRequest\x2C\x0d\n  readableStreamAddReadIntoRequest\x2C\x0d\n  readableStreamReaderGenericCancel\x2C\x0d\n  readableStreamReaderGenericInitialize\x2C\x0d\n  readableStreamReaderGenericRelease\x2C\x0d\n  readableStreamBYOBReaderRead\x2C\x0d\n  readableStreamDefaultReaderRead\x2C\x0d\n  setupReadableStreamBYOBReader\x2C\x0d\n  setupReadableStreamDefaultReader\x2C\x0d\n  readableStreamDefaultControllerClose\x2C\x0d\n  readableStreamDefaultControllerEnqueue\x2C\x0d\n  readableStreamDefaultControllerHasBackpressure\x2C\x0d\n  readableStreamDefaultControllerCanCloseOrEnqueue\x2C\x0d\n  readableStreamDefaultControllerGetDesiredSize\x2C\x0d\n  readableStreamDefaultControllerShouldCallPull\x2C\x0d\n  readableStreamDefaultControllerCallPullIfNeeded\x2C\x0d\n  readableStreamDefaultControllerClearAlgorithms\x2C\x0d\n  readableStreamDefaultControllerError\x2C\x0d\n  readableStreamDefaultControllerCancelSteps\x2C\x0d\n  readableStreamDefaultControllerPullSteps\x2C\x0d\n  setupReadableStreamDefaultController\x2C\x0d\n  setupReadableStreamDefaultControllerFromSource\x2C\x0d\n  readableByteStreamControllerClose\x2C\x0d\n  readableByteStreamControllerCommitPullIntoDescriptor\x2C\x0d\n  readableByteStreamControllerInvalidateBYOBRequest\x2C\x0d\n  readableByteStreamControllerClearAlgorithms\x2C\x0d\n  readableByteStreamControllerClearPendingPullIntos\x2C\x0d\n  readableByteStreamControllerGetDesiredSize\x2C\x0d\n  readableByteStreamControllerShouldCallPull\x2C\x0d\n  readableByteStreamControllerHandleQueueDrain\x2C\x0d\n  readableByteStreamControllerPullInto\x2C\x0d\n  readableByteStreamControllerRespondInternal\x2C\x0d\n  readableByteStreamControllerRespond\x2C\x0d\n  readableByteStreamControllerRespondInClosedState\x2C\x0d\n  readableByteStreamControllerFillHeadPullIntoDescriptor\x2C\x0d\n  readableByteStreamControllerEnqueue\x2C\x0d\n  readableByteStreamControllerEnqueueChunkToQueue\x2C\x0d\n  readableByteStreamControllerFillPullIntoDescriptorFromQueue\x2C\x0d\n  readableByteStreamControllerProcessPullIntoDescriptorsUsingQueue\x2C\x0d\n  readableByteStreamControllerRespondInReadableState\x2C\x0d\n  readableByteStreamControllerRespondWithNewView\x2C\x0d\n  readableByteStreamControllerShiftPendingPullInto\x2C\x0d\n  readableByteStreamControllerCallPullIfNeeded\x2C\x0d\n  readableByteStreamControllerError\x2C\x0d\n  readableByteStreamControllerCancelSteps\x2C\x0d\n  readableByteStreamControllerPullSteps\x2C\x0d\n  setupReadableByteStreamController\x2C\x0d\n  setupReadableByteStreamControllerFromSource\x2C\x0d\n};\x0d\n\x0d\n/* eslint-enable no-use-before-define */\x0d\n
code-source-info,0x109c10cd016,118,0,79330,C0O0C4O79330,,
code-creation,Function,10,211021,0x109c10d2f7e,3524, node:internal/webstreams/readablestream:1:1,0x109c10ccf90,~
code-source-info,0x109c10d2f7e,118,0,79330,C0O0C655O73C661O89C667O119C673O142C679O166C685O183C691O209C697O235C703O247C709O267C715O284C720O311C726O336C732O348C738O374C744O399C750O418C756O436C762O451C768O472C773O483C779O507C784O529C790O725C794O725C800O725C806O587C812O617C818O645C824O672C830O696C836O786C840O786C846O767C852O869C856O869C862O830C868O852C874O977C878O977C884O915C890O962C895O1049C899O1049C905O1017C911O1031C917O1099C921O1099C927O1078C933O1160C937O1160C943O1145C949O1233C953O1233C959O1212C965O1350C969O1350C975O1278C980O1295C985O1309C990O1327C996O1429C1000O1429C1006O1408C1012O1534C1016O1534C1022O1484C1027O1501C1032O1516C1037O2062C1041O2062C1047O1583C1053O1612C1059O1645C1065O1678C1071O1707C1077O1725C1083O1745C1089O1763C1095O1780C1101O1800C1107O1825C1113O1850C1119O1875C1125O1892C1130O1909C1136O1924C1142O1946C1148O1970C1154O1986C1160O2000C1166O2015C1172O2025C1178O2036C1183O2468C1187O2468C1193O2113C1199O2147C1205O2168C1211O2195C1216O2233C1221O2269C1227O2293C1233O2333C1239O2390C1245O2429C1251O2533C1255O2533C1259O2533C1261O2580C1265O2580C1269O2580C1271O2615C1275O2615C1279O2615C1281O2649C1285O2649C1289O2649C1291O2683C1295O2683C1299O2683C1301O2716C1305O2716C1309O2716C1331O4247C1341O4284C1349O5919C1359O5988C1369O6065C1421O14457C1431O14719C1441O15532C1451O15721C1487O4220C1489O15943C1493O15981C1507O15998C1509O16020C1519O16119C1525O16129C1546O16154C1557O16186C1568O16221C1579O16258C1590O16290C1601O16319C1606O15943C1611O16827C1617O16837C1621O16851C1645O16904C1655O16952C1681O18603C1717O16866C1719O18776C1723O18825C1737O18847C1743O18880C1749O18924C1753O18776C1771O19342C1781O19423C1791O19509C1819O19240C1834O19723C1844O19804C1854O19884C1882O19624C1904O20039C1914O20089C1946O22259C1982O19999C1984O22497C1988O22548C2002O22572C2008O22602C2014O22639C2020O22671C2024O22497C2049O22737C2059O22784C2091O25776C2131O22700C2133O26028C2137O26076C2158O26100C2168O26130C2178O26167C2188O26199C2196O26028C2226O26272C2236O26326C2270O27216C2285O27316C2298O27415C2344O26228C2346O27515C2350O27570C2371O27599C2381O27630C2391O27663C2401O27694C2409O27515C2446O28010C2456O28061C2514O31059C2529O31156C2542O31252C2588O27969C2590O31352C2594O31404C2615O31433C2625O31470C2635O31501C2645O31534C2655O31565C2663O31352C2673O32602C2679O32602C2687O32602C2689O32677C2695O32677C2703O32677C2705O32763C2711O32763C2719O32763C2721O32848C2727O32848C2735O32848C2737O32932C2743O32932C2751O32932C2753O76145C2764O76167C2774O76186C2784O76218C2794O76247C2804O76277C2814O76310C2824O76346C2834O76406C2844O76427C2854O76462C2864O76494C2874O76528C2884O76559C2894O76593C2904O76633C2914O76658C2924O76680C2934O76738C2944O76765C2954O76790C2964O76814C2974O76838C2984O76873C2994O76910C3004O76942C3014O76983C3024O77020C3034O77061C3044O77094C3054O77131C3064O77169C3074O77211C3084O77250C3094O77283C3104O77319C3114O77353C3124O77390C3134O77431C3144O77474C3154O77525C3164O77578C3174O77628C3184O77678C3194O77730C3204O77781C3214O77822C3224O77869C3234O77914C3244O77955C3254O78006C3264O78044C3274O78101C3284O78155C3294O78203C3304O78257C3314O78304C3324O78351C3334O78400C3344O78441C3354O78489C3364O78529C3374O78582C3384O78641C3394O78681C3404O78733C3414O78797C3424O78866C3434O78921C3444O78972C3454O79025C3464O79074C3474O79112C3484O79156C3494O79198C3504O79236C3514O76160C3523O79329,,
code-creation,Function,10,211319,0x109c10d421e,16,<instance_members_initializer> node:internal/webstreams/readablestream:1035:3,0x109c10cfe78,~
code-source-info,0x109c10d421e,118,28009,28049,C3O28019C15O28049,,
code-creation,Function,10,211341,0x109c10d4296,16,<instance_members_initializer> node:internal/webstreams/readablestream:965:3,0x109c10cfae0,~
code-source-info,0x109c10d4296,118,26271,26314,C3O26281C15O26314,,
code-creation,Function,10,211361,0x109c10d4316,16,<instance_members_initializer> node:internal/webstreams/readablestream:848:3,0x109c10cf7b8,~
code-source-info,0x109c10d4316,118,22736,22772,C3O22746C15O22772,,
code-creation,Function,10,211381,0x109c10d438e,16,<instance_members_initializer> node:internal/webstreams/readablestream:754:3,0x109c10cf530,~
code-source-info,0x109c10d438e,118,20038,20077,C3O20048C15O20077,,
code-creation,Function,10,211402,0x109c10d4406,16,<instance_members_initializer> node:internal/webstreams/readablestream:622:3,0x109c10cef48,~
code-source-info,0x109c10d4406,118,16903,16940,C3O16913C15O16940,,
code-creation,Function,10,211422,0x109c10d447e,16,<instance_members_initializer> node:internal/webstreams/readablestream:201:3,0x109c10cec88,~
code-source-info,0x109c10d447e,118,4246,4272,C3O4256C15O4272,,
code-creation,Eval,10,211882,0x109c10db25e,5, node:internal/webstreams/util:1:1,0x109c10dafa8,~
script-source,119,node:internal/webstreams/util,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayBufferPrototype\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeShift\x2C\x0d\n  AsyncIteratorPrototype\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  MathMax\x2C\x0d\n  NumberIsNaN\x2C\x0d\n  ObjectCreate\x2C\x0d\n  PromisePrototypeThen\x2C\x0d\n  PromiseResolve\x2C\x0d\n  PromiseReject\x2C\x0d\n  ReflectGet\x2C\x0d\n  Symbol\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_OPERATION_FAILED\x2C\x0d\n  }\x2C\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  copyArrayBuffer\x2C\x0d\n  detachArrayBuffer\x0d\n} = internalBinding('buffer');\x0d\n\x0d\nconst {\x0d\n  isPromise\x2C\x0d\n} = require('internal/util/types');\x0d\n\x0d\nconst {\x0d\n  inspect\x2C\x0d\n} = require('util');\x0d\n\x0d\nconst {\x0d\n  getPromiseDetails\x2C\x0d\n  kPending\x2C\x0d\n} = internalBinding('util');\x0d\n\x0d\nconst assert = require('internal/assert');\x0d\n\x0d\nconst kState = Symbol('kState');\x0d\nconst kType = Symbol('kType');\x0d\n\x0d\nconst AsyncIterator = ObjectCreate(AsyncIteratorPrototype\x2C {\x0d\n  next: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x2C\x0d\n    writable: true\x2C\x0d\n  }\x2C\x0d\n  return: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x2C\x0d\n    writable: true\x2C\x0d\n  }\x2C\x0d\n});\x0d\n\x0d\nfunction extractHighWaterMark(value\x2C defaultHWM) {\x0d\n  if (value === undefined) return defaultHWM;\x0d\n  value = +value;\x0d\n  if (typeof value !== 'number' ||\x0d\n      NumberIsNaN(value) ||\x0d\n      value < 0)\x0d\n    throw new ERR_INVALID_ARG_VALUE.RangeError('strategy.highWaterMark'\x2C value);\x0d\n  return value;\x0d\n}\x0d\n\x0d\nfunction extractSizeAlgorithm(size) {\x0d\n  if (size === undefined) return () => 1;\x0d\n  if (typeof size !== 'function')\x0d\n    throw new ERR_INVALID_ARG_TYPE('strategy.size'\x2C 'Function'\x2C size);\x0d\n  return size;\x0d\n}\x0d\n\x0d\nfunction customInspect(depth\x2C options\x2C name\x2C data) {\x0d\n  if (depth < 0)\x0d\n    return this;\x0d\n\x0d\n  const opts = {\x0d\n    ...options\x2C\x0d\n    depth: options.depth == null ? null : options.depth - 1\x0d\n  };\x0d\n\x0d\n  return `${name} ${inspect(data\x2C opts)}`;\x0d\n}\x0d\n\x0d\n// These are defensive to work around the possibility that\x0d\n// the buffer\x2C byteLength\x2C and byteOffset properties on\x0d\n// ArrayBuffer and ArrayBufferView's may have been tampered with.\x0d\n\x0d\nfunction ArrayBufferViewGetBuffer(view) {\x0d\n  return ReflectGet(view.constructor.prototype\x2C 'buffer'\x2C view);\x0d\n}\x0d\n\x0d\nfunction ArrayBufferViewGetByteLength(view) {\x0d\n  return ReflectGet(view.constructor.prototype\x2C 'byteLength'\x2C view);\x0d\n}\x0d\n\x0d\nfunction ArrayBufferViewGetByteOffset(view) {\x0d\n  return ReflectGet(view.constructor.prototype\x2C 'byteOffset'\x2C view);\x0d\n}\x0d\n\x0d\nfunction ArrayBufferGetByteLength(view) {\x0d\n  return ReflectGet(ArrayBufferPrototype\x2C 'byteLength'\x2C view);\x0d\n}\x0d\n\x0d\nfunction isBrandCheck(brand) {\x0d\n  return (value) => {\x0d\n    return value != null &&\x0d\n           value[kState] !== undefined &&\x0d\n           value[kType] === brand;\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction transferArrayBuffer(buffer) {\x0d\n  const res = detachArrayBuffer(buffer);\x0d\n  if (res === undefined) {\x0d\n    throw new ERR_OPERATION_FAILED.TypeError(\x0d\n      'The ArrayBuffer could not be transferred');\x0d\n  }\x0d\n  return res;\x0d\n}\x0d\n\x0d\nfunction dequeueValue(controller) {\x0d\n  assert(controller[kState].queue !== undefined);\x0d\n  assert(controller[kState].queueTotalSize !== undefined);\x0d\n  assert(controller[kState].queue.length);\x0d\n  const {\x0d\n    value\x2C\x0d\n    size\x2C\x0d\n  } = ArrayPrototypeShift(controller[kState].queue);\x0d\n  controller[kState].queueTotalSize =\x0d\n    MathMax(0\x2C controller[kState].queueTotalSize - size);\x0d\n  return value;\x0d\n}\x0d\n\x0d\nfunction resetQueue(controller) {\x0d\n  assert(controller[kState].queue !== undefined);\x0d\n  assert(controller[kState].queueTotalSize !== undefined);\x0d\n  controller[kState].queue = [];\x0d\n  controller[kState].queueTotalSize = 0;\x0d\n}\x0d\n\x0d\nfunction peekQueueValue(controller) {\x0d\n  assert(controller[kState].queue !== undefined);\x0d\n  assert(controller[kState].queueTotalSize !== undefined);\x0d\n  assert(controller[kState].queue.length);\x0d\n  return controller[kState].queue[0].value;\x0d\n}\x0d\n\x0d\nfunction enqueueValueWithSize(controller\x2C value\x2C size) {\x0d\n  assert(controller[kState].queue !== undefined);\x0d\n  assert(controller[kState].queueTotalSize !== undefined);\x0d\n  size = +size;\x0d\n  if (typeof size !== 'number' ||\x0d\n      size < 0 ||\x0d\n      NumberIsNaN(size) ||\x0d\n      size === Infinity) {\x0d\n    throw new ERR_INVALID_ARG_VALUE.RangeError('size'\x2C size);\x0d\n  }\x0d\n  ArrayPrototypePush(controller[kState].queue\x2C { value\x2C size });\x0d\n  controller[kState].queueTotalSize += size;\x0d\n}\x0d\n\x0d\nfunction ensureIsPromise(fn\x2C thisArg\x2C ...args) {\x0d\n  try {\x0d\n    const value = FunctionPrototypeCall(fn\x2C thisArg\x2C ...args);\x0d\n    return isPromise(value) ? value : PromiseResolve(value);\x0d\n  } catch (error) {\x0d\n    return PromiseReject(error);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction isPromisePending(promise) {\x0d\n  if (promise === undefined) return false;\x0d\n  const details = getPromiseDetails(promise);\x0d\n  return details?.[0] === kPending;\x0d\n}\x0d\n\x0d\nfunction setPromiseHandled(promise) {\x0d\n  // Alternatively\x2C we could use the native API\x0d\n  // MarkAsHandled\x2C but this avoids the extra boundary cross\x0d\n  // and is hopefully faster at the cost of an extra Promise\x0d\n  // allocation.\x0d\n  PromisePrototypeThen(promise\x2C () => {}\x2C () => {});\x0d\n}\x0d\n\x0d\nasync function nonOpFlush() {}\x0d\n\x0d\nfunction nonOpStart() {}\x0d\n\x0d\nasync function nonOpPull() {}\x0d\n\x0d\nasync function nonOpCancel() {}\x0d\n\x0d\nasync function nonOpWrite() {}\x0d\n\x0d\nlet transfer;\x0d\nfunction lazyTransfer() {\x0d\n  if (transfer === undefined)\x0d\n    transfer = require('internal/webstreams/transfer');\x0d\n  return transfer;\x0d\n}\x0d\n\x0d\nconst kEnumerableProperty = ObjectCreate(null);\x0d\nkEnumerableProperty.enumerable = true;\x0d\n\x0d\nmodule.exports = {\x0d\n  ArrayBufferViewGetBuffer\x2C\x0d\n  ArrayBufferViewGetByteLength\x2C\x0d\n  ArrayBufferViewGetByteOffset\x2C\x0d\n  ArrayBufferGetByteLength\x2C\x0d\n  AsyncIterator\x2C\x0d\n  copyArrayBuffer\x2C\x0d\n  customInspect\x2C\x0d\n  dequeueValue\x2C\x0d\n  ensureIsPromise\x2C\x0d\n  enqueueValueWithSize\x2C\x0d\n  extractHighWaterMark\x2C\x0d\n  extractSizeAlgorithm\x2C\x0d\n  lazyTransfer\x2C\x0d\n  isBrandCheck\x2C\x0d\n  isPromisePending\x2C\x0d\n  peekQueueValue\x2C\x0d\n  resetQueue\x2C\x0d\n  setPromiseHandled\x2C\x0d\n  transferArrayBuffer\x2C\x0d\n  nonOpCancel\x2C\x0d\n  nonOpFlush\x2C\x0d\n  nonOpPull\x2C\x0d\n  nonOpStart\x2C\x0d\n  nonOpWrite\x2C\x0d\n  kType\x2C\x0d\n  kState\x2C\x0d\n  kEnumerableProperty\x2C\x0d\n};\x0d\n
code-source-info,0x109c10db25e,119,0,5939,C0O0C4O5939,,
code-creation,Function,10,212218,0x109c10dbece,631, node:internal/webstreams/util:1:1,0x109c10db1d8,~
code-source-info,0x109c10dbece,119,0,5939,C0O0C196O28C202O53C208O76C214O100C219O127C225O153C231O165C237O181C242O198C248O223C254O242C260O260C266O275C271O417C279O417C285O417C291O329C297O356C303O384C309O502C313O502C319O459C324O479C330O559C338O559C344O543C350O619C358O619C364O605C370O687C374O687C380O650C386O672C392O730C400O730C404O730C406O776C410O776C414O776C416O809C420O809C424O809C426O864C432O851C438O5126C439O5126C441O5305C444O5305C450O5326C451O5357C455O5368C463O5390C469O5419C475O5452C481O5485C487O5514C493O5532C499O5552C505O5570C511O5587C517O5607C523O5632C529O5657C535O5682C541O5699C547O5716C553O5737C559O5756C565O5771C571O5793C577O5817C583O5833C589O5848C595O5862C601O5877C607O5892C613O5902C619O5913C625O5383C630O5938,,
code-creation,Eval,10,213127,0x109c10de35e,5, node:internal/webstreams/writablestream:1:1,0x109c10ddb50,~
script-source,120,node:internal/webstreams/writablestream,'use strict';\x0d\n\x0d\n/* eslint-disable no-use-before-define */\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeShift\x2C\x0d\n  FunctionPrototypeBind\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  PromisePrototypeThen\x2C\x0d\n  PromiseResolve\x2C\x0d\n  PromiseReject\x2C\x0d\n  ReflectConstruct\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolToStringTag\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_ILLEGAL_CONSTRUCTOR\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_STATE\x2C\x0d\n    ERR_INVALID_THIS\x2C\x0d\n  }\x2C\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  DOMException\x2C\x0d\n} = internalBinding('messaging');\x0d\n\x0d\nconst {\x0d\n  createDeferredPromise\x2C\x0d\n  customInspectSymbol: kInspect\x2C\x0d\n} = require('internal/util');\x0d\n\x0d\nconst {\x0d\n  MessageChannel\x2C\x0d\n} = require('internal/worker/io');\x0d\n\x0d\nconst {\x0d\n  kDeserialize\x2C\x0d\n  kTransfer\x2C\x0d\n  kTransferList\x2C\x0d\n  makeTransferable\x2C\x0d\n} = require('internal/worker/js_transferable');\x0d\n\x0d\nconst {\x0d\n  customInspect\x2C\x0d\n  dequeueValue\x2C\x0d\n  ensureIsPromise\x2C\x0d\n  enqueueValueWithSize\x2C\x0d\n  extractHighWaterMark\x2C\x0d\n  extractSizeAlgorithm\x2C\x0d\n  lazyTransfer\x2C\x0d\n  isBrandCheck\x2C\x0d\n  isPromisePending\x2C\x0d\n  peekQueueValue\x2C\x0d\n  resetQueue\x2C\x0d\n  setPromiseHandled\x2C\x0d\n  nonOpCancel\x2C\x0d\n  nonOpStart\x2C\x0d\n  nonOpWrite\x2C\x0d\n  kType\x2C\x0d\n  kState\x2C\x0d\n  kEnumerableProperty\x2C\x0d\n} = require('internal/webstreams/util');\x0d\n\x0d\nconst {\x0d\n  AbortController\x2C\x0d\n} = require('internal/abort_controller');\x0d\n\x0d\nconst assert = require('internal/assert');\x0d\n\x0d\nconst kAbort = Symbol('kAbort');\x0d\nconst kCloseSentinel = Symbol('kCloseSentinel');\x0d\nconst kError = Symbol('kError');\x0d\n\x0d\n/**\x0d\n * @typedef {import('../abort_controller').AbortSignal} AbortSignal\x0d\n * @typedef {import('./queuingstrategies').QueuingStrategy\x0d\n * } QueuingStrategy\x0d\n * @typedef {import('./queuingstrategies').QueuingStrategySize\x0d\n * } QueuingStrategySize\x0d\n */\x0d\n\x0d\n/**\x0d\n * @callback UnderlyingSinkStartCallback\x0d\n * @param {WritableStreamDefaultController} controller\x0d\n */\x0d\n\x0d\n/**\x0d\n * @callback UnderlyingSinkWriteCallback\x0d\n * @param {any} chunk\x0d\n * @param {WritableStreamDefaultController} controller\x0d\n * @returns {Promise<void>}\x0d\n */\x0d\n\x0d\n/**\x0d\n * @callback UnderlyingSinkCloseCallback\x0d\n * @returns {Promise<void>}\x0d\n */\x0d\n\x0d\n/**\x0d\n * @callback UnderlyingSinkAbortCallback\x0d\n * @param {any} reason\x0d\n * @returns {Promise<void>}\x0d\n */\x0d\n\x0d\n/**\x0d\n * @typedef {{\x0d\n *   start? : UnderlyingSinkStartCallback\x2C\x0d\n *   write? : UnderlyingSinkWriteCallback\x2C\x0d\n *   close? : UnderlyingSinkCloseCallback\x2C\x0d\n *   abort? : UnderlyingSinkAbortCallback\x2C\x0d\n *   type? : any\x2C\x0d\n * }} UnderlyingSink\x0d\n */\x0d\n\x0d\nclass WritableStream {\x0d\n  [kType] = 'WritableStream';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  /**\x0d\n   * @param {UnderlyingSink} [sink]\x0d\n   * @param {QueuingStrategy} [strategy]\x0d\n   */\x0d\n  constructor(sink = null\x2C strategy = {}) {\x0d\n    const type = sink?.type;\x0d\n    if (type !== undefined)\x0d\n      throw new ERR_INVALID_ARG_VALUE.RangeError('type'\x2C type);\x0d\n\x0d\n    this[kState] = {\x0d\n      close: createDeferredPromise()\x2C\x0d\n      closeRequest: {\x0d\n        promise: undefined\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      }\x2C\x0d\n      inFlightWriteRequest: {\x0d\n        promise: undefined\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      }\x2C\x0d\n      inFlightCloseRequest: {\x0d\n        promise: undefined\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      }\x2C\x0d\n      pendingAbortRequest: {\x0d\n        abort: {\x0d\n          promise: undefined\x2C\x0d\n          resolve: undefined\x2C\x0d\n          reject: undefined\x2C\x0d\n        }\x2C\x0d\n        reason: undefined\x2C\x0d\n        wasAlreadyErroring: false\x2C\x0d\n      }\x2C\x0d\n      backpressure: false\x2C\x0d\n      controller: undefined\x2C\x0d\n      state: 'writable'\x2C\x0d\n      storedError: undefined\x2C\x0d\n      writeRequests: []\x2C\x0d\n      writer: undefined\x2C\x0d\n      transfer: {\x0d\n        readable: undefined\x2C\x0d\n        port1: undefined\x2C\x0d\n        port2: undefined\x2C\x0d\n        promise: undefined\x2C\x0d\n      }\x0d\n    };\x0d\n\x0d\n    const size = extractSizeAlgorithm(strategy?.size);\x0d\n    const highWaterMark = extractHighWaterMark(strategy?.highWaterMark\x2C 1);\x0d\n\x0d\n    setupWritableStreamDefaultControllerFromSink(\x0d\n      this\x2C\x0d\n      sink\x2C\x0d\n      highWaterMark\x2C\x0d\n      size);\x0d\n\x0d\n    // eslint-disable-next-line no-constructor-return\x0d\n    return makeTransferable(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {boolean}\x0d\n   */\x0d\n  get locked() {\x0d\n    if (!isWritableStream(this))\x0d\n      throw new ERR_INVALID_THIS('WritableStream');\x0d\n    return isWritableStreamLocked(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} reason\x0d\n   * @returns {Promise<vois>}\x0d\n   */\x0d\n  abort(reason = undefined) {\x0d\n    if (!isWritableStream(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('WritableStream'));\x0d\n    if (isWritableStreamLocked(this)) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError('WritableStream is locked'));\x0d\n    }\x0d\n    return writableStreamAbort(this\x2C reason);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @returns {Promise<void>}\x0d\n   */\x0d\n  close() {\x0d\n    if (!isWritableStream(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('WritableStream'));\x0d\n    if (isWritableStreamLocked(this)) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError('WritableStream is locked'));\x0d\n    }\x0d\n    if (writableStreamCloseQueuedOrInFlight(this)) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError('Failure closing WritableStream'));\x0d\n    }\x0d\n    return writableStreamClose(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @returns {WritableStreamDefaultWriter}\x0d\n   */\x0d\n  getWriter() {\x0d\n    if (!isWritableStream(this))\x0d\n      throw new ERR_INVALID_THIS('WritableStream');\x0d\n    return new WritableStreamDefaultWriter(this);\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\x0d\n      locked: this.locked\x2C\x0d\n      state: this[kState].state\x2C\x0d\n    });\x0d\n  }\x0d\n\x0d\n  [kTransfer]() {\x0d\n    if (!isWritableStream(this))\x0d\n      throw new ERR_INVALID_THIS('WritableStream');\x0d\n    if (this.locked) {\x0d\n      this[kState].transfer.port1?.close();\x0d\n      this[kState].transfer.port1 = undefined;\x0d\n      this[kState].transfer.port2 = undefined;\x0d\n      throw new DOMException(\x0d\n        'Cannot transfer a locked WritableStream'\x2C\x0d\n        'DataCloneError');\x0d\n    }\x0d\n\x0d\n    const {\x0d\n      readable\x2C\x0d\n      promise\x2C\x0d\n    } = lazyTransfer().newCrossRealmReadableStream(\x0d\n      this\x2C\x0d\n      this[kState].transfer.port1);\x0d\n\x0d\n    this[kState].transfer.readable = readable;\x0d\n    this[kState].transfer.promise = promise;\x0d\n\x0d\n    setPromiseHandled(this[kState].transfer.promise);\x0d\n\x0d\n    return {\x0d\n      data: { port: this[kState].transfer.port2 }\x2C\x0d\n      deserializeInfo:\x0d\n        'internal/webstreams/writablestream:TransferredWritableStream'\x0d\n    };\x0d\n  }\x0d\n\x0d\n  [kTransferList]() {\x0d\n    const { port1\x2C port2 } = new MessageChannel();\x0d\n    this[kState].transfer.port1 = port1;\x0d\n    this[kState].transfer.port2 = port2;\x0d\n    return [ port2 ];\x0d\n  }\x0d\n\x0d\n  [kDeserialize]({ port }) {\x0d\n    const transfer = lazyTransfer();\x0d\n    setupWritableStreamDefaultControllerFromSink(\x0d\n      this\x2C\x0d\n      new transfer.CrossRealmTransformWritableSink(port)\x2C\x0d\n      1\x2C\x0d\n      () => 1);\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(WritableStream.prototype\x2C {\x0d\n  locked: kEnumerableProperty\x2C\x0d\n  abort: kEnumerableProperty\x2C\x0d\n  close: kEnumerableProperty\x2C\x0d\n  getWriter: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nfunction TransferredWritableStream() {\x0d\n  return makeTransferable(ReflectConstruct(\x0d\n    function() {\x0d\n      this[kType] = 'WritableStream';\x0d\n      this[kState] = {\x0d\n        close: createDeferredPromise()\x2C\x0d\n        closeRequest: {\x0d\n          promise: undefined\x2C\x0d\n          resolve: undefined\x2C\x0d\n          reject: undefined\x2C\x0d\n        }\x2C\x0d\n        inFlightWriteRequest: {\x0d\n          promise: undefined\x2C\x0d\n          resolve: undefined\x2C\x0d\n          reject: undefined\x2C\x0d\n        }\x2C\x0d\n        inFlightCloseRequest: {\x0d\n          promise: undefined\x2C\x0d\n          resolve: undefined\x2C\x0d\n          reject: undefined\x2C\x0d\n        }\x2C\x0d\n        pendingAbortRequest: {\x0d\n          abort: {\x0d\n            promise: undefined\x2C\x0d\n            resolve: undefined\x2C\x0d\n            reject: undefined\x2C\x0d\n          }\x2C\x0d\n          reason: undefined\x2C\x0d\n          wasAlreadyErroring: false\x2C\x0d\n        }\x2C\x0d\n        backpressure: false\x2C\x0d\n        controller: undefined\x2C\x0d\n        state: 'writable'\x2C\x0d\n        storedError: undefined\x2C\x0d\n        writeRequests: []\x2C\x0d\n        writer: undefined\x2C\x0d\n        transfer: {\x0d\n          promise: undefined\x2C\x0d\n          port1: undefined\x2C\x0d\n          port2: undefined\x2C\x0d\n          readable: undefined\x2C\x0d\n        }\x2C\x0d\n      };\x0d\n    }\x2C\x0d\n    []\x2C WritableStream));\x0d\n}\x0d\nTransferredWritableStream.prototype[kDeserialize] = () => {};\x0d\n\x0d\nclass WritableStreamDefaultWriter {\x0d\n  [kType] = 'WritableStreamDefaultWriter';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  /**\x0d\n   * @param {WritableStream} stream\x0d\n   */\x0d\n  constructor(stream) {\x0d\n    if (!isWritableStream(stream))\x0d\n      throw new ERR_INVALID_ARG_TYPE('stream'\x2C 'WritableStream'\x2C stream);\x0d\n    this[kState] = {\x0d\n      stream: undefined\x2C\x0d\n      close: {\x0d\n        promise: undefined\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      }\x2C\x0d\n      ready: {\x0d\n        promise: undefined\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      }\x0d\n    };\x0d\n    setupWritableStreamDefaultWriter(this\x2C stream);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {Promise<void>}\x0d\n   */\x0d\n  get closed() {\x0d\n    if (!isWritableStreamDefaultWriter(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\x0d\n    return this[kState].close.promise;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {number}\x0d\n   */\x0d\n  get desiredSize() {\x0d\n    if (!isWritableStreamDefaultWriter(this))\x0d\n      throw new ERR_INVALID_THIS('WritableStreamDefaultWriter');\x0d\n    if (this[kState].stream === undefined) {\x0d\n      throw new ERR_INVALID_STATE.TypeError(\x0d\n        'Writer is not bound to a WritableStream');\x0d\n    }\x0d\n    return writableStreamDefaultWriterGetDesiredSize(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {Promise<void>}\x0d\n   */\x0d\n  get ready() {\x0d\n    if (!isWritableStreamDefaultWriter(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\x0d\n    return this[kState].ready.promise;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} reason\x0d\n   * @returns {Promise<void>}\x0d\n   */\x0d\n  abort(reason = undefined) {\x0d\n    if (!isWritableStreamDefaultWriter(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\x0d\n    if (this[kState].stream === undefined) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError(\x0d\n          'Writer is not bound to a WritableStream'));\x0d\n    }\x0d\n    return writableStreamDefaultWriterAbort(this\x2C reason);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @returns {Promise<void>}\x0d\n   */\x0d\n  close() {\x0d\n    if (!isWritableStreamDefaultWriter(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\x0d\n    const {\x0d\n      stream\x2C\x0d\n    } = this[kState];\x0d\n    if (stream === undefined) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError(\x0d\n          'Writer is not bound to a WritableStream'));\x0d\n    }\x0d\n    if (writableStreamCloseQueuedOrInFlight(stream)) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError('Failure to close WritableStream'));\x0d\n    }\x0d\n    return writableStreamDefaultWriterClose(this);\x0d\n  }\x0d\n\x0d\n  releaseLock() {\x0d\n    if (!isWritableStreamDefaultWriter(this))\x0d\n      throw new ERR_INVALID_THIS('WritableStreamDefaultWriter');\x0d\n    const {\x0d\n      stream\x2C\x0d\n    } = this[kState];\x0d\n    if (stream === undefined)\x0d\n      return;\x0d\n    assert(stream[kState].writer !== undefined);\x0d\n    writableStreamDefaultWriterRelease(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} chunk\x0d\n   * @returns {Promise<void>}\x0d\n   */\x0d\n  write(chunk = undefined) {\x0d\n    if (!isWritableStreamDefaultWriter(this))\x0d\n      return PromiseReject(new ERR_INVALID_THIS('WritableStreamDefaultWriter'));\x0d\n    if (this[kState].stream === undefined) {\x0d\n      return PromiseReject(\x0d\n        new ERR_INVALID_STATE.TypeError(\x0d\n          'Writer is not bound to a WritableStream'));\x0d\n    }\x0d\n    return writableStreamDefaultWriterWrite(this\x2C chunk);\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\x0d\n      stream: this[kState].stream\x2C\x0d\n      close: this[kState].close.promise\x2C\x0d\n      ready: this[kState].ready.promise\x2C\x0d\n      desiredSize: this.desiredSize\x2C\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(WritableStreamDefaultWriter.prototype\x2C {\x0d\n  closed: kEnumerableProperty\x2C\x0d\n  ready: kEnumerableProperty\x2C\x0d\n  desiredSize: kEnumerableProperty\x2C\x0d\n  abort: kEnumerableProperty\x2C\x0d\n  close: kEnumerableProperty\x2C\x0d\n  releaseLock: kEnumerableProperty\x2C\x0d\n  write: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nclass WritableStreamDefaultController {\x0d\n  [kType] = 'WritableStreamDefaultController';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  constructor() {\x0d\n    throw new ERR_ILLEGAL_CONSTRUCTOR();\x0d\n  }\x0d\n\x0d\n  [kAbort](reason) {\x0d\n    const result = this[kState].abortAlgorithm(reason);\x0d\n    writableStreamDefaultControllerClearAlgorithms(this);\x0d\n    return result;\x0d\n  }\x0d\n\x0d\n  [kError]() {\x0d\n    resetQueue(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {any}\x0d\n   */\x0d\n  get abortReason() {\x0d\n    if (!isWritableStreamDefaultController(this))\x0d\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\x0d\n    return this[kState].abortReason;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {AbortSignal}\x0d\n   */\x0d\n  get signal() {\x0d\n    if (!isWritableStreamDefaultController(this))\x0d\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\x0d\n    return this[kState].abortController.signal;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {any} error\x0d\n   */\x0d\n  error(error = undefined) {\x0d\n    if (!isWritableStreamDefaultController(this))\x0d\n      throw new ERR_INVALID_THIS('WritableStreamDefaultController');\x0d\n    if (this[kState].stream[kState].state !== 'writable')\x0d\n      return;\x0d\n    writableStreamDefaultControllerError(this\x2C error);\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\x0d\n      stream: this[kState].stream\x2C\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(WritableStreamDefaultController.prototype\x2C {\x0d\n  abortReason: kEnumerableProperty\x2C\x0d\n  signal: kEnumerableProperty\x2C\x0d\n  error: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nfunction createWritableStreamDefaultController() {\x0d\n  return ReflectConstruct(\x0d\n    function() {\x0d\n      this[kType] = 'WritableStreamDefaultController';\x0d\n    }\x2C\x0d\n    []\x2C WritableStreamDefaultController);\x0d\n}\x0d\n\x0d\nconst isWritableStream =\x0d\n  isBrandCheck('WritableStream');\x0d\nconst isWritableStreamDefaultWriter =\x0d\n  isBrandCheck('WritableStreamDefaultWriter');\x0d\nconst isWritableStreamDefaultController =\x0d\n  isBrandCheck('WritableStreamDefaultController');\x0d\n\x0d\nfunction isWritableStreamLocked(stream) {\x0d\n  return stream[kState].writer !== undefined;\x0d\n}\x0d\n\x0d\nfunction setupWritableStreamDefaultWriter(writer\x2C stream) {\x0d\n  if (isWritableStreamLocked(stream))\x0d\n    throw new ERR_INVALID_STATE.TypeError('WritableStream is locked');\x0d\n  writer[kState].stream = stream;\x0d\n  stream[kState].writer = writer;\x0d\n  switch (stream[kState].state) {\x0d\n    case 'writable':\x0d\n      if (!writableStreamCloseQueuedOrInFlight(stream) &&\x0d\n          stream[kState].backpressure) {\x0d\n        writer[kState].ready = createDeferredPromise();\x0d\n      } else {\x0d\n        writer[kState].ready = {\x0d\n          promise: PromiseResolve()\x2C\x0d\n          resolve: undefined\x2C\x0d\n          reject: undefined\x2C\x0d\n        };\x0d\n      }\x0d\n      setClosedPromiseToNewPromise();\x0d\n      break;\x0d\n    case 'erroring':\x0d\n      writer[kState].ready = {\x0d\n        promise: PromiseReject(stream[kState].storedError)\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      };\x0d\n      setPromiseHandled(writer[kState].ready.promise);\x0d\n      setClosedPromiseToNewPromise();\x0d\n      break;\x0d\n    case 'closed':\x0d\n      writer[kState].ready = {\x0d\n        promise: PromiseResolve()\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      };\x0d\n      writer[kState].close = {\x0d\n        promise: PromiseResolve()\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      };\x0d\n      break;\x0d\n    default:\x0d\n      writer[kState].ready = {\x0d\n        promise: PromiseReject(stream[kState].storedError)\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      };\x0d\n      writer[kState].close = {\x0d\n        promise: PromiseReject(stream[kState].storedError)\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      };\x0d\n      setPromiseHandled(writer[kState].ready.promise);\x0d\n      setPromiseHandled(writer[kState].close.promise);\x0d\n  }\x0d\n\x0d\n  function setClosedPromiseToNewPromise() {\x0d\n    writer[kState].close = createDeferredPromise();\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction writableStreamAbort(stream\x2C reason) {\x0d\n  const {\x0d\n    state\x2C\x0d\n    controller\x2C\x0d\n  } = stream[kState];\x0d\n  if (state === 'closed' || state === 'errored')\x0d\n    return PromiseResolve();\x0d\n\x0d\n  controller[kState].abortReason = reason;\x0d\n  controller[kState].abortController.abort();\x0d\n\x0d\n  if (stream[kState].pendingAbortRequest.abort.promise !== undefined)\x0d\n    return stream[kState].pendingAbortRequest.abort.promise;\x0d\n\x0d\n  assert(state === 'writable' || state === 'erroring');\x0d\n\x0d\n  let wasAlreadyErroring = false;\x0d\n  if (state === 'erroring') {\x0d\n    wasAlreadyErroring = true;\x0d\n    reason = undefined;\x0d\n  }\x0d\n\x0d\n  const abort = createDeferredPromise();\x0d\n\x0d\n  stream[kState].pendingAbortRequest = {\x0d\n    abort\x2C\x0d\n    reason\x2C\x0d\n    wasAlreadyErroring\x2C\x0d\n  };\x0d\n\x0d\n  if (!wasAlreadyErroring)\x0d\n    writableStreamStartErroring(stream\x2C reason);\x0d\n\x0d\n  return abort.promise;\x0d\n}\x0d\n\x0d\nfunction writableStreamClose(stream) {\x0d\n  const {\x0d\n    state\x2C\x0d\n    writer\x2C\x0d\n    backpressure\x2C\x0d\n    controller\x2C\x0d\n  } = stream[kState];\x0d\n  if (state === 'closed' || state === 'errored') {\x0d\n    return PromiseReject(\x0d\n      new ERR_INVALID_STATE.TypeError('WritableStream is closed'));\x0d\n  }\x0d\n  assert(state === 'writable' || state === 'erroring');\x0d\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\x0d\n  stream[kState].closeRequest = createDeferredPromise();\x0d\n  const { promise } = stream[kState].closeRequest;\x0d\n  if (writer !== undefined && backpressure && state === 'writable')\x0d\n    writer[kState].ready.resolve?.();\x0d\n  writableStreamDefaultControllerClose(controller);\x0d\n  return promise;\x0d\n}\x0d\n\x0d\nfunction writableStreamUpdateBackpressure(stream\x2C backpressure) {\x0d\n  assert(stream[kState].state === 'writable');\x0d\n  assert(!writableStreamCloseQueuedOrInFlight(stream));\x0d\n  const {\x0d\n    writer\x2C\x0d\n  } = stream[kState];\x0d\n  if (writer !== undefined && stream[kState].backpressure !== backpressure) {\x0d\n    if (backpressure) {\x0d\n      writer[kState].ready = createDeferredPromise();\x0d\n    } else {\x0d\n      writer[kState].ready.resolve?.();\x0d\n    }\x0d\n  }\x0d\n  stream[kState].backpressure = backpressure;\x0d\n}\x0d\n\x0d\nfunction writableStreamStartErroring(stream\x2C reason) {\x0d\n  assert(stream[kState].storedError === undefined);\x0d\n  assert(stream[kState].state === 'writable');\x0d\n  const {\x0d\n    controller\x2C\x0d\n    writer\x2C\x0d\n  } = stream[kState];\x0d\n  assert(controller !== undefined);\x0d\n  stream[kState].state = 'erroring';\x0d\n  stream[kState].storedError = reason;\x0d\n  if (writer !== undefined) {\x0d\n    writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C reason);\x0d\n  }\x0d\n  if (!writableStreamHasOperationMarkedInFlight(stream) &&\x0d\n      controller[kState].started) {\x0d\n    writableStreamFinishErroring(stream);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction writableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\x0d\n  assert(stream[kState].state === 'errored');\x0d\n  if (stream[kState].closeRequest.promise !== undefined) {\x0d\n    assert(stream[kState].inFlightCloseRequest.promise === undefined);\x0d\n    stream[kState].closeRequest.reject?.(stream[kState].storedError);\x0d\n    stream[kState].closeRequest = {\x0d\n      promise: undefined\x2C\x0d\n      reject: undefined\x2C\x0d\n      resolve: undefined\x2C\x0d\n    };\x0d\n  }\x0d\n  const {\x0d\n    writer\x2C\x0d\n  } = stream[kState];\x0d\n  if (writer !== undefined) {\x0d\n    writer[kState].close.reject?.(stream[kState].storedError);\x0d\n    setPromiseHandled(writer[kState].close.promise);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction writableStreamMarkFirstWriteRequestInFlight(stream) {\x0d\n  assert(stream[kState].inFlightWriteRequest.promise === undefined);\x0d\n  assert(stream[kState].writeRequests.length);\x0d\n  const writeRequest = ArrayPrototypeShift(stream[kState].writeRequests);\x0d\n  stream[kState].inFlightWriteRequest = writeRequest;\x0d\n}\x0d\n\x0d\nfunction writableStreamMarkCloseRequestInFlight(stream) {\x0d\n  assert(stream[kState].inFlightWriteRequest.promise === undefined);\x0d\n  assert(stream[kState].closeRequest.promise !== undefined);\x0d\n  stream[kState].inFlightCloseRequest = stream[kState].closeRequest;\x0d\n  stream[kState].closeRequest = {\x0d\n    promise: undefined\x2C\x0d\n    resolve: undefined\x2C\x0d\n    reject: undefined\x2C\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction writableStreamHasOperationMarkedInFlight(stream) {\x0d\n  const {\x0d\n    inFlightWriteRequest\x2C\x0d\n    inFlightCloseRequest\x2C\x0d\n  } = stream[kState];\x0d\n  if (inFlightWriteRequest.promise === undefined &&\x0d\n      inFlightCloseRequest.promise === undefined) {\x0d\n    return false;\x0d\n  }\x0d\n  return true;\x0d\n}\x0d\n\x0d\nfunction writableStreamFinishInFlightWriteWithError(stream\x2C error) {\x0d\n  assert(stream[kState].inFlightWriteRequest.promise !== undefined);\x0d\n  stream[kState].inFlightWriteRequest.reject?.(error);\x0d\n  stream[kState].inFlightWriteRequest = {\x0d\n    promise: undefined\x2C\x0d\n    resolve: undefined\x2C\x0d\n    reject: undefined\x2C\x0d\n  };\x0d\n  assert(stream[kState].state === 'writable' ||\x0d\n         stream[kState].state === 'erroring');\x0d\n  writableStreamDealWithRejection(stream\x2C error);\x0d\n}\x0d\n\x0d\nfunction writableStreamFinishInFlightWrite(stream) {\x0d\n  assert(stream[kState].inFlightWriteRequest.promise !== undefined);\x0d\n  stream[kState].inFlightWriteRequest.resolve?.();\x0d\n  stream[kState].inFlightWriteRequest = {\x0d\n    promise: undefined\x2C\x0d\n    resolve: undefined\x2C\x0d\n    reject: undefined\x2C\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction writableStreamFinishInFlightCloseWithError(stream\x2C error) {\x0d\n  assert(stream[kState].inFlightCloseRequest.promise !== undefined);\x0d\n  stream[kState].inFlightCloseRequest.reject?.(error);\x0d\n  stream[kState].inFlightCloseRequest = {\x0d\n    promise: undefined\x2C\x0d\n    resolve: undefined\x2C\x0d\n    reject: undefined\x2C\x0d\n  };\x0d\n  assert(stream[kState].state === 'writable' ||\x0d\n         stream[kState].state === 'erroring');\x0d\n  if (stream[kState].pendingAbortRequest.abort.promise !== undefined) {\x0d\n    stream[kState].pendingAbortRequest.abort.reject?.(error);\x0d\n    stream[kState].pendingAbortRequest = {\x0d\n      abort: {\x0d\n        promise: undefined\x2C\x0d\n        resolve: undefined\x2C\x0d\n        reject: undefined\x2C\x0d\n      }\x2C\x0d\n      reason: undefined\x2C\x0d\n      wasAlreadyErroring: false\x2C\x0d\n    };\x0d\n  }\x0d\n  writableStreamDealWithRejection(stream\x2C error);\x0d\n}\x0d\n\x0d\nfunction writableStreamFinishInFlightClose(stream) {\x0d\n  assert(stream[kState].inFlightCloseRequest.promise !== undefined);\x0d\n  stream[kState].inFlightCloseRequest.resolve?.();\x0d\n  stream[kState].inFlightCloseRequest = {\x0d\n    promise: undefined\x2C\x0d\n    resolve: undefined\x2C\x0d\n    reject: undefined\x2C\x0d\n  };\x0d\n  if (stream[kState].state === 'erroring') {\x0d\n    stream[kState].storedError = undefined;\x0d\n    if (stream[kState].pendingAbortRequest.abort.promise !== undefined) {\x0d\n      stream[kState].pendingAbortRequest.abort.resolve?.();\x0d\n      stream[kState].pendingAbortRequest = {\x0d\n        abort: {\x0d\n          promise: undefined\x2C\x0d\n          resolve: undefined\x2C\x0d\n          reject: undefined\x2C\x0d\n        }\x2C\x0d\n        reason: undefined\x2C\x0d\n        wasAlreadyErroring: false\x2C\x0d\n      };\x0d\n    }\x0d\n  }\x0d\n  stream[kState].state = 'closed';\x0d\n  if (stream[kState].writer !== undefined)\x0d\n    stream[kState].writer[kState].close.resolve?.();\x0d\n  assert(stream[kState].pendingAbortRequest.abort.promise === undefined);\x0d\n  assert(stream[kState].storedError === undefined);\x0d\n}\x0d\n\x0d\nfunction writableStreamFinishErroring(stream) {\x0d\n  assert(stream[kState].state === 'erroring');\x0d\n  assert(!writableStreamHasOperationMarkedInFlight(stream));\x0d\n  stream[kState].state = 'errored';\x0d\n  stream[kState].controller[kError]();\x0d\n  const storedError = stream[kState].storedError;\x0d\n  for (let n = 0; n < stream[kState].writeRequests.length; n++)\x0d\n    stream[kState].writeRequests[n].reject?.(storedError);\x0d\n  stream[kState].writeRequests = [];\x0d\n\x0d\n  if (stream[kState].pendingAbortRequest.abort.promise === undefined) {\x0d\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  const abortRequest = stream[kState].pendingAbortRequest;\x0d\n  stream[kState].pendingAbortRequest = {\x0d\n    abort: {\x0d\n      promise: undefined\x2C\x0d\n      resolve: undefined\x2C\x0d\n      reject: undefined\x2C\x0d\n    }\x2C\x0d\n    reason: undefined\x2C\x0d\n    wasAlreadyErroring: false\x2C\x0d\n  };\x0d\n  if (abortRequest.wasAlreadyErroring) {\x0d\n    abortRequest.abort.reject?.(storedError);\x0d\n    writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\x0d\n    return;\x0d\n  }\x0d\n  PromisePrototypeThen(\x0d\n    ensureIsPromise(\x0d\n      stream[kState].controller[kAbort]\x2C\x0d\n      stream[kState].controller\x2C\x0d\n      abortRequest.reason)\x2C\x0d\n    () => {\x0d\n      abortRequest.abort.resolve?.();\x0d\n      writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\x0d\n    }\x2C\x0d\n    (error) => {\x0d\n      abortRequest.abort.reject?.(error);\x0d\n      writableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\x0d\n    });\x0d\n}\x0d\n\x0d\nfunction writableStreamDealWithRejection(stream\x2C error) {\x0d\n  const {\x0d\n    state\x2C\x0d\n  } = stream[kState];\x0d\n  if (state === 'writable') {\x0d\n    writableStreamStartErroring(stream\x2C error);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  assert(state === 'erroring');\x0d\n  writableStreamFinishErroring(stream);\x0d\n}\x0d\n\x0d\nfunction writableStreamCloseQueuedOrInFlight(stream) {\x0d\n  if (stream[kState].closeRequest.promise === undefined &&\x0d\n      stream[kState].inFlightCloseRequest.promise === undefined) {\x0d\n    return false;\x0d\n  }\x0d\n  return true;\x0d\n}\x0d\n\x0d\nfunction writableStreamAddWriteRequest(stream) {\x0d\n  assert(isWritableStreamLocked(stream));\x0d\n  assert(stream[kState].state === 'writable');\x0d\n  const {\x0d\n    promise\x2C\x0d\n    resolve\x2C\x0d\n    reject\x2C\x0d\n  } = createDeferredPromise();\x0d\n  ArrayPrototypePush(\x0d\n    stream[kState].writeRequests\x2C\x0d\n    {\x0d\n      promise\x2C\x0d\n      resolve\x2C\x0d\n      reject\x2C\x0d\n    });\x0d\n  return promise;\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultWriterWrite(writer\x2C chunk) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = writer[kState];\x0d\n  assert(stream !== undefined);\x0d\n  const {\x0d\n    controller\x2C\x0d\n  } = stream[kState];\x0d\n  const chunkSize = writableStreamDefaultControllerGetChunkSize(\x0d\n    controller\x2C\x0d\n    chunk);\x0d\n  if (stream !== writer[kState].stream) {\x0d\n    return PromiseReject(\x0d\n      new ERR_INVALID_STATE.TypeError('Mismatched WritableStreams'));\x0d\n  }\x0d\n  const {\x0d\n    state\x2C\x0d\n  } = stream[kState];\x0d\n\x0d\n  if (state === 'errored')\x0d\n    return PromiseReject(stream[kState].storedError);\x0d\n\x0d\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\x0d\n    return PromiseReject(\x0d\n      new ERR_INVALID_STATE.TypeError('WritableStream is closed'));\x0d\n  }\x0d\n\x0d\n  if (state === 'erroring')\x0d\n    return PromiseReject(stream[kState].storedError);\x0d\n\x0d\n  assert(state === 'writable');\x0d\n\x0d\n  const promise = writableStreamAddWriteRequest(stream);\x0d\n  writableStreamDefaultControllerWrite(controller\x2C chunk\x2C chunkSize);\x0d\n  return promise;\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultWriterRelease(writer) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = writer[kState];\x0d\n  assert(stream !== undefined);\x0d\n  assert(stream[kState].writer === writer);\x0d\n  const releasedError =\x0d\n    new ERR_INVALID_STATE.TypeError('Writer has been released');\x0d\n  writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C releasedError);\x0d\n  writableStreamDefaultWriterEnsureClosedPromiseRejected(writer\x2C releasedError);\x0d\n  stream[kState].writer = undefined;\x0d\n  writer[kState].stream = undefined;\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultWriterGetDesiredSize(writer) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = writer[kState];\x0d\n  switch (stream[kState].state) {\x0d\n    case 'errored':\x0d\n      // Fall through\x0d\n    case 'erroring':\x0d\n      return null;\x0d\n    case 'closed':\x0d\n      return 0;\x0d\n  }\x0d\n  return writableStreamDefaultControllerGetDesiredSize(\x0d\n    stream[kState].controller);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultWriterEnsureReadyPromiseRejected(writer\x2C error) {\x0d\n  if (isPromisePending(writer[kState].ready.promise)) {\x0d\n    writer[kState].ready.reject?.(error);\x0d\n  } else {\x0d\n    writer[kState].ready = {\x0d\n      promise: PromiseReject(error)\x2C\x0d\n      resolve: undefined\x2C\x0d\n      reject: undefined\x2C\x0d\n    };\x0d\n  }\x0d\n  setPromiseHandled(writer[kState].ready.promise);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultWriterEnsureClosedPromiseRejected(writer\x2C error) {\x0d\n  if (isPromisePending(writer[kState].close.promise)) {\x0d\n    writer[kState].close.reject?.(error);\x0d\n  } else {\x0d\n    writer[kState].close = {\x0d\n      promise: PromiseReject(error)\x2C\x0d\n      resolve: undefined\x2C\x0d\n      reject: undefined\x2C\x0d\n    };\x0d\n  }\x0d\n  setPromiseHandled(writer[kState].close.promise);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultWriterCloseWithErrorPropagation(writer) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = writer[kState];\x0d\n  assert(stream !== undefined);\x0d\n  const {\x0d\n    state\x2C\x0d\n  } = stream[kState];\x0d\n  if (writableStreamCloseQueuedOrInFlight(stream) || state === 'closed')\x0d\n    return PromiseResolve();\x0d\n\x0d\n  if (state === 'errored')\x0d\n    return PromiseReject(stream[kState].storedError);\x0d\n\x0d\n  assert(state === 'writable' || state === 'erroring');\x0d\n\x0d\n  return writableStreamDefaultWriterClose(writer);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultWriterClose(writer) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = writer[kState];\x0d\n  assert(stream !== undefined);\x0d\n  return writableStreamClose(stream);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultWriterAbort(writer\x2C reason) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = writer[kState];\x0d\n  assert(stream !== undefined);\x0d\n  return writableStreamAbort(stream\x2C reason);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerWrite(controller\x2C chunk\x2C chunkSize) {\x0d\n  try {\x0d\n    enqueueValueWithSize(controller\x2C chunk\x2C chunkSize);\x0d\n  } catch (error) {\x0d\n    writableStreamDefaultControllerErrorIfNeeded(controller\x2C error);\x0d\n    return;\x0d\n  }\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  if (!writableStreamCloseQueuedOrInFlight(stream) &&\x0d\n      stream[kState].state === 'writable') {\x0d\n    writableStreamUpdateBackpressure(\x0d\n      stream\x2C\x0d\n      writableStreamDefaultControllerGetBackpressure(controller));\x0d\n  }\x0d\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerProcessWrite(controller\x2C chunk) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n    writeAlgorithm\x2C\x0d\n  } = controller[kState];\x0d\n  writableStreamMarkFirstWriteRequestInFlight(stream);\x0d\n\x0d\n  PromisePrototypeThen(\x0d\n    ensureIsPromise(writeAlgorithm\x2C controller\x2C chunk\x2C controller)\x2C\x0d\n    () => {\x0d\n      writableStreamFinishInFlightWrite(stream);\x0d\n      const {\x0d\n        state\x2C\x0d\n      } = stream[kState];\x0d\n      assert(state === 'writable' || state === 'erroring');\x0d\n      dequeueValue(controller);\x0d\n      if (!writableStreamCloseQueuedOrInFlight(stream) &&\x0d\n          state === 'writable') {\x0d\n        writableStreamUpdateBackpressure(\x0d\n          stream\x2C\x0d\n          writableStreamDefaultControllerGetBackpressure(controller));\x0d\n      }\x0d\n      writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\x0d\n    }\x2C\x0d\n    (error) => {\x0d\n      if (stream[kState].state === 'writable')\x0d\n        writableStreamDefaultControllerClearAlgorithms(controller);\x0d\n      writableStreamFinishInFlightWriteWithError(stream\x2C error);\x0d\n    });\x0d\n\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerProcessClose(controller) {\x0d\n  const {\x0d\n    closeAlgorithm\x2C\x0d\n    queue\x2C\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  writableStreamMarkCloseRequestInFlight(stream);\x0d\n  dequeueValue(controller);\x0d\n  assert(!queue.length);\x0d\n  const sinkClosePromise = ensureIsPromise(closeAlgorithm\x2C controller);\x0d\n  writableStreamDefaultControllerClearAlgorithms(controller);\x0d\n  PromisePrototypeThen(\x0d\n    sinkClosePromise\x2C\x0d\n    () => writableStreamFinishInFlightClose(stream)\x2C\x0d\n    (error) => writableStreamFinishInFlightCloseWithError(stream\x2C error));\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerGetDesiredSize(controller) {\x0d\n  const {\x0d\n    highWaterMark\x2C\x0d\n    queueTotalSize\x2C\x0d\n  } = controller[kState];\x0d\n  return highWaterMark - queueTotalSize;\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerGetChunkSize(controller\x2C chunk) {\x0d\n  try {\x0d\n    return FunctionPrototypeCall(\x0d\n      controller[kState].sizeAlgorithm\x2C\x0d\n      undefined\x2C\x0d\n      chunk);\x0d\n  } catch (error) {\x0d\n    writableStreamDefaultControllerErrorIfNeeded(controller\x2C error);\x0d\n    return 1;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerErrorIfNeeded(controller\x2C error) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  if (stream[kState].state === 'writable')\x0d\n    writableStreamDefaultControllerError(controller\x2C error);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerError(controller\x2C error) {\x0d\n  const {\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  assert(stream[kState].state === 'writable');\x0d\n  writableStreamDefaultControllerClearAlgorithms(controller);\x0d\n  writableStreamStartErroring(stream\x2C error);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerClose(controller) {\x0d\n  enqueueValueWithSize(controller\x2C kCloseSentinel\x2C 0);\x0d\n  writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerClearAlgorithms(controller) {\x0d\n  controller[kState].writeAlgorithm = undefined;\x0d\n  controller[kState].closeAlgorithm = undefined;\x0d\n  controller[kState].abortAlgorithm = undefined;\x0d\n  controller[kState].sizeAlgorithm = undefined;\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerGetBackpressure(controller) {\x0d\n  return writableStreamDefaultControllerGetDesiredSize(controller) <= 0;\x0d\n}\x0d\n\x0d\nfunction writableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\x0d\n  const {\x0d\n    queue\x2C\x0d\n    started\x2C\x0d\n    stream\x2C\x0d\n  } = controller[kState];\x0d\n  if (!started || stream[kState].inFlightWriteRequest.promise !== undefined)\x0d\n    return;\x0d\n\x0d\n  if (stream[kState].state === 'erroring') {\x0d\n    writableStreamFinishErroring(stream);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (!queue.length)\x0d\n    return;\x0d\n\x0d\n  const value = peekQueueValue(controller);\x0d\n  if (value === kCloseSentinel)\x0d\n    writableStreamDefaultControllerProcessClose(controller);\x0d\n  else\x0d\n    writableStreamDefaultControllerProcessWrite(controller\x2C value);\x0d\n}\x0d\n\x0d\nfunction setupWritableStreamDefaultControllerFromSink(\x0d\n  stream\x2C\x0d\n  sink\x2C\x0d\n  highWaterMark\x2C\x0d\n  sizeAlgorithm) {\x0d\n  const controller = createWritableStreamDefaultController();\x0d\n  const start = sink?.start;\x0d\n  const write = sink?.write;\x0d\n  const close = sink?.close;\x0d\n  const abort = sink?.abort;\x0d\n  const startAlgorithm = start ?\x0d\n    FunctionPrototypeBind(start\x2C sink\x2C controller) :\x0d\n    nonOpStart;\x0d\n  const writeAlgorithm = write ?\x0d\n    FunctionPrototypeBind(write\x2C sink) :\x0d\n    nonOpWrite;\x0d\n  const closeAlgorithm = close ?\x0d\n    FunctionPrototypeBind(close\x2C sink) : nonOpCancel;\x0d\n  const abortAlgorithm = abort ?\x0d\n    FunctionPrototypeBind(abort\x2C sink) : nonOpCancel;\x0d\n  setupWritableStreamDefaultController(\x0d\n    stream\x2C\x0d\n    controller\x2C\x0d\n    startAlgorithm\x2C\x0d\n    writeAlgorithm\x2C\x0d\n    closeAlgorithm\x2C\x0d\n    abortAlgorithm\x2C\x0d\n    highWaterMark\x2C\x0d\n    sizeAlgorithm);\x0d\n}\x0d\n\x0d\nfunction setupWritableStreamDefaultController(\x0d\n  stream\x2C\x0d\n  controller\x2C\x0d\n  startAlgorithm\x2C\x0d\n  writeAlgorithm\x2C\x0d\n  closeAlgorithm\x2C\x0d\n  abortAlgorithm\x2C\x0d\n  highWaterMark\x2C\x0d\n  sizeAlgorithm) {\x0d\n  assert(isWritableStream(stream));\x0d\n  assert(stream[kState].controller === undefined);\x0d\n  controller[kState] = {\x0d\n    abortAlgorithm\x2C\x0d\n    abortReason: undefined\x2C\x0d\n    closeAlgorithm\x2C\x0d\n    highWaterMark\x2C\x0d\n    queue: []\x2C\x0d\n    queueTotalSize: 0\x2C\x0d\n    abortController: new AbortController()\x2C\x0d\n    sizeAlgorithm\x2C\x0d\n    started: false\x2C\x0d\n    stream\x2C\x0d\n    writeAlgorithm\x2C\x0d\n  };\x0d\n  stream[kState].controller = controller;\x0d\n\x0d\n  writableStreamUpdateBackpressure(\x0d\n    stream\x2C\x0d\n    writableStreamDefaultControllerGetBackpressure(controller));\x0d\n\x0d\n  const startResult = startAlgorithm();\x0d\n\x0d\n  PromisePrototypeThen(\x0d\n    PromiseResolve(startResult)\x2C\x0d\n    () => {\x0d\n      assert(stream[kState].state === 'writable' ||\x0d\n             stream[kState].state === 'erroring');\x0d\n      controller[kState].started = true;\x0d\n      writableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\x0d\n    }\x2C\x0d\n    (error) => {\x0d\n      assert(stream[kState].state === 'writable' ||\x0d\n             stream[kState].state === 'erroring');\x0d\n      controller[kState].started = true;\x0d\n      writableStreamDealWithRejection(stream\x2C error);\x0d\n    });\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  WritableStream\x2C\x0d\n  WritableStreamDefaultWriter\x2C\x0d\n  WritableStreamDefaultController\x2C\x0d\n  TransferredWritableStream\x2C\x0d\n\x0d\n  // Exported Brand Checks\x0d\n  isWritableStream\x2C\x0d\n  isWritableStreamDefaultController\x2C\x0d\n  isWritableStreamDefaultWriter\x2C\x0d\n\x0d\n  isWritableStreamLocked\x2C\x0d\n  setupWritableStreamDefaultWriter\x2C\x0d\n  writableStreamAbort\x2C\x0d\n  writableStreamClose\x2C\x0d\n  writableStreamUpdateBackpressure\x2C\x0d\n  writableStreamStartErroring\x2C\x0d\n  writableStreamRejectCloseAndClosedPromiseIfNeeded\x2C\x0d\n  writableStreamMarkFirstWriteRequestInFlight\x2C\x0d\n  writableStreamMarkCloseRequestInFlight\x2C\x0d\n  writableStreamHasOperationMarkedInFlight\x2C\x0d\n  writableStreamFinishInFlightWriteWithError\x2C\x0d\n  writableStreamFinishInFlightWrite\x2C\x0d\n  writableStreamFinishInFlightCloseWithError\x2C\x0d\n  writableStreamFinishInFlightClose\x2C\x0d\n  writableStreamFinishErroring\x2C\x0d\n  writableStreamDealWithRejection\x2C\x0d\n  writableStreamCloseQueuedOrInFlight\x2C\x0d\n  writableStreamAddWriteRequest\x2C\x0d\n  writableStreamDefaultWriterWrite\x2C\x0d\n  writableStreamDefaultWriterRelease\x2C\x0d\n  writableStreamDefaultWriterGetDesiredSize\x2C\x0d\n  writableStreamDefaultWriterEnsureReadyPromiseRejected\x2C\x0d\n  writableStreamDefaultWriterEnsureClosedPromiseRejected\x2C\x0d\n  writableStreamDefaultWriterCloseWithErrorPropagation\x2C\x0d\n  writableStreamDefaultWriterClose\x2C\x0d\n  writableStreamDefaultWriterAbort\x2C\x0d\n  writableStreamDefaultControllerWrite\x2C\x0d\n  writableStreamDefaultControllerProcessWrite\x2C\x0d\n  writableStreamDefaultControllerProcessClose\x2C\x0d\n  writableStreamDefaultControllerGetDesiredSize\x2C\x0d\n  writableStreamDefaultControllerGetChunkSize\x2C\x0d\n  writableStreamDefaultControllerErrorIfNeeded\x2C\x0d\n  writableStreamDefaultControllerError\x2C\x0d\n  writableStreamDefaultControllerClose\x2C\x0d\n  writableStreamDefaultControllerClearAlgorithms\x2C\x0d\n  writableStreamDefaultControllerGetBackpressure\x2C\x0d\n  writableStreamDefaultControllerAdvanceQueueIfNeeded\x2C\x0d\n  setupWritableStreamDefaultControllerFromSink\x2C\x0d\n  setupWritableStreamDefaultController\x2C\x0d\n};\x0d\n\x0d\n/* eslint-enable no-use-before-define */\x0d\n
code-source-info,0x109c10de35e,120,0,37951,C0O0C4O37951,,
code-creation,Function,10,215029,0x109c10e11fe,1564, node:internal/webstreams/writablestream:1:1,0x109c10de2d8,~
code-source-info,0x109c10e11fe,120,0,37951,C0O0C381O73C387O96C393O120C399O146C405O172C410O199C416O224C422O243C428O261C434O282C439O293C444O496C447O496C452O496C457O358C463O388C469O416C475O443C481O467C487O557C490O557C495O538C501O663C504O663C509O601C515O648C520O724C523O724C528O703C534O841C537O841C542O769C547O786C552O800C557O818C563O1233C566O1233C571O899C577O917C583O934C589O954C595O979C601O1004C607O1029C613O1046C618O1063C624O1084C630O1103C636O1118C642O1140C648O1156C654O1171C660O1186C666O1196C672O1207C677O1306C680O1306C685O1284C691O1362C694O1362C698O1362C700O1408C703O1408C707O1408C709O1450C712O1450C716O1450C718O1492C721O1492C725O1492C745O2500C755O2537C787O5534C797O5701C807O6573C817O6762C851O2473C853O6987C856O7025C868O7049C874O7080C880O7111C886O7146C890O6987C895O8436C900O8446C904O8460C926O8515C936O8565C986O11972C1020O8475C1022O12235C1025O12286C1037O12310C1043O12341C1049O12378C1055O12409C1061O12440C1067O12477C1073O12508C1077O12235C1100O12581C1110O12635C1120O12754C1132O12919C1160O13748C1194O12537C1196O13889C1199O13944C1211O13973C1217O14005C1223O14036C1227O13889C1232O14303C1235O14303C1239O14303C1241O14377C1244O14377C1248O14377C1250O14468C1253O14468C1257O14468C1259O35973C1266O35995C1272O36014C1278O36046C1284O36082C1290O36142C1296O36163C1302O36201C1308O36237C1314O36264C1320O36301C1326O36325C1332O36349C1338O36386C1344O36418C1350O36472C1356O36520C1362O36563C1368O36608C1374O36655C1380O36693C1386O36740C1392O36778C1398O36811C1404O36847C1410O36887C1416O36921C1422O36958C1428O36997C1434O37043C1440O37101C1446O37160C1452O37217C1458O37254C1464O37291C1470O37332C1476O37380C1482O37428C1488O37478C1494O37526C1500O37575C1506O37616C1512O37657C1518O37708C1524O37759C1534O37815C1544O37864C1554O35988C1563O37950,,
code-creation,Function,10,215211,0x109c10e1afe,16,<instance_members_initializer> node:internal/webstreams/writablestream:493:3,0x109c10dfb58,~
code-source-info,0x109c10e1afe,120,12580,12623,C3O12590C15O12623,,
code-creation,Function,10,215233,0x109c10e1b7e,16,<instance_members_initializer> node:internal/webstreams/writablestream:349:3,0x109c10df860,~
code-source-info,0x109c10e1b7e,120,8514,8553,C3O8524C15O8553,,
code-creation,Function,10,215253,0x109c10e1bf6,16,<instance_members_initializer> node:internal/webstreams/writablestream:122:3,0x109c10df418,~
code-source-info,0x109c10e1bf6,120,2499,2525,C3O2509C15O2525,,
code-creation,LazyCompile,10,215521,0x109c10e531e,14,isBrandCheck node:internal/webstreams/util:112:22,0x109c10db4c0,~
code-source-info,0x109c10e531e,119,2509,2658,C0O2509C9O2522C13O2655,,
code-creation,Eval,10,215987,0x109c10e63fe,5, node:internal/webstreams/queuingstrategies:1:1,0x109c10e6108,~
script-source,121,node:internal/webstreams/queuingstrategies,'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectDefineProperties\x2C\x0d\n  SymbolToStringTag\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_INVALID_THIS\x2C\x0d\n    ERR_MISSING_OPTION\x2C\x0d\n  }\x2C\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  customInspectSymbol: kInspect\x2C\x0d\n} = require('internal/util');\x0d\n\x0d\nconst {\x0d\n  customInspect\x2C\x0d\n  isBrandCheck\x2C\x0d\n  kType\x2C\x0d\n  kState\x2C\x0d\n  kEnumerableProperty\x2C\x0d\n} = require('internal/webstreams/util');\x0d\n\x0d\nconst {\x0d\n  validateObject\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst isByteLengthQueuingStrategy =\x0d\n  isBrandCheck('ByteLengthQueuingStrategy');\x0d\n\x0d\nconst isCountQueuingStrategy =\x0d\n  isBrandCheck('CountQueuingStrategy');\x0d\n\x0d\n/**\x0d\n * @callback QueuingStrategySize\x0d\n * @param {any} chunk\x0d\n * @returns {number}\x0d\n */\x0d\n\x0d\n/**\x0d\n * @typedef {{\x0d\n *   highWaterMark : number\x2C\x0d\n *   size? : QueuingStrategySize\x2C\x0d\n * }} QueuingStrategy\x0d\n */\x0d\n\x0d\n// eslint-disable-next-line func-name-matching\x2Cfunc-style\x0d\nconst byteSizeFunction = function size(chunk) { return chunk.byteLength; };\x0d\n\x0d\n// eslint-disable-next-line func-name-matching\x2Cfunc-style\x0d\nconst countSizeFunction = function size() { return 1; };\x0d\n\x0d\n/**\x0d\n * @type {QueuingStrategy}\x0d\n */\x0d\nclass ByteLengthQueuingStrategy {\x0d\n  [kType] = 'ByteLengthQueuingStrategy';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  /**\x0d\n   * @param {{\x0d\n   *   highWaterMark : number\x0d\n   * }} init\x0d\n   */\x0d\n  constructor(init) {\x0d\n    validateObject(init\x2C 'init');\x0d\n    if (init.highWaterMark === undefined)\x0d\n      throw new ERR_MISSING_OPTION('options.highWaterMark');\x0d\n\x0d\n    // The highWaterMark value is not checked until the strategy\x0d\n    // is actually used\x2C per the spec.\x0d\n    this[kState] = {\x0d\n      highWaterMark: +init.highWaterMark\x2C\x0d\n    };\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {number}\x0d\n   */\x0d\n  get highWaterMark() {\x0d\n    if (!isByteLengthQueuingStrategy(this))\x0d\n      throw new ERR_INVALID_THIS('ByteLengthQueuingStrategy');\x0d\n    return this[kState].highWaterMark;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {QueuingStrategySize}\x0d\n   */\x0d\n  get size() {\x0d\n    if (!isByteLengthQueuingStrategy(this))\x0d\n      throw new ERR_INVALID_THIS('ByteLengthQueuingStrategy');\x0d\n    return byteSizeFunction;\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\x0d\n      highWaterMark: this.highWaterMark\x2C\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(ByteLengthQueuingStrategy.prototype\x2C {\x0d\n  highWaterMark: kEnumerableProperty\x2C\x0d\n  size: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\n/**\x0d\n * @type {QueuingStrategy}\x0d\n */\x0d\nclass CountQueuingStrategy {\x0d\n  [kType] = 'CountQueuingStrategy';\x0d\n\x0d\n  get [SymbolToStringTag]() { return this[kType]; }\x0d\n\x0d\n  /**\x0d\n   * @param {{\x0d\n   *   highWaterMark : number\x0d\n   * }} init\x0d\n   */\x0d\n  constructor(init) {\x0d\n    validateObject(init\x2C 'init');\x0d\n    if (init.highWaterMark === undefined)\x0d\n      throw new ERR_MISSING_OPTION('options.highWaterMark');\x0d\n\x0d\n    // The highWaterMark value is not checked until the strategy\x0d\n    // is actually used\x2C per the spec.\x0d\n    this[kState] = {\x0d\n      highWaterMark: +init.highWaterMark\x2C\x0d\n    };\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @readonly\x0d\n   * @type {number}\x0d\n   */\x0d\n  get highWaterMark() {\x0d\n    if (!isCountQueuingStrategy(this))\x0d\n      throw new ERR_INVALID_THIS('CountQueuingStrategy');\x0d\n    return this[kState].highWaterMark;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {QueuingStrategySize}\x0d\n   */\x0d\n  get size() {\x0d\n    if (!isCountQueuingStrategy(this))\x0d\n      throw new ERR_INVALID_THIS('CountQueuingStrategy');\x0d\n    return countSizeFunction;\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    return customInspect(depth\x2C options\x2C this[kType]\x2C {\x0d\n      highWaterMark: this.highWaterMark\x2C\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(CountQueuingStrategy.prototype\x2C {\x0d\n  highWaterMark: kEnumerableProperty\x2C\x0d\n  size: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\nmodule.exports = {\x0d\n  ByteLengthQueuingStrategy\x2C\x0d\n  CountQueuingStrategy\x2C\x0d\n};\x0d\n
code-source-info,0x109c10e63fe,121,0,3808,C0O0C4O3808,,
code-creation,Function,10,216224,0x109c10e70f6,404, node:internal/webstreams/queuingstrategies:1:1,0x109c10e6378,~
code-source-info,0x109c10e70f6,121,0,3808,C0O0C35O28C40O55C45O174C48O174C53O174C58O120C64O143C70O252C73O252C78O237C83O374C86O374C91O292C97O310C102O327C108O337C114O348C119O446C122O446C127O425C133O520C136O520C140O520C142O600C145O600C149O600C151O932C155O932C157O1071C161O1071C180O1181C190O1229C209O2148C244O2344C256O2375C262O2405C266O2295C288O2505C298O2548C317O3448C352O3639C364O3670C370O3700C374O3595C379O3729C386O3751C392O3781C398O3744C403O3807,,
code-creation,Function,10,216285,0x109c10e73ae,16,<instance_members_initializer> node:internal/webstreams/queuingstrategies:116:3,0x109c10e68a8,~
code-source-info,0x109c10e73ae,121,2504,2536,C3O2514C15O2536,,
code-creation,Function,10,216306,0x109c10e7426,16,<instance_members_initializer> node:internal/webstreams/queuingstrategies:60:3,0x109c10e66a0,~
code-source-info,0x109c10e7426,121,1180,1217,C3O1190C15O1217,,
code-creation,LazyCompile,10,216536,0x109c10e813e,251,promisify node:internal/util:324:19,0x25ca2705de8,~
script-source,16,node:internal/util,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayFrom\x2C\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  ArrayPrototypeSort\x2C\x0d\n  Error\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectGetOwnPropertyDescriptor\x2C\x0d\n  ObjectGetOwnPropertyDescriptors\x2C\x0d\n  ObjectGetPrototypeOf\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  Promise\x2C\x0d\n  ReflectApply\x2C\x0d\n  ReflectConstruct\x2C\x0d\n  RegExpPrototypeExec\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeSet\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  StringPrototypeToLowerCase\x2C\x0d\n  StringPrototypeToUpperCase\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolFor\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  hideStackFrames\x2C\x0d\n  codes: {\x0d\n    ERR_NO_CRYPTO\x2C\x0d\n    ERR_UNKNOWN_SIGNAL\x0d\n  }\x2C\x0d\n  uvErrmapGet\x2C\x0d\n  overrideStackTrace\x2C\x0d\n} = require('internal/errors');\x0d\nconst { signals } = internalBinding('constants').os;\x0d\nconst {\x0d\n  getHiddenValue\x2C\x0d\n  setHiddenValue\x2C\x0d\n  arrow_message_private_symbol: kArrowMessagePrivateSymbolIndex\x2C\x0d\n  decorated_private_symbol: kDecoratedPrivateSymbolIndex\x2C\x0d\n  sleep: _sleep\x2C\x0d\n  toUSVString: _toUSVString\x2C\x0d\n} = internalBinding('util');\x0d\nconst { isNativeError } = internalBinding('types');\x0d\n\x0d\nconst noCrypto = !process.versions.openssl;\x0d\n\x0d\nconst experimentalWarnings = new SafeSet();\x0d\n\x0d\nconst colorRegExp = /\\u001b\\[\\d\\d?m/g; // eslint-disable-line no-control-regex\x0d\n\x0d\nconst unpairedSurrogateRe =\x0d\n  /(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])/;\x0d\nfunction toUSVString(val) {\x0d\n  const str = `${val}`;\x0d\n  // As of V8 5.5\x2C `str.search()` (and `unpairedSurrogateRe[@@search]()`) are\x0d\n  // slower than `unpairedSurrogateRe.exec()`.\x0d\n  const match = RegExpPrototypeExec(unpairedSurrogateRe\x2C str);\x0d\n  if (!match)\x0d\n    return str;\x0d\n  return _toUSVString(str\x2C match.index);\x0d\n}\x0d\n\x0d\nlet uvBinding;\x0d\n\x0d\nfunction lazyUv() {\x0d\n  uvBinding ??= internalBinding('uv');\x0d\n  return uvBinding;\x0d\n}\x0d\n\x0d\nfunction removeColors(str) {\x0d\n  return StringPrototypeReplace(str\x2C colorRegExp\x2C '');\x0d\n}\x0d\n\x0d\nfunction isError(e) {\x0d\n  // An error could be an instance of Error while not being a native error\x0d\n  // or could be from a different realm and not be instance of Error but still\x0d\n  // be a native error.\x0d\n  return isNativeError(e) || e instanceof Error;\x0d\n}\x0d\n\x0d\n// Keep a list of deprecation codes that have been warned on so we only warn on\x0d\n// each one once.\x0d\nconst codesWarned = new SafeSet();\x0d\n\x0d\nlet validateString;\x0d\n\x0d\n// Mark that a method should not be used.\x0d\n// Returns a modified function which warns once by default.\x0d\n// If --no-deprecation is set\x2C then it is a no-op.\x0d\nfunction deprecate(fn\x2C msg\x2C code) {\x0d\n  if (process.noDeprecation === true) {\x0d\n    return fn;\x0d\n  }\x0d\n\x0d\n  // Lazy-load to avoid a circular dependency.\x0d\n  if (validateString === undefined)\x0d\n    ({ validateString } = require('internal/validators'));\x0d\n\x0d\n  if (code !== undefined)\x0d\n    validateString(code\x2C 'code');\x0d\n\x0d\n  let warned = false;\x0d\n  function deprecated(...args) {\x0d\n    if (!warned) {\x0d\n      warned = true;\x0d\n      if (code !== undefined) {\x0d\n        if (!codesWarned.has(code)) {\x0d\n          process.emitWarning(msg\x2C 'DeprecationWarning'\x2C code\x2C deprecated);\x0d\n          codesWarned.add(code);\x0d\n        }\x0d\n      } else {\x0d\n        process.emitWarning(msg\x2C 'DeprecationWarning'\x2C deprecated);\x0d\n      }\x0d\n    }\x0d\n    if (new.target) {\x0d\n      return ReflectConstruct(fn\x2C args\x2C new.target);\x0d\n    }\x0d\n    return ReflectApply(fn\x2C this\x2C args);\x0d\n  }\x0d\n\x0d\n  // The wrapper will keep the same prototype as fn to maintain prototype chain\x0d\n  ObjectSetPrototypeOf(deprecated\x2C fn);\x0d\n  if (fn.prototype) {\x0d\n    // Setting this (rather than using Object.setPrototype\x2C as above) ensures\x0d\n    // that calling the unwrapped constructor gives an instanceof the wrapped\x0d\n    // constructor.\x0d\n    deprecated.prototype = fn.prototype;\x0d\n  }\x0d\n\x0d\n  return deprecated;\x0d\n}\x0d\n\x0d\nfunction decorateErrorStack(err) {\x0d\n  if (!(isError(err) && err.stack) ||\x0d\n      getHiddenValue(err\x2C kDecoratedPrivateSymbolIndex) === true)\x0d\n    return;\x0d\n\x0d\n  const arrow = getHiddenValue(err\x2C kArrowMessagePrivateSymbolIndex);\x0d\n\x0d\n  if (arrow) {\x0d\n    err.stack = arrow + err.stack;\x0d\n    setHiddenValue(err\x2C kDecoratedPrivateSymbolIndex\x2C true);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction assertCrypto() {\x0d\n  if (noCrypto)\x0d\n    throw new ERR_NO_CRYPTO();\x0d\n}\x0d\n\x0d\n// Return undefined if there is no match.\x0d\n// Move the "slow cases" to a separate function to make sure this function gets\x0d\n// inlined properly. That prioritizes the common case.\x0d\nfunction normalizeEncoding(enc) {\x0d\n  if (enc == null || enc === 'utf8' || enc === 'utf-8') return 'utf8';\x0d\n  return slowCases(enc);\x0d\n}\x0d\n\x0d\nfunction slowCases(enc) {\x0d\n  switch (enc.length) {\x0d\n    case 4:\x0d\n      if (enc === 'UTF8') return 'utf8';\x0d\n      if (enc === 'ucs2' || enc === 'UCS2') return 'utf16le';\x0d\n      enc = `${enc}`.toLowerCase();\x0d\n      if (enc === 'utf8') return 'utf8';\x0d\n      if (enc === 'ucs2') return 'utf16le';\x0d\n      break;\x0d\n    case 3:\x0d\n      if (enc === 'hex' || enc === 'HEX' ||\x0d\n          `${enc}`.toLowerCase() === 'hex')\x0d\n        return 'hex';\x0d\n      break;\x0d\n    case 5:\x0d\n      if (enc === 'ascii') return 'ascii';\x0d\n      if (enc === 'ucs-2') return 'utf16le';\x0d\n      if (enc === 'UTF-8') return 'utf8';\x0d\n      if (enc === 'ASCII') return 'ascii';\x0d\n      if (enc === 'UCS-2') return 'utf16le';\x0d\n      enc = `${enc}`.toLowerCase();\x0d\n      if (enc === 'utf-8') return 'utf8';\x0d\n      if (enc === 'ascii') return 'ascii';\x0d\n      if (enc === 'ucs-2') return 'utf16le';\x0d\n      break;\x0d\n    case 6:\x0d\n      if (enc === 'base64') return 'base64';\x0d\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\x0d\n      if (enc === 'BASE64') return 'base64';\x0d\n      if (enc === 'LATIN1' || enc === 'BINARY') return 'latin1';\x0d\n      enc = `${enc}`.toLowerCase();\x0d\n      if (enc === 'base64') return 'base64';\x0d\n      if (enc === 'latin1' || enc === 'binary') return 'latin1';\x0d\n      break;\x0d\n    case 7:\x0d\n      if (enc === 'utf16le' || enc === 'UTF16LE' ||\x0d\n          `${enc}`.toLowerCase() === 'utf16le')\x0d\n        return 'utf16le';\x0d\n      break;\x0d\n    case 8:\x0d\n      if (enc === 'utf-16le' || enc === 'UTF-16LE' ||\x0d\n        `${enc}`.toLowerCase() === 'utf-16le')\x0d\n        return 'utf16le';\x0d\n      break;\x0d\n    case 9:\x0d\n      if (enc === 'base64url' || enc === 'BASE64URL' ||\x0d\n          `${enc}`.toLowerCase() === 'base64url')\x0d\n        return 'base64url';\x0d\n      break;\x0d\n    default:\x0d\n      if (enc === '') return 'utf8';\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction emitExperimentalWarning(feature) {\x0d\n  if (experimentalWarnings.has(feature)) return;\x0d\n  const msg = `${feature} is an experimental feature. This feature could ` +\x0d\n       'change at any time';\x0d\n  experimentalWarnings.add(feature);\x0d\n  process.emitWarning(msg\x2C 'ExperimentalWarning');\x0d\n}\x0d\n\x0d\nfunction filterDuplicateStrings(items\x2C low) {\x0d\n  const map = new SafeMap();\x0d\n  for (let i = 0; i < items.length; i++) {\x0d\n    const item = items[i];\x0d\n    const key = StringPrototypeToLowerCase(item);\x0d\n    if (low) {\x0d\n      map.set(key\x2C key);\x0d\n    } else {\x0d\n      map.set(key\x2C item);\x0d\n    }\x0d\n  }\x0d\n  return ArrayPrototypeSort(ArrayFrom(map.values()));\x0d\n}\x0d\n\x0d\nfunction cachedResult(fn) {\x0d\n  let result;\x0d\n  return () => {\x0d\n    if (result === undefined)\x0d\n      result = fn();\x0d\n    return ArrayPrototypeSlice(result);\x0d\n  };\x0d\n}\x0d\n\x0d\n// Useful for Wrapping an ES6 Class with a constructor Function that\x0d\n// does not require the new keyword. For instance:\x0d\n//   class A { constructor(x) {this.x = x;}}\x0d\n//   const B = createClassWrapper(A);\x0d\n//   B() instanceof A // true\x0d\n//   B() instanceof B // true\x0d\nfunction createClassWrapper(type) {\x0d\n  function fn(...args) {\x0d\n    return ReflectConstruct(type\x2C args\x2C new.target || type);\x0d\n  }\x0d\n  // Mask the wrapper function name and length values\x0d\n  ObjectDefineProperties(fn\x2C {\x0d\n    name: { value: type.name }\x2C\x0d\n    length: { value: type.length }\x0d\n  });\x0d\n  ObjectSetPrototypeOf(fn\x2C type);\x0d\n  fn.prototype = type.prototype;\x0d\n  return fn;\x0d\n}\x0d\n\x0d\nlet signalsToNamesMapping;\x0d\nfunction getSignalsToNamesMapping() {\x0d\n  if (signalsToNamesMapping !== undefined)\x0d\n    return signalsToNamesMapping;\x0d\n\x0d\n  signalsToNamesMapping = ObjectCreate(null);\x0d\n  for (const key in signals) {\x0d\n    signalsToNamesMapping[signals[key]] = key;\x0d\n  }\x0d\n\x0d\n  return signalsToNamesMapping;\x0d\n}\x0d\n\x0d\nfunction convertToValidSignal(signal) {\x0d\n  if (typeof signal === 'number' && getSignalsToNamesMapping()[signal])\x0d\n    return signal;\x0d\n\x0d\n  if (typeof signal === 'string') {\x0d\n    const signalName = signals[StringPrototypeToUpperCase(signal)];\x0d\n    if (signalName) return signalName;\x0d\n  }\x0d\n\x0d\n  throw new ERR_UNKNOWN_SIGNAL(signal);\x0d\n}\x0d\n\x0d\nfunction getConstructorOf(obj) {\x0d\n  while (obj) {\x0d\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\x0d\n    if (descriptor !== undefined &&\x0d\n        typeof descriptor.value === 'function' &&\x0d\n        descriptor.value.name !== '') {\x0d\n      return descriptor.value;\x0d\n    }\x0d\n\x0d\n    obj = ObjectGetPrototypeOf(obj);\x0d\n  }\x0d\n\x0d\n  return null;\x0d\n}\x0d\n\x0d\nfunction getSystemErrorName(err) {\x0d\n  const entry = uvErrmapGet(err);\x0d\n  return entry ? entry[0] : `Unknown system error ${err}`;\x0d\n}\x0d\n\x0d\nfunction getSystemErrorMap() {\x0d\n  return lazyUv().getErrorMap();\x0d\n}\x0d\n\x0d\nconst kCustomPromisifiedSymbol = SymbolFor('nodejs.util.promisify.custom');\x0d\nconst kCustomPromisifyArgsSymbol = Symbol('customPromisifyArgs');\x0d\n\x0d\nlet validateFunction;\x0d\n\x0d\nfunction promisify(original) {\x0d\n  // Lazy-load to avoid a circular dependency.\x0d\n  if (validateFunction === undefined)\x0d\n    ({ validateFunction } = require('internal/validators'));\x0d\n\x0d\n  validateFunction(original\x2C 'original');\x0d\n\x0d\n  if (original[kCustomPromisifiedSymbol]) {\x0d\n    const fn = original[kCustomPromisifiedSymbol];\x0d\n\x0d\n    validateFunction(fn\x2C 'util.promisify.custom');\x0d\n\x0d\n    return ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\x0d\n      value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\x0d\n    });\x0d\n  }\x0d\n\x0d\n  // Names to create an object from in case the callback receives multiple\x0d\n  // arguments\x2C e.g. ['bytesRead'\x2C 'buffer'] for fs.read.\x0d\n  const argumentNames = original[kCustomPromisifyArgsSymbol];\x0d\n\x0d\n  function fn(...args) {\x0d\n    return new Promise((resolve\x2C reject) => {\x0d\n      ArrayPrototypePush(args\x2C (err\x2C ...values) => {\x0d\n        if (err) {\x0d\n          return reject(err);\x0d\n        }\x0d\n        if (argumentNames !== undefined && values.length > 1) {\x0d\n          const obj = {};\x0d\n          for (let i = 0; i < argumentNames.length; i++)\x0d\n            obj[argumentNames[i]] = values[i];\x0d\n          resolve(obj);\x0d\n        } else {\x0d\n          resolve(values[0]);\x0d\n        }\x0d\n      });\x0d\n      ReflectApply(original\x2C this\x2C args);\x0d\n    });\x0d\n  }\x0d\n\x0d\n  ObjectSetPrototypeOf(fn\x2C ObjectGetPrototypeOf(original));\x0d\n\x0d\n  ObjectDefineProperty(fn\x2C kCustomPromisifiedSymbol\x2C {\x0d\n    value: fn\x2C enumerable: false\x2C writable: false\x2C configurable: true\x0d\n  });\x0d\n  return ObjectDefineProperties(\x0d\n    fn\x2C\x0d\n    ObjectGetOwnPropertyDescriptors(original)\x0d\n  );\x0d\n}\x0d\n\x0d\npromisify.custom = kCustomPromisifiedSymbol;\x0d\n\x0d\n// The built-in Array#join is slower in v8 6.0\x0d\nfunction join(output\x2C separator) {\x0d\n  let str = '';\x0d\n  if (output.length !== 0) {\x0d\n    const lastIndex = output.length - 1;\x0d\n    for (let i = 0; i < lastIndex; i++) {\x0d\n      // It is faster not to use a template string here\x0d\n      str += output[i];\x0d\n      str += separator;\x0d\n    }\x0d\n    str += output[lastIndex];\x0d\n  }\x0d\n  return str;\x0d\n}\x0d\n\x0d\n// As of V8 6.6\x2C depending on the size of the array\x2C this is anywhere\x0d\n// between 1.5-10x faster than the two-arg version of Array#splice()\x0d\nfunction spliceOne(list\x2C index) {\x0d\n  for (; index + 1 < list.length; index++)\x0d\n    list[index] = list[index + 1];\x0d\n  list.pop();\x0d\n}\x0d\n\x0d\nconst kNodeModulesRE = /^(.*)[\\\\/]node_modules[\\\\/]/;\x0d\n\x0d\nlet getStructuredStack;\x0d\n\x0d\nfunction isInsideNodeModules() {\x0d\n  if (getStructuredStack === undefined) {\x0d\n    // Lazy-load to avoid a circular dependency.\x0d\n    const { runInNewContext } = require('vm');\x0d\n    // Use `runInNewContext()` to get something tamper-proof and\x0d\n    // side-effect-free. Since this is currently only used for a deprecated API\x2C\x0d\n    // the perf implications should be okay.\x0d\n    getStructuredStack = runInNewContext(`(function() {\x0d\n      try { Error.stackTraceLimit = Infinity; } catch {}\x0d\n      return function structuredStack() {\x0d\n        const e = new Error();\x0d\n        overrideStackTrace.set(e\x2C (err\x2C trace) => trace);\x0d\n        return e.stack;\x0d\n      };\x0d\n    })()`\x2C { overrideStackTrace }\x2C { filename: 'structured-stack' });\x0d\n  }\x0d\n\x0d\n  const stack = getStructuredStack();\x0d\n\x0d\n  // Iterate over all stack frames and look for the first one not coming\x0d\n  // from inside Node.js itself:\x0d\n  if (ArrayIsArray(stack)) {\x0d\n    for (const frame of stack) {\x0d\n      const filename = frame.getFileName();\x0d\n      // If a filename does not start with / or contain \\\x2C\x0d\n      // it's likely from Node.js core.\x0d\n      if (!RegExpPrototypeTest(/^\\/|\\\\/\x2C filename))\x0d\n        continue;\x0d\n      return RegExpPrototypeTest(kNodeModulesRE\x2C filename);\x0d\n    }\x0d\n  }\x0d\n  return false;\x0d\n}\x0d\n\x0d\nfunction once(callback) {\x0d\n  let called = false;\x0d\n  return function(...args) {\x0d\n    if (called) return;\x0d\n    called = true;\x0d\n    ReflectApply(callback\x2C this\x2C args);\x0d\n  };\x0d\n}\x0d\n\x0d\nlet validateUint32;\x0d\n\x0d\nfunction sleep(msec) {\x0d\n  // Lazy-load to avoid a circular dependency.\x0d\n  if (validateUint32 === undefined)\x0d\n    ({ validateUint32 } = require('internal/validators'));\x0d\n\x0d\n  validateUint32(msec\x2C 'msec');\x0d\n  _sleep(msec);\x0d\n}\x0d\n\x0d\nfunction createDeferredPromise() {\x0d\n  let resolve;\x0d\n  let reject;\x0d\n  const promise = new Promise((res\x2C rej) => {\x0d\n    resolve = res;\x0d\n    reject = rej;\x0d\n  });\x0d\n\x0d\n  return { promise\x2C resolve\x2C reject };\x0d\n}\x0d\n\x0d\nlet _DOMException;\x0d\nconst lazyDOMExceptionClass = () => {\x0d\n  _DOMException ??= internalBinding('messaging').DOMException;\x0d\n  return _DOMException;\x0d\n};\x0d\n\x0d\nconst lazyDOMException = hideStackFrames((message\x2C name) => {\x0d\n  _DOMException ??= internalBinding('messaging').DOMException;\x0d\n  return new _DOMException(message\x2C name);\x0d\n});\x0d\n\x0d\nmodule.exports = {\x0d\n  assertCrypto\x2C\x0d\n  cachedResult\x2C\x0d\n  convertToValidSignal\x2C\x0d\n  createClassWrapper\x2C\x0d\n  createDeferredPromise\x2C\x0d\n  decorateErrorStack\x2C\x0d\n  deprecate\x2C\x0d\n  emitExperimentalWarning\x2C\x0d\n  filterDuplicateStrings\x2C\x0d\n  getConstructorOf\x2C\x0d\n  getSystemErrorMap\x2C\x0d\n  getSystemErrorName\x2C\x0d\n  isError\x2C\x0d\n  isInsideNodeModules\x2C\x0d\n  join\x2C\x0d\n  lazyDOMException\x2C\x0d\n  lazyDOMExceptionClass\x2C\x0d\n  normalizeEncoding\x2C\x0d\n  once\x2C\x0d\n  promisify\x2C\x0d\n  sleep\x2C\x0d\n  spliceOne\x2C\x0d\n  toUSVString\x2C\x0d\n  removeColors\x2C\x0d\n\x0d\n  // Symbol used to customize promisify conversion\x0d\n  customPromisifyArgs: kCustomPromisifyArgsSymbol\x2C\x0d\n\x0d\n  // Symbol used to provide a custom inspect function for an object as an\x0d\n  // alternative to using 'inspect'\x0d\n  customInspectSymbol: SymbolFor('nodejs.util.inspect.custom')\x2C\x0d\n\x0d\n  // Used by the buffer module to capture an internal reference to the\x0d\n  // default isEncoding implementation\x2C just in case userland overrides it.\x0d\n  kIsEncodingSymbol: Symbol('kIsEncodingSymbol')\x2C\x0d\n  kVmBreakFirstLineSymbol: Symbol('kVmBreakFirstLineSymbol')\x0d\n};\x0d\n
code-source-info,0x109c10e813e,16,9168,10721,C0O9168C17O9232C25O9273C33O9297C38O9276C55O9335C68O9335C73O9380C80O9393C82O9392C87O9438C94O9447C96O9446C100O9481C110O9481C115O9535C126O9567C136O9609C143O9542C148O9676C149O9844C156O9853C158O9852C161O9844C163O10429C174O10454C180O10454C185O10429C190O10492C201O10517C211O10557C218O10492C223O10626C234O10671C240O10671C245O10633C250O10718,,
code-creation,LazyCompile,10,217436,0x109c10e970e,65,EventEmitterMixin node:internal/event_target:966:27,0x394c9e1e4f8,~
script-source,44,node:internal/event_target,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayFrom\x2C\x0d\n  Boolean\x2C\x0d\n  Error\x2C\x0d\n  FunctionPrototypeBind\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  NumberIsInteger\x2C\x0d\n  ObjectAssign\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectGetOwnPropertyDescriptor\x2C\x0d\n  ObjectGetOwnPropertyDescriptors\x2C\x0d\n  ReflectApply\x2C\x0d\n  SafeArrayIterator\x2C\x0d\n  SafeFinalizationRegistry\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeWeakMap\x2C\x0d\n  SafeWeakRef\x2C\x0d\n  SafeWeakSet\x2C\x0d\n  String\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolFor\x2C\x0d\n  SymbolToStringTag\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_EVENT_RECURSION\x2C\x0d\n    ERR_MISSING_ARGS\x2C\x0d\n    ERR_INVALID_THIS\x2C\x0d\n  }\x0d\n} = require('internal/errors');\x0d\nconst { validateObject\x2C validateString } = require('internal/validators');\x0d\n\x0d\nconst { customInspectSymbol } = require('internal/util');\x0d\nconst { inspect } = require('util');\x0d\n\x0d\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\x0d\nconst kIsNodeEventTarget = Symbol('kIsNodeEventTarget');\x0d\n\x0d\nconst EventEmitter = require('events');\x0d\nconst {\x0d\n  kMaxEventTargetListeners\x2C\x0d\n  kMaxEventTargetListenersWarned\x2C\x0d\n} = EventEmitter;\x0d\n\x0d\nconst kEvents = Symbol('kEvents');\x0d\nconst kIsBeingDispatched = Symbol('kIsBeingDispatched');\x0d\nconst kStop = Symbol('kStop');\x0d\nconst kTarget = Symbol('kTarget');\x0d\nconst kHandlers = Symbol('khandlers');\x0d\nconst kWeakHandler = Symbol('kWeak');\x0d\n\x0d\nconst kHybridDispatch = SymbolFor('nodejs.internal.kHybridDispatch');\x0d\nconst kCreateEvent = Symbol('kCreateEvent');\x0d\nconst kNewListener = Symbol('kNewListener');\x0d\nconst kRemoveListener = Symbol('kRemoveListener');\x0d\nconst kIsNodeStyleListener = Symbol('kIsNodeStyleListener');\x0d\nconst kTrustEvent = Symbol('kTrustEvent');\x0d\n\x0d\nconst { now } = require('internal/perf/utils');\x0d\n\x0d\n// TODO(joyeecheung): V8 snapshot does not support instance member\x0d\n// initializers for now:\x0d\n// https://bugs.chromium.org/p/v8/issues/detail?id=10704\x0d\nconst kType = Symbol('type');\x0d\nconst kDefaultPrevented = Symbol('defaultPrevented');\x0d\nconst kCancelable = Symbol('cancelable');\x0d\nconst kTimestamp = Symbol('timestamp');\x0d\nconst kBubbles = Symbol('bubbles');\x0d\nconst kComposed = Symbol('composed');\x0d\nconst kPropagationStopped = Symbol('propagationStopped');\x0d\n\x0d\nconst isTrustedSet = new SafeWeakSet();\x0d\nconst isTrusted = ObjectGetOwnPropertyDescriptor({\x0d\n  get isTrusted() {\x0d\n    return isTrustedSet.has(this);\x0d\n  }\x0d\n}\x2C 'isTrusted').get;\x0d\n\x0d\nfunction isEvent(value) {\x0d\n  return typeof value?.[kType] === 'string';\x0d\n}\x0d\n\x0d\nclass Event {\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @param {{\x0d\n   *   bubbles?: boolean\x2C\x0d\n   *   cancelable?: boolean\x2C\x0d\n   *   composed?: boolean\x2C\x0d\n   * }} [options]\x0d\n   */\x0d\n  constructor(type\x2C options = null) {\x0d\n    if (arguments.length === 0)\x0d\n      throw new ERR_MISSING_ARGS('type');\x0d\n    validateObject(options\x2C 'options'\x2C {\x0d\n      allowArray: true\x2C allowFunction: true\x2C nullable: true\x2C\x0d\n    });\x0d\n    const { cancelable\x2C bubbles\x2C composed } = { ...options };\x0d\n    this[kCancelable] = !!cancelable;\x0d\n    this[kBubbles] = !!bubbles;\x0d\n    this[kComposed] = !!composed;\x0d\n    this[kType] = `${type}`;\x0d\n    this[kDefaultPrevented] = false;\x0d\n    this[kTimestamp] = now();\x0d\n    this[kPropagationStopped] = false;\x0d\n    if (options?.[kTrustEvent]) {\x0d\n      isTrustedSet.add(this);\x0d\n    }\x0d\n\x0d\n    // isTrusted is special (LegacyUnforgeable)\x0d\n    ObjectDefineProperty(this\x2C 'isTrusted'\x2C {\x0d\n      get: isTrusted\x2C\x0d\n      enumerable: true\x2C\x0d\n      configurable: false\x0d\n    });\x0d\n    this[kTarget] = null;\x0d\n    this[kIsBeingDispatched] = false;\x0d\n  }\x0d\n\x0d\n  [customInspectSymbol](depth\x2C options) {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    const name = this.constructor.name;\x0d\n    if (depth < 0)\x0d\n      return name;\x0d\n\x0d\n    const opts = ObjectAssign({}\x2C options\x2C {\x0d\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\x0d\n    });\x0d\n\x0d\n    return `${name} ${inspect({\x0d\n      type: this[kType]\x2C\x0d\n      defaultPrevented: this[kDefaultPrevented]\x2C\x0d\n      cancelable: this[kCancelable]\x2C\x0d\n      timeStamp: this[kTimestamp]\x2C\x0d\n    }\x2C opts)}`;\x0d\n  }\x0d\n\x0d\n  stopImmediatePropagation() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    this[kStop] = true;\x0d\n  }\x0d\n\x0d\n  preventDefault() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    this[kDefaultPrevented] = true;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {EventTarget}\x0d\n   */\x0d\n  get target() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kTarget];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {EventTarget}\x0d\n   */\x0d\n  get currentTarget() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kTarget];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {EventTarget}\x0d\n   */\x0d\n  get srcElement() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kTarget];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {string}\x0d\n   */\x0d\n  get type() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kType];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {boolean}\x0d\n   */\x0d\n  get cancelable() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kCancelable];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {boolean}\x0d\n   */\x0d\n  get defaultPrevented() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kCancelable] && this[kDefaultPrevented];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {number}\x0d\n   */\x0d\n  get timeStamp() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kTimestamp];\x0d\n  }\x0d\n\x0d\n\x0d\n  // The following are non-op and unused properties/methods from Web API Event.\x0d\n  // These are not supported in Node.js and are provided purely for\x0d\n  // API completeness.\x0d\n  /**\x0d\n   * @returns {EventTarget[]}\x0d\n   */\x0d\n  composedPath() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kIsBeingDispatched] ? [this[kTarget]] : [];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {boolean}\x0d\n   */\x0d\n  get returnValue() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return !this.defaultPrevented;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {boolean}\x0d\n   */\x0d\n  get bubbles() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kBubbles];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {boolean}\x0d\n   */\x0d\n  get composed() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kComposed];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {number}\x0d\n   */\x0d\n  get eventPhase() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kIsBeingDispatched] ? Event.AT_TARGET : Event.NONE;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {boolean}\x0d\n   */\x0d\n  get cancelBubble() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    return this[kPropagationStopped];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @type {boolean}\x0d\n   */\x0d\n  set cancelBubble(value) {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    if (value) {\x0d\n      this.stopPropagation();\x0d\n    }\x0d\n  }\x0d\n\x0d\n  stopPropagation() {\x0d\n    if (!isEvent(this))\x0d\n      throw new ERR_INVALID_THIS('Event');\x0d\n    this[kPropagationStopped] = true;\x0d\n  }\x0d\n\x0d\n  static NONE = 0;\x0d\n  static CAPTURING_PHASE = 1;\x0d\n  static AT_TARGET = 2;\x0d\n  static BUBBLING_PHASE = 3;\x0d\n}\x0d\n\x0d\nconst kEnumerableProperty = ObjectCreate(null);\x0d\nkEnumerableProperty.enumerable = true;\x0d\n\x0d\nObjectDefineProperties(\x0d\n  Event.prototype\x2C {\x0d\n    [SymbolToStringTag]: {\x0d\n      writable: false\x2C\x0d\n      enumerable: false\x2C\x0d\n      configurable: true\x2C\x0d\n      value: 'Event'\x2C\x0d\n    }\x2C\x0d\n    stopImmediatePropagation: kEnumerableProperty\x2C\x0d\n    preventDefault: kEnumerableProperty\x2C\x0d\n    target: kEnumerableProperty\x2C\x0d\n    currentTarget: kEnumerableProperty\x2C\x0d\n    srcElement: kEnumerableProperty\x2C\x0d\n    type: kEnumerableProperty\x2C\x0d\n    cancelable: kEnumerableProperty\x2C\x0d\n    defaultPrevented: kEnumerableProperty\x2C\x0d\n    timeStamp: kEnumerableProperty\x2C\x0d\n    composedPath: kEnumerableProperty\x2C\x0d\n    returnValue: kEnumerableProperty\x2C\x0d\n    bubbles: kEnumerableProperty\x2C\x0d\n    composed: kEnumerableProperty\x2C\x0d\n    eventPhase: kEnumerableProperty\x2C\x0d\n    cancelBubble: kEnumerableProperty\x2C\x0d\n    stopPropagation: kEnumerableProperty\x2C\x0d\n  });\x0d\n\x0d\nclass NodeCustomEvent extends Event {\x0d\n  constructor(type\x2C options) {\x0d\n    super(type\x2C options);\x0d\n    if (options?.detail) {\x0d\n      this.detail = options.detail;\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\n// Weak listener cleanup\x0d\n// This has to be lazy for snapshots to work\x0d\nlet weakListenersState = null;\x0d\n// The resource needs to retain the callback so that it doesn't\x0d\n// get garbage collected now that it's weak.\x0d\nlet objectToWeakListenerMap = null;\x0d\nfunction weakListeners() {\x0d\n  weakListenersState ??= new SafeFinalizationRegistry(\x0d\n    (listener) => listener.remove()\x0d\n  );\x0d\n  objectToWeakListenerMap ??= new SafeWeakMap();\x0d\n  return { registry: weakListenersState\x2C map: objectToWeakListenerMap };\x0d\n}\x0d\n\x0d\n// The listeners for an EventTarget are maintained as a linked list.\x0d\n// Unfortunately\x2C the way EventTarget is defined\x2C listeners are accounted\x0d\n// using the tuple [handler\x2Ccapture]\x2C and even if we don't actually make\x0d\n// use of capture or bubbling\x2C in order to be spec compliant we have to\x0d\n// take on the additional complexity of supporting it. Fortunately\x2C using\x0d\n// the linked list makes dispatching faster\x2C even if adding/removing is\x0d\n// slower.\x0d\nclass Listener {\x0d\n  constructor(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\x0d\n              isNodeStyleListener\x2C weak) {\x0d\n    this.next = undefined;\x0d\n    if (previous !== undefined)\x0d\n      previous.next = this;\x0d\n    this.previous = previous;\x0d\n    this.listener = listener;\x0d\n    // TODO(benjamingr) these 4 can be 'flags' to save 3 slots\x0d\n    this.once = once;\x0d\n    this.capture = capture;\x0d\n    this.passive = passive;\x0d\n    this.isNodeStyleListener = isNodeStyleListener;\x0d\n    this.removed = false;\x0d\n    this.weak = Boolean(weak); // Don't retain the object\x0d\n\x0d\n    if (this.weak) {\x0d\n      this.callback = new SafeWeakRef(listener);\x0d\n      weakListeners().registry.register(listener\x2C this\x2C this);\x0d\n      // Make the retainer retain the listener in a WeakMap\x0d\n      weakListeners().map.set(weak\x2C listener);\x0d\n      this.listener = this.callback;\x0d\n    } else if (typeof listener === 'function') {\x0d\n      this.callback = listener;\x0d\n      this.listener = listener;\x0d\n    } else {\x0d\n      this.callback = FunctionPrototypeBind(listener.handleEvent\x2C listener);\x0d\n      this.listener = listener;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  same(listener\x2C capture) {\x0d\n    const myListener = this.weak ? this.listener.deref() : this.listener;\x0d\n    return myListener === listener && this.capture === capture;\x0d\n  }\x0d\n\x0d\n  remove() {\x0d\n    if (this.previous !== undefined)\x0d\n      this.previous.next = this.next;\x0d\n    if (this.next !== undefined)\x0d\n      this.next.previous = this.previous;\x0d\n    this.removed = true;\x0d\n    if (this.weak)\x0d\n      weakListeners().registry.unregister(this);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction initEventTarget(self) {\x0d\n  self[kEvents] = new SafeMap();\x0d\n  self[kMaxEventTargetListeners] = EventEmitter.defaultMaxListeners;\x0d\n  self[kMaxEventTargetListenersWarned] = false;\x0d\n}\x0d\n\x0d\nclass EventTarget {\x0d\n  // Used in checking whether an object is an EventTarget. This is a well-known\x0d\n  // symbol as EventTarget may be used cross-realm.\x0d\n  // Ref: https://github.com/nodejs/node/pull/33661\x0d\n  static [kIsEventTarget] = true;\x0d\n\x0d\n  constructor() {\x0d\n    initEventTarget(this);\x0d\n  }\x0d\n\x0d\n  [kNewListener](size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak) {\x0d\n    if (this[kMaxEventTargetListeners] > 0 &&\x0d\n        size > this[kMaxEventTargetListeners] &&\x0d\n        !this[kMaxEventTargetListenersWarned]) {\x0d\n      this[kMaxEventTargetListenersWarned] = true;\x0d\n      // No error code for this since it is a Warning\x0d\n      // eslint-disable-next-line no-restricted-syntax\x0d\n      const w = new Error('Possible EventTarget memory leak detected. ' +\x0d\n                          `${size} ${type} listeners ` +\x0d\n                          `added to ${inspect(this\x2C { depth: -1 })}. Use ` +\x0d\n                          'events.setMaxListeners() to increase limit');\x0d\n      w.name = 'MaxListenersExceededWarning';\x0d\n      w.target = this;\x0d\n      w.type = type;\x0d\n      w.count = size;\x0d\n      process.emitWarning(w);\x0d\n    }\x0d\n  }\x0d\n  [kRemoveListener](size\x2C type\x2C listener\x2C capture) {}\x0d\n\x0d\n  /**\x0d\n   * @callback EventTargetCallback\x0d\n   * @param {Event} event\x0d\n   */\x0d\n\x0d\n  /**\x0d\n   * @typedef {{ handleEvent: EventTargetCallback }} EventListener\x0d\n   */\x0d\n\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @param {EventTargetCallback|EventListener} listener\x0d\n   * @param {{\x0d\n   *   capture?: boolean\x2C\x0d\n   *   once?: boolean\x2C\x0d\n   *   passive?: boolean\x2C\x0d\n   *   signal?: AbortSignal\x0d\n   * }} [options]\x0d\n   */\x0d\n  addEventListener(type\x2C listener\x2C options = {}) {\x0d\n    if (!isEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('EventTarget');\x0d\n    if (arguments.length < 2)\x0d\n      throw new ERR_MISSING_ARGS('type'\x2C 'listener');\x0d\n\x0d\n    // We validateOptions before the shouldAddListeners check because the spec\x0d\n    // requires us to hit getters.\x0d\n    const {\x0d\n      once\x2C\x0d\n      capture\x2C\x0d\n      passive\x2C\x0d\n      signal\x2C\x0d\n      isNodeStyleListener\x2C\x0d\n      weak\x2C\x0d\n    } = validateEventListenerOptions(options);\x0d\n\x0d\n    if (!shouldAddListener(listener)) {\x0d\n      // The DOM silently allows passing undefined as a second argument\x0d\n      // No error code for this since it is a Warning\x0d\n      // eslint-disable-next-line no-restricted-syntax\x0d\n      const w = new Error(`addEventListener called with ${listener}` +\x0d\n                          ' which has no effect.');\x0d\n      w.name = 'AddEventListenerArgumentTypeWarning';\x0d\n      w.target = this;\x0d\n      w.type = type;\x0d\n      process.emitWarning(w);\x0d\n      return;\x0d\n    }\x0d\n    type = String(type);\x0d\n\x0d\n    if (signal) {\x0d\n      if (signal.aborted) {\x0d\n        return;\x0d\n      }\x0d\n      // TODO(benjamingr) make this weak somehow? ideally the signal would\x0d\n      // not prevent the event target from GC.\x0d\n      signal.addEventListener('abort'\x2C () => {\x0d\n        this.removeEventListener(type\x2C listener\x2C options);\x0d\n      }\x2C { once: true\x2C [kWeakHandler]: this });\x0d\n    }\x0d\n\x0d\n    let root = this[kEvents].get(type);\x0d\n\x0d\n    if (root === undefined) {\x0d\n      root = { size: 1\x2C next: undefined };\x0d\n      // This is the first handler in our linked list.\x0d\n      new Listener(root\x2C listener\x2C once\x2C capture\x2C passive\x2C\x0d\n                   isNodeStyleListener\x2C weak);\x0d\n      this[kNewListener](\x0d\n        root.size\x2C\x0d\n        type\x2C\x0d\n        listener\x2C\x0d\n        once\x2C\x0d\n        capture\x2C\x0d\n        passive\x2C\x0d\n        weak);\x0d\n      this[kEvents].set(type\x2C root);\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    let handler = root.next;\x0d\n    let previous = root;\x0d\n\x0d\n    // We have to walk the linked list to see if we have a match\x0d\n    while (handler !== undefined && !handler.same(listener\x2C capture)) {\x0d\n      previous = handler;\x0d\n      handler = handler.next;\x0d\n    }\x0d\n\x0d\n    if (handler !== undefined) { // Duplicate! Ignore\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    new Listener(previous\x2C listener\x2C once\x2C capture\x2C passive\x2C\x0d\n                 isNodeStyleListener\x2C weak);\x0d\n    root.size++;\x0d\n    this[kNewListener](root.size\x2C type\x2C listener\x2C once\x2C capture\x2C passive\x2C weak);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @param {EventTargetCallback|EventListener} listener\x0d\n   * @param {{\x0d\n   *   capture?: boolean\x2C\x0d\n   * }} [options]\x0d\n   */\x0d\n  removeEventListener(type\x2C listener\x2C options = {}) {\x0d\n    if (!isEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('EventTarget');\x0d\n    if (!shouldAddListener(listener))\x0d\n      return;\x0d\n\x0d\n    type = String(type);\x0d\n    const capture = options?.capture === true;\x0d\n\x0d\n    const root = this[kEvents].get(type);\x0d\n    if (root === undefined || root.next === undefined)\x0d\n      return;\x0d\n\x0d\n    let handler = root.next;\x0d\n    while (handler !== undefined) {\x0d\n      if (handler.same(listener\x2C capture)) {\x0d\n        handler.remove();\x0d\n        root.size--;\x0d\n        if (root.size === 0)\x0d\n          this[kEvents].delete(type);\x0d\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\x0d\n        break;\x0d\n      }\x0d\n      handler = handler.next;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {Event} event\x0d\n   */\x0d\n  dispatchEvent(event) {\x0d\n    if (!isEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('EventTarget');\x0d\n\x0d\n    if (!(event instanceof Event))\x0d\n      throw new ERR_INVALID_ARG_TYPE('event'\x2C 'Event'\x2C event);\x0d\n\x0d\n    if (event[kIsBeingDispatched])\x0d\n      throw new ERR_EVENT_RECURSION(event.type);\x0d\n\x0d\n    this[kHybridDispatch](event\x2C event.type\x2C event);\x0d\n\x0d\n    return event.defaultPrevented !== true;\x0d\n  }\x0d\n\x0d\n  [kHybridDispatch](nodeValue\x2C type\x2C event) {\x0d\n    const createEvent = () => {\x0d\n      if (event === undefined) {\x0d\n        event = this[kCreateEvent](nodeValue\x2C type);\x0d\n        event[kTarget] = this;\x0d\n        event[kIsBeingDispatched] = true;\x0d\n      }\x0d\n      return event;\x0d\n    };\x0d\n    if (event !== undefined) {\x0d\n      event[kTarget] = this;\x0d\n      event[kIsBeingDispatched] = true;\x0d\n    }\x0d\n\x0d\n    const root = this[kEvents].get(type);\x0d\n    if (root === undefined || root.next === undefined) {\x0d\n      if (event !== undefined)\x0d\n        event[kIsBeingDispatched] = false;\x0d\n      return true;\x0d\n    }\x0d\n\x0d\n    let handler = root.next;\x0d\n    let next;\x0d\n\x0d\n    while (handler !== undefined &&\x0d\n           (handler.passive || event?.[kStop] !== true)) {\x0d\n      // Cache the next item in case this iteration removes the current one\x0d\n      next = handler.next;\x0d\n\x0d\n      if (handler.removed) {\x0d\n        // Deal with the case an event is removed while event handlers are\x0d\n        // Being processed (removeEventListener called from a listener)\x0d\n        handler = next;\x0d\n        continue;\x0d\n      }\x0d\n      if (handler.once) {\x0d\n        handler.remove();\x0d\n        root.size--;\x0d\n        const { listener\x2C capture } = handler;\x0d\n        this[kRemoveListener](root.size\x2C type\x2C listener\x2C capture);\x0d\n      }\x0d\n\x0d\n      try {\x0d\n        let arg;\x0d\n        if (handler.isNodeStyleListener) {\x0d\n          arg = nodeValue;\x0d\n        } else {\x0d\n          arg = createEvent();\x0d\n        }\x0d\n        const callback = handler.weak ?\x0d\n          handler.callback.deref() : handler.callback;\x0d\n        let result;\x0d\n        if (callback) {\x0d\n          result = FunctionPrototypeCall(callback\x2C this\x2C arg);\x0d\n          if (!handler.isNodeStyleListener) {\x0d\n            arg[kIsBeingDispatched] = false;\x0d\n          }\x0d\n        }\x0d\n        if (result !== undefined && result !== null)\x0d\n          addCatch(result);\x0d\n      } catch (err) {\x0d\n        emitUncaughtException(err);\x0d\n      }\x0d\n\x0d\n      handler = next;\x0d\n    }\x0d\n\x0d\n    if (event !== undefined)\x0d\n      event[kIsBeingDispatched] = false;\x0d\n  }\x0d\n\x0d\n  [kCreateEvent](nodeValue\x2C type) {\x0d\n    return new NodeCustomEvent(type\x2C { detail: nodeValue });\x0d\n  }\x0d\n  [customInspectSymbol](depth\x2C options) {\x0d\n    if (!isEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('EventTarget');\x0d\n    const name = this.constructor.name;\x0d\n    if (depth < 0)\x0d\n      return name;\x0d\n\x0d\n    const opts = ObjectAssign({}\x2C options\x2C {\x0d\n      depth: NumberIsInteger(options.depth) ? options.depth - 1 : options.depth\x0d\n    });\x0d\n\x0d\n    return `${name} ${inspect({}\x2C opts)}`;\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(EventTarget.prototype\x2C {\x0d\n  addEventListener: kEnumerableProperty\x2C\x0d\n  removeEventListener: kEnumerableProperty\x2C\x0d\n  dispatchEvent: kEnumerableProperty\x2C\x0d\n  [SymbolToStringTag]: {\x0d\n    writable: false\x2C\x0d\n    enumerable: false\x2C\x0d\n    configurable: true\x2C\x0d\n    value: 'EventTarget'\x2C\x0d\n  }\x0d\n});\x0d\n\x0d\nfunction initNodeEventTarget(self) {\x0d\n  initEventTarget(self);\x0d\n}\x0d\n\x0d\nclass NodeEventTarget extends EventTarget {\x0d\n  static [kIsNodeEventTarget] = true;\x0d\n  static defaultMaxListeners = 10;\x0d\n\x0d\n  constructor() {\x0d\n    super();\x0d\n    initNodeEventTarget(this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {number} n\x0d\n   */\x0d\n  setMaxListeners(n) {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    EventEmitter.setMaxListeners(n\x2C this);\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @returns {number}\x0d\n   */\x0d\n  getMaxListeners() {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    return this[kMaxEventTargetListeners];\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @returns {string[]}\x0d\n   */\x0d\n  eventNames() {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    return ArrayFrom(this[kEvents].keys());\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {string} [type]\x0d\n   * @returns {number}\x0d\n   */\x0d\n  listenerCount(type) {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    const root = this[kEvents].get(String(type));\x0d\n    return root !== undefined ? root.size : 0;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @param {EventTargetCallback|EventListener} listener\x0d\n   * @param {{\x0d\n   *   capture?: boolean\x2C\x0d\n   * }} [options]\x0d\n   * @returns {NodeEventTarget}\x0d\n   */\x0d\n  off(type\x2C listener\x2C options) {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    this.removeEventListener(type\x2C listener\x2C options);\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @param {EventTargetCallback|EventListener} listener\x0d\n   * @param {{\x0d\n   *   capture?: boolean\x2C\x0d\n   * }} [options]\x0d\n   * @returns {NodeEventTarget}\x0d\n   */\x0d\n  removeListener(type\x2C listener\x2C options) {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    this.removeEventListener(type\x2C listener\x2C options);\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @param {EventTargetCallback|EventListener} listener\x0d\n   * @returns {NodeEventTarget}\x0d\n   */\x0d\n  on(type\x2C listener) {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @param {EventTargetCallback|EventListener} listener\x0d\n   * @returns {NodeEventTarget}\x0d\n   */\x0d\n  addListener(type\x2C listener) {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    this.addEventListener(type\x2C listener\x2C { [kIsNodeStyleListener]: true });\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @param {any} arg\x0d\n   * @returns {boolean}\x0d\n   */\x0d\n  emit(type\x2C arg) {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    validateString(type\x2C 'type');\x0d\n    const hadListeners = this.listenerCount(type) > 0;\x0d\n    this[kHybridDispatch](arg\x2C type);\x0d\n    return hadListeners;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @param {EventTargetCallback|EventListener} listener\x0d\n   * @returns {NodeEventTarget}\x0d\n   */\x0d\n  once(type\x2C listener) {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    this.addEventListener(type\x2C listener\x2C\x0d\n                          { once: true\x2C [kIsNodeStyleListener]: true });\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  /**\x0d\n   * @param {string} type\x0d\n   * @returns {NodeEventTarget}\x0d\n   */\x0d\n  removeAllListeners(type) {\x0d\n    if (!isNodeEventTarget(this))\x0d\n      throw new ERR_INVALID_THIS('NodeEventTarget');\x0d\n    if (type !== undefined) {\x0d\n      this[kEvents].delete(String(type));\x0d\n    } else {\x0d\n      this[kEvents].clear();\x0d\n    }\x0d\n\x0d\n    return this;\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(NodeEventTarget.prototype\x2C {\x0d\n  setMaxListeners: kEnumerableProperty\x2C\x0d\n  getMaxListeners: kEnumerableProperty\x2C\x0d\n  eventNames: kEnumerableProperty\x2C\x0d\n  listenerCount: kEnumerableProperty\x2C\x0d\n  off: kEnumerableProperty\x2C\x0d\n  removeListener: kEnumerableProperty\x2C\x0d\n  on: kEnumerableProperty\x2C\x0d\n  addListener: kEnumerableProperty\x2C\x0d\n  once: kEnumerableProperty\x2C\x0d\n  emit: kEnumerableProperty\x2C\x0d\n  removeAllListeners: kEnumerableProperty\x2C\x0d\n});\x0d\n\x0d\n// EventTarget API\x0d\n\x0d\nfunction shouldAddListener(listener) {\x0d\n  if (typeof listener === 'function' ||\x0d\n      typeof listener?.handleEvent === 'function') {\x0d\n    return true;\x0d\n  }\x0d\n\x0d\n  if (listener == null)\x0d\n    return false;\x0d\n\x0d\n  throw new ERR_INVALID_ARG_TYPE('listener'\x2C 'EventListener'\x2C listener);\x0d\n}\x0d\n\x0d\nfunction validateEventListenerOptions(options) {\x0d\n  if (typeof options === 'boolean')\x0d\n    return { capture: options };\x0d\n\x0d\n  if (options === null)\x0d\n    return {};\x0d\n  validateObject(options\x2C 'options'\x2C {\x0d\n    allowArray: true\x2C allowFunction: true\x2C\x0d\n  });\x0d\n  return {\x0d\n    once: Boolean(options.once)\x2C\x0d\n    capture: Boolean(options.capture)\x2C\x0d\n    passive: Boolean(options.passive)\x2C\x0d\n    signal: options.signal\x2C\x0d\n    weak: options[kWeakHandler]\x2C\x0d\n    isNodeStyleListener: Boolean(options[kIsNodeStyleListener])\x0d\n  };\x0d\n}\x0d\n\x0d\n// Test whether the argument is an event object. This is far from a fool-proof\x0d\n// test\x2C for example this input will result in a false positive:\x0d\n// > isEventTarget({ constructor: EventTarget })\x0d\n// It stands in its current implementation as a compromise.\x0d\n// Ref: https://github.com/nodejs/node/pull/33661\x0d\nfunction isEventTarget(obj) {\x0d\n  return obj?.constructor?.[kIsEventTarget];\x0d\n}\x0d\n\x0d\nfunction isNodeEventTarget(obj) {\x0d\n  return obj?.constructor?.[kIsNodeEventTarget];\x0d\n}\x0d\n\x0d\nfunction addCatch(promise) {\x0d\n  const then = promise.then;\x0d\n  if (typeof then === 'function') {\x0d\n    FunctionPrototypeCall(then\x2C promise\x2C undefined\x2C function(err) {\x0d\n      // The callback is called with nextTick to avoid a follow-up\x0d\n      // rejection from this promise.\x0d\n      emitUncaughtException(err);\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction emitUncaughtException(err) {\x0d\n  process.nextTick(() => { throw err; });\x0d\n}\x0d\n\x0d\nfunction makeEventHandler(handler) {\x0d\n  // Event handlers are dispatched in the order they were first set\x0d\n  // See https://github.com/nodejs/node/pull/35949#issuecomment-722496598\x0d\n  function eventHandler(...args) {\x0d\n    if (typeof eventHandler.handler !== 'function') {\x0d\n      return;\x0d\n    }\x0d\n    return ReflectApply(eventHandler.handler\x2C this\x2C args);\x0d\n  }\x0d\n  eventHandler.handler = handler;\x0d\n  return eventHandler;\x0d\n}\x0d\n\x0d\nfunction defineEventHandler(emitter\x2C name) {\x0d\n  // 8.1.5.1 Event handlers - basically `on[eventName]` attributes\x0d\n  ObjectDefineProperty(emitter\x2C `on${name}`\x2C {\x0d\n    get() {\x0d\n      return this[kHandlers]?.get(name)?.handler;\x0d\n    }\x2C\x0d\n    set(value) {\x0d\n      if (!this[kHandlers]) {\x0d\n        this[kHandlers] = new SafeMap();\x0d\n      }\x0d\n      let wrappedHandler = this[kHandlers]?.get(name);\x0d\n      if (wrappedHandler) {\x0d\n        if (typeof wrappedHandler.handler === 'function') {\x0d\n          this[kEvents].get(name).size--;\x0d\n          const size = this[kEvents].get(name).size;\x0d\n          this[kRemoveListener](size\x2C name\x2C wrappedHandler.handler\x2C false);\x0d\n        }\x0d\n        wrappedHandler.handler = value;\x0d\n        if (typeof wrappedHandler.handler === 'function') {\x0d\n          this[kEvents].get(name).size++;\x0d\n          const size = this[kEvents].get(name).size;\x0d\n          this[kNewListener](size\x2C name\x2C value\x2C false\x2C false\x2C false\x2C false);\x0d\n        }\x0d\n      } else {\x0d\n        wrappedHandler = makeEventHandler(value);\x0d\n        this.addEventListener(name\x2C wrappedHandler);\x0d\n      }\x0d\n      this[kHandlers].set(name\x2C wrappedHandler);\x0d\n    }\x2C\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x0d\n  });\x0d\n}\x0d\n\x0d\nconst EventEmitterMixin = (Superclass) => {\x0d\n  class MixedEventEmitter extends Superclass {\x0d\n    constructor(...args) {\x0d\n      args = new SafeArrayIterator(args);\x0d\n      super(...args);\x0d\n      FunctionPrototypeCall(EventEmitter\x2C this);\x0d\n    }\x0d\n  }\x0d\n  const protoProps = ObjectGetOwnPropertyDescriptors(EventEmitter.prototype);\x0d\n  delete protoProps.constructor;\x0d\n  ObjectDefineProperties(MixedEventEmitter.prototype\x2C protoProps);\x0d\n  return MixedEventEmitter;\x0d\n};\x0d\n\x0d\nmodule.exports = {\x0d\n  Event\x2C\x0d\n  EventEmitterMixin\x2C\x0d\n  EventTarget\x2C\x0d\n  NodeEventTarget\x2C\x0d\n  defineEventHandler\x2C\x0d\n  initEventTarget\x2C\x0d\n  initNodeEventTarget\x2C\x0d\n  kCreateEvent\x2C\x0d\n  kNewListener\x2C\x0d\n  kTrustEvent\x2C\x0d\n  kRemoveListener\x2C\x0d\n  kEvents\x2C\x0d\n  kWeakHandler\x2C\x0d\n  isEventTarget\x2C\x0d\n};\x0d\n
code-source-info,0x109c10e970e,44,26757,27191,C0O26810C23O27001C30O27033C33O27046C38O27001C43O27061C47O27095C52O27136C57O27095C62O27163C64O27188,,
tick,0x7ff99731f235,219094,0,0x0,3,0x7ff7e78fdb40,0x1abee83d9bb,0x1abee802285,0x1abee801555,0x1abee839712,0x1abee802285,0x1abee801555,0x1abee838fa2,0x1abee802285,0x1abee801555,0x1abee82c3b5,0x1abee802285,0x1abee801555,0x1abee82a79c,0x1abee802285,0x1abee801555,0x1abee825ff9,0x1abee802285,0x1abee801555,0x1abee821e04,0x1abee806742,0x1abee8012dd
code-creation,Eval,10,219549,0x109c10ec586,5, node:internal/modules/esm/translators:1:1,0x109c10ec120,~
script-source,122,node:internal/modules/esm/translators,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  ArrayPrototypeMap\x2C\x0d\n  Boolean\x2C\x0d\n  JSONParse\x2C\x0d\n  ObjectGetPrototypeOf\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  ObjectKeys\x2C\x0d\n  SafeArrayIterator\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeSet\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n  SyntaxErrorPrototype\x2C\x0d\n  globalThis: { WebAssembly }\x2C\x0d\n} = primordials;\x0d\n\x0d\nlet _TYPES = null;\x0d\nfunction lazyTypes() {\x0d\n  if (_TYPES !== null) return _TYPES;\x0d\n  return _TYPES = require('internal/util/types');\x0d\n}\x0d\n\x0d\nconst { readFileSync } = require('fs');\x0d\nconst { extname\x2C isAbsolute } = require('path');\x0d\nconst {\x0d\n  hasEsmSyntax\x2C\x0d\n  loadNativeModule\x2C\x0d\n  stripBOM\x2C\x0d\n} = require('internal/modules/cjs/helpers');\x0d\nconst {\x0d\n  Module: CJSModule\x2C\x0d\n  cjsParseCache\x0d\n} = require('internal/modules/cjs/loader');\x0d\nconst internalURLModule = require('internal/url');\x0d\nconst createDynamicModule = require(\x0d\n  'internal/modules/esm/create_dynamic_module');\x0d\nconst { fileURLToPath\x2C URL } = require('url');\x0d\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\x0d\n  debug = fn;\x0d\n});\x0d\nconst { emitExperimentalWarning } = require('internal/util');\x0d\nconst {\x0d\n  ERR_UNKNOWN_BUILTIN_MODULE\x2C\x0d\n  ERR_INVALID_RETURN_PROPERTY_VALUE\x0d\n} = require('internal/errors').codes;\x0d\nconst { maybeCacheSourceMap } = require('internal/source_map/source_map_cache');\x0d\nconst moduleWrap = internalBinding('module_wrap');\x0d\nconst { ModuleWrap } = moduleWrap;\x0d\nconst asyncESM = require('internal/process/esm_loader');\x0d\nconst { emitWarningSync } = require('internal/process/warning');\x0d\nconst { TextDecoder } = require('internal/encoding');\x0d\n\x0d\nlet cjsParse;\x0d\nasync function initCJSParse() {\x0d\n  if (typeof WebAssembly === 'undefined') {\x0d\n    cjsParse = require('internal/deps/cjs-module-lexer/lexer').parse;\x0d\n  } else {\x0d\n    const { parse\x2C init } =\x0d\n        require('internal/deps/cjs-module-lexer/dist/lexer');\x0d\n    await init();\x0d\n    cjsParse = parse;\x0d\n  }\x0d\n}\x0d\n\x0d\nconst translators = new SafeMap();\x0d\nexports.translators = translators;\x0d\nexports.enrichCJSError = enrichCJSError;\x0d\n\x0d\nlet DECODER = null;\x0d\nfunction assertBufferSource(body\x2C allowString\x2C hookName) {\x0d\n  if (allowString && typeof body === 'string') {\x0d\n    return;\x0d\n  }\x0d\n  const { isArrayBufferView\x2C isAnyArrayBuffer } = lazyTypes();\x0d\n  if (isArrayBufferView(body) || isAnyArrayBuffer(body)) {\x0d\n    return;\x0d\n  }\x0d\n  throw new ERR_INVALID_RETURN_PROPERTY_VALUE(\x0d\n    `${allowString ? 'string\x2C ' : ''}array buffer\x2C or typed array`\x2C\x0d\n    hookName\x2C\x0d\n    'source'\x2C\x0d\n    body\x0d\n  );\x0d\n}\x0d\n\x0d\nfunction stringify(body) {\x0d\n  if (typeof body === 'string') return body;\x0d\n  assertBufferSource(body\x2C false\x2C 'transformSource');\x0d\n  DECODER = DECODER === null ? new TextDecoder() : DECODER;\x0d\n  return DECODER.decode(body);\x0d\n}\x0d\n\x0d\nfunction errPath(url) {\x0d\n  const parsed = new URL(url);\x0d\n  if (parsed.protocol === 'file:') {\x0d\n    return fileURLToPath(parsed);\x0d\n  }\x0d\n  return url;\x0d\n}\x0d\n\x0d\nasync function importModuleDynamically(specifier\x2C { url }\x2C assertions) {\x0d\n  return asyncESM.esmLoader.import(specifier\x2C url\x2C assertions);\x0d\n}\x0d\n\x0d\n// Strategy for loading a standard JavaScript module.\x0d\ntranslators.set('module'\x2C async function moduleStrategy(url\x2C source\x2C isMain) {\x0d\n  assertBufferSource(source\x2C true\x2C 'load');\x0d\n  source = stringify(source);\x0d\n  maybeCacheSourceMap(url\x2C source);\x0d\n  debug(`Translating StandardModule ${url}`);\x0d\n  const module = new ModuleWrap(url\x2C undefined\x2C source\x2C 0\x2C 0);\x0d\n  moduleWrap.callbackMap.set(module\x2C {\x0d\n    initializeImportMeta: (meta\x2C wrap) => this.importMetaInitialize(meta\x2C {\x0d\n      url: wrap.url\x0d\n    })\x2C\x0d\n    importModuleDynamically\x2C\x0d\n  });\x0d\n  return module;\x0d\n});\x0d\n\x0d\n/**\x0d\n * @param {Error | any} err\x0d\n * @param {string} [content] Content of the file\x2C if known.\x0d\n * @param {string} [filename] Useful only if `content` is unknown.\x0d\n */\x0d\nfunction enrichCJSError(err\x2C content\x2C filename) {\x0d\n  if (err != null && ObjectGetPrototypeOf(err) === SyntaxErrorPrototype &&\x0d\n      hasEsmSyntax(content || readFileSync(filename\x2C 'utf-8'))) {\x0d\n    // Emit the warning synchronously because we are in the middle of handling\x0d\n    // a SyntaxError that will throw and likely terminate the process before an\x0d\n    // asynchronous warning would be emitted.\x0d\n    emitWarningSync(\x0d\n      'To load an ES module\x2C set "type": "module" in the package.json or use ' +\x0d\n      'the .mjs extension.'\x0d\n    );\x0d\n  }\x0d\n}\x0d\n\x0d\n// Strategy for loading a node-style CommonJS module\x0d\nconst isWindows = process.platform === 'win32';\x0d\nconst winSepRegEx = /\\//g;\x0d\ntranslators.set('commonjs'\x2C async function commonjsStrategy(url\x2C source\x2C\x0d\n                                                            isMain) {\x0d\n  debug(`Translating CJSModule ${url}`);\x0d\n\x0d\n  let filename = internalURLModule.fileURLToPath(new URL(url));\x0d\n  if (isWindows)\x0d\n    filename = StringPrototypeReplace(filename\x2C winSepRegEx\x2C '\\\\');\x0d\n\x0d\n  if (!cjsParse) await initCJSParse();\x0d\n  const { module\x2C exportNames } = cjsPreparseModuleExports(filename);\x0d\n  const namesWithDefault = exportNames.has('default') ?\x0d\n    [...exportNames] : ['default'\x2C ...exportNames];\x0d\n\x0d\n  return new ModuleWrap(url\x2C undefined\x2C namesWithDefault\x2C function() {\x0d\n    debug(`Loading CJSModule ${url}`);\x0d\n\x0d\n    let exports;\x0d\n    if (asyncESM.esmLoader.cjsCache.has(module)) {\x0d\n      exports = asyncESM.esmLoader.cjsCache.get(module);\x0d\n      asyncESM.esmLoader.cjsCache.delete(module);\x0d\n    } else {\x0d\n      try {\x0d\n        exports = CJSModule._load(filename\x2C undefined\x2C isMain);\x0d\n      } catch (err) {\x0d\n        enrichCJSError(err\x2C undefined\x2C filename);\x0d\n        throw err;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    for (const exportName of exportNames) {\x0d\n      if (!ObjectPrototypeHasOwnProperty(exports\x2C exportName) ||\x0d\n          exportName === 'default')\x0d\n        continue;\x0d\n      // We might trigger a getter -> dont fail.\x0d\n      let value;\x0d\n      try {\x0d\n        value = exports[exportName];\x0d\n      } catch {}\x0d\n      this.setExport(exportName\x2C value);\x0d\n    }\x0d\n    this.setExport('default'\x2C exports);\x0d\n  });\x0d\n});\x0d\n\x0d\nfunction cjsPreparseModuleExports(filename) {\x0d\n  let module = CJSModule._cache[filename];\x0d\n  if (module) {\x0d\n    const cached = cjsParseCache.get(module);\x0d\n    if (cached)\x0d\n      return { module\x2C exportNames: cached.exportNames };\x0d\n  }\x0d\n  const loaded = Boolean(module);\x0d\n  if (!loaded) {\x0d\n    module = new CJSModule(filename);\x0d\n    module.filename = filename;\x0d\n    module.paths = CJSModule._nodeModulePaths(module.path);\x0d\n    CJSModule._cache[filename] = module;\x0d\n  }\x0d\n\x0d\n  let source;\x0d\n  try {\x0d\n    source = readFileSync(filename\x2C 'utf8');\x0d\n  } catch {}\x0d\n\x0d\n  let exports\x2C reexports;\x0d\n  try {\x0d\n    ({ exports\x2C reexports } = cjsParse(source || ''));\x0d\n  } catch {\x0d\n    exports = [];\x0d\n    reexports = [];\x0d\n  }\x0d\n\x0d\n  const exportNames = new SafeSet(new SafeArrayIterator(exports));\x0d\n\x0d\n  // Set first for cycles.\x0d\n  cjsParseCache.set(module\x2C { source\x2C exportNames\x2C loaded });\x0d\n\x0d\n  if (reexports.length) {\x0d\n    module.filename = filename;\x0d\n    module.paths = CJSModule._nodeModulePaths(module.path);\x0d\n  }\x0d\n  ArrayPrototypeForEach(reexports\x2C (reexport) => {\x0d\n    let resolved;\x0d\n    try {\x0d\n      resolved = CJSModule._resolveFilename(reexport\x2C module);\x0d\n    } catch {\x0d\n      return;\x0d\n    }\x0d\n    const ext = extname(resolved);\x0d\n    if ((ext === '.js' || ext === '.cjs' || !CJSModule._extensions[ext]) &&\x0d\n        isAbsolute(resolved)) {\x0d\n      const { exportNames: reexportNames } = cjsPreparseModuleExports(resolved);\x0d\n      for (const name of reexportNames)\x0d\n        exportNames.add(name);\x0d\n    }\x0d\n  });\x0d\n\x0d\n  return { module\x2C exportNames };\x0d\n}\x0d\n\x0d\n// Strategy for loading a node builtin CommonJS module that isn't\x0d\n// through normal resolution\x0d\ntranslators.set('builtin'\x2C async function builtinStrategy(url) {\x0d\n  debug(`Translating BuiltinModule ${url}`);\x0d\n  // Slice 'node:' scheme\x0d\n  const id = StringPrototypeSlice(url\x2C 5);\x0d\n  const module = loadNativeModule(id\x2C url);\x0d\n  if (!StringPrototypeStartsWith(url\x2C 'node:') || !module) {\x0d\n    throw new ERR_UNKNOWN_BUILTIN_MODULE(url);\x0d\n  }\x0d\n  debug(`Loading BuiltinModule ${url}`);\x0d\n  return module.getESMFacade();\x0d\n});\x0d\n\x0d\n// Strategy for loading a JSON file\x0d\ntranslators.set('json'\x2C async function jsonStrategy(url\x2C source) {\x0d\n  emitExperimentalWarning('Importing JSON modules');\x0d\n  assertBufferSource(source\x2C true\x2C 'load');\x0d\n  debug(`Loading JSONModule ${url}`);\x0d\n  const pathname = StringPrototypeStartsWith(url\x2C 'file:') ?\x0d\n    fileURLToPath(url) : null;\x0d\n  let modulePath;\x0d\n  let module;\x0d\n  if (pathname) {\x0d\n    modulePath = isWindows ?\x0d\n      StringPrototypeReplace(pathname\x2C winSepRegEx\x2C '\\\\') : pathname;\x0d\n    module = CJSModule._cache[modulePath];\x0d\n    if (module && module.loaded) {\x0d\n      const exports = module.exports;\x0d\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\x0d\n        this.setExport('default'\x2C exports);\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n  source = stringify(source);\x0d\n  if (pathname) {\x0d\n    // A require call could have been called on the same file during loading and\x0d\n    // that resolves synchronously. To make sure we always return the identical\x0d\n    // export\x2C we have to check again if the module already exists or not.\x0d\n    module = CJSModule._cache[modulePath];\x0d\n    if (module && module.loaded) {\x0d\n      const exports = module.exports;\x0d\n      return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\x0d\n        this.setExport('default'\x2C exports);\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n  try {\x0d\n    const exports = JSONParse(stripBOM(source));\x0d\n    module = {\x0d\n      exports\x2C\x0d\n      loaded: true\x0d\n    };\x0d\n  } catch (err) {\x0d\n    // TODO (BridgeAR): We could add a NodeCore error that wraps the JSON\x0d\n    // parse error instead of just manipulating the original error message.\x0d\n    // That would allow to add further properties and maybe additional\x0d\n    // debugging information.\x0d\n    err.message = errPath(url) + ': ' + err.message;\x0d\n    throw err;\x0d\n  }\x0d\n  if (pathname) {\x0d\n    CJSModule._cache[modulePath] = module;\x0d\n  }\x0d\n  return new ModuleWrap(url\x2C undefined\x2C ['default']\x2C function() {\x0d\n    debug(`Parsing JSONModule ${url}`);\x0d\n    this.setExport('default'\x2C module.exports);\x0d\n  });\x0d\n});\x0d\n\x0d\n// Strategy for loading a wasm module\x0d\ntranslators.set('wasm'\x2C async function(url\x2C source) {\x0d\n  emitExperimentalWarning('Importing WebAssembly modules');\x0d\n\x0d\n  assertBufferSource(source\x2C false\x2C 'load');\x0d\n\x0d\n  debug(`Translating WASMModule ${url}`);\x0d\n\x0d\n  let compiled;\x0d\n  try {\x0d\n    compiled = await WebAssembly.compile(source);\x0d\n  } catch (err) {\x0d\n    err.message = errPath(url) + ': ' + err.message;\x0d\n    throw err;\x0d\n  }\x0d\n\x0d\n  const imports =\x0d\n      ArrayPrototypeMap(WebAssembly.Module.imports(compiled)\x2C\x0d\n                        ({ module }) => module);\x0d\n  const exports =\x0d\n    ArrayPrototypeMap(WebAssembly.Module.exports(compiled)\x2C\x0d\n                      ({ name }) => name);\x0d\n\x0d\n  return createDynamicModule(imports\x2C exports\x2C url\x2C (reflect) => {\x0d\n    const { exports } = new WebAssembly.Instance(compiled\x2C reflect.imports);\x0d\n    for (const expt of ObjectKeys(exports))\x0d\n      reflect.exports[expt].set(exports[expt]);\x0d\n  }).module;\x0d\n});\x0d\n
code-source-info,0x109c10ec586,122,0,10933,C0O0C4O10933,,
code-creation,Function,10,220093,0x109c10ecd26,715, node:internal/modules/esm/translators:1:1,0x109c10ec500,~
code-source-info,0x109c10ecd26,122,0,10933,C0O0C180O28C186O54C192O76C198O88C204O102C210O127C216O161C222O176C228O198C233O210C239O222C245O249C251O274C257O304C268O343C274O392C275O392C277O543C283O543C288O526C294O591C300O591C305O567C311O576C317O673C323O673C328O620C334O637C340O658C346O767C352O767C357O734C363O748C369O834C375O834C379O834C381O888C387O888C391O888C393O979C399O979C404O956C410O971C416O1008C422O1008C427O1041C440O1042C446O1008C448O1125C454O1125C459O1097C465O1233C471O1233C476O1259C481O1163C487O1194C493O1300C499O1300C504O1276C510O1369C513O1369C517O1369C519O1425C522O1410C528O1455C534O1455C538O1455C540O1524C546O1524C551O1504C557O1586C563O1586C568O1570C574O1623C575O1623C577O1959C579O1959C585O1975C587O1995C591O2011C593O2034C597O2069C598O2069C600O3107C613O3107C619O4409C626O4418C629O4401C631O4452C635O4452C637O4472C650O4472C656O7578C669O7578C675O8040C688O8040C694O10044C707O10044C714O10932,,
code-creation,Eval,10,220362,0x109c10ee1fe,5, node:internal/modules/esm/create_dynamic_module:1:1,0x109c10ee028,~
script-source,123,node:internal/modules/esm/create_dynamic_module,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypeMap\x2C\x0d\n  JSONStringify\x2C\x0d\n  ObjectCreate\x2C\x0d\n  SafeSet\x2C\x0d\n} = primordials;\x0d\n\x0d\nlet debug = require('internal/util/debuglog').debuglog('esm'\x2C (fn) => {\x0d\n  debug = fn;\x0d\n});\x0d\n\x0d\nfunction createImport(impt\x2C index) {\x0d\n  const imptPath = JSONStringify(impt);\x0d\n  return `import * as $import_${index} from ${imptPath};\x0d\nimport.meta.imports[${imptPath}] = $import_${index};`;\x0d\n}\x0d\n\x0d\nfunction createExport(expt) {\x0d\n  const name = `${expt}`;\x0d\n  return `let $${name};\x0d\nexport { $${name} as ${name} };\x0d\nimport.meta.exports.${name} = {\x0d\n  get: () => $${name}\x2C\x0d\n  set: (v) => $${name} = v\x2C\x0d\n};`;\x0d\n}\x0d\n\x0d\nconst createDynamicModule = (imports\x2C exports\x2C url = ''\x2C evaluate) => {\x0d\n  debug('creating ESM facade for %s with exports: %j'\x2C url\x2C exports);\x0d\n  const source = `\x0d\n${ArrayPrototypeJoin(ArrayPrototypeMap(imports\x2C createImport)\x2C '\\n')}\x0d\n${ArrayPrototypeJoin(ArrayPrototypeMap(exports\x2C createExport)\x2C '\\n')}\x0d\nimport.meta.done();\x0d\n`;\x0d\n  const { ModuleWrap\x2C callbackMap } = internalBinding('module_wrap');\x0d\n  const m = new ModuleWrap(`${url}`\x2C undefined\x2C source\x2C 0\x2C 0);\x0d\n\x0d\n  const readyfns = new SafeSet();\x0d\n  const reflect = {\x0d\n    exports: ObjectCreate(null)\x2C\x0d\n    onReady: (cb) => { readyfns.add(cb); }\x2C\x0d\n  };\x0d\n\x0d\n  if (imports.length)\x0d\n    reflect.imports = ObjectCreate(null);\x0d\n\x0d\n  callbackMap.set(m\x2C {\x0d\n    initializeImportMeta: (meta\x2C wrap) => {\x0d\n      meta.exports = reflect.exports;\x0d\n      if (reflect.imports)\x0d\n        meta.imports = reflect.imports;\x0d\n      meta.done = () => {\x0d\n        evaluate(reflect);\x0d\n        reflect.onReady = (cb) => cb(reflect);\x0d\n        for (const fn of readyfns) {\x0d\n          readyfns.delete(fn);\x0d\n          fn(reflect);\x0d\n        }\x0d\n      };\x0d\n    }\x2C\x0d\n  });\x0d\n\x0d\n  return {\x0d\n    module: m\x2C\x0d\n    reflect\x2C\x0d\n  };\x0d\n};\x0d\n\x0d\nmodule.exports = createDynamicModule;\x0d\n
code-source-info,0x109c10ee1fe,123,0,1828,C0O0C4O1828,,
code-creation,Function,10,220489,0x109c10ee426,111, node:internal/modules/esm/create_dynamic_module:1:1,0x109c10ee178,~
code-source-info,0x109c10ee426,123,0,1828,C0O0C39O28C45O51C51O73C57O91C63O108C69O150C72O150C77O183C90O184C96O150C98O672C103O1789C105O1804C110O1827,,
code-creation,Eval,10,220913,0x109c10ef35e,5, node:internal/vm/module:1:1,0x109c10eee18,~
script-source,124,node:internal/vm/module,'use strict';\x0d\n\x0d\nconst assert = require('internal/assert');\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  ArrayPrototypeIndexOf\x2C\x0d\n  ArrayPrototypeSome\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectGetPrototypeOf\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  PromiseAll\x2C\x0d\n  ReflectApply\x2C\x0d\n  SafeWeakMap\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolToStringTag\x2C\x0d\n  TypeError\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { isContext } = internalBinding('contextify');\x0d\nconst {\x0d\n  isModuleNamespaceObject\x2C\x0d\n  isArrayBufferView\x2C\x0d\n} = require('internal/util/types');\x0d\nconst {\x0d\n  getConstructorOf\x2C\x0d\n  customInspectSymbol\x2C\x0d\n  emitExperimentalWarning\x2C\x0d\n} = require('internal/util');\x0d\nconst {\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n  ERR_INVALID_ARG_VALUE\x2C\x0d\n  ERR_VM_MODULE_ALREADY_LINKED\x2C\x0d\n  ERR_VM_MODULE_DIFFERENT_CONTEXT\x2C\x0d\n  ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA\x2C\x0d\n  ERR_VM_MODULE_LINKING_ERRORED\x2C\x0d\n  ERR_VM_MODULE_NOT_MODULE\x2C\x0d\n  ERR_VM_MODULE_STATUS\x2C\x0d\n} = require('internal/errors').codes;\x0d\nconst {\x0d\n  validateBoolean\x2C\x0d\n  validateFunction\x2C\x0d\n  validateInt32\x2C\x0d\n  validateObject\x2C\x0d\n  validateUint32\x2C\x0d\n  validateString\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst binding = internalBinding('module_wrap');\x0d\nconst {\x0d\n  ModuleWrap\x2C\x0d\n  kUninstantiated\x2C\x0d\n  kInstantiating\x2C\x0d\n  kInstantiated\x2C\x0d\n  kEvaluating\x2C\x0d\n  kEvaluated\x2C\x0d\n  kErrored\x2C\x0d\n} = binding;\x0d\n\x0d\nconst STATUS_MAP = {\x0d\n  [kUninstantiated]: 'unlinked'\x2C\x0d\n  [kInstantiating]: 'linking'\x2C\x0d\n  [kInstantiated]: 'linked'\x2C\x0d\n  [kEvaluating]: 'evaluating'\x2C\x0d\n  [kEvaluated]: 'evaluated'\x2C\x0d\n  [kErrored]: 'errored'\x2C\x0d\n};\x0d\n\x0d\nlet globalModuleId = 0;\x0d\nconst defaultModuleName = 'vm:module';\x0d\nconst wrapToModuleMap = new SafeWeakMap();\x0d\n\x0d\nconst kWrap = Symbol('kWrap');\x0d\nconst kContext = Symbol('kContext');\x0d\nconst kPerContextModuleId = Symbol('kPerContextModuleId');\x0d\nconst kLink = Symbol('kLink');\x0d\n\x0d\nclass Module {\x0d\n  constructor(options) {\x0d\n    emitExperimentalWarning('VM Modules');\x0d\n\x0d\n    if (new.target === Module) {\x0d\n      // eslint-disable-next-line no-restricted-syntax\x0d\n      throw new TypeError('Module is not a constructor');\x0d\n    }\x0d\n\x0d\n    const {\x0d\n      context\x2C\x0d\n      sourceText\x2C\x0d\n      syntheticExportNames\x2C\x0d\n      syntheticEvaluationSteps\x2C\x0d\n    } = options;\x0d\n\x0d\n    if (context !== undefined) {\x0d\n      validateObject(context\x2C 'context');\x0d\n      if (!isContext(context)) {\x0d\n        throw new ERR_INVALID_ARG_TYPE('options.context'\x2C 'vm.Context'\x2C\x0d\n                                       context);\x0d\n      }\x0d\n    }\x0d\n\x0d\n    let { identifier } = options;\x0d\n    if (identifier !== undefined) {\x0d\n      validateString(identifier\x2C 'options.identifier');\x0d\n    } else if (context === undefined) {\x0d\n      identifier = `${defaultModuleName}(${globalModuleId++})`;\x0d\n    } else if (context[kPerContextModuleId] !== undefined) {\x0d\n      const curId = context[kPerContextModuleId];\x0d\n      identifier = `${defaultModuleName}(${curId})`;\x0d\n      context[kPerContextModuleId] += 1;\x0d\n    } else {\x0d\n      identifier = `${defaultModuleName}(0)`;\x0d\n      ObjectDefineProperty(context\x2C kPerContextModuleId\x2C {\x0d\n        value: 1\x2C\x0d\n        writable: true\x2C\x0d\n        enumerable: false\x2C\x0d\n        configurable: true\x2C\x0d\n      });\x0d\n    }\x0d\n\x0d\n    if (sourceText !== undefined) {\x0d\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C sourceText\x2C\x0d\n                                   options.lineOffset\x2C options.columnOffset\x2C\x0d\n                                   options.cachedData);\x0d\n\x0d\n      binding.callbackMap.set(this[kWrap]\x2C {\x0d\n        initializeImportMeta: options.initializeImportMeta\x2C\x0d\n        importModuleDynamically: options.importModuleDynamically ?\x0d\n          importModuleDynamicallyWrap(options.importModuleDynamically) :\x0d\n          undefined\x2C\x0d\n      });\x0d\n    } else {\x0d\n      assert(syntheticEvaluationSteps);\x0d\n      this[kWrap] = new ModuleWrap(identifier\x2C context\x2C\x0d\n                                   syntheticExportNames\x2C\x0d\n                                   syntheticEvaluationSteps);\x0d\n    }\x0d\n\x0d\n    wrapToModuleMap.set(this[kWrap]\x2C this);\x0d\n\x0d\n    this[kContext] = context;\x0d\n  }\x0d\n\x0d\n  get identifier() {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    return this[kWrap].url;\x0d\n  }\x0d\n\x0d\n  get context() {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    return this[kContext];\x0d\n  }\x0d\n\x0d\n  get namespace() {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    if (this[kWrap].getStatus() < kInstantiated) {\x0d\n      throw new ERR_VM_MODULE_STATUS('must not be unlinked or linking');\x0d\n    }\x0d\n    return this[kWrap].getNamespace();\x0d\n  }\x0d\n\x0d\n  get status() {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    return STATUS_MAP[this[kWrap].getStatus()];\x0d\n  }\x0d\n\x0d\n  get error() {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    if (this[kWrap].getStatus() !== kErrored) {\x0d\n      throw new ERR_VM_MODULE_STATUS('must be errored');\x0d\n    }\x0d\n    return this[kWrap].getError();\x0d\n  }\x0d\n\x0d\n  async link(linker) {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    validateFunction(linker\x2C 'linker');\x0d\n    if (this.status === 'linked') {\x0d\n      throw new ERR_VM_MODULE_ALREADY_LINKED();\x0d\n    }\x0d\n    if (this.status !== 'unlinked') {\x0d\n      throw new ERR_VM_MODULE_STATUS('must be unlinked');\x0d\n    }\x0d\n    await this[kLink](linker);\x0d\n    this[kWrap].instantiate();\x0d\n  }\x0d\n\x0d\n  async evaluate(options = {}) {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n\x0d\n    validateObject(options\x2C 'options');\x0d\n\x0d\n    let timeout = options.timeout;\x0d\n    if (timeout === undefined) {\x0d\n      timeout = -1;\x0d\n    } else {\x0d\n      validateUint32(timeout\x2C 'options.timeout'\x2C true);\x0d\n    }\x0d\n    const { breakOnSigint = false } = options;\x0d\n    validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\x0d\n    const status = this[kWrap].getStatus();\x0d\n    if (status !== kInstantiated &&\x0d\n        status !== kEvaluated &&\x0d\n        status !== kErrored) {\x0d\n      throw new ERR_VM_MODULE_STATUS(\x0d\n        'must be one of linked\x2C evaluated\x2C or errored'\x0d\n      );\x0d\n    }\x0d\n    await this[kWrap].evaluate(timeout\x2C breakOnSigint);\x0d\n  }\x0d\n\x0d\n  [customInspectSymbol](depth\x2C options) {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    if (typeof depth === 'number' && depth < 0)\x0d\n      return this;\x0d\n\x0d\n    const constructor = getConstructorOf(this) || Module;\x0d\n    const o = ObjectCreate({ constructor });\x0d\n    o.status = this.status;\x0d\n    o.identifier = this.identifier;\x0d\n    o.context = this.context;\x0d\n\x0d\n    ObjectSetPrototypeOf(o\x2C ObjectGetPrototypeOf(this));\x0d\n    ObjectDefineProperty(o\x2C SymbolToStringTag\x2C {\x0d\n      value: constructor.name\x2C\x0d\n      configurable: true\x0d\n    });\x0d\n\x0d\n    // Lazy to avoid circular dependency\x0d\n    const { inspect } = require('internal/util/inspect');\x0d\n    return inspect(o\x2C { ...options\x2C customInspect: false });\x0d\n  }\x0d\n}\x0d\n\x0d\nconst kDependencySpecifiers = Symbol('kDependencySpecifiers');\x0d\nconst kNoError = Symbol('kNoError');\x0d\n\x0d\nclass SourceTextModule extends Module {\x0d\n  #error = kNoError;\x0d\n  #statusOverride;\x0d\n\x0d\n  constructor(sourceText\x2C options = {}) {\x0d\n    validateString(sourceText\x2C 'sourceText');\x0d\n    validateObject(options\x2C 'options');\x0d\n\x0d\n    const {\x0d\n      lineOffset = 0\x2C\x0d\n      columnOffset = 0\x2C\x0d\n      initializeImportMeta\x2C\x0d\n      importModuleDynamically\x2C\x0d\n      context\x2C\x0d\n      identifier\x2C\x0d\n      cachedData\x2C\x0d\n    } = options;\x0d\n\x0d\n    validateInt32(lineOffset\x2C 'options.lineOffset');\x0d\n    validateInt32(columnOffset\x2C 'options.columnOffset');\x0d\n\x0d\n    if (initializeImportMeta !== undefined &&\x0d\n        typeof initializeImportMeta !== 'function') {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'options.initializeImportMeta'\x2C 'function'\x2C initializeImportMeta);\x0d\n    }\x0d\n\x0d\n    if (importModuleDynamically !== undefined &&\x0d\n        typeof importModuleDynamically !== 'function') {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'options.importModuleDynamically'\x2C 'function'\x2C\x0d\n        importModuleDynamically);\x0d\n    }\x0d\n\x0d\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'options.cachedData'\x2C\x0d\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\x0d\n        cachedData\x0d\n      );\x0d\n    }\x0d\n\x0d\n    super({\x0d\n      sourceText\x2C\x0d\n      context\x2C\x0d\n      identifier\x2C\x0d\n      lineOffset\x2C\x0d\n      columnOffset\x2C\x0d\n      cachedData\x2C\x0d\n      initializeImportMeta\x2C\x0d\n      importModuleDynamically\x2C\x0d\n    });\x0d\n\x0d\n    this[kLink] = async (linker) => {\x0d\n      this.#statusOverride = 'linking';\x0d\n\x0d\n      const promises = this[kWrap].link(async (identifier\x2C assert) => {\x0d\n        const module = await linker(identifier\x2C this\x2C { assert });\x0d\n        if (module[kWrap] === undefined) {\x0d\n          throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n        }\x0d\n        if (module.context !== this.context) {\x0d\n          throw new ERR_VM_MODULE_DIFFERENT_CONTEXT();\x0d\n        }\x0d\n        if (module.status === 'errored') {\x0d\n          // TODO(devsnek): replace with ERR_VM_MODULE_LINK_FAILURE\x0d\n          // and error cause proposal.\x0d\n          throw new ERR_VM_MODULE_LINKING_ERRORED();\x0d\n        }\x0d\n        if (module.status === 'unlinked') {\x0d\n          await module[kLink](linker);\x0d\n        }\x0d\n        return module[kWrap];\x0d\n      });\x0d\n\x0d\n      try {\x0d\n        if (promises !== undefined) {\x0d\n          await PromiseAll(promises);\x0d\n        }\x0d\n      } catch (e) {\x0d\n        this.#error = e;\x0d\n        throw e;\x0d\n      } finally {\x0d\n        this.#statusOverride = undefined;\x0d\n      }\x0d\n    };\x0d\n\x0d\n    this[kDependencySpecifiers] = undefined;\x0d\n  }\x0d\n\x0d\n  get dependencySpecifiers() {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    if (this[kDependencySpecifiers] === undefined) {\x0d\n      this[kDependencySpecifiers] = this[kWrap].getStaticDependencySpecifiers();\x0d\n    }\x0d\n    return this[kDependencySpecifiers];\x0d\n  }\x0d\n\x0d\n  get status() {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    if (this.#error !== kNoError) {\x0d\n      return 'errored';\x0d\n    }\x0d\n    if (this.#statusOverride) {\x0d\n      return this.#statusOverride;\x0d\n    }\x0d\n    return super.status;\x0d\n  }\x0d\n\x0d\n  get error() {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    if (this.#error !== kNoError) {\x0d\n      return this.#error;\x0d\n    }\x0d\n    return super.error;\x0d\n  }\x0d\n\x0d\n  createCachedData() {\x0d\n    const { status } = this;\x0d\n    if (status === 'evaluating' ||\x0d\n        status === 'evaluated' ||\x0d\n        status === 'errored') {\x0d\n      throw new ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA();\x0d\n    }\x0d\n    return this[kWrap].createCachedData();\x0d\n  }\x0d\n}\x0d\n\x0d\nclass SyntheticModule extends Module {\x0d\n  constructor(exportNames\x2C evaluateCallback\x2C options = {}) {\x0d\n    if (!ArrayIsArray(exportNames) ||\x0d\n      ArrayPrototypeSome(exportNames\x2C (e) => typeof e !== 'string')) {\x0d\n      throw new ERR_INVALID_ARG_TYPE('exportNames'\x2C\x0d\n                                     'Array of unique strings'\x2C\x0d\n                                     exportNames);\x0d\n    } else {\x0d\n      ArrayPrototypeForEach(exportNames\x2C (name\x2C i) => {\x0d\n        if (ArrayPrototypeIndexOf(exportNames\x2C name\x2C i + 1) !== -1) {\x0d\n          throw new ERR_INVALID_ARG_VALUE(`exportNames.${name}`\x2C\x0d\n                                          name\x2C\x0d\n                                          'is duplicated');\x0d\n        }\x0d\n      });\x0d\n    }\x0d\n    validateFunction(evaluateCallback\x2C 'evaluateCallback');\x0d\n\x0d\n    validateObject(options\x2C 'options');\x0d\n\x0d\n    const { context\x2C identifier } = options;\x0d\n\x0d\n    super({\x0d\n      syntheticExportNames: exportNames\x2C\x0d\n      syntheticEvaluationSteps: evaluateCallback\x2C\x0d\n      context\x2C\x0d\n      identifier\x2C\x0d\n    });\x0d\n\x0d\n    this[kLink] = () => this[kWrap].link(() => {\x0d\n      assert.fail('link callback should not be called');\x0d\n    });\x0d\n  }\x0d\n\x0d\n  setExport(name\x2C value) {\x0d\n    if (this[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    validateString(name\x2C 'name');\x0d\n    if (this[kWrap].getStatus() < kInstantiated) {\x0d\n      throw new ERR_VM_MODULE_STATUS('must be linked');\x0d\n    }\x0d\n    this[kWrap].setExport(name\x2C value);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction importModuleDynamicallyWrap(importModuleDynamically) {\x0d\n  const importModuleDynamicallyWrapper = async (...args) => {\x0d\n    const m = await ReflectApply(importModuleDynamically\x2C this\x2C args);\x0d\n    if (isModuleNamespaceObject(m)) {\x0d\n      return m;\x0d\n    }\x0d\n    if (!m || m[kWrap] === undefined) {\x0d\n      throw new ERR_VM_MODULE_NOT_MODULE();\x0d\n    }\x0d\n    if (m.status === 'errored') {\x0d\n      throw m.error;\x0d\n    }\x0d\n    return m.namespace;\x0d\n  };\x0d\n  return importModuleDynamicallyWrapper;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  Module\x2C\x0d\n  SourceTextModule\x2C\x0d\n  SyntheticModule\x2C\x0d\n  importModuleDynamicallyWrap\x2C\x0d\n  getModuleFromWrap: (wrap) => wrapToModuleMap.get(wrap)\x2C\x0d\n};\x0d\n
code-source-info,0x109c10ef35e,124,0,12768,C0O0C4O12768,,
code-creation,Function,10,221562,0x109c10f05be,872, node:internal/vm/module:1:1,0x109c10ef2d8,~
code-source-info,0x109c10f05be,124,0,12768,C0O0C156O32C162O32C166O32C168O72C174O89C180O115C186O141C192O164C198O181C204O206C210O231C216O256C222O271C228O288C233O304C238O315C244O337C250O391C253O391C258O377C264O486C270O486C275O434C281O462C287O605C293O605C298O530C304O551C309O575C315O897C321O897C326O923C331O643C337O668C343O694C349O727C355O763C361O807C367O841C373O870C379O1061C385O1061C390O943C396O963C402O984C408O1002C414O1021C420O1040C426O1112C429O1112C433O1112C435O1274C438O1156C444O1171C449O1191C454O1210C460O1228C465O1244C471O1259C477O1305C484O1311C488O1329C495O1345C499O1362C506O1377C510O1393C517O1407C521O1421C528O1439C532O1452C539O1469C543O1480C550O1305C552O1519C553O1519C555O1549C557O1549C559O1587C561O1587C566O1587C568O1623C571O1623C575O1623C577O1658C580O1658C584O1658C586O1707C589O1707C593O1707C595O1753C598O1753C602O1753C660O6149C688O6934C691O6934C695O6934C697O6985C700O6985C704O6985C736O7039C799O10653C827O12601C834O12623C840O12634C846O12655C852O12675C856O12726C866O12616C871O12767,,
code-creation,Function,10,221700,0x109c10f0afe,30,<instance_members_initializer> node:internal/vm/module:256:3,0x109c10ef948,~
code-source-info,0x109c10f0afe,124,7051,7088,C3O7060C29O7088,,
code-creation,LazyCompile,10,221890,0x109c10f1f6e,30,ESMLoader node:internal/modules/esm/loader:57:1,0x1abee82ba70,~
code-source-info,0x109c10f1f6e,106,1613,1613,C9O1613C29O1613,,
code-creation,LazyCompile,10,221952,0x109c10f327e,27,ModuleMap node:internal/modules/esm/module_map:17:14,0x1abee82df28,~
code-source-info,0x109c10f327e,107,534,551,C3O540C7O546C11O540C26O550,,
code-creation,LazyCompile,10,222012,0x109c10f3526,13,desc.value node:internal/per_context/primordials:325:32,0x147335c9f88,~
code-source-info,0x109c10f3526,6,9820,9881,C0O9838C7O9845C12O9868,,
code-creation,LazyCompile,10,222055,0x109c10f362e,13,SafeIterator node:internal/per_context/primordials:270:16,0x147335c99d8,~
code-source-info,0x109c10f362e,6,8054,8116,C0O8074C3O8091C7O8089C12O8115,,
code-creation,LazyCompile,10,222100,0x109c10f3766,13,next node:internal/per_context/primordials:273:9,0x147335c9aa0,~
code-source-info,0x109c10f3766,6,8126,8173,C0O8138C3O8155C8O8145C12O8166,,
code-creation,Function,11,222169,0x29be72c4200,108,next node:internal/per_context/primordials:273:9,0x147335c9aa0,^
code-source-info,0x29be72c4200,6,8126,8173,,,
code-creation,Function,11,222205,0x29be72c4300,684,nativeModuleRequire node:internal/bootstrap/loaders:332:29,0x147335cfea0,^
code-source-info,0x29be72c4300,9,10647,11000,,,
code-creation,Function,11,222240,0x29be72c4640,1300,compileForInternalLoader node:internal/bootstrap/loaders:299:27,0x147335cfdd0,^
code-source-info,0x29be72c4640,9,9827,10410,,,
code-creation,Function,11,222268,0x29be72c4c00,444,getCLIOptionsFromBinding node:internal/options:18:34,0x1abee8055a0,^
code-source-info,0x29be72c4c00,97,514,620,,,
code-creation,Function,11,222291,0x29be72c4e40,180,isBrandCheck node:internal/webstreams/util:112:22,0x109c10db4c0,^
code-source-info,0x29be72c4e40,119,2509,2658,,,
code-creation,Function,11,222321,0x29be72c4f80,576,internalBinding node:internal/bootstrap/loaders:164:45,0x147335cf920,^
code-source-info,0x29be72c4f80,9,5278,5523,,,
code-creation,LazyCompile,10,222501,0x109c10f3c6e,152,deprecate node:internal/util:96:19,0x25ca2705698,~
code-source-info,0x109c10f3c6e,16,2503,3720,C0O2503C26O2524C31O2536C37O2550C42O2567C44O2577C45O2636C53O2675C61O2697C66O2678C83O2735C87O2764C100O2764C105O2812C106O2812C108O3407C121O3407C126O3448C129O3455C135O3652C141O3678C145O3673C149O3699C151O3717,,
code-creation,LazyCompile,10,222608,0x109c10f424e,28,getEmbedderOptions node:internal/options:32:28,0x1abee805640,~
code-source-info,0x109c10f424e,97,791,913,C0O799C6O828C11O846C17O844C23O887C27O910,,
code-creation,LazyCompile,10,222763,0x109c10f44f6,315,Module._initPaths node:internal/modules/cjs/loader:1223:29,0x1abee825030,~
code-source-info,0x109c10f44f6,103,39479,40463,C0O39503C9O39523C14O39527C22O39541C28O39541C33O39581C42O39601C47O39605C55O39617C61O39617C66O39816C74O39833C77O39838C85O39854C93O39838C103O39877C106O39882C114O39898C125O39882C131O39940C140O39941C143O39946C157O39946C169O39987C173O40007C180O40036C183O40041C191O40041C198O40007C203O40084C210O40113C213O40118C221O40118C228O40084C233O40164C237O40185C244O40219C249O40248C254O40279C257O40284C262O40248C270O40303C273O40219C279O40185C284O40330C286O40342C292O40406C297O40427C302O40447C305O40427C309O40425C314O40462,,
code-creation,Eval,10,222991,0x109c10f73be,5, node:internal/modules/run_main:1:1,0x109c10f7198,~
script-source,125,node:internal/modules/run_main,'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectCreate\x2C\x0d\n  StringPrototypeEndsWith\x2C\x0d\n} = primordials;\x0d\nconst CJSLoader = require('internal/modules/cjs/loader');\x0d\nconst { Module\x2C toRealPath\x2C readPackageScope } = CJSLoader;\x0d\nconst { getOptionValue } = require('internal/options');\x0d\nconst path = require('path');\x0d\nconst {\x0d\n  handleProcessExit\x2C\x0d\n} = require('internal/modules/esm/handle_process_exit');\x0d\n\x0d\nfunction resolveMainPath(main) {\x0d\n  // Note extension resolution for the main entry point can be deprecated in a\x0d\n  // future major.\x0d\n  // Module._findPath is monkey-patchable here.\x0d\n  let mainPath = Module._findPath(path.resolve(main)\x2C null\x2C true);\x0d\n  if (!mainPath)\x0d\n    return;\x0d\n\x0d\n  const preserveSymlinksMain = getOptionValue('--preserve-symlinks-main');\x0d\n  if (!preserveSymlinksMain)\x0d\n    mainPath = toRealPath(mainPath);\x0d\n\x0d\n  return mainPath;\x0d\n}\x0d\n\x0d\nfunction shouldUseESMLoader(mainPath) {\x0d\n  const userLoader = getOptionValue('--experimental-loader');\x0d\n  if (userLoader)\x0d\n    return true;\x0d\n  const esModuleSpecifierResolution =\x0d\n    getOptionValue('--experimental-specifier-resolution');\x0d\n  if (esModuleSpecifierResolution === 'node')\x0d\n    return true;\x0d\n  // Determine the module format of the main\x0d\n  if (mainPath && StringPrototypeEndsWith(mainPath\x2C '.mjs'))\x0d\n    return true;\x0d\n  if (!mainPath || StringPrototypeEndsWith(mainPath\x2C '.cjs'))\x0d\n    return false;\x0d\n  const pkg = readPackageScope(mainPath);\x0d\n  return pkg && pkg.data.type === 'module';\x0d\n}\x0d\n\x0d\nfunction runMainESM(mainPath) {\x0d\n  const { loadESM } = require('internal/process/esm_loader');\x0d\n  const { pathToFileURL } = require('internal/url');\x0d\n\x0d\n  handleMainPromise(loadESM((esmLoader) => {\x0d\n    const main = path.isAbsolute(mainPath) ?\x0d\n      pathToFileURL(mainPath).href : mainPath;\x0d\n    return esmLoader.import(main\x2C undefined\x2C ObjectCreate(null));\x0d\n  }));\x0d\n}\x0d\n\x0d\nasync function handleMainPromise(promise) {\x0d\n  process.on('exit'\x2C handleProcessExit);\x0d\n  try {\x0d\n    return await promise;\x0d\n  } finally {\x0d\n    process.off('exit'\x2C handleProcessExit);\x0d\n  }\x0d\n}\x0d\n\x0d\n// For backwards compatibility\x2C we have to run a bunch of\x0d\n// monkey-patchable code that belongs to the CJS loader (exposed by\x0d\n// `require('module')`) even when the entry point is ESM.\x0d\nfunction executeUserEntryPoint(main = process.argv[1]) {\x0d\n  const resolvedMain = resolveMainPath(main);\x0d\n  const useESMLoader = shouldUseESMLoader(resolvedMain);\x0d\n  if (useESMLoader) {\x0d\n    runMainESM(resolvedMain || main);\x0d\n  } else {\x0d\n    // Module._load is the monkey-patchable CJS module loader.\x0d\n    Module._load(main\x2C null\x2C true);\x0d\n  }\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  executeUserEntryPoint\x2C\x0d\n  handleMainPromise\x2C\x0d\n};\x0d\n
code-source-info,0x109c10f73be,125,0,2621,C0O0C4O2621,,
code-creation,Function,10,223146,0x109c10f76a6,178, node:internal/modules/run_main:1:1,0x109c10f7338,~
code-source-info,0x109c10f76a6,125,0,2621,C0O0C66O28C72O45C78O107C84O107C89O156C95O164C101O176C107O236C113O236C118O217C124O279C130O279C134O279C136O332C142O332C147O308C153O2549C160O2571C166O2597C172O2564C177O2620,,
code-creation,LazyCompile,10,223271,0x109c10f7c96,163,initializeESMLoader node:internal/bootstrap/pre_execution:422:29,0x1abee8037b8,~
code-source-info,0x109c10f7c96,96,13851,14966,C0O13935C6O13935C13O13984C16O13980C21O13978C25O14004C30O14008C34O14028C40O14057C41O14064C42O14169C48O14169C53O14083C58O14124C63O14216C69O14216C74O14420C79O14378C83O14491C88O14452C92O14661C100O14665C106O14784C112O14784C117O14732C122O14740C127O14758C132O14831C138O14831C143O14851C145O14861C149O14876C151O14896C155O14921C157O14940C162O14965,,
code-creation,LazyCompile,10,223352,0x109c10f7eae,5,get hasLoadedAnyUserCJSModule node:internal/modules/cjs/loader:74:32,0x1abee824520,~
code-source-info,0x109c10f7eae,103,2379,2419,C0O2384C4O2417,,
code-creation,LazyCompile,10,223404,0x109c10f7f56,21,assert node:internal/assert:11:16,0x25ca27204c0,~
script-source,21,node:internal/assert,'use strict';\x0d\n\x0d\nlet error;\x0d\nfunction lazyError() {\x0d\n  if (!error) {\x0d\n    error = require('internal/errors').codes.ERR_INTERNAL_ASSERTION;\x0d\n  }\x0d\n  return error;\x0d\n}\x0d\n\x0d\nfunction assert(value\x2C message) {\x0d\n  if (!value) {\x0d\n    const ERR_INTERNAL_ASSERTION = lazyError();\x0d\n    throw new ERR_INTERNAL_ASSERTION(message);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction fail(message) {\x0d\n  const ERR_INTERNAL_ASSERTION = lazyError();\x0d\n  throw new ERR_INTERNAL_ASSERTION(message);\x0d\n}\x0d\n\x0d\nassert.fail = fail;\x0d\n\x0d\nmodule.exports = assert;\x0d\n
code-source-info,0x109c10f7f56,21,182,322,C0O204C4O254C7O254C11O272C13O278C18O272C20O321,,
code-creation,LazyCompile,10,223490,0x109c10f8156,53,loadPreloadModules node:internal/bootstrap/pre_execution:465:28,0x1abee8038a8,~
code-source-info,0x109c10f8156,96,15458,15789,C0O15547C8O15547C13O15579C15O15616C21O15623C26O15704C32O15704C37O15704C42O15669C47O15749C52O15788,,
code-creation,LazyCompile,10,223567,0x109c10f834e,166,Module._preloadModules node:internal/modules/cjs/loader:1253:34,0x1abee8250c0,~
code-source-info,0x109c10f834e,103,40501,41096,C0O40517C5O40522C11O40551C12O40558C13O40564C17O40577C23O40777C33O40777C42O40829C45O40851C53O40876C58O40876C63O40851C68O40842C85O40906C88O40912C95O40917C100O40940C106O40953C114O40969C116O40969C119O41006C121O41022C125O41011C130O41047C137O41063C141O41047C146O41031C151O40993C154O41072C158O41085C165O41095,,
code-creation,LazyCompile,10,223649,0x109c10f856e,94,Module node:internal/modules/cjs/loader:172:16,0x1abee823e80,~
code-source-info,0x109c10f856e,103,5455,5701,C14O5478C16O5486C20O5495C22O5507C25O5512C30O5512C35O5505C39O5528C40O5541C44O5550C49O5568C54O5568C60O5590C71O5590C76O5630C77O5644C81O5655C82O5667C86O5679C88O5693C93O5700,,
code-creation,LazyCompile,10,223783,0x109c10f8766,449,dirname node:path:653:10,0x394c9e0d768,~
code-source-info,0x109c10f8766,41,21280,23908,C0O21294C8O21294C13O21346C18O21359C19O21367C24O21381C26O21392C27O21412C30O21434C32O21455C39O21455C45O21498C47O21506C52O21628C55O21635C67O21670C68O21713C71O21717C77O21779C81O21810C86O21830C92O21830C98O21814C104O21941C107O21964C108O22039C110O22033C120O22075C123O22075C129O22059C135O22125C140O22024C143O22150C145O22156C152O22167C157O22213C162O22295C164O22289C174O22332C177O22332C183O22316C189O22384C194O22280C197O22413C199O22419C206O22430C211O22480C216O22570C218O22564C228O22610C231O22610C237O22594C243O22664C248O22555C251O22697C253O22703C258O22774C260O22786C261O22815C263O22821C268O23051C270O23072C277O23166C280O23170C288O23215C294O23215C302O23254C304O23250C309O23275C311O23298C321O23321C327O23321C333O23305C346O23373C347O23415C350O23443C352O23467C354O23471C358O23478C360O23478C365O23503C370O23523C373O23523C379O23507C385O23571C389O23603C394O23623C398O23714C400O23491C405O23454C408O23759C410O23767C415O23784C417O23796C422O23813C424O23824C425O23834C430O23861C443O23868C448O23903,,
code-creation,LazyCompile,10,223930,0x109c10f8b6e,45,updateChildren node:internal/modules/cjs/loader:165:24,0x1abee823e30,~
code-source-info,0x109c10f8b6e,103,5213,5390,C0O5257C7O5263C15O5278C19O5296C23O5304C26O5304C33O5351C38O5351C44O5389,,
code-creation,LazyCompile,10,224025,0x109c10f8d5e,251,Module._nodeModulePaths node:internal/modules/cjs/loader:583:37,0x1abee8248d0,~
code-source-info,0x109c10f8d5e,103,17747,19298,C0O17804C5O17816C10O17816C17O18156C22O18197C26O18204C30O18160C38O18224C40O18209C47O18256C50O18293C54O18300C58O18256C66O18309C68O18305C73O18328C82O18341C91O18359C92O18381C95O18408C99O18415C103O18424C105O18439C110O18449C111O18449C116O18482C121O18482C127O18821C129O18834C131O18830C138O18877C140O18873C147O18919C149O18915C154O18942C156O18952C158O18948C163O18970C170O19023C181O19023C189O19059C193O18970C198O19101C201O19120C205O19141C207O19147C212O19166C219O19177C225O19181C230O19204C237O19238C240O18457C245O18390C248O19280C250O19293,,
code-creation,LazyCompile,10,224162,0x109c10f91be,127,Module.require node:internal/modules/cjs/loader:991:36,0x1abee824cc0,~
code-source-info,0x109c10f91be,103,31943,32246,C0O31953C8O31953C13O31982C15O31989C20O32004C36O32010C41O32004C42O32122C51O32134C60O32152C63O32166C76O32166C93O32223C102O32235C126O32245,,
code-creation,LazyCompile,10,224322,0x109c10f94a6,619,Module._load node:internal/modules/cjs/loader:757:24,0x1abee824b20,~
code-source-info,0x109c10f94a6,103,23946,26953,C0O23981C2O24011C6O24030C14O24090C23O24030C28O24324C42O24335C47O24368C54O24388C58O24422C60O24480C63O24487C70O24493C74O24512C76O24555C88O24555C93O24626C99O24645C102O24652C106O24695C107O24725C111O24733C112O24750C119O24778C121O24840C124O24847C138O24847C144O24893C152O24897C159O24990C167O24990C173O25047C178O25047C184O25083C189O25094C198O25127C205O25133C210O25127C211O25203C215O25211C216O25243C219O25250C226O25256C230O25271C232O25310C244O25310C249O25377C255O25420C260O25434C265O25434C271O25460C273O25504C279O25521C282O25528C286O25571C287O25579C288O25604C294O25653C298O25661C299O25691C304O25691C310O25731C315O25738C324O25773C328O25781C329O25870C344O25886C350O25921C354O25940C359O25959C363O25974C365O25984C369O26001C372O26008C379O26025C383O26038C387O26071C394O26119C398O26153C403O26180C409O26180C414O26201C426O26207C427O26236C432O26256C436O26270C444O26277C446O26295C450O26332C458O26360C460O26414C467O26420C475O26441C481O26445C487O26496C493O26496C499O26548C501O26558C506O26581C522O26581C529O26679C537O26707C541O26722C547O26707C555O26750C559O26778C565O26750C573O26809C575O26787C580O26856C586O26884C594O26893C598O26856C614O26942C618O26950,,
code-creation,LazyCompile,10,224476,0x109c10f993e,104,logger node:internal/util/debuglog:96:18,0x25ca2721ac8,~
code-source-info,0x109c10f993e,22,2994,3226,C0O2994C3O3027C30O3052C35O3059C38O3067C39O3083C45O3100C49O3090C53O3105C54O3121C60O3138C66O3147C70O3128C75O3152C76O3169C80O3176C87O3189C92O3185C98O3176C103O3214,,
code-creation,LazyCompile,10,224533,0x109c10f9a96,3, node:internal/per_context/primordials:276:21,0x147335c9b48,~
code-source-info,0x109c10f9a96,6,8195,8226,C0O8207C2O8219,,
code-creation,LazyCompile,10,224593,0x109c10f9b6e,155,debug node:internal/util/debuglog:76:15,0x25ca2721a28,~
code-source-info,0x109c10f9b6e,22,2432,2869,C0O2432C3O2452C6O2452C9O2563C16O2584C22O2571C30O2569C36O2604C42O2641C47O2644C50O2641C54O2670C81O2695C86O2702C89O2710C90O2726C96O2743C100O2733C104O2748C105O2764C111O2781C117O2790C121O2771C126O2795C127O2812C131O2819C138O2832C143O2828C149O2819C154O2857,,
code-creation,LazyCompile,10,224656,0x109c10f9d3e,41,init node:internal/util/debuglog:72:16,0x25ca27219d8,~
code-source-info,0x109c10f9d3e,22,2330,2416,C0O2340C10O2346C14O2344C16O2384C26O2394C33O2392C40O2415,,
code-creation,LazyCompile,10,224695,0x109c10f9e2e,2,testEnabled node:internal/util/debuglog:32:19,0x1abee8160e0,~
code-source-info,0x109c10f9e2e,22,1004,1015,C0O1010C1O1015,,
code-creation,LazyCompile,10,224760,0x109c10f9fc6,116,debuglogImpl node:internal/util/debuglog:49:22,0x25ca2721828,~
code-source-info,0x109c10f9fc6,22,1499,2059,C0O1499C9O1519C18O1533C23O1561C34O1595C39O1603C43O1595C45O1615C55O1615C59O1648C71O1659C75O1664C83O1994C97O2012C99O2010C103O2033C112O2050C115O2056,,
code-creation,LazyCompile,10,224814,0x109c10fa17e,10, node:internal/modules/cjs/loader:272:66,0x1abee8247f0,~
code-source-info,0x109c10fa17e,103,7980,8007,C0O7993C2O7999C9O8006,,
code-creation,LazyCompile,10,224849,0x109c10fa22e,2,noop node:internal/util/debuglog:47:14,0x25ca27217d8,~
code-source-info,0x109c10fa22e,22,1465,1473,C1O1472,,
code-creation,LazyCompile,10,225014,0x109c10fa62e,809,Module._resolveFilename node:internal/modules/cjs/loader:848:35,0x1abee824ba8,~
code-source-info,0x109c10fa62e,103,26992,30069,C0O27032C10O27036C19O27090C23O27103C29O27103C36O27141C38O27156C39O27171C41O27183C51O27243C57O27268C63O27247C69O27304C79O27304C88O27359C96O27359C105O27417C111O27430C119O27430C128O27487C136O27487C142O27541C144O27584C151O27635C164O27635C170O27668C173O27704C175O27719C181O27725C185O27709C190O27772C198O27777C202O27793C206O27819C212O27819C217O27810C221O27874C225O27881C231O27881C238O27949C240O27968C244O27954C249O27996C257O28042C262O28001C269O28063C277O28100C282O28063C287O27977C292O27936C295O27734C300O27691C305O28163C311O28193C315O28208C321O28208C330O28267C340O28324C348O28273C353O28267C356O28356C360O28371C366O28371C373O28419C380O28429C389O28448C390O28459C397O28463C402O28493C406O28517C412O28493C420O28549C428O28553C441O28600C447O28643C453O28674C457O28695C463O28674C471O28741C478O28643C485O28764C491O28791C497O28607C502O28797C516O28832C520O28838C528O28843C533O28884C539O28890C543O28884C544O28932C546O28932C547O29036C551O29036C556O29087C560O29087C566O29120C568O29162C570O29170C575O29198C583O29205C589O29218C596O29224C604O29224C609O29179C613O29265C617O29272C625O29293C629O29314C631O29334C632O29424C636O29431C654O29431C660O29476C662O29490C664O29506C665O29531C668O29556C673O29569C677O29629C683O29669C692O29688C698O29629C703O29589C709O29609C715O29609C721O29538C724O29715C730O29738C742O29770C749O29777C754O29789C756O29807C763O29849C771O29849C776O29832C780O29963C788O29963C794O29986C796O29995C800O30020C802O30037C806O30056C808O30056,,
code-creation,LazyCompile,10,225203,0x109c10fabe6,28,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x147335cfc00,~
code-source-info,0x109c10fabe6,9,7593,7692,C0O7617C5O7630C10O7634C15O7634C21O7648C23O7666C27O7687,,
code-creation,LazyCompile,10,225297,0x109c10fae9e,327,Module._resolveLookupPaths node:internal/modules/cjs/loader:667:38,0x1abee8249f0,~
code-source-info,0x109c10fae9e,103,20612,21826,C0O20635C5O20652C10O20652C17O20690C25O20690C30O20735C31O20747C32O20794C39O20798C47O20832C52O20859C59O20866C66O20880C72O20880C80O20914C87O20932C93O20932C101O20966C108O20986C114O20999C120O20999C128O21033C133O21066C138O21084C145O21094C152O21101C161O21120C166O21156C171O21128C177O21185C191O21185C196O21250C202O21257C212O21276C213O21327C217O21350C223O21364C229O21538C234O21552C248O21552C253O21608C255O21625C256O21636C264O21703C272O21636C277O21731C286O21732C289O21737C294O21752C299O21737C311O21767C319O21767C324O21806C326O21823,,
code-creation,LazyCompile,10,225404,0x109c10fb1be,76,trySelfParentPath node:internal/modules/cjs/loader:427:27,0x1abee8241a0,~
code-source-info,0x109c10fb1be,103,12696,12971,C0O12710C4O12723C5O12736C6O12753C12O12784C16O12793C17O12815C24O12818C29O12841C36O12844C44O12888C47O12903C52O12903C59O12911C62O12916C66O12909C69O12920C72O12943C73O12956C75O12970,,
code-creation,LazyCompile,10,225498,0x109c10fb3fe,232,trySelf node:internal/modules/cjs/loader:441:17,0x1abee8241f0,~
code-source-info,0x109c10fb3fe,103,12991,13840,C0O13018C4O13035C5O13048C6O13091C9O13091C17O13068C22O13079C27O13130C31O13146C37O13169C38O13182C39O13201C47O13220C48O13233C49O13243C51O13277C55O13269C60O13290C65O13317C70O13363C82O13321C89O13380C94O13398C97O13432C102O13437C107O13398C112O13396C118O13463C119O13476C123O13498C128O13527C133O13557C138O13579C142O13557C149O13622C152O13622C159O13649C168O13527C180O13505C185O13686C197O13709C200O13715C207O13720C212O13755C219O13799C223O13761C228O13755C229O13824C231O13824,,
code-creation,LazyCompile,10,225600,0x109c10fb6ae,129,readPackageScope node:internal/modules/cjs/loader:321:26,0x1abee823fc0,~
code-source-info,0x109c10fb6ae,103,9239,9772,C0O9283C7O9317C10O9283C16O9330C18O9359C25O9414C28O9376C34O9425C47O9437C54O9494C61O9533C66O9537C70O9498C77O9563C78O9576C79O9596C84O9620C86O9618C90O9596C95O9631C97O9642C104O9664C110O9684C116O9702C117O9730C119O9730C124O9349C127O9756C128O9769,,
code-creation,LazyCompile,10,225704,0x109c10fba0e,234,readPackage node:internal/modules/cjs/loader:290:21,0x1abee823f70,~
code-source-info,0x109c10fba0e,103,8391,9210,C0O8427C5O8432C13O8432C20O8492C25O8509C30O8509C36O8527C38O8555C40O8571C41O8592C46O8610C51O8610C57O8649C63O8662C72O8688C77O8699C79O8730C84O8747C91O8747C97O8774C98O8787C102O8824C107O8824C112O8863C117O8885C125O8911C133O8940C141O8972C149O9001C160O9019C165O9036C170O9036C176O9066C178O9082C190O9105C195O9112C199O9129C207O9158C213O9169C220O9180C224O9176C227O9139C231O9194C233O9194,,
code-creation,LazyCompile,10,225829,0x109c10fbd16,199,read node:internal/modules/package_json_reader:16:14,0x1abee829bc0,~
code-source-info,0x109c10fbd16,104,307,992,C0O323C5O333C10O333C17O355C22O368C27O368C32O382C33O432C40O461C43O461C48O432C53O404C59O415C66O512C73O514C79O522C86O568C92O568C97O549C102O600C106O633C112O670C115O681C127O732C132O766C142O679C148O805C154O853C159O853C164O885C169O894C174O894C180O943C185O949C190O949C196O975C198O989,,
code-creation,LazyCompile,10,225936,0x109c10fc136,232,toNamespacedPath node:path:618:19,0x394c9e0d6f8,~
code-source-info,0x109c10fc136,41,20086,21201,C0O20152C6O20189C12O20196C17O20210C19O20222C20O20251C25O20257C30O20257C36O20296C43O20303C48O20316C50O20328C51O20336C58O20340C66O20387C68O20383C73O20445C81O20449C89O20496C91O20492C96O20541C104O20541C110O20594C112O20607C114O20603C121O20638C123O20634C128O20738C133O20760C139O20760C148O20800C151O20833C156O20865C161O20865C167O20845C175O20919C181O20919C189O20966C191O20962C198O20987C204O20987C212O21034C214O21030C219O21137C224O21154C228O21169C229O21184C231O21196,,
code-creation,LazyCompile,10,226267,0x109c10fc8ee,436,Module._findPath node:internal/modules/cjs/loader:494:28,0x1abee824840,~
code-source-info,0x109c10fc8ee,103,14802,17488,C0O14856C5O14861C10O14861C16O14885C18O14913C26O14937C30O14957C36O14964C41O14978C42O14991C43O15019C45O15027C51O15038C57O15038C62O15036C66O15090C69O15097C76O15107C80O15122C82O15138C84O15151C85O15161C87O15198C93O15205C100O15217C103O15260C107O15267C111O15217C119O15281C121O15272C125O15304C127O15331C134O15367C137O15347C143O15440C145O15453C149O15445C154O15540C156O15545C160O15555C165O15570C172O15584C177O15589C179O15606C183O15661C186O15661C192O15702C194O15732C196O15755C197O15787C202O15792C207O15792C214O15828C216O15856C219O15856C224O15877C228O15906C229O15913C234O15941C238O15967C244O16004C249O16020C254O16020C262O16072C265O16083C272O16134C278O16757C283O16773C288O16773C296O16821C299O16832C304O16883C308O16956C312O16991C320O17016C325O16998C330O17039C342O17050C348O17112C354O17132C359O17219C363O17252C371O17277C376O17259C381O17298C396O17309C402O17368C406O17391C409O17398C416O17419C420O17438C422O17454C423O15462C428O15427C434O17472C435O17485,,
code-creation,LazyCompile,10,226410,0x109c10fcc9e,109,isAbsolute node:path:402:13,0x394c9e0d5d0,~
code-source-info,0x109c10fcc9e,41,13104,13523,C0O13118C8O13118C13O13170C18O13183C19O13191C24O13205C25O13218C26O13239C33O13239C39O13280C42O13287C50O13355C58O13369C66O13405C72O13405C80O13444C82O13440C92O13481C98O13481C104O13465C108O13518,,
code-creation,LazyCompile,10,226559,0x109c10fcf2e,85,stat node:internal/modules/cjs/loader:151:14,0x1abee823de0,~
code-source-info,0x109c10fcf2e,103,4777,5186,C0O4793C5O4809C10O4809C17O4840C23O4886C28O4896C33O4896C39O4916C41O4942C43O4956C44O4980C49O4980C54O5013C61O5046C66O5128C71O5138C76O5138C82O5169C84O5183,,
code-creation,LazyCompile,10,226713,0x109c10fd086,44,tryExtensions node:internal/modules/cjs/loader:400:23,0x1abee824100,~
code-source-info,0x109c10fd086,103,11900,12093,C0O11936C2O11948C6O11941C11O11985C16O12001C19O11995C23O11985C29O12022C31O12045C33O12061C34O11957C39O11923C42O12077C43O12090,,
code-creation,LazyCompile,10,226774,0x109c10fd1b6,50,tryFile node:internal/modules/cjs/loader:384:17,0x1abee824060,~
code-source-info,0x109c10fd1b6,103,11460,11661,C0O11498C3O11498C8O11520C9O11527C14O11534C15O11541C16O11545C24O11570C26O11585C31O11597C36O11597C41O11618C42O11627C45O11634C49O11658,,
code-creation,LazyCompile,10,226941,0x109c10fd2fe,42,toRealPath node:internal/modules/cjs/loader:393:20,0x1abee8240b0,~
code-source-info,0x109c10fd2fe,103,11684,11800,C0O11703C5O11713C10O11726C17O11747C20O11758C28O11777C35O11713C41O11797,,
new,MemoryChunk,0x1c1d96c0000,262144
code-creation,LazyCompile,10,227315,0x109c10fd72e,1036,realpathSync node:fs:2410:22,0x1d498299340,~
script-source,81,node:fs,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n// Maintainers\x2C keep in mind that ES1-style octal literals (`0666`) are not\x0d\n// allowed in strict mode. Use ES6-style octal literals instead (`0o666`).\x0d\n\x0d\n'use strict';\x0d\n\x0d\n// When using FSReqCallback\x2C make sure to create the object only *after* all\x0d\n// parameter validation has happened\x2C so that the objects are not kept in memory\x0d\n// in case they are created but never used due to an exception.\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypePush\x2C\x0d\n  BigIntPrototypeToString\x2C\x0d\n  MathMax\x2C\x0d\n  Number\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  Promise\x2C\x0d\n  ReflectApply\x2C\x0d\n  RegExpPrototypeExec\x2C\x0d\n  SafeMap\x2C\x0d\n  String\x2C\x0d\n  StringPrototypeCharCodeAt\x2C\x0d\n  StringPrototypeIndexOf\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { fs: constants } = internalBinding('constants');\x0d\nconst {\x0d\n  S_IFIFO\x2C\x0d\n  S_IFLNK\x2C\x0d\n  S_IFMT\x2C\x0d\n  S_IFREG\x2C\x0d\n  S_IFSOCK\x2C\x0d\n  F_OK\x2C\x0d\n  R_OK\x2C\x0d\n  W_OK\x2C\x0d\n  X_OK\x2C\x0d\n  O_WRONLY\x2C\x0d\n  O_SYMLINK\x0d\n} = constants;\x0d\n\x0d\nconst pathModule = require('path');\x0d\nconst { isArrayBufferView } = require('internal/util/types');\x0d\n\x0d\n// We need to get the statValues from the binding at the callsite since\x0d\n// it's re-initialized after deserialization.\x0d\n\x0d\nconst binding = internalBinding('fs');\x0d\nconst { Buffer } = require('buffer');\x0d\nconst {\x0d\n  aggregateTwoErrors\x2C\x0d\n  codes: {\x0d\n    ERR_FS_FILE_TOO_LARGE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_FEATURE_UNAVAILABLE_ON_PLATFORM\x2C\x0d\n  }\x2C\x0d\n  AbortError\x2C\x0d\n  uvErrmapGet\x2C\x0d\n  uvException\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst { FSReqCallback } = binding;\x0d\nconst { toPathIfFileURL } = require('internal/url');\x0d\nconst internalUtil = require('internal/util');\x0d\nconst {\x0d\n  constants: {\x0d\n    kIoMaxLength\x2C\x0d\n    kMaxUserId\x2C\x0d\n  }\x2C\x0d\n  copyObject\x2C\x0d\n  Dirent\x2C\x0d\n  emitRecursiveRmdirWarning\x2C\x0d\n  getDirents\x2C\x0d\n  getOptions\x2C\x0d\n  getValidatedFd\x2C\x0d\n  getValidatedPath\x2C\x0d\n  getValidMode\x2C\x0d\n  handleErrorFromBinding\x2C\x0d\n  nullCheck\x2C\x0d\n  preprocessSymlinkDestination\x2C\x0d\n  Stats\x2C\x0d\n  getStatsFromBinding\x2C\x0d\n  realpathCacheKey\x2C\x0d\n  stringToFlags\x2C\x0d\n  stringToSymlinkType\x2C\x0d\n  toUnixTimestamp\x2C\x0d\n  validateBufferArray\x2C\x0d\n  validateCpOptions\x2C\x0d\n  validateOffsetLengthRead\x2C\x0d\n  validateOffsetLengthWrite\x2C\x0d\n  validatePath\x2C\x0d\n  validatePosition\x2C\x0d\n  validateRmOptions\x2C\x0d\n  validateRmOptionsSync\x2C\x0d\n  validateRmdirOptions\x2C\x0d\n  validateStringAfterArrayBufferView\x2C\x0d\n  warnOnNonPortableTemplate\x0d\n} = require('internal/fs/utils');\x0d\nconst {\x0d\n  Dir\x2C\x0d\n  opendir\x2C\x0d\n  opendirSync\x0d\n} = require('internal/fs/dir');\x0d\nconst {\x0d\n  CHAR_FORWARD_SLASH\x2C\x0d\n  CHAR_BACKWARD_SLASH\x2C\x0d\n} = require('internal/constants');\x0d\nconst {\x0d\n  isUint32\x2C\x0d\n  parseFileMode\x2C\x0d\n  validateBoolean\x2C\x0d\n  validateBuffer\x2C\x0d\n  validateCallback\x2C\x0d\n  validateEncoding\x2C\x0d\n  validateFunction\x2C\x0d\n  validateInteger\x2C\x0d\n  validateString\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst watchers = require('internal/fs/watchers');\x0d\nconst ReadFileContext = require('internal/fs/read_file_context');\x0d\n\x0d\nlet truncateWarn = true;\x0d\nlet fs;\x0d\n\x0d\n// Lazy loaded\x0d\nlet cpFn;\x0d\nlet cpSyncFn;\x0d\nlet promises = null;\x0d\nlet ReadStream;\x0d\nlet WriteStream;\x0d\nlet rimraf;\x0d\nlet rimrafSync;\x0d\n\x0d\n// These have to be separate because of how graceful-fs happens to do it's\x0d\n// monkeypatching.\x0d\nlet FileReadStream;\x0d\nlet FileWriteStream;\x0d\n\x0d\nconst isWindows = process.platform === 'win32';\x0d\nconst isOSX = process.platform === 'darwin';\x0d\n\x0d\n\x0d\nfunction showTruncateDeprecation() {\x0d\n  if (truncateWarn) {\x0d\n    process.emitWarning(\x0d\n      'Using fs.truncate with a file descriptor is deprecated. Please use ' +\x0d\n      'fs.ftruncate with a file descriptor instead.'\x2C\x0d\n      'DeprecationWarning'\x2C 'DEP0081');\x0d\n    truncateWarn = false;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction maybeCallback(cb) {\x0d\n  validateCallback(cb);\x0d\n\x0d\n  return cb;\x0d\n}\x0d\n\x0d\n// Ensure that callbacks run in the global context. Only use this function\x0d\n// for callbacks that are passed to the binding layer\x2C callbacks that are\x0d\n// invoked from JS already run in the proper scope.\x0d\nfunction makeCallback(cb) {\x0d\n  validateCallback(cb);\x0d\n\x0d\n  return (...args) => ReflectApply(cb\x2C this\x2C args);\x0d\n}\x0d\n\x0d\n// Special case of `makeCallback()` that is specific to async `*stat()` calls as\x0d\n// an optimization\x2C since the data passed back to the callback needs to be\x0d\n// transformed anyway.\x0d\nfunction makeStatsCallback(cb) {\x0d\n  validateCallback(cb);\x0d\n\x0d\n  return (err\x2C stats) => {\x0d\n    if (err) return cb(err);\x0d\n    cb(err\x2C getStatsFromBinding(stats));\x0d\n  };\x0d\n}\x0d\n\x0d\nconst isFd = isUint32;\x0d\n\x0d\nfunction isFileType(stats\x2C fileType) {\x0d\n  // Use stats array directly to avoid creating an fs.Stats instance just for\x0d\n  // our internal use.\x0d\n  let mode = stats[1];\x0d\n  if (typeof mode === 'bigint')\x0d\n    mode = Number(mode);\x0d\n  return (mode & S_IFMT) === fileType;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Tests a user's permissions for the file or directory\x0d\n * specified by `path`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} [mode]\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction access(path\x2C mode\x2C callback) {\x0d\n  if (typeof mode === 'function') {\x0d\n    callback = mode;\x0d\n    mode = F_OK;\x0d\n  }\x0d\n\x0d\n  path = getValidatedPath(path);\x0d\n  mode = getValidMode(mode\x2C 'access');\x0d\n  callback = makeCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously tests a user's permissions for the file or\x0d\n * directory specified by `path`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} [mode]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction accessSync(path\x2C mode) {\x0d\n  path = getValidatedPath(path);\x0d\n  mode = getValidMode(mode\x2C 'access');\x0d\n\x0d\n  const ctx = { path };\x0d\n  binding.access(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Tests whether or not the given path exists.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {(exists?: boolean) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction exists(path\x2C callback) {\x0d\n  maybeCallback(callback);\x0d\n\x0d\n  function suppressedCallback(err) {\x0d\n    callback(err ? false : true);\x0d\n  }\x0d\n\x0d\n  try {\x0d\n    fs.access(path\x2C F_OK\x2C suppressedCallback);\x0d\n  } catch {\x0d\n    return callback(false);\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperty(exists\x2C internalUtil.promisify.custom\x2C {\x0d\n  value: (path) => {\x0d\n    return new Promise((resolve) => fs.exists(path\x2C resolve));\x0d\n  }\x0d\n});\x0d\n\x0d\n// fs.existsSync never throws\x2C it only returns true or false.\x0d\n// Since fs.existsSync never throws\x2C users have established\x0d\n// the expectation that passing invalid arguments to it\x2C even like\x0d\n// fs.existsSync()\x2C would only get a false in return\x2C so we cannot signal\x0d\n// validation errors to users properly out of compatibility concerns.\x0d\n// TODO(joyeecheung): deprecate the never-throw-on-invalid-arguments behavior\x0d\n/**\x0d\n * Synchronously tests whether or not the given path exists.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @returns {boolean}\x0d\n */\x0d\nfunction existsSync(path) {\x0d\n  try {\x0d\n    path = getValidatedPath(path);\x0d\n  } catch {\x0d\n    return false;\x0d\n  }\x0d\n  const ctx = { path };\x0d\n  const nPath = pathModule.toNamespacedPath(path);\x0d\n  binding.access(nPath\x2C F_OK\x2C undefined\x2C ctx);\x0d\n\x0d\n  // In case of an invalid symlink\x2C `binding.access()` on win32\x0d\n  // will **not** return an error and is therefore not enough.\x0d\n  // Double check with `binding.stat()`.\x0d\n  if (isWindows && ctx.errno === undefined) {\x0d\n    binding.stat(nPath\x2C false\x2C undefined\x2C ctx);\x0d\n  }\x0d\n\x0d\n  return ctx.errno === undefined;\x0d\n}\x0d\n\x0d\nfunction readFileAfterOpen(err\x2C fd) {\x0d\n  const context = this.context;\x0d\n\x0d\n  if (err) {\x0d\n    context.callback(err);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  context.fd = fd;\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = readFileAfterStat;\x0d\n  req.context = context;\x0d\n  binding.fstat(fd\x2C false\x2C req);\x0d\n}\x0d\n\x0d\nfunction readFileAfterStat(err\x2C stats) {\x0d\n  const context = this.context;\x0d\n\x0d\n  if (err)\x0d\n    return context.close(err);\x0d\n\x0d\n  const size = context.size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\x0d\n\x0d\n  if (size > kIoMaxLength) {\x0d\n    err = new ERR_FS_FILE_TOO_LARGE(size);\x0d\n    return context.close(err);\x0d\n  }\x0d\n\x0d\n  try {\x0d\n    if (size === 0) {\x0d\n      context.buffers = [];\x0d\n    } else {\x0d\n      context.buffer = Buffer.allocUnsafeSlow(size);\x0d\n    }\x0d\n  } catch (err) {\x0d\n    return context.close(err);\x0d\n  }\x0d\n  context.read();\x0d\n}\x0d\n\x0d\nfunction checkAborted(signal\x2C callback) {\x0d\n  if (signal?.aborted) {\x0d\n    callback(new AbortError(undefined\x2C { cause: signal?.reason }));\x0d\n    return true;\x0d\n  }\x0d\n  return false;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously reads the entire contents of a file.\x0d\n * @param {string | Buffer | URL | number} path\x0d\n * @param {{\x0d\n *   encoding?: string | null;\x0d\n *   flag?: string;\x0d\n *   signal?: AbortSignal;\x0d\n *   } | string} [options]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   data?: string | Buffer\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction readFile(path\x2C options\x2C callback) {\x0d\n  callback = maybeCallback(callback || options);\x0d\n  options = getOptions(options\x2C { flag: 'r' });\x0d\n  const context = new ReadFileContext(callback\x2C options.encoding);\x0d\n  context.isUserFd = isFd(path); // File descriptor ownership\x0d\n\x0d\n  if (options.signal) {\x0d\n    context.signal = options.signal;\x0d\n  }\x0d\n  if (context.isUserFd) {\x0d\n    process.nextTick(function tick(context) {\x0d\n      ReflectApply(readFileAfterOpen\x2C { context }\x2C [null\x2C path]);\x0d\n    }\x2C context);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (checkAborted(options.signal\x2C callback))\x0d\n    return;\x0d\n\x0d\n  const flagsNumber = stringToFlags(options.flag\x2C 'options.flag');\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.context = context;\x0d\n  req.oncomplete = readFileAfterOpen;\x0d\n  binding.open(pathModule.toNamespacedPath(path)\x2C\x0d\n               flagsNumber\x2C\x0d\n               0o666\x2C\x0d\n               req);\x0d\n}\x0d\n\x0d\nfunction tryStatSync(fd\x2C isUserFd) {\x0d\n  const ctx = {};\x0d\n  const stats = binding.fstat(fd\x2C false\x2C undefined\x2C ctx);\x0d\n  if (ctx.errno !== undefined && !isUserFd) {\x0d\n    fs.closeSync(fd);\x0d\n    throw uvException(ctx);\x0d\n  }\x0d\n  return stats;\x0d\n}\x0d\n\x0d\nfunction tryCreateBuffer(size\x2C fd\x2C isUserFd) {\x0d\n  let threw = true;\x0d\n  let buffer;\x0d\n  try {\x0d\n    if (size > kIoMaxLength) {\x0d\n      throw new ERR_FS_FILE_TOO_LARGE(size);\x0d\n    }\x0d\n    buffer = Buffer.allocUnsafe(size);\x0d\n    threw = false;\x0d\n  } finally {\x0d\n    if (threw && !isUserFd) fs.closeSync(fd);\x0d\n  }\x0d\n  return buffer;\x0d\n}\x0d\n\x0d\nfunction tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C len) {\x0d\n  let threw = true;\x0d\n  let bytesRead;\x0d\n  try {\x0d\n    bytesRead = fs.readSync(fd\x2C buffer\x2C pos\x2C len);\x0d\n    threw = false;\x0d\n  } finally {\x0d\n    if (threw && !isUserFd) fs.closeSync(fd);\x0d\n  }\x0d\n  return bytesRead;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously reads the entire contents of a file.\x0d\n * @param {string | Buffer | URL | number} path\x0d\n * @param {{\x0d\n *   encoding?: string | null;\x0d\n *   flag?: string;\x0d\n *   }} [options]\x0d\n * @returns {string | Buffer}\x0d\n */\x0d\nfunction readFileSync(path\x2C options) {\x0d\n  options = getOptions(options\x2C { flag: 'r' });\x0d\n  const isUserFd = isFd(path); // File descriptor ownership\x0d\n  const fd = isUserFd ? path : fs.openSync(path\x2C options.flag\x2C 0o666);\x0d\n\x0d\n  const stats = tryStatSync(fd\x2C isUserFd);\x0d\n  const size = isFileType(stats\x2C S_IFREG) ? stats[8] : 0;\x0d\n  let pos = 0;\x0d\n  let buffer; // Single buffer with file data\x0d\n  let buffers; // List for when size is unknown\x0d\n\x0d\n  if (size === 0) {\x0d\n    buffers = [];\x0d\n  } else {\x0d\n    buffer = tryCreateBuffer(size\x2C fd\x2C isUserFd);\x0d\n  }\x0d\n\x0d\n  let bytesRead;\x0d\n\x0d\n  if (size !== 0) {\x0d\n    do {\x0d\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C pos\x2C size - pos);\x0d\n      pos += bytesRead;\x0d\n    } while (bytesRead !== 0 && pos < size);\x0d\n  } else {\x0d\n    do {\x0d\n      // The kernel lies about many files.\x0d\n      // Go ahead and try to read some bytes.\x0d\n      buffer = Buffer.allocUnsafe(8192);\x0d\n      bytesRead = tryReadSync(fd\x2C isUserFd\x2C buffer\x2C 0\x2C 8192);\x0d\n      if (bytesRead !== 0) {\x0d\n        ArrayPrototypePush(buffers\x2C buffer.slice(0\x2C bytesRead));\x0d\n      }\x0d\n      pos += bytesRead;\x0d\n    } while (bytesRead !== 0);\x0d\n  }\x0d\n\x0d\n  if (!isUserFd)\x0d\n    fs.closeSync(fd);\x0d\n\x0d\n  if (size === 0) {\x0d\n    // Data was collected into the buffers list.\x0d\n    buffer = Buffer.concat(buffers\x2C pos);\x0d\n  } else if (pos < size) {\x0d\n    buffer = buffer.slice(0\x2C pos);\x0d\n  }\x0d\n\x0d\n  if (options.encoding) buffer = buffer.toString(options.encoding);\x0d\n  return buffer;\x0d\n}\x0d\n\x0d\nfunction defaultCloseCallback(err) {\x0d\n  if (err != null) throw err;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Closes the file descriptor.\x0d\n * @param {number} fd\x0d\n * @param {(err?: Error) => any} [callback]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction close(fd\x2C callback = defaultCloseCallback) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  if (callback !== defaultCloseCallback)\x0d\n    callback = makeCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.close(fd\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously closes the file descriptor.\x0d\n * @param {number} fd\x0d\n * @returns {void}\x0d\n */\x0d\nfunction closeSync(fd) {\x0d\n  fd = getValidatedFd(fd);\x0d\n\x0d\n  const ctx = {};\x0d\n  binding.close(fd\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously opens a file.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | number} [flags]\x0d\n * @param {string | number} [mode]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   fd?: number\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction open(path\x2C flags\x2C mode\x2C callback) {\x0d\n  path = getValidatedPath(path);\x0d\n  if (arguments.length < 3) {\x0d\n    callback = flags;\x0d\n    flags = 'r';\x0d\n    mode = 0o666;\x0d\n  } else if (typeof mode === 'function') {\x0d\n    callback = mode;\x0d\n    mode = 0o666;\x0d\n  } else {\x0d\n    mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\x0d\n  }\x0d\n  const flagsNumber = stringToFlags(flags);\x0d\n  callback = makeCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n\x0d\n  binding.open(pathModule.toNamespacedPath(path)\x2C\x0d\n               flagsNumber\x2C\x0d\n               mode\x2C\x0d\n               req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously opens a file.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | number} [flags]\x0d\n * @param {string | number} [mode]\x0d\n * @returns {number}\x0d\n */\x0d\nfunction openSync(path\x2C flags\x2C mode) {\x0d\n  path = getValidatedPath(path);\x0d\n  const flagsNumber = stringToFlags(flags);\x0d\n  mode = parseFileMode(mode\x2C 'mode'\x2C 0o666);\x0d\n\x0d\n  const ctx = { path };\x0d\n  const result = binding.open(pathModule.toNamespacedPath(path)\x2C\x0d\n                              flagsNumber\x2C mode\x2C\x0d\n                              undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Reads file from the specified `fd` (file descriptor).\x0d\n * @param {number} fd\x0d\n * @param {Buffer | TypedArray | DataView} buffer\x0d\n * @param {number} offset\x0d\n * @param {number} length\x0d\n * @param {number | bigint} position\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   bytesRead?: number\x2C\x0d\n *   buffer?: Buffer\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\x0d\n  fd = getValidatedFd(fd);\x0d\n\x0d\n  if (arguments.length <= 3) {\x0d\n    // Assume fs.read(fd\x2C options\x2C callback)\x0d\n    let options = {};\x0d\n    if (arguments.length < 3) {\x0d\n      // This is fs.read(fd\x2C callback)\x0d\n      // buffer will be the callback\x0d\n      callback = buffer;\x0d\n    } else {\x0d\n      // This is fs.read(fd\x2C {}\x2C callback)\x0d\n      // buffer will be the options object\x0d\n      // offset is the callback\x0d\n      options = buffer;\x0d\n      callback = offset;\x0d\n    }\x0d\n\x0d\n    ({\x0d\n      buffer = Buffer.alloc(16384)\x2C\x0d\n      offset = 0\x2C\x0d\n      length = buffer.byteLength\x2C\x0d\n      position\x0d\n    } = options);\x0d\n  }\x0d\n\x0d\n  validateBuffer(buffer);\x0d\n  callback = maybeCallback(callback);\x0d\n\x0d\n  if (offset == null) {\x0d\n    offset = 0;\x0d\n  } else {\x0d\n    validateInteger(offset\x2C 'offset'\x2C 0);\x0d\n  }\x0d\n\x0d\n  length |= 0;\x0d\n\x0d\n  if (length === 0) {\x0d\n    return process.nextTick(function tick() {\x0d\n      callback(null\x2C 0\x2C buffer);\x0d\n    });\x0d\n  }\x0d\n\x0d\n  if (buffer.byteLength === 0) {\x0d\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\x0d\n                                    'is empty and cannot be written');\x0d\n  }\x0d\n\x0d\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\x0d\n\x0d\n  if (position == null)\x0d\n    position = -1;\x0d\n\x0d\n  validatePosition(position\x2C 'position');\x0d\n\x0d\n  function wrapper(err\x2C bytesRead) {\x0d\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\x0d\n    callback(err\x2C bytesRead || 0\x2C buffer);\x0d\n  }\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = wrapper;\x0d\n\x0d\n  binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\x0d\n}\x0d\n\x0d\nObjectDefineProperty(read\x2C internalUtil.customPromisifyArgs\x2C\x0d\n                     { value: ['bytesRead'\x2C 'buffer']\x2C enumerable: false });\x0d\n\x0d\n/**\x0d\n * Synchronously reads the file from the\x0d\n * specified `fd` (file descriptor).\x0d\n * @param {number} fd\x0d\n * @param {Buffer | TypedArray | DataView} buffer\x0d\n * @param {{\x0d\n *   offset?: number;\x0d\n *   length?: number;\x0d\n *   position?: number | bigint;\x0d\n *   }} [offset]\x0d\n * @returns {number}\x0d\n */\x0d\nfunction readSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\x0d\n  fd = getValidatedFd(fd);\x0d\n\x0d\n  validateBuffer(buffer);\x0d\n\x0d\n  if (arguments.length <= 3) {\x0d\n    // Assume fs.read(fd\x2C buffer\x2C options)\x0d\n    const options = offset || {};\x0d\n\x0d\n    ({ offset = 0\x2C length = buffer.byteLength\x2C position } = options);\x0d\n  }\x0d\n\x0d\n  if (offset == null) {\x0d\n    offset = 0;\x0d\n  } else {\x0d\n    validateInteger(offset\x2C 'offset'\x2C 0);\x0d\n  }\x0d\n\x0d\n  length |= 0;\x0d\n\x0d\n  if (length === 0) {\x0d\n    return 0;\x0d\n  }\x0d\n\x0d\n  if (buffer.byteLength === 0) {\x0d\n    throw new ERR_INVALID_ARG_VALUE('buffer'\x2C buffer\x2C\x0d\n                                    'is empty and cannot be written');\x0d\n  }\x0d\n\x0d\n  validateOffsetLengthRead(offset\x2C length\x2C buffer.byteLength);\x0d\n\x0d\n  if (position == null)\x0d\n    position = -1;\x0d\n\x0d\n  validatePosition(position\x2C 'position');\x0d\n\x0d\n  const ctx = {};\x0d\n  const result = binding.read(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\x0d\n                              undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Reads file from the specified `fd` (file descriptor)\x0d\n * and writes to an array of `ArrayBufferView`s.\x0d\n * @param {number} fd\x0d\n * @param {ArrayBufferView[]} buffers\x0d\n * @param {number} [position]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   bytesRead?: number\x2C\x0d\n *   buffers?: ArrayBufferView[];\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction readv(fd\x2C buffers\x2C position\x2C callback) {\x0d\n  function wrapper(err\x2C read) {\x0d\n    callback(err\x2C read || 0\x2C buffers);\x0d\n  }\x0d\n\x0d\n  fd = getValidatedFd(fd);\x0d\n  validateBufferArray(buffers);\x0d\n  callback = maybeCallback(callback || position);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = wrapper;\x0d\n\x0d\n  if (typeof position !== 'number')\x0d\n    position = null;\x0d\n\x0d\n  return binding.readBuffers(fd\x2C buffers\x2C position\x2C req);\x0d\n}\x0d\n\x0d\nObjectDefineProperty(readv\x2C internalUtil.customPromisifyArgs\x2C\x0d\n                     { value: ['bytesRead'\x2C 'buffers']\x2C enumerable: false });\x0d\n\x0d\n/**\x0d\n * Synchronously reads file from the\x0d\n * specified `fd` (file descriptor) and writes to an array\x0d\n * of `ArrayBufferView`s.\x0d\n * @param {number} fd\x0d\n * @param {ArrayBufferView[]} buffers\x0d\n * @param {number} [position]\x0d\n * @returns {number}\x0d\n */\x0d\nfunction readvSync(fd\x2C buffers\x2C position) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  validateBufferArray(buffers);\x0d\n\x0d\n  const ctx = {};\x0d\n\x0d\n  if (typeof position !== 'number')\x0d\n    position = null;\x0d\n\x0d\n  const result = binding.readBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Writes `buffer` to the specified `fd` (file descriptor).\x0d\n * @param {number} fd\x0d\n * @param {Buffer | TypedArray | DataView | string | object} buffer\x0d\n * @param {number} [offset]\x0d\n * @param {number} [length]\x0d\n * @param {number} [position]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   bytesWritten?: number;\x0d\n *   buffer?: Buffer | TypedArray | DataView\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback) {\x0d\n  function wrapper(err\x2C written) {\x0d\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\x0d\n    callback(err\x2C written || 0\x2C buffer);\x0d\n  }\x0d\n\x0d\n  fd = getValidatedFd(fd);\x0d\n\x0d\n  if (isArrayBufferView(buffer)) {\x0d\n    callback = maybeCallback(callback || position || length || offset);\x0d\n    if (offset == null || typeof offset === 'function') {\x0d\n      offset = 0;\x0d\n    } else {\x0d\n      validateInteger(offset\x2C 'offset'\x2C 0);\x0d\n    }\x0d\n    if (typeof length !== 'number')\x0d\n      length = buffer.byteLength - offset;\x0d\n    if (typeof position !== 'number')\x0d\n      position = null;\x0d\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\x0d\n\x0d\n    const req = new FSReqCallback();\x0d\n    req.oncomplete = wrapper;\x0d\n    return binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C req);\x0d\n  }\x0d\n\x0d\n  validateStringAfterArrayBufferView(buffer\x2C 'buffer');\x0d\n\x0d\n  if (typeof position !== 'function') {\x0d\n    if (typeof offset === 'function') {\x0d\n      position = offset;\x0d\n      offset = null;\x0d\n    } else {\x0d\n      position = length;\x0d\n    }\x0d\n    length = 'utf8';\x0d\n  }\x0d\n\x0d\n  const str = String(buffer);\x0d\n  validateEncoding(str\x2C length);\x0d\n  callback = maybeCallback(position);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = wrapper;\x0d\n  return binding.writeString(fd\x2C str\x2C offset\x2C length\x2C req);\x0d\n}\x0d\n\x0d\nObjectDefineProperty(write\x2C internalUtil.customPromisifyArgs\x2C\x0d\n                     { value: ['bytesWritten'\x2C 'buffer']\x2C enumerable: false });\x0d\n\x0d\n/**\x0d\n * Synchronously writes `buffer` to the\x0d\n * specified `fd` (file descriptor).\x0d\n * @param {number} fd\x0d\n * @param {Buffer | TypedArray | DataView | string | object} buffer\x0d\n * @param {number} [offset]\x0d\n * @param {number} [length]\x0d\n * @param {number} [position]\x0d\n * @returns {number}\x0d\n */\x0d\nfunction writeSync(fd\x2C buffer\x2C offset\x2C length\x2C position) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  const ctx = {};\x0d\n  let result;\x0d\n  if (isArrayBufferView(buffer)) {\x0d\n    if (position === undefined)\x0d\n      position = null;\x0d\n    if (offset == null) {\x0d\n      offset = 0;\x0d\n    } else {\x0d\n      validateInteger(offset\x2C 'offset'\x2C 0);\x0d\n    }\x0d\n    if (typeof length !== 'number')\x0d\n      length = buffer.byteLength - offset;\x0d\n    validateOffsetLengthWrite(offset\x2C length\x2C buffer.byteLength);\x0d\n    result = binding.writeBuffer(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C\x0d\n                                 undefined\x2C ctx);\x0d\n  } else {\x0d\n    validateStringAfterArrayBufferView(buffer\x2C 'buffer');\x0d\n    validateEncoding(buffer\x2C length);\x0d\n\x0d\n    if (offset === undefined)\x0d\n      offset = null;\x0d\n    result = binding.writeString(fd\x2C buffer\x2C offset\x2C length\x2C\x0d\n                                 undefined\x2C ctx);\x0d\n  }\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Writes an array of `ArrayBufferView`s to the\x0d\n * specified `fd` (file descriptor).\x0d\n * @param {number} fd\x0d\n * @param {ArrayBufferView[]} buffers\x0d\n * @param {number} [position]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   bytesWritten?: number\x2C\x0d\n *   buffers?: ArrayBufferView[]\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction writev(fd\x2C buffers\x2C position\x2C callback) {\x0d\n  function wrapper(err\x2C written) {\x0d\n    callback(err\x2C written || 0\x2C buffers);\x0d\n  }\x0d\n\x0d\n  fd = getValidatedFd(fd);\x0d\n  validateBufferArray(buffers);\x0d\n  callback = maybeCallback(callback || position);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = wrapper;\x0d\n\x0d\n  if (typeof position !== 'number')\x0d\n    position = null;\x0d\n\x0d\n  return binding.writeBuffers(fd\x2C buffers\x2C position\x2C req);\x0d\n}\x0d\n\x0d\nObjectDefineProperty(writev\x2C internalUtil.customPromisifyArgs\x2C {\x0d\n  value: ['bytesWritten'\x2C 'buffer']\x2C\x0d\n  enumerable: false\x0d\n});\x0d\n\x0d\n/**\x0d\n * Synchronously writes an array of `ArrayBufferView`s\x0d\n * to the specified `fd` (file descriptor).\x0d\n * @param {number} fd\x0d\n * @param {ArrayBufferView[]} buffers\x0d\n * @param {number} [position]\x0d\n * @returns {number}\x0d\n */\x0d\nfunction writevSync(fd\x2C buffers\x2C position) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  validateBufferArray(buffers);\x0d\n\x0d\n  const ctx = {};\x0d\n\x0d\n  if (typeof position !== 'number')\x0d\n    position = null;\x0d\n\x0d\n  const result = binding.writeBuffers(fd\x2C buffers\x2C position\x2C undefined\x2C ctx);\x0d\n\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously renames file at `oldPath` to\x0d\n * the pathname provided as `newPath`.\x0d\n * @param {string | Buffer | URL} oldPath\x0d\n * @param {string | Buffer | URL} newPath\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction rename(oldPath\x2C newPath\x2C callback) {\x0d\n  callback = makeCallback(callback);\x0d\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\x0d\n  newPath = getValidatedPath(newPath\x2C 'newPath');\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\x0d\n                 pathModule.toNamespacedPath(newPath)\x2C\x0d\n                 req);\x0d\n}\x0d\n\x0d\n\x0d\n/**\x0d\n * Synchronously renames file at `oldPath` to\x0d\n * the pathname provided as `newPath`.\x0d\n * @param {string | Buffer | URL} oldPath\x0d\n * @param {string | Buffer | URL} newPath\x0d\n * @returns {void}\x0d\n */\x0d\nfunction renameSync(oldPath\x2C newPath) {\x0d\n  oldPath = getValidatedPath(oldPath\x2C 'oldPath');\x0d\n  newPath = getValidatedPath(newPath\x2C 'newPath');\x0d\n  const ctx = { path: oldPath\x2C dest: newPath };\x0d\n  binding.rename(pathModule.toNamespacedPath(oldPath)\x2C\x0d\n                 pathModule.toNamespacedPath(newPath)\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Truncates the file.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} [len]\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction truncate(path\x2C len\x2C callback) {\x0d\n  if (typeof path === 'number') {\x0d\n    showTruncateDeprecation();\x0d\n    return fs.ftruncate(path\x2C len\x2C callback);\x0d\n  }\x0d\n  if (typeof len === 'function') {\x0d\n    callback = len;\x0d\n    len = 0;\x0d\n  } else if (len === undefined) {\x0d\n    len = 0;\x0d\n  }\x0d\n\x0d\n  validateInteger(len\x2C 'len');\x0d\n  len = MathMax(0\x2C len);\x0d\n  callback = maybeCallback(callback);\x0d\n  fs.open(path\x2C 'r+'\x2C (er\x2C fd) => {\x0d\n    if (er) return callback(er);\x0d\n    const req = new FSReqCallback();\x0d\n    req.oncomplete = function oncomplete(er) {\x0d\n      fs.close(fd\x2C (er2) => {\x0d\n        callback(aggregateTwoErrors(er2\x2C er));\x0d\n      });\x0d\n    };\x0d\n    binding.ftruncate(fd\x2C len\x2C req);\x0d\n  });\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously truncates the file.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} [len]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction truncateSync(path\x2C len) {\x0d\n  if (typeof path === 'number') {\x0d\n    // legacy\x0d\n    showTruncateDeprecation();\x0d\n    return fs.ftruncateSync(path\x2C len);\x0d\n  }\x0d\n  if (len === undefined) {\x0d\n    len = 0;\x0d\n  }\x0d\n  // Allow error to be thrown\x2C but still close fd.\x0d\n  const fd = fs.openSync(path\x2C 'r+');\x0d\n  let ret;\x0d\n\x0d\n  try {\x0d\n    ret = fs.ftruncateSync(fd\x2C len);\x0d\n  } finally {\x0d\n    fs.closeSync(fd);\x0d\n  }\x0d\n  return ret;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Truncates the file descriptor.\x0d\n * @param {number} fd\x0d\n * @param {number} [len]\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction ftruncate(fd\x2C len = 0\x2C callback) {\x0d\n  if (typeof len === 'function') {\x0d\n    callback = len;\x0d\n    len = 0;\x0d\n  }\x0d\n  fd = getValidatedFd(fd);\x0d\n  validateInteger(len\x2C 'len');\x0d\n  len = MathMax(0\x2C len);\x0d\n  callback = makeCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.ftruncate(fd\x2C len\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously truncates the file descriptor.\x0d\n * @param {number} fd\x0d\n * @param {number} [len]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction ftruncateSync(fd\x2C len = 0) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  validateInteger(len\x2C 'len');\x0d\n  len = MathMax(0\x2C len);\x0d\n  const ctx = {};\x0d\n  binding.ftruncate(fd\x2C len\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\nfunction lazyLoadCp() {\x0d\n  if (cpFn === undefined) {\x0d\n    ({ cpFn } = require('internal/fs/cp/cp'));\x0d\n    cpFn = require('util').callbackify(cpFn);\x0d\n    ({ cpSyncFn } = require('internal/fs/cp/cp-sync'));\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction lazyLoadRimraf() {\x0d\n  if (rimraf === undefined)\x0d\n    ({ rimraf\x2C rimrafSync } = require('internal/fs/rimraf'));\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously removes a directory.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{\x0d\n *   maxRetries?: number;\x0d\n *   recursive?: boolean;\x0d\n *   retryDelay?: number;\x0d\n *   }} [options]\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction rmdir(path\x2C options\x2C callback) {\x0d\n  if (typeof options === 'function') {\x0d\n    callback = options;\x0d\n    options = undefined;\x0d\n  }\x0d\n\x0d\n  callback = makeCallback(callback);\x0d\n  path = pathModule.toNamespacedPath(getValidatedPath(path));\x0d\n\x0d\n  if (options?.recursive) {\x0d\n    emitRecursiveRmdirWarning();\x0d\n    validateRmOptions(\x0d\n      path\x2C\x0d\n      { ...options\x2C force: false }\x2C\x0d\n      true\x2C\x0d\n      (err\x2C options) => {\x0d\n        if (err === false) {\x0d\n          const req = new FSReqCallback();\x0d\n          req.oncomplete = callback;\x0d\n          return binding.rmdir(path\x2C req);\x0d\n        }\x0d\n        if (err) {\x0d\n          return callback(err);\x0d\n        }\x0d\n\x0d\n        lazyLoadRimraf();\x0d\n        rimraf(path\x2C options\x2C callback);\x0d\n      });\x0d\n  } else {\x0d\n    validateRmdirOptions(options);\x0d\n    const req = new FSReqCallback();\x0d\n    req.oncomplete = callback;\x0d\n    return binding.rmdir(path\x2C req);\x0d\n  }\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously removes a directory.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{\x0d\n *   maxRetries?: number;\x0d\n *   recursive?: boolean;\x0d\n *   retryDelay?: number;\x0d\n *   }} [options]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction rmdirSync(path\x2C options) {\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  if (options?.recursive) {\x0d\n    emitRecursiveRmdirWarning();\x0d\n    options = validateRmOptionsSync(path\x2C { ...options\x2C force: false }\x2C true);\x0d\n    if (options !== false) {\x0d\n      lazyLoadRimraf();\x0d\n      return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\x0d\n    }\x0d\n  } else {\x0d\n    validateRmdirOptions(options);\x0d\n  }\x0d\n\x0d\n  const ctx = { path };\x0d\n  binding.rmdir(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\x0d\n  return handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously removes files and\x0d\n * directories (modeled on the standard POSIX `rm` utility).\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{\x0d\n *   force?: boolean;\x0d\n *   maxRetries?: number;\x0d\n *   recursive?: boolean;\x0d\n *   retryDelay?: number;\x0d\n *   }} [options]\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction rm(path\x2C options\x2C callback) {\x0d\n  if (typeof options === 'function') {\x0d\n    callback = options;\x0d\n    options = undefined;\x0d\n  }\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  validateRmOptions(path\x2C options\x2C false\x2C (err\x2C options) => {\x0d\n    if (err) {\x0d\n      return callback(err);\x0d\n    }\x0d\n    lazyLoadRimraf();\x0d\n    return rimraf(pathModule.toNamespacedPath(path)\x2C options\x2C callback);\x0d\n  });\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously removes files and\x0d\n * directories (modeled on the standard POSIX `rm` utility).\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{\x0d\n *   force?: boolean;\x0d\n *   maxRetries?: number;\x0d\n *   recursive?: boolean;\x0d\n *   retryDelay?: number;\x0d\n *   }} [options]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction rmSync(path\x2C options) {\x0d\n  path = getValidatedPath(path);\x0d\n  options = validateRmOptionsSync(path\x2C options\x2C false);\x0d\n\x0d\n  lazyLoadRimraf();\x0d\n  return rimrafSync(pathModule.toNamespacedPath(path)\x2C options);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Forces all currently queued I/O operations associated\x0d\n * with the file to the operating system's synchronized\x0d\n * I/O completion state.\x0d\n * @param {number} fd\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction fdatasync(fd\x2C callback) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = makeCallback(callback);\x0d\n  binding.fdatasync(fd\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously forces all currently queued I/O operations\x0d\n * associated with the file to the operating\x0d\n * system's synchronized I/O completion state.\x0d\n * @param {number} fd\x0d\n * @returns {void}\x0d\n */\x0d\nfunction fdatasyncSync(fd) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  const ctx = {};\x0d\n  binding.fdatasync(fd\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Requests for all data for the open file descriptor\x0d\n * to be flushed to the storage device.\x0d\n * @param {number} fd\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction fsync(fd\x2C callback) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = makeCallback(callback);\x0d\n  binding.fsync(fd\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously requests for all data for the open\x0d\n * file descriptor to be flushed to the storage device.\x0d\n * @param {number} fd\x0d\n * @returns {void}\x0d\n */\x0d\nfunction fsyncSync(fd) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  const ctx = {};\x0d\n  binding.fsync(fd\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously creates a directory.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{\x0d\n *   recursive?: boolean;\x0d\n *   mode?: string | number;\x0d\n *   } | number} [options]\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction mkdir(path\x2C options\x2C callback) {\x0d\n  let mode = 0o777;\x0d\n  let recursive = false;\x0d\n  if (typeof options === 'function') {\x0d\n    callback = options;\x0d\n  } else if (typeof options === 'number' || typeof options === 'string') {\x0d\n    mode = options;\x0d\n  } else if (options) {\x0d\n    if (options.recursive !== undefined)\x0d\n      recursive = options.recursive;\x0d\n    if (options.mode !== undefined)\x0d\n      mode = options.mode;\x0d\n  }\x0d\n  callback = makeCallback(callback);\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  validateBoolean(recursive\x2C 'options.recursive');\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.mkdir(pathModule.toNamespacedPath(path)\x2C\x0d\n                parseFileMode(mode\x2C 'mode')\x2C recursive\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously creates a directory.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{\x0d\n *   recursive?: boolean;\x0d\n *   mode?: string | number;\x0d\n *   } | number} [options]\x0d\n * @returns {string | void}\x0d\n */\x0d\nfunction mkdirSync(path\x2C options) {\x0d\n  let mode = 0o777;\x0d\n  let recursive = false;\x0d\n  if (typeof options === 'number' || typeof options === 'string') {\x0d\n    mode = options;\x0d\n  } else if (options) {\x0d\n    if (options.recursive !== undefined)\x0d\n      recursive = options.recursive;\x0d\n    if (options.mode !== undefined)\x0d\n      mode = options.mode;\x0d\n  }\x0d\n  path = getValidatedPath(path);\x0d\n  validateBoolean(recursive\x2C 'options.recursive');\x0d\n\x0d\n  const ctx = { path };\x0d\n  const result = binding.mkdir(pathModule.toNamespacedPath(path)\x2C\x0d\n                               parseFileMode(mode\x2C 'mode')\x2C recursive\x2C\x0d\n                               undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  if (recursive) {\x0d\n    return result;\x0d\n  }\x0d\n}\x0d\n\x0d\n/**\x0d\n * Reads the contents of a directory.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | {\x0d\n *   encoding?: string;\x0d\n *   withFileTypes?: boolean;\x0d\n *   }} [options]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   files?: string[] | Buffer[] | Direct[];\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction readdir(path\x2C options\x2C callback) {\x0d\n  callback = makeCallback(typeof options === 'function' ? options : callback);\x0d\n  options = getOptions(options\x2C {});\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  if (!options.withFileTypes) {\x0d\n    req.oncomplete = callback;\x0d\n  } else {\x0d\n    req.oncomplete = (err\x2C result) => {\x0d\n      if (err) {\x0d\n        callback(err);\x0d\n        return;\x0d\n      }\x0d\n      getDirents(path\x2C result\x2C callback);\x0d\n    };\x0d\n  }\x0d\n  binding.readdir(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C\x0d\n                  !!options.withFileTypes\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously reads the contents of a directory.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | {\x0d\n *   encoding?: string;\x0d\n *   withFileTypes?: boolean;\x0d\n *   }} [options]\x0d\n * @returns {string | Buffer[] | Dirent[]}\x0d\n */\x0d\nfunction readdirSync(path\x2C options) {\x0d\n  options = getOptions(options\x2C {});\x0d\n  path = getValidatedPath(path);\x0d\n  const ctx = { path };\x0d\n  const result = binding.readdir(pathModule.toNamespacedPath(path)\x2C\x0d\n                                 options.encoding\x2C !!options.withFileTypes\x2C\x0d\n                                 undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return options.withFileTypes ? getDirents(path\x2C result) : result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Invokes the callback with the `fs.Stats`\x0d\n * for the file descriptor.\x0d\n * @param {number} fd\x0d\n * @param {{ bigint?: boolean; }} [options]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   stats?: Stats\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction fstat(fd\x2C options = { bigint: false }\x2C callback) {\x0d\n  if (typeof options === 'function') {\x0d\n    callback = options;\x0d\n    options = {};\x0d\n  }\x0d\n  fd = getValidatedFd(fd);\x0d\n  callback = makeStatsCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback(options.bigint);\x0d\n  req.oncomplete = callback;\x0d\n  binding.fstat(fd\x2C options.bigint\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Retrieves the `fs.Stats` for the symbolic link\x0d\n * referred to by the `path`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{ bigint?: boolean; }} [options]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   stats?: Stats\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction lstat(path\x2C options = { bigint: false }\x2C callback) {\x0d\n  if (typeof options === 'function') {\x0d\n    callback = options;\x0d\n    options = {};\x0d\n  }\x0d\n  callback = makeStatsCallback(callback);\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  const req = new FSReqCallback(options.bigint);\x0d\n  req.oncomplete = callback;\x0d\n  binding.lstat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously gets the stats of a file.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{ bigint?: boolean; }} [options]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   stats?: Stats\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction stat(path\x2C options = { bigint: false }\x2C callback) {\x0d\n  if (typeof options === 'function') {\x0d\n    callback = options;\x0d\n    options = {};\x0d\n  }\x0d\n  callback = makeStatsCallback(callback);\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  const req = new FSReqCallback(options.bigint);\x0d\n  req.oncomplete = callback;\x0d\n  binding.stat(pathModule.toNamespacedPath(path)\x2C options.bigint\x2C req);\x0d\n}\x0d\n\x0d\nfunction hasNoEntryError(ctx) {\x0d\n  if (ctx.errno) {\x0d\n    const uvErr = uvErrmapGet(ctx.errno);\x0d\n    return uvErr?.[0] === 'ENOENT';\x0d\n  }\x0d\n\x0d\n  if (ctx.error) {\x0d\n    return ctx.error.code === 'ENOENT';\x0d\n  }\x0d\n\x0d\n  return false;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously retrieves the `fs.Stats` for\x0d\n * the file descriptor.\x0d\n * @param {number} fd\x0d\n * @param {{\x0d\n *   bigint?: boolean;\x0d\n *   throwIfNoEntry?: boolean;\x0d\n *   }} [options]\x0d\n * @returns {Stats}\x0d\n */\x0d\nfunction fstatSync(fd\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  const ctx = { fd };\x0d\n  const stats = binding.fstat(fd\x2C options.bigint\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return getStatsFromBinding(stats);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously retrieves the `fs.Stats` for\x0d\n * the symbolic link referred to by the `path`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{\x0d\n *   bigint?: boolean;\x0d\n *   throwIfNoEntry?: boolean;\x0d\n *   }} [options]\x0d\n * @returns {Stats}\x0d\n */\x0d\nfunction lstatSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\x0d\n  path = getValidatedPath(path);\x0d\n  const ctx = { path };\x0d\n  const stats = binding.lstat(pathModule.toNamespacedPath(path)\x2C\x0d\n                              options.bigint\x2C undefined\x2C ctx);\x0d\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\x0d\n    return undefined;\x0d\n  }\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return getStatsFromBinding(stats);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously retrieves the `fs.Stats`\x0d\n * for the `path`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{\x0d\n *   bigint?: boolean;\x0d\n *   throwIfNoEntry?: boolean;\x0d\n *   }} [options]\x0d\n * @returns {Stats}\x0d\n */\x0d\nfunction statSync(path\x2C options = { bigint: false\x2C throwIfNoEntry: true }) {\x0d\n  path = getValidatedPath(path);\x0d\n  const ctx = { path };\x0d\n  const stats = binding.stat(pathModule.toNamespacedPath(path)\x2C\x0d\n                             options.bigint\x2C undefined\x2C ctx);\x0d\n  if (options.throwIfNoEntry === false && hasNoEntryError(ctx)) {\x0d\n    return undefined;\x0d\n  }\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return getStatsFromBinding(stats);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Reads the contents of a symbolic link\x0d\n * referred to by `path`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{ encoding?: string; } | string} [options]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   linkString?: string | Buffer\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction readlink(path\x2C options\x2C callback) {\x0d\n  callback = makeCallback(typeof options === 'function' ? options : callback);\x0d\n  options = getOptions(options\x2C {});\x0d\n  path = getValidatedPath(path\x2C 'oldPath');\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.readlink(pathModule.toNamespacedPath(path)\x2C options.encoding\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously reads the contents of a symbolic link\x0d\n * referred to by `path`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {{ encoding?: string; } | string} [options]\x0d\n * @returns {string | Buffer}\x0d\n */\x0d\nfunction readlinkSync(path\x2C options) {\x0d\n  options = getOptions(options\x2C {});\x0d\n  path = getValidatedPath(path\x2C 'oldPath');\x0d\n  const ctx = { path };\x0d\n  const result = binding.readlink(pathModule.toNamespacedPath(path)\x2C\x0d\n                                  options.encoding\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Creates the link called `path` pointing to `target`.\x0d\n * @param {string | Buffer | URL} target\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string} [type_]\x0d\n * @param {(err?: Error) => any} callback_\x0d\n * @returns {void}\x0d\n */\x0d\nfunction symlink(target\x2C path\x2C type_\x2C callback_) {\x0d\n  const type = (typeof type_ === 'string' ? type_ : null);\x0d\n  const callback = makeCallback(arguments[arguments.length - 1]);\x0d\n\x0d\n  target = getValidatedPath(target\x2C 'target');\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  if (isWindows && type === null) {\x0d\n    let absoluteTarget;\x0d\n    try {\x0d\n      // Symlinks targets can be relative to the newly created path.\x0d\n      // Calculate absolute file name of the symlink target\x2C and check\x0d\n      // if it is a directory. Ignore resolve error to keep symlink\x0d\n      // errors consistent between platforms if invalid path is\x0d\n      // provided.\x0d\n      absoluteTarget = pathModule.resolve(path\x2C '..'\x2C target);\x0d\n    } catch { }\x0d\n    if (absoluteTarget !== undefined) {\x0d\n      stat(absoluteTarget\x2C (err\x2C stat) => {\x0d\n        const resolvedType = !err && stat.isDirectory() ? 'dir' : 'file';\x0d\n        const resolvedFlags = stringToSymlinkType(resolvedType);\x0d\n        const destination = preprocessSymlinkDestination(target\x2C\x0d\n                                                         resolvedType\x2C\x0d\n                                                         path);\x0d\n\x0d\n        const req = new FSReqCallback();\x0d\n        req.oncomplete = callback;\x0d\n        binding.symlink(destination\x2C\x0d\n                        pathModule.toNamespacedPath(path)\x2C resolvedFlags\x2C req);\x0d\n      });\x0d\n      return;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  const destination = preprocessSymlinkDestination(target\x2C type\x2C path);\x0d\n\x0d\n  const flags = stringToSymlinkType(type);\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.symlink(destination\x2C pathModule.toNamespacedPath(path)\x2C flags\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously creates the link called `path`\x0d\n * pointing to `target`.\x0d\n * @param {string | Buffer | URL} target\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string} [type]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction symlinkSync(target\x2C path\x2C type) {\x0d\n  type = (typeof type === 'string' ? type : null);\x0d\n  if (isWindows && type === null) {\x0d\n    const absoluteTarget = pathModule.resolve(`${path}`\x2C '..'\x2C `${target}`);\x0d\n    if (statSync(absoluteTarget\x2C { throwIfNoEntry: false })?.isDirectory()) {\x0d\n      type = 'dir';\x0d\n    }\x0d\n  }\x0d\n  target = getValidatedPath(target\x2C 'target');\x0d\n  path = getValidatedPath(path);\x0d\n  const flags = stringToSymlinkType(type);\x0d\n\x0d\n  const ctx = { path: target\x2C dest: path };\x0d\n  binding.symlink(preprocessSymlinkDestination(target\x2C type\x2C path)\x2C\x0d\n                  pathModule.toNamespacedPath(path)\x2C flags\x2C undefined\x2C ctx);\x0d\n\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Creates a new link from the `existingPath`\x0d\n * to the `newPath`.\x0d\n * @param {string | Buffer | URL} existingPath\x0d\n * @param {string | Buffer | URL} newPath\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction link(existingPath\x2C newPath\x2C callback) {\x0d\n  callback = makeCallback(callback);\x0d\n\x0d\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\x0d\n  newPath = getValidatedPath(newPath\x2C 'newPath');\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n\x0d\n  binding.link(pathModule.toNamespacedPath(existingPath)\x2C\x0d\n               pathModule.toNamespacedPath(newPath)\x2C\x0d\n               req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously creates a new link from the `existingPath`\x0d\n * to the `newPath`.\x0d\n * @param {string | Buffer | URL} existingPath\x0d\n * @param {string | Buffer | URL} newPath\x0d\n * @returns {void}\x0d\n */\x0d\nfunction linkSync(existingPath\x2C newPath) {\x0d\n  existingPath = getValidatedPath(existingPath\x2C 'existingPath');\x0d\n  newPath = getValidatedPath(newPath\x2C 'newPath');\x0d\n\x0d\n  const ctx = { path: existingPath\x2C dest: newPath };\x0d\n  const result = binding.link(pathModule.toNamespacedPath(existingPath)\x2C\x0d\n                              pathModule.toNamespacedPath(newPath)\x2C\x0d\n                              undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously removes a file or symbolic link.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction unlink(path\x2C callback) {\x0d\n  callback = makeCallback(callback);\x0d\n  path = getValidatedPath(path);\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously removes a file or symbolic link.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @returns {void}\x0d\n */\x0d\nfunction unlinkSync(path) {\x0d\n  path = getValidatedPath(path);\x0d\n  const ctx = { path };\x0d\n  binding.unlink(pathModule.toNamespacedPath(path)\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Sets the permissions on the file.\x0d\n * @param {number} fd\x0d\n * @param {string | number} mode\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction fchmod(fd\x2C mode\x2C callback) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  mode = parseFileMode(mode\x2C 'mode');\x0d\n  callback = makeCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.fchmod(fd\x2C mode\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously sets the permissions on the file.\x0d\n * @param {number} fd\x0d\n * @param {string | number} mode\x0d\n * @returns {void}\x0d\n */\x0d\nfunction fchmodSync(fd\x2C mode) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  mode = parseFileMode(mode\x2C 'mode');\x0d\n  const ctx = {};\x0d\n  binding.fchmod(fd\x2C mode\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Changes the permissions on a symbolic link.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} mode\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction lchmod(path\x2C mode\x2C callback) {\x0d\n  callback = maybeCallback(callback);\x0d\n  mode = parseFileMode(mode\x2C 'mode');\x0d\n  fs.open(path\x2C O_WRONLY | O_SYMLINK\x2C (err\x2C fd) => {\x0d\n    if (err) {\x0d\n      callback(err);\x0d\n      return;\x0d\n    }\x0d\n    // Prefer to return the chmod error\x2C if one occurs\x2C\x0d\n    // but still try to close\x2C and report closing errors if they occur.\x0d\n    fs.fchmod(fd\x2C mode\x2C (err) => {\x0d\n      fs.close(fd\x2C (err2) => {\x0d\n        callback(aggregateTwoErrors(err2\x2C err));\x0d\n      });\x0d\n    });\x0d\n  });\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously changes the permissions on a symbolic link.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} mode\x0d\n * @returns {void}\x0d\n */\x0d\nfunction lchmodSync(path\x2C mode) {\x0d\n  const fd = fs.openSync(path\x2C O_WRONLY | O_SYMLINK);\x0d\n\x0d\n  // Prefer to return the chmod error\x2C if one occurs\x2C\x0d\n  // but still try to close\x2C and report closing errors if they occur.\x0d\n  let ret;\x0d\n  try {\x0d\n    ret = fs.fchmodSync(fd\x2C mode);\x0d\n  } finally {\x0d\n    fs.closeSync(fd);\x0d\n  }\x0d\n  return ret;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously changes the permissions of a file.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | number} mode\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction chmod(path\x2C mode\x2C callback) {\x0d\n  path = getValidatedPath(path);\x0d\n  mode = parseFileMode(mode\x2C 'mode');\x0d\n  callback = makeCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously changes the permissions of a file.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | number} mode\x0d\n * @returns {void}\x0d\n */\x0d\nfunction chmodSync(path\x2C mode) {\x0d\n  path = getValidatedPath(path);\x0d\n  mode = parseFileMode(mode\x2C 'mode');\x0d\n\x0d\n  const ctx = { path };\x0d\n  binding.chmod(pathModule.toNamespacedPath(path)\x2C mode\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Sets the owner of the symbolic link.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} uid\x0d\n * @param {number} gid\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction lchown(path\x2C uid\x2C gid\x2C callback) {\x0d\n  callback = makeCallback(callback);\x0d\n  path = getValidatedPath(path);\x0d\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\x0d\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously sets the owner of the symbolic link.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} uid\x0d\n * @param {number} gid\x0d\n * @returns {void}\x0d\n */\x0d\nfunction lchownSync(path\x2C uid\x2C gid) {\x0d\n  path = getValidatedPath(path);\x0d\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\x0d\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\x0d\n  const ctx = { path };\x0d\n  binding.lchown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Sets the owner of the file.\x0d\n * @param {number} fd\x0d\n * @param {number} uid\x0d\n * @param {number} gid\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction fchown(fd\x2C uid\x2C gid\x2C callback) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\x0d\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\x0d\n  callback = makeCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.fchown(fd\x2C uid\x2C gid\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously sets the owner of the file.\x0d\n * @param {number} fd\x0d\n * @param {number} uid\x0d\n * @param {number} gid\x0d\n * @returns {void}\x0d\n */\x0d\nfunction fchownSync(fd\x2C uid\x2C gid) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\x0d\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\x0d\n\x0d\n  const ctx = {};\x0d\n  binding.fchown(fd\x2C uid\x2C gid\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously changes the owner and group\x0d\n * of a file.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} uid\x0d\n * @param {number} gid\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction chown(path\x2C uid\x2C gid\x2C callback) {\x0d\n  callback = makeCallback(callback);\x0d\n  path = getValidatedPath(path);\x0d\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\x0d\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously changes the owner and group\x0d\n * of a file.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number} uid\x0d\n * @param {number} gid\x0d\n * @returns {void}\x0d\n */\x0d\nfunction chownSync(path\x2C uid\x2C gid) {\x0d\n  path = getValidatedPath(path);\x0d\n  validateInteger(uid\x2C 'uid'\x2C -1\x2C kMaxUserId);\x0d\n  validateInteger(gid\x2C 'gid'\x2C -1\x2C kMaxUserId);\x0d\n  const ctx = { path };\x0d\n  binding.chown(pathModule.toNamespacedPath(path)\x2C uid\x2C gid\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Changes the file system timestamps of the object\x0d\n * referenced by `path`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number | string | Date} atime\x0d\n * @param {number | string | Date} mtime\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction utimes(path\x2C atime\x2C mtime\x2C callback) {\x0d\n  callback = makeCallback(callback);\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\x0d\n                 toUnixTimestamp(atime)\x2C\x0d\n                 toUnixTimestamp(mtime)\x2C\x0d\n                 req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously changes the file system timestamps\x0d\n * of the object referenced by `path`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number | string | Date} atime\x0d\n * @param {number | string | Date} mtime\x0d\n * @returns {void}\x0d\n */\x0d\nfunction utimesSync(path\x2C atime\x2C mtime) {\x0d\n  path = getValidatedPath(path);\x0d\n  const ctx = { path };\x0d\n  binding.utimes(pathModule.toNamespacedPath(path)\x2C\x0d\n                 toUnixTimestamp(atime)\x2C toUnixTimestamp(mtime)\x2C\x0d\n                 undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Changes the file system timestamps of the object\x0d\n * referenced by the supplied `fd` (file descriptor).\x0d\n * @param {number} fd\x0d\n * @param {number | string | Date} atime\x0d\n * @param {number | string | Date} mtime\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction futimes(fd\x2C atime\x2C mtime\x2C callback) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  atime = toUnixTimestamp(atime\x2C 'atime');\x0d\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\x0d\n  callback = makeCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.futimes(fd\x2C atime\x2C mtime\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously changes the file system timestamps\x0d\n * of the object referenced by the\x0d\n * supplied `fd` (file descriptor).\x0d\n * @param {number} fd\x0d\n * @param {number | string | Date} atime\x0d\n * @param {number | string | Date} mtime\x0d\n * @returns {void}\x0d\n */\x0d\nfunction futimesSync(fd\x2C atime\x2C mtime) {\x0d\n  fd = getValidatedFd(fd);\x0d\n  atime = toUnixTimestamp(atime\x2C 'atime');\x0d\n  mtime = toUnixTimestamp(mtime\x2C 'mtime');\x0d\n  const ctx = {};\x0d\n  binding.futimes(fd\x2C atime\x2C mtime\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Changes the access and modification times of\x0d\n * a file in the same way as `fs.utimes()`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number | string | Date} atime\x0d\n * @param {number | string | Date} mtime\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction lutimes(path\x2C atime\x2C mtime\x2C callback) {\x0d\n  callback = makeCallback(callback);\x0d\n  path = getValidatedPath(path);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\x0d\n                  toUnixTimestamp(atime)\x2C\x0d\n                  toUnixTimestamp(mtime)\x2C\x0d\n                  req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously changes the access and modification\x0d\n * times of a file in the same way as `fs.utimesSync()`.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {number | string | Date} atime\x0d\n * @param {number | string | Date} mtime\x0d\n * @returns {void}\x0d\n */\x0d\nfunction lutimesSync(path\x2C atime\x2C mtime) {\x0d\n  path = getValidatedPath(path);\x0d\n  const ctx = { path };\x0d\n  binding.lutimes(pathModule.toNamespacedPath(path)\x2C\x0d\n                  toUnixTimestamp(atime)\x2C\x0d\n                  toUnixTimestamp(mtime)\x2C\x0d\n                  undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\nfunction writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback) {\x0d\n  if (signal?.aborted) {\x0d\n    const abortError = new AbortError(undefined\x2C { cause: signal?.reason });\x0d\n    if (isUserFd) {\x0d\n      callback(abortError);\x0d\n    } else {\x0d\n      fs.close(fd\x2C (err) => {\x0d\n        callback(aggregateTwoErrors(err\x2C abortError));\x0d\n      });\x0d\n    }\x0d\n    return;\x0d\n  }\x0d\n  // write(fd\x2C buffer\x2C offset\x2C length\x2C position\x2C callback)\x0d\n  fs.write(fd\x2C buffer\x2C offset\x2C length\x2C null\x2C (writeErr\x2C written) => {\x0d\n    if (writeErr) {\x0d\n      if (isUserFd) {\x0d\n        callback(writeErr);\x0d\n      } else {\x0d\n        fs.close(fd\x2C (err) => {\x0d\n          callback(aggregateTwoErrors(err\x2C writeErr));\x0d\n        });\x0d\n      }\x0d\n    } else if (written === length) {\x0d\n      if (isUserFd) {\x0d\n        callback(null);\x0d\n      } else {\x0d\n        fs.close(fd\x2C callback);\x0d\n      }\x0d\n    } else {\x0d\n      offset += written;\x0d\n      length -= written;\x0d\n      writeAll(fd\x2C isUserFd\x2C buffer\x2C offset\x2C length\x2C signal\x2C callback);\x0d\n    }\x0d\n  });\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously writes data to the file.\x0d\n * @param {string | Buffer | URL | number} path\x0d\n * @param {string | Buffer | TypedArray | DataView | object} data\x0d\n * @param {{\x0d\n *   encoding?: string | null;\x0d\n *   mode?: number;\x0d\n *   flag?: string;\x0d\n *   signal?: AbortSignal;\x0d\n *   } | string} [options]\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction writeFile(path\x2C data\x2C options\x2C callback) {\x0d\n  callback = maybeCallback(callback || options);\x0d\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\x0d\n  const flag = options.flag || 'w';\x0d\n\x0d\n  if (!isArrayBufferView(data)) {\x0d\n    validateStringAfterArrayBufferView(data\x2C 'data');\x0d\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\x0d\n  }\x0d\n\x0d\n  if (isFd(path)) {\x0d\n    const isUserFd = true;\x0d\n    const signal = options.signal;\x0d\n    writeAll(path\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (checkAborted(options.signal\x2C callback))\x0d\n    return;\x0d\n\x0d\n  fs.open(path\x2C flag\x2C options.mode\x2C (openErr\x2C fd) => {\x0d\n    if (openErr) {\x0d\n      callback(openErr);\x0d\n    } else {\x0d\n      const isUserFd = false;\x0d\n      const signal = options.signal;\x0d\n      writeAll(fd\x2C isUserFd\x2C data\x2C 0\x2C data.byteLength\x2C signal\x2C callback);\x0d\n    }\x0d\n  });\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously writes data to the file.\x0d\n * @param {string | Buffer | URL | number} path\x0d\n * @param {string | Buffer | TypedArray | DataView | object} data\x0d\n * @param {{\x0d\n *   encoding?: string | null;\x0d\n *   mode?: number;\x0d\n *   flag?: string;\x0d\n *   } | string} [options]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction writeFileSync(path\x2C data\x2C options) {\x0d\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'w' });\x0d\n\x0d\n  if (!isArrayBufferView(data)) {\x0d\n    validateStringAfterArrayBufferView(data\x2C 'data');\x0d\n    data = Buffer.from(String(data)\x2C options.encoding || 'utf8');\x0d\n  }\x0d\n\x0d\n  const flag = options.flag || 'w';\x0d\n\x0d\n  const isUserFd = isFd(path); // File descriptor ownership\x0d\n  const fd = isUserFd ? path : fs.openSync(path\x2C flag\x2C options.mode);\x0d\n\x0d\n  let offset = 0;\x0d\n  let length = data.byteLength;\x0d\n  try {\x0d\n    while (length > 0) {\x0d\n      const written = fs.writeSync(fd\x2C data\x2C offset\x2C length);\x0d\n      offset += written;\x0d\n      length -= written;\x0d\n    }\x0d\n  } finally {\x0d\n    if (!isUserFd) fs.closeSync(fd);\x0d\n  }\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously appends data to a file.\x0d\n * @param {string | Buffer | URL | number} path\x0d\n * @param {string | Buffer} data\x0d\n * @param {{\x0d\n *   encoding?: string | null;\x0d\n *   mode?: number;\x0d\n *   flag?: string;\x0d\n *   } | string} [options]\x0d\n * @param {(err?: Error) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction appendFile(path\x2C data\x2C options\x2C callback) {\x0d\n  callback = maybeCallback(callback || options);\x0d\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\x0d\n\x0d\n  // Don't make changes directly on options object\x0d\n  options = copyObject(options);\x0d\n\x0d\n  // Force append behavior when using a supplied file descriptor\x0d\n  if (!options.flag || isFd(path))\x0d\n    options.flag = 'a';\x0d\n\x0d\n  fs.writeFile(path\x2C data\x2C options\x2C callback);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously appends data to a file.\x0d\n * @param {string | Buffer | URL | number} path\x0d\n * @param {string | Buffer} data\x0d\n * @param {{\x0d\n *   encoding?: string | null;\x0d\n *   mode?: number;\x0d\n *   flag?: string;\x0d\n *   } | string} [options]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction appendFileSync(path\x2C data\x2C options) {\x0d\n  options = getOptions(options\x2C { encoding: 'utf8'\x2C mode: 0o666\x2C flag: 'a' });\x0d\n\x0d\n  // Don't make changes directly on options object\x0d\n  options = copyObject(options);\x0d\n\x0d\n  // Force append behavior when using a supplied file descriptor\x0d\n  if (!options.flag || isFd(path))\x0d\n    options.flag = 'a';\x0d\n\x0d\n  fs.writeFileSync(path\x2C data\x2C options);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Watches for the changes on `filename`.\x0d\n * @param {string | Buffer | URL} filename\x0d\n * @param {string | {\x0d\n *   persistent?: boolean;\x0d\n *   recursive?: boolean;\x0d\n *   encoding?: string;\x0d\n *   signal?: AbortSignal;\x0d\n *   }} [options]\x0d\n * @param {(\x0d\n *   eventType?: string\x2C\x0d\n *   filename?: string | Buffer\x0d\n *   ) => any} [listener]\x0d\n * @returns {watchers.FSWatcher}\x0d\n */\x0d\nfunction watch(filename\x2C options\x2C listener) {\x0d\n  if (typeof options === 'function') {\x0d\n    listener = options;\x0d\n  }\x0d\n  options = getOptions(options\x2C {});\x0d\n\x0d\n  // Don't make changes directly on options object\x0d\n  options = copyObject(options);\x0d\n\x0d\n  if (options.persistent === undefined) options.persistent = true;\x0d\n  if (options.recursive === undefined) options.recursive = false;\x0d\n  if (options.recursive && !(isOSX || isWindows))\x0d\n    throw new ERR_FEATURE_UNAVAILABLE_ON_PLATFORM('watch recursively');\x0d\n  const watcher = new watchers.FSWatcher();\x0d\n  watcher[watchers.kFSWatchStart](filename\x2C\x0d\n                                  options.persistent\x2C\x0d\n                                  options.recursive\x2C\x0d\n                                  options.encoding);\x0d\n\x0d\n  if (listener) {\x0d\n    watcher.addListener('change'\x2C listener);\x0d\n  }\x0d\n  if (options.signal) {\x0d\n    if (options.signal.aborted) {\x0d\n      process.nextTick(() => watcher.close());\x0d\n    } else {\x0d\n      const listener = () => watcher.close();\x0d\n      options.signal.addEventListener('abort'\x2C listener);\x0d\n      watcher.once('close'\x2C () => {\x0d\n        options.signal.removeEventListener('abort'\x2C listener);\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return watcher;\x0d\n}\x0d\n\x0d\n\x0d\nconst statWatchers = new SafeMap();\x0d\n\x0d\n/**\x0d\n * Watches for changes on `filename`.\x0d\n * @param {string | Buffer | URL} filename\x0d\n * @param {{\x0d\n *   bigint?: boolean;\x0d\n *   persistent?: boolean;\x0d\n *   interval?: number;\x0d\n *   }} [options]\x0d\n * @param {(\x0d\n *   current?: Stats\x2C\x0d\n *   previous?: Stats\x0d\n *   ) => any} listener\x0d\n * @returns {watchers.StatWatcher}\x0d\n */\x0d\nfunction watchFile(filename\x2C options\x2C listener) {\x0d\n  filename = getValidatedPath(filename);\x0d\n  filename = pathModule.resolve(filename);\x0d\n  let stat;\x0d\n\x0d\n  if (options === null || typeof options !== 'object') {\x0d\n    listener = options;\x0d\n    options = null;\x0d\n  }\x0d\n\x0d\n  options = {\x0d\n    // Poll interval in milliseconds. 5007 is what libev used to use. It's\x0d\n    // a little on the slow side but let's stick with it for now to keep\x0d\n    // behavioral changes to a minimum.\x0d\n    interval: 5007\x2C\x0d\n    persistent: true\x2C\x0d\n    ...options\x0d\n  };\x0d\n\x0d\n  validateFunction(listener\x2C 'listener');\x0d\n\x0d\n  stat = statWatchers.get(filename);\x0d\n\x0d\n  if (stat === undefined) {\x0d\n    stat = new watchers.StatWatcher(options.bigint);\x0d\n    stat[watchers.kFSStatWatcherStart](filename\x2C\x0d\n                                       options.persistent\x2C options.interval);\x0d\n    statWatchers.set(filename\x2C stat);\x0d\n  } else {\x0d\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('add');\x0d\n  }\x0d\n\x0d\n  stat.addListener('change'\x2C listener);\x0d\n  return stat;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Stops watching for changes on `filename`.\x0d\n * @param {string | Buffer | URL} filename\x0d\n * @param {() => any} [listener]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction unwatchFile(filename\x2C listener) {\x0d\n  filename = getValidatedPath(filename);\x0d\n  filename = pathModule.resolve(filename);\x0d\n  const stat = statWatchers.get(filename);\x0d\n\x0d\n  if (stat === undefined) return;\x0d\n\x0d\n  if (typeof listener === 'function') {\x0d\n    const beforeListenerCount = stat.listenerCount('change');\x0d\n    stat.removeListener('change'\x2C listener);\x0d\n    if (stat.listenerCount('change') < beforeListenerCount)\x0d\n      stat[watchers.kFSStatWatcherAddOrCleanRef]('clean');\x0d\n  } else {\x0d\n    stat.removeAllListeners('change');\x0d\n    stat[watchers.kFSStatWatcherAddOrCleanRef]('cleanAll');\x0d\n  }\x0d\n\x0d\n  if (stat.listenerCount('change') === 0) {\x0d\n    stat.stop();\x0d\n    statWatchers.delete(filename);\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nlet splitRoot;\x0d\nif (isWindows) {\x0d\n  // Regex to find the device root on Windows (e.g. 'c:\\\\')\x2C including trailing\x0d\n  // slash.\x0d\n  const splitRootRe = /^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*/;\x0d\n  splitRoot = function splitRoot(str) {\x0d\n    return RegExpPrototypeExec(splitRootRe\x2C str)[0];\x0d\n  };\x0d\n} else {\x0d\n  splitRoot = function splitRoot(str) {\x0d\n    for (let i = 0; i < str.length; ++i) {\x0d\n      if (StringPrototypeCharCodeAt(str\x2C i) !== CHAR_FORWARD_SLASH)\x0d\n        return StringPrototypeSlice(str\x2C 0\x2C i);\x0d\n    }\x0d\n    return str;\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction encodeRealpathResult(result\x2C options) {\x0d\n  if (!options || !options.encoding || options.encoding === 'utf8')\x0d\n    return result;\x0d\n  const asBuffer = Buffer.from(result);\x0d\n  if (options.encoding === 'buffer') {\x0d\n    return asBuffer;\x0d\n  }\x0d\n  return asBuffer.toString(options.encoding);\x0d\n}\x0d\n\x0d\n// Finds the next portion of a (partial) path\x2C up to the next path delimiter\x0d\nlet nextPart;\x0d\nif (isWindows) {\x0d\n  nextPart = function nextPart(p\x2C i) {\x0d\n    for (; i < p.length; ++i) {\x0d\n      const ch = StringPrototypeCharCodeAt(p\x2C i);\x0d\n\x0d\n      // Check for a separator character\x0d\n      if (ch === CHAR_BACKWARD_SLASH || ch === CHAR_FORWARD_SLASH)\x0d\n        return i;\x0d\n    }\x0d\n    return -1;\x0d\n  };\x0d\n} else {\x0d\n  nextPart = function nextPart(p\x2C i) {\x0d\n    return StringPrototypeIndexOf(p\x2C '/'\x2C i);\x0d\n  };\x0d\n}\x0d\n\x0d\nconst emptyObj = ObjectCreate(null);\x0d\n\x0d\n/**\x0d\n * Returns the resolved pathname.\x0d\n * @param {string | Buffer | URL} p\x0d\n * @param {string | { encoding?: string | null; }} [options]\x0d\n * @returns {string | Buffer}\x0d\n */\x0d\nfunction realpathSync(p\x2C options) {\x0d\n  options = getOptions(options\x2C emptyObj);\x0d\n  p = toPathIfFileURL(p);\x0d\n  if (typeof p !== 'string') {\x0d\n    p += '';\x0d\n  }\x0d\n  validatePath(p);\x0d\n  p = pathModule.resolve(p);\x0d\n\x0d\n  const cache = options[realpathCacheKey];\x0d\n  const maybeCachedResult = cache?.get(p);\x0d\n  if (maybeCachedResult) {\x0d\n    return maybeCachedResult;\x0d\n  }\x0d\n\x0d\n  const seenLinks = ObjectCreate(null);\x0d\n  const knownHard = ObjectCreate(null);\x0d\n  const original = p;\x0d\n\x0d\n  // Current character position in p\x0d\n  let pos;\x0d\n  // The partial path so far\x2C including a trailing slash if any\x0d\n  let current;\x0d\n  // The partial path without a trailing slash (except when pointing at a root)\x0d\n  let base;\x0d\n  // The partial path scanned in the previous round\x2C with slash\x0d\n  let previous;\x0d\n\x0d\n  // Skip over roots\x0d\n  current = base = splitRoot(p);\x0d\n  pos = current.length;\x0d\n\x0d\n  // On windows\x2C check that the root exists. On unix there is no need.\x0d\n  if (isWindows) {\x0d\n    const ctx = { path: base };\x0d\n    binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\x0d\n    handleErrorFromBinding(ctx);\x0d\n    knownHard[base] = true;\x0d\n  }\x0d\n\x0d\n  // Walk down the path\x2C swapping out linked path parts for their real\x0d\n  // values\x0d\n  // NB: p.length changes.\x0d\n  while (pos < p.length) {\x0d\n    // find the next part\x0d\n    const result = nextPart(p\x2C pos);\x0d\n    previous = current;\x0d\n    if (result === -1) {\x0d\n      const last = StringPrototypeSlice(p\x2C pos);\x0d\n      current += last;\x0d\n      base = previous + last;\x0d\n      pos = p.length;\x0d\n    } else {\x0d\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\x0d\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\x0d\n      pos = result + 1;\x0d\n    }\x0d\n\x0d\n    // Continue if not a symlink\x2C break if a pipe/socket\x0d\n    if (knownHard[base] || cache?.get(base) === base) {\x0d\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\x0d\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\x0d\n        break;\x0d\n      }\x0d\n      continue;\x0d\n    }\x0d\n\x0d\n    let resolvedLink;\x0d\n    const maybeCachedResolved = cache?.get(base);\x0d\n    if (maybeCachedResolved) {\x0d\n      resolvedLink = maybeCachedResolved;\x0d\n    } else {\x0d\n      // Use stats array directly to avoid creating an fs.Stats instance just\x0d\n      // for our internal use.\x0d\n\x0d\n      const baseLong = pathModule.toNamespacedPath(base);\x0d\n      const ctx = { path: base };\x0d\n      const stats = binding.lstat(baseLong\x2C true\x2C undefined\x2C ctx);\x0d\n      handleErrorFromBinding(ctx);\x0d\n\x0d\n      if (!isFileType(stats\x2C S_IFLNK)) {\x0d\n        knownHard[base] = true;\x0d\n        cache?.set(base\x2C base);\x0d\n        continue;\x0d\n      }\x0d\n\x0d\n      // Read the link if it wasn't read before\x0d\n      // dev/ino always return 0 on windows\x2C so skip the check.\x0d\n      let linkTarget = null;\x0d\n      let id;\x0d\n      if (!isWindows) {\x0d\n        const dev = BigIntPrototypeToString(stats[0]\x2C 32);\x0d\n        const ino = BigIntPrototypeToString(stats[7]\x2C 32);\x0d\n        id = `${dev}:${ino}`;\x0d\n        if (seenLinks[id]) {\x0d\n          linkTarget = seenLinks[id];\x0d\n        }\x0d\n      }\x0d\n      if (linkTarget === null) {\x0d\n        const ctx = { path: base };\x0d\n        binding.stat(baseLong\x2C false\x2C undefined\x2C ctx);\x0d\n        handleErrorFromBinding(ctx);\x0d\n        linkTarget = binding.readlink(baseLong\x2C undefined\x2C undefined\x2C ctx);\x0d\n        handleErrorFromBinding(ctx);\x0d\n      }\x0d\n      resolvedLink = pathModule.resolve(previous\x2C linkTarget);\x0d\n\x0d\n      if (cache) cache.set(base\x2C resolvedLink);\x0d\n      if (!isWindows) seenLinks[id] = linkTarget;\x0d\n    }\x0d\n\x0d\n    // Resolve the link\x2C then start over\x0d\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\x0d\n\x0d\n    // Skip over roots\x0d\n    current = base = splitRoot(p);\x0d\n    pos = current.length;\x0d\n\x0d\n    // On windows\x2C check that the root exists. On unix there is no need.\x0d\n    if (isWindows && !knownHard[base]) {\x0d\n      const ctx = { path: base };\x0d\n      binding.lstat(pathModule.toNamespacedPath(base)\x2C false\x2C undefined\x2C ctx);\x0d\n      handleErrorFromBinding(ctx);\x0d\n      knownHard[base] = true;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  cache?.set(original\x2C p);\x0d\n  return encodeRealpathResult(p\x2C options);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Returns the resolved pathname.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | { encoding?: string; }} [options]\x0d\n * @returns {string | Buffer}\x0d\n */\x0d\nrealpathSync.native = (path\x2C options) => {\x0d\n  options = getOptions(options\x2C {});\x0d\n  path = getValidatedPath(path);\x0d\n  const ctx = { path };\x0d\n  const result = binding.realpath(path\x2C options.encoding\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return result;\x0d\n};\x0d\n\x0d\n/**\x0d\n * Asynchronously computes the canonical pathname by\x0d\n * resolving `.`\x2C `..` and symbolic links.\x0d\n * @param {string | Buffer | URL} p\x0d\n * @param {string | { encoding?: string; }} [options]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   resolvedPath?: string | Buffer\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction realpath(p\x2C options\x2C callback) {\x0d\n  callback = typeof options === 'function' ? options : maybeCallback(callback);\x0d\n  options = getOptions(options\x2C {});\x0d\n  p = toPathIfFileURL(p);\x0d\n\x0d\n  if (typeof p !== 'string') {\x0d\n    p += '';\x0d\n  }\x0d\n  validatePath(p);\x0d\n  p = pathModule.resolve(p);\x0d\n\x0d\n  const seenLinks = ObjectCreate(null);\x0d\n  const knownHard = ObjectCreate(null);\x0d\n\x0d\n  // Current character position in p\x0d\n  let pos;\x0d\n  // The partial path so far\x2C including a trailing slash if any\x0d\n  let current;\x0d\n  // The partial path without a trailing slash (except when pointing at a root)\x0d\n  let base;\x0d\n  // The partial path scanned in the previous round\x2C with slash\x0d\n  let previous;\x0d\n\x0d\n  current = base = splitRoot(p);\x0d\n  pos = current.length;\x0d\n\x0d\n  // On windows\x2C check that the root exists. On unix there is no need.\x0d\n  if (isWindows && !knownHard[base]) {\x0d\n    fs.lstat(base\x2C (err\x2C stats) => {\x0d\n      if (err) return callback(err);\x0d\n      knownHard[base] = true;\x0d\n      LOOP();\x0d\n    });\x0d\n  } else {\x0d\n    process.nextTick(LOOP);\x0d\n  }\x0d\n\x0d\n  // Walk down the path\x2C swapping out linked path parts for their real\x0d\n  // values\x0d\n  function LOOP() {\x0d\n    // Stop if scanned past end of path\x0d\n    if (pos >= p.length) {\x0d\n      return callback(null\x2C encodeRealpathResult(p\x2C options));\x0d\n    }\x0d\n\x0d\n    // find the next part\x0d\n    const result = nextPart(p\x2C pos);\x0d\n    previous = current;\x0d\n    if (result === -1) {\x0d\n      const last = StringPrototypeSlice(p\x2C pos);\x0d\n      current += last;\x0d\n      base = previous + last;\x0d\n      pos = p.length;\x0d\n    } else {\x0d\n      current += StringPrototypeSlice(p\x2C pos\x2C result + 1);\x0d\n      base = previous + StringPrototypeSlice(p\x2C pos\x2C result);\x0d\n      pos = result + 1;\x0d\n    }\x0d\n\x0d\n    // Continue if not a symlink\x2C break if a pipe/socket\x0d\n    if (knownHard[base]) {\x0d\n      if (isFileType(binding.statValues\x2C S_IFIFO) ||\x0d\n          isFileType(binding.statValues\x2C S_IFSOCK)) {\x0d\n        return callback(null\x2C encodeRealpathResult(p\x2C options));\x0d\n      }\x0d\n      return process.nextTick(LOOP);\x0d\n    }\x0d\n\x0d\n    return fs.lstat(base\x2C { bigint: true }\x2C gotStat);\x0d\n  }\x0d\n\x0d\n  function gotStat(err\x2C stats) {\x0d\n    if (err) return callback(err);\x0d\n\x0d\n    // If not a symlink\x2C skip to the next path part\x0d\n    if (!stats.isSymbolicLink()) {\x0d\n      knownHard[base] = true;\x0d\n      return process.nextTick(LOOP);\x0d\n    }\x0d\n\x0d\n    // Stat & read the link if not read before.\x0d\n    // Call `gotTarget()` as soon as the link target is known.\x0d\n    // `dev`/`ino` always return 0 on windows\x2C so skip the check.\x0d\n    let id;\x0d\n    if (!isWindows) {\x0d\n      const dev = BigIntPrototypeToString(stats.dev\x2C 32);\x0d\n      const ino = BigIntPrototypeToString(stats.ino\x2C 32);\x0d\n      id = `${dev}:${ino}`;\x0d\n      if (seenLinks[id]) {\x0d\n        return gotTarget(null\x2C seenLinks[id]);\x0d\n      }\x0d\n    }\x0d\n    fs.stat(base\x2C (err) => {\x0d\n      if (err) return callback(err);\x0d\n\x0d\n      fs.readlink(base\x2C (err\x2C target) => {\x0d\n        if (!isWindows) seenLinks[id] = target;\x0d\n        gotTarget(err\x2C target);\x0d\n      });\x0d\n    });\x0d\n  }\x0d\n\x0d\n  function gotTarget(err\x2C target) {\x0d\n    if (err) return callback(err);\x0d\n\x0d\n    gotResolvedLink(pathModule.resolve(previous\x2C target));\x0d\n  }\x0d\n\x0d\n  function gotResolvedLink(resolvedLink) {\x0d\n    // Resolve the link\x2C then start over\x0d\n    p = pathModule.resolve(resolvedLink\x2C StringPrototypeSlice(p\x2C pos));\x0d\n    current = base = splitRoot(p);\x0d\n    pos = current.length;\x0d\n\x0d\n    // On windows\x2C check that the root exists. On unix there is no need.\x0d\n    if (isWindows && !knownHard[base]) {\x0d\n      fs.lstat(base\x2C (err) => {\x0d\n        if (err) return callback(err);\x0d\n        knownHard[base] = true;\x0d\n        LOOP();\x0d\n      });\x0d\n    } else {\x0d\n      process.nextTick(LOOP);\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously computes the canonical pathname by\x0d\n * resolving `.`\x2C `..` and symbolic links.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | { encoding?: string; }} [options]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   resolvedPath?: string | Buffer\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nrealpath.native = (path\x2C options\x2C callback) => {\x0d\n  callback = makeCallback(callback || options);\x0d\n  options = getOptions(options\x2C {});\x0d\n  path = getValidatedPath(path);\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  return binding.realpath(path\x2C options.encoding\x2C req);\x0d\n};\x0d\n\x0d\n/**\x0d\n * Creates a unique temporary directory.\x0d\n * @param {string} prefix\x0d\n * @param {string | { encoding?: string; }} [options]\x0d\n * @param {(\x0d\n *   err?: Error\x2C\x0d\n *   directory?: string\x0d\n *   ) => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction mkdtemp(prefix\x2C options\x2C callback) {\x0d\n  callback = makeCallback(typeof options === 'function' ? options : callback);\x0d\n  options = getOptions(options\x2C {});\x0d\n\x0d\n  validateString(prefix\x2C 'prefix');\x0d\n  nullCheck(prefix\x2C 'prefix');\x0d\n  warnOnNonPortableTemplate(prefix);\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.mkdtemp(`${prefix}XXXXXX`\x2C options.encoding\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously creates a unique temporary directory.\x0d\n * @param {string} prefix\x0d\n * @param {string | { encoding?: string; }} [options]\x0d\n * @returns {string}\x0d\n */\x0d\nfunction mkdtempSync(prefix\x2C options) {\x0d\n  options = getOptions(options\x2C {});\x0d\n\x0d\n  validateString(prefix\x2C 'prefix');\x0d\n  nullCheck(prefix\x2C 'prefix');\x0d\n  warnOnNonPortableTemplate(prefix);\x0d\n  const path = `${prefix}XXXXXX`;\x0d\n  const ctx = { path };\x0d\n  const result = binding.mkdtemp(path\x2C options.encoding\x2C\x0d\n                                 undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously copies `src` to `dest`. By\x0d\n * default\x2C `dest` is overwritten if it already exists.\x0d\n * @param {string | Buffer | URL} src\x0d\n * @param {string | Buffer | URL} dest\x0d\n * @param {number} [mode]\x0d\n * @param {() => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction copyFile(src\x2C dest\x2C mode\x2C callback) {\x0d\n  if (typeof mode === 'function') {\x0d\n    callback = mode;\x0d\n    mode = 0;\x0d\n  }\x0d\n\x0d\n  src = getValidatedPath(src\x2C 'src');\x0d\n  dest = getValidatedPath(dest\x2C 'dest');\x0d\n\x0d\n  src = pathModule._makeLong(src);\x0d\n  dest = pathModule._makeLong(dest);\x0d\n  mode = getValidMode(mode\x2C 'copyFile');\x0d\n  callback = makeCallback(callback);\x0d\n\x0d\n  const req = new FSReqCallback();\x0d\n  req.oncomplete = callback;\x0d\n  binding.copyFile(src\x2C dest\x2C mode\x2C req);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously copies `src` to `dest`. By\x0d\n * default\x2C `dest` is overwritten if it already exists.\x0d\n * @param {string | Buffer | URL} src\x0d\n * @param {string | Buffer | URL} dest\x0d\n * @param {number} [mode]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction copyFileSync(src\x2C dest\x2C mode) {\x0d\n  src = getValidatedPath(src\x2C 'src');\x0d\n  dest = getValidatedPath(dest\x2C 'dest');\x0d\n\x0d\n  const ctx = { path: src\x2C dest };  // non-prefixed\x0d\n\x0d\n  src = pathModule._makeLong(src);\x0d\n  dest = pathModule._makeLong(dest);\x0d\n  mode = getValidMode(mode\x2C 'copyFile');\x0d\n  binding.copyFile(src\x2C dest\x2C mode\x2C undefined\x2C ctx);\x0d\n  handleErrorFromBinding(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Asynchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\x0d\n * symlink. The contents of directories will be copied recursively.\x0d\n * @param {string | URL} src\x0d\n * @param {string | URL} dest\x0d\n * @param {object} [options]\x0d\n * @param {() => any} callback\x0d\n * @returns {void}\x0d\n */\x0d\nfunction cp(src\x2C dest\x2C options\x2C callback) {\x0d\n  if (typeof options === 'function') {\x0d\n    callback = options;\x0d\n    options = undefined;\x0d\n  }\x0d\n  callback = makeCallback(callback);\x0d\n  options = validateCpOptions(options);\x0d\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\x0d\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\x0d\n  lazyLoadCp();\x0d\n  cpFn(src\x2C dest\x2C options\x2C callback);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Synchronously copies `src` to `dest`. `src` can be a file\x2C directory\x2C or\x0d\n * symlink. The contents of directories will be copied recursively.\x0d\n * @param {string | URL} src\x0d\n * @param {string | URL} dest\x0d\n * @param {object} [options]\x0d\n * @returns {void}\x0d\n */\x0d\nfunction cpSync(src\x2C dest\x2C options) {\x0d\n  options = validateCpOptions(options);\x0d\n  src = pathModule.toNamespacedPath(getValidatedPath(src\x2C 'src'));\x0d\n  dest = pathModule.toNamespacedPath(getValidatedPath(dest\x2C 'dest'));\x0d\n  lazyLoadCp();\x0d\n  cpSyncFn(src\x2C dest\x2C options);\x0d\n}\x0d\n\x0d\nfunction lazyLoadStreams() {\x0d\n  if (!ReadStream) {\x0d\n    ({ ReadStream\x2C WriteStream } = require('internal/fs/streams'));\x0d\n    FileReadStream = ReadStream;\x0d\n    FileWriteStream = WriteStream;\x0d\n  }\x0d\n}\x0d\n\x0d\n/**\x0d\n * Creates a readable stream with a default `highWaterMark`\x0d\n * of 64 kb.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | {\x0d\n *   flags?: string;\x0d\n *   encoding?: string;\x0d\n *   fd?: number | FileHandle;\x0d\n *   mode?: number;\x0d\n *   autoClose?: boolean;\x0d\n *   emitClose?: boolean;\x0d\n *   start: number;\x0d\n *   end?: number;\x0d\n *   highWaterMark?: number;\x0d\n *   fs?: Object | null;\x0d\n *   }} [options]\x0d\n * @returns {ReadStream}\x0d\n */\x0d\nfunction createReadStream(path\x2C options) {\x0d\n  lazyLoadStreams();\x0d\n  return new ReadStream(path\x2C options);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Creates a write stream.\x0d\n * @param {string | Buffer | URL} path\x0d\n * @param {string | {\x0d\n *   flags?: string;\x0d\n *   encoding?: string;\x0d\n *   fd?: number | FileHandle;\x0d\n *   mode?: number;\x0d\n *   autoClose?: boolean;\x0d\n *   emitClose?: boolean;\x0d\n *   start: number;\x0d\n *   fs?: Object | null;\x0d\n *   }} [options]\x0d\n * @returns {WriteStream}\x0d\n */\x0d\nfunction createWriteStream(path\x2C options) {\x0d\n  lazyLoadStreams();\x0d\n  return new WriteStream(path\x2C options);\x0d\n}\x0d\n\x0d\nmodule.exports = fs = {\x0d\n  appendFile\x2C\x0d\n  appendFileSync\x2C\x0d\n  access\x2C\x0d\n  accessSync\x2C\x0d\n  chown\x2C\x0d\n  chownSync\x2C\x0d\n  chmod\x2C\x0d\n  chmodSync\x2C\x0d\n  close\x2C\x0d\n  closeSync\x2C\x0d\n  copyFile\x2C\x0d\n  copyFileSync\x2C\x0d\n  cp\x2C\x0d\n  cpSync\x2C\x0d\n  createReadStream\x2C\x0d\n  createWriteStream\x2C\x0d\n  exists\x2C\x0d\n  existsSync\x2C\x0d\n  fchown\x2C\x0d\n  fchownSync\x2C\x0d\n  fchmod\x2C\x0d\n  fchmodSync\x2C\x0d\n  fdatasync\x2C\x0d\n  fdatasyncSync\x2C\x0d\n  fstat\x2C\x0d\n  fstatSync\x2C\x0d\n  fsync\x2C\x0d\n  fsyncSync\x2C\x0d\n  ftruncate\x2C\x0d\n  ftruncateSync\x2C\x0d\n  futimes\x2C\x0d\n  futimesSync\x2C\x0d\n  lchown\x2C\x0d\n  lchownSync\x2C\x0d\n  lchmod: constants.O_SYMLINK !== undefined ? lchmod : undefined\x2C\x0d\n  lchmodSync: constants.O_SYMLINK !== undefined ? lchmodSync : undefined\x2C\x0d\n  link\x2C\x0d\n  linkSync\x2C\x0d\n  lstat\x2C\x0d\n  lstatSync\x2C\x0d\n  lutimes\x2C\x0d\n  lutimesSync\x2C\x0d\n  mkdir\x2C\x0d\n  mkdirSync\x2C\x0d\n  mkdtemp\x2C\x0d\n  mkdtempSync\x2C\x0d\n  open\x2C\x0d\n  openSync\x2C\x0d\n  opendir\x2C\x0d\n  opendirSync\x2C\x0d\n  readdir\x2C\x0d\n  readdirSync\x2C\x0d\n  read\x2C\x0d\n  readSync\x2C\x0d\n  readv\x2C\x0d\n  readvSync\x2C\x0d\n  readFile\x2C\x0d\n  readFileSync\x2C\x0d\n  readlink\x2C\x0d\n  readlinkSync\x2C\x0d\n  realpath\x2C\x0d\n  realpathSync\x2C\x0d\n  rename\x2C\x0d\n  renameSync\x2C\x0d\n  rm\x2C\x0d\n  rmSync\x2C\x0d\n  rmdir\x2C\x0d\n  rmdirSync\x2C\x0d\n  stat\x2C\x0d\n  statSync\x2C\x0d\n  symlink\x2C\x0d\n  symlinkSync\x2C\x0d\n  truncate\x2C\x0d\n  truncateSync\x2C\x0d\n  unwatchFile\x2C\x0d\n  unlink\x2C\x0d\n  unlinkSync\x2C\x0d\n  utimes\x2C\x0d\n  utimesSync\x2C\x0d\n  watch\x2C\x0d\n  watchFile\x2C\x0d\n  writeFile\x2C\x0d\n  writeFileSync\x2C\x0d\n  write\x2C\x0d\n  writeSync\x2C\x0d\n  writev\x2C\x0d\n  writevSync\x2C\x0d\n  Dir\x2C\x0d\n  Dirent\x2C\x0d\n  Stats\x2C\x0d\n\x0d\n  get ReadStream() {\x0d\n    lazyLoadStreams();\x0d\n    return ReadStream;\x0d\n  }\x2C\x0d\n\x0d\n  set ReadStream(val) {\x0d\n    ReadStream = val;\x0d\n  }\x2C\x0d\n\x0d\n  get WriteStream() {\x0d\n    lazyLoadStreams();\x0d\n    return WriteStream;\x0d\n  }\x2C\x0d\n\x0d\n  set WriteStream(val) {\x0d\n    WriteStream = val;\x0d\n  }\x2C\x0d\n\x0d\n  // Legacy names... these have to be separate because of how graceful-fs\x0d\n  // (and possibly other) modules monkey patch the values.\x0d\n  get FileReadStream() {\x0d\n    lazyLoadStreams();\x0d\n    return FileReadStream;\x0d\n  }\x2C\x0d\n\x0d\n  set FileReadStream(val) {\x0d\n    FileReadStream = val;\x0d\n  }\x2C\x0d\n\x0d\n  get FileWriteStream() {\x0d\n    lazyLoadStreams();\x0d\n    return FileWriteStream;\x0d\n  }\x2C\x0d\n\x0d\n  set FileWriteStream(val) {\x0d\n    FileWriteStream = val;\x0d\n  }\x2C\x0d\n\x0d\n  // For tests\x0d\n  _toUnixTimestamp: toUnixTimestamp\x0d\n};\x0d\n\x0d\nObjectDefineProperties(fs\x2C {\x0d\n  F_OK: { enumerable: true\x2C value: F_OK || 0 }\x2C\x0d\n  R_OK: { enumerable: true\x2C value: R_OK || 0 }\x2C\x0d\n  W_OK: { enumerable: true\x2C value: W_OK || 0 }\x2C\x0d\n  X_OK: { enumerable: true\x2C value: X_OK || 0 }\x2C\x0d\n  constants: {\x0d\n    configurable: false\x2C\x0d\n    enumerable: true\x2C\x0d\n    value: constants\x0d\n  }\x2C\x0d\n  promises: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x2C\x0d\n    get() {\x0d\n      if (promises === null)\x0d\n        promises = require('internal/fs/promises').exports;\x0d\n      return promises;\x0d\n    }\x0d\n  }\x0d\n});\x0d\n
code-source-info,0x109c10fd72e,81,66533,70573,C0O66551C8O66581C12O66561C19O66595C25O66599C31O66622C35O66656C45O66673C51O66673C55O66693C61O66708C67O66708C74O66739C76O66747C78O66746C82O66795C86O66800C92O66802C101O66813C103O66843C105O66868C106O66897C115O66897C120O66938C129O66938C134O66978C137O67028C139O67105C141O67202C143O67280C145O67317C151O67334C157O67365C162O67450C168O67484C176O67492C183O67505C189O67513C197O67519C201O67530C207O67530C223O67513C228O67583C234O67583C238O67617C239O67633C243O67779C247O67775C252O67836C258O67836C264O67859C267O67884C269O67895C274O67925C280O67925C287O67962C289O67973C296O67986C298O68002C302O68025C309O68054C311O68065C317O68101C328O68065C340O68114C342O68132C355O68132C360O68130C364O68177C366O68190C370O68267C372O68280C384O68295C390O68297C402O68307C407O68326C413O68341C417O68349C425O68361C429O68330C442O68395C446O68403C454O68415C458O68384C465O68437C467O68460C469O68488C471O68535C478O68540C484O68542C493O68558C495O68592C502O68779C508O68790C514O68790C520O68833C528O68841C535O68870C541O68878C559O68878C565O68924C571O68924C575O68962C581O68985C585O68967C592O69006C593O69022C597O69039C604O69044C610O69046C619O69072C621O69231C624O69248C627O69259C633O69298C640O69327C649O69298C656O69358C664O69387C673O69358C680O69406C694O69421C700O69437C702O69450C707O69469C709O69491C714O69524C718O69572C726O69580C733O69597C739O69605C757O69605C762O69653C768O69653C772O69691C778O69712C796O69712C803O69768C809O69768C813O69813C819O69839C825O69839C832O69879C836O69896C842O69896C848O69928C854O69944C856O69958C860O70028C866O70043C874O70065C878O70065C885O70043C893O70127C899O70144C905O70177C910O70266C918O70293C923O70322C931O70330C938O70345C944O70353C952O70359C956O70370C962O70370C978O70353C983O70425C989O70425C993O70461C994O70477C998O67764C1004O70502C1011O70507C1017O70509C1026O70530C1030O70537C1035O70570,,
code-creation,LazyCompile,10,231551,0x1c1d96c7196,123,getOptions node:internal/fs/utils:314:20,0x1d4982a1aa8,~
script-source,82,node:internal/fs/utils,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  BigInt\x2C\x0d\n  Date\x2C\x0d\n  DateNow\x2C\x0d\n  DatePrototypeGetTime\x2C\x0d\n  ErrorCaptureStackTrace\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  Number\x2C\x0d\n  NumberIsFinite\x2C\x0d\n  NumberIsInteger\x2C\x0d\n  MathMin\x2C\x0d\n  ObjectIs\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  ReflectApply\x2C\x0d\n  ReflectOwnKeys\x2C\x0d\n  StringPrototypeEndsWith\x2C\x0d\n  StringPrototypeIncludes\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  Symbol\x2C\x0d\n  TypedArrayPrototypeIncludes\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { Buffer } = require('buffer');\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_FS_EISDIR\x2C\x0d\n    ERR_FS_INVALID_SYMLINK_TYPE\x2C\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_OUT_OF_RANGE\x0d\n  }\x2C\x0d\n  hideStackFrames\x2C\x0d\n  uvException\x0d\n} = require('internal/errors');\x0d\nconst {\x0d\n  isArrayBufferView\x2C\x0d\n  isUint8Array\x2C\x0d\n  isDate\x2C\x0d\n  isBigUint64Array\x0d\n} = require('internal/util/types');\x0d\nconst { once } = require('internal/util');\x0d\nconst { toPathIfFileURL } = require('internal/url');\x0d\nconst {\x0d\n  validateAbortSignal\x2C\x0d\n  validateBoolean\x2C\x0d\n  validateFunction\x2C\x0d\n  validateInt32\x2C\x0d\n  validateInteger\x2C\x0d\n  validateObject\x2C\x0d\n  validateUint32\x2C\x0d\n} = require('internal/validators');\x0d\nconst pathModule = require('path');\x0d\nconst kType = Symbol('type');\x0d\nconst kStats = Symbol('stats');\x0d\nconst assert = require('internal/assert');\x0d\n\x0d\nconst {\x0d\n  fs: {\x0d\n    F_OK = 0\x2C\x0d\n    W_OK = 0\x2C\x0d\n    R_OK = 0\x2C\x0d\n    X_OK = 0\x2C\x0d\n    COPYFILE_EXCL\x2C\x0d\n    COPYFILE_FICLONE\x2C\x0d\n    COPYFILE_FICLONE_FORCE\x2C\x0d\n    O_APPEND\x2C\x0d\n    O_CREAT\x2C\x0d\n    O_EXCL\x2C\x0d\n    O_RDONLY\x2C\x0d\n    O_RDWR\x2C\x0d\n    O_SYNC\x2C\x0d\n    O_TRUNC\x2C\x0d\n    O_WRONLY\x2C\x0d\n    S_IFBLK\x2C\x0d\n    S_IFCHR\x2C\x0d\n    S_IFDIR\x2C\x0d\n    S_IFIFO\x2C\x0d\n    S_IFLNK\x2C\x0d\n    S_IFMT\x2C\x0d\n    S_IFREG\x2C\x0d\n    S_IFSOCK\x2C\x0d\n    UV_FS_SYMLINK_DIR\x2C\x0d\n    UV_FS_SYMLINK_JUNCTION\x2C\x0d\n    UV_DIRENT_UNKNOWN\x2C\x0d\n    UV_DIRENT_FILE\x2C\x0d\n    UV_DIRENT_DIR\x2C\x0d\n    UV_DIRENT_LINK\x2C\x0d\n    UV_DIRENT_FIFO\x2C\x0d\n    UV_DIRENT_SOCKET\x2C\x0d\n    UV_DIRENT_CHAR\x2C\x0d\n    UV_DIRENT_BLOCK\x0d\n  }\x2C\x0d\n  os: {\x0d\n    errno: {\x0d\n      EISDIR\x0d\n    }\x0d\n  }\x0d\n} = internalBinding('constants');\x0d\n\x0d\n// The access modes can be any of F_OK\x2C R_OK\x2C W_OK or X_OK. Some might not be\x0d\n// available on specific systems. They can be used in combination as well\x0d\n// (F_OK | R_OK | W_OK | X_OK).\x0d\nconst kMinimumAccessMode = MathMin(F_OK\x2C W_OK\x2C R_OK\x2C X_OK);\x0d\nconst kMaximumAccessMode = F_OK | W_OK | R_OK | X_OK;\x0d\n\x0d\nconst kDefaultCopyMode = 0;\x0d\n// The copy modes can be any of COPYFILE_EXCL\x2C COPYFILE_FICLONE or\x0d\n// COPYFILE_FICLONE_FORCE. They can be used in combination as well\x0d\n// (COPYFILE_EXCL | COPYFILE_FICLONE | COPYFILE_FICLONE_FORCE).\x0d\nconst kMinimumCopyMode = MathMin(\x0d\n  kDefaultCopyMode\x2C\x0d\n  COPYFILE_EXCL\x2C\x0d\n  COPYFILE_FICLONE\x2C\x0d\n  COPYFILE_FICLONE_FORCE\x0d\n);\x0d\nconst kMaximumCopyMode = COPYFILE_EXCL |\x0d\n                         COPYFILE_FICLONE |\x0d\n                         COPYFILE_FICLONE_FORCE;\x0d\n\x0d\n// Most platforms don't allow reads or writes >= 2 GB.\x0d\n// See https://github.com/libuv/libuv/pull/1501.\x0d\nconst kIoMaxLength = 2 ** 31 - 1;\x0d\n\x0d\n// Use 64kb in case the file type is not a regular file and thus do not know the\x0d\n// actual file size. Increasing the value further results in more frequent over\x0d\n// allocation for small files and consumes CPU time and memory that should be\x0d\n// used else wise.\x0d\n// Use up to 512kb per read otherwise to partition reading big files to prevent\x0d\n// blocking other threads in case the available threads are all in use.\x0d\nconst kReadFileUnknownBufferLength = 64 * 1024;\x0d\nconst kReadFileBufferLength = 512 * 1024;\x0d\n\x0d\nconst kWriteFileMaxChunkSize = 512 * 1024;\x0d\n\x0d\nconst kMaxUserId = 2 ** 32 - 1;\x0d\n\x0d\nconst isWindows = process.platform === 'win32';\x0d\n\x0d\nlet fs;\x0d\nfunction lazyLoadFs() {\x0d\n  if (!fs) {\x0d\n    fs = require('fs');\x0d\n  }\x0d\n  return fs;\x0d\n}\x0d\n\x0d\nfunction assertEncoding(encoding) {\x0d\n  if (encoding && !Buffer.isEncoding(encoding)) {\x0d\n    const reason = 'is invalid encoding';\x0d\n    throw new ERR_INVALID_ARG_VALUE(encoding\x2C 'encoding'\x2C reason);\x0d\n  }\x0d\n}\x0d\n\x0d\nclass Dirent {\x0d\n  constructor(name\x2C type) {\x0d\n    this.name = name;\x0d\n    this[kType] = type;\x0d\n  }\x0d\n\x0d\n  isDirectory() {\x0d\n    return this[kType] === UV_DIRENT_DIR;\x0d\n  }\x0d\n\x0d\n  isFile() {\x0d\n    return this[kType] === UV_DIRENT_FILE;\x0d\n  }\x0d\n\x0d\n  isBlockDevice() {\x0d\n    return this[kType] === UV_DIRENT_BLOCK;\x0d\n  }\x0d\n\x0d\n  isCharacterDevice() {\x0d\n    return this[kType] === UV_DIRENT_CHAR;\x0d\n  }\x0d\n\x0d\n  isSymbolicLink() {\x0d\n    return this[kType] === UV_DIRENT_LINK;\x0d\n  }\x0d\n\x0d\n  isFIFO() {\x0d\n    return this[kType] === UV_DIRENT_FIFO;\x0d\n  }\x0d\n\x0d\n  isSocket() {\x0d\n    return this[kType] === UV_DIRENT_SOCKET;\x0d\n  }\x0d\n}\x0d\n\x0d\nclass DirentFromStats extends Dirent {\x0d\n  constructor(name\x2C stats) {\x0d\n    super(name\x2C null);\x0d\n    this[kStats] = stats;\x0d\n  }\x0d\n}\x0d\n\x0d\nfor (const name of ReflectOwnKeys(Dirent.prototype)) {\x0d\n  if (name === 'constructor') {\x0d\n    continue;\x0d\n  }\x0d\n  DirentFromStats.prototype[name] = function() {\x0d\n    return this[kStats][name]();\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction copyObject(source) {\x0d\n  const target = {};\x0d\n  for (const key in source)\x0d\n    target[key] = source[key];\x0d\n  return target;\x0d\n}\x0d\n\x0d\nconst bufferSep = Buffer.from(pathModule.sep);\x0d\n\x0d\nfunction join(path\x2C name) {\x0d\n  if ((typeof path === 'string' || isUint8Array(path)) &&\x0d\n      name === undefined) {\x0d\n    return path;\x0d\n  }\x0d\n\x0d\n  if (typeof path === 'string' && isUint8Array(name)) {\x0d\n    const pathBuffer = Buffer.from(pathModule.join(path\x2C pathModule.sep));\x0d\n    return Buffer.concat([pathBuffer\x2C name]);\x0d\n  }\x0d\n\x0d\n  if (typeof path === 'string' && typeof name === 'string') {\x0d\n    return pathModule.join(path\x2C name);\x0d\n  }\x0d\n\x0d\n  if (isUint8Array(path) && isUint8Array(name)) {\x0d\n    return Buffer.concat([path\x2C bufferSep\x2C name]);\x0d\n  }\x0d\n\x0d\n  throw new ERR_INVALID_ARG_TYPE(\x0d\n    'path'\x2C ['string'\x2C 'Buffer']\x2C path);\x0d\n}\x0d\n\x0d\nfunction getDirents(path\x2C { 0: names\x2C 1: types }\x2C callback) {\x0d\n  let i;\x0d\n  if (typeof callback === 'function') {\x0d\n    const len = names.length;\x0d\n    let toFinish = 0;\x0d\n    callback = once(callback);\x0d\n    for (i = 0; i < len; i++) {\x0d\n      const type = types[i];\x0d\n      if (type === UV_DIRENT_UNKNOWN) {\x0d\n        const name = names[i];\x0d\n        const idx = i;\x0d\n        toFinish++;\x0d\n        let filepath;\x0d\n        try {\x0d\n          filepath = join(path\x2C name);\x0d\n        } catch (err) {\x0d\n          callback(err);\x0d\n          return;\x0d\n        }\x0d\n        lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\x0d\n          if (err) {\x0d\n            callback(err);\x0d\n            return;\x0d\n          }\x0d\n          names[idx] = new DirentFromStats(name\x2C stats);\x0d\n          if (--toFinish === 0) {\x0d\n            callback(null\x2C names);\x0d\n          }\x0d\n        });\x0d\n      } else {\x0d\n        names[i] = new Dirent(names[i]\x2C types[i]);\x0d\n      }\x0d\n    }\x0d\n    if (toFinish === 0) {\x0d\n      callback(null\x2C names);\x0d\n    }\x0d\n  } else {\x0d\n    const len = names.length;\x0d\n    for (i = 0; i < len; i++) {\x0d\n      names[i] = getDirent(path\x2C names[i]\x2C types[i]);\x0d\n    }\x0d\n    return names;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction getDirent(path\x2C name\x2C type\x2C callback) {\x0d\n  if (typeof callback === 'function') {\x0d\n    if (type === UV_DIRENT_UNKNOWN) {\x0d\n      let filepath;\x0d\n      try {\x0d\n        filepath = join(path\x2C name);\x0d\n      } catch (err) {\x0d\n        callback(err);\x0d\n        return;\x0d\n      }\x0d\n      lazyLoadFs().lstat(filepath\x2C (err\x2C stats) => {\x0d\n        if (err) {\x0d\n          callback(err);\x0d\n          return;\x0d\n        }\x0d\n        callback(null\x2C new DirentFromStats(name\x2C stats));\x0d\n      });\x0d\n    } else {\x0d\n      callback(null\x2C new Dirent(name\x2C type));\x0d\n    }\x0d\n  } else if (type === UV_DIRENT_UNKNOWN) {\x0d\n    const stats = lazyLoadFs().lstatSync(join(path\x2C name));\x0d\n    return new DirentFromStats(name\x2C stats);\x0d\n  } else {\x0d\n    return new Dirent(name\x2C type);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction getOptions(options\x2C defaultOptions) {\x0d\n  if (options === null || options === undefined ||\x0d\n      typeof options === 'function') {\x0d\n    return defaultOptions;\x0d\n  }\x0d\n\x0d\n  if (typeof options === 'string') {\x0d\n    defaultOptions = { ...defaultOptions };\x0d\n    defaultOptions.encoding = options;\x0d\n    options = defaultOptions;\x0d\n  } else if (typeof options !== 'object') {\x0d\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C ['string'\x2C 'Object']\x2C options);\x0d\n  }\x0d\n\x0d\n  if (options.encoding !== 'buffer')\x0d\n    assertEncoding(options.encoding);\x0d\n\x0d\n  if (options.signal !== undefined) {\x0d\n    validateAbortSignal(options.signal\x2C 'options.signal');\x0d\n  }\x0d\n  return options;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {InternalFSBinding.FSSyncContext} ctx\x0d\n */\x0d\nfunction handleErrorFromBinding(ctx) {\x0d\n  if (ctx.errno !== undefined) {  // libuv error numbers\x0d\n    const err = uvException(ctx);\x0d\n    ErrorCaptureStackTrace(err\x2C handleErrorFromBinding);\x0d\n    throw err;\x0d\n  }\x0d\n  if (ctx.error !== undefined) {  // Errors created in C++ land.\x0d\n    // TODO(joyeecheung): currently\x2C ctx.error are encoding errors\x0d\n    // usually caused by memory problems. We need to figure out proper error\x0d\n    // code(s) for this.\x0d\n    ErrorCaptureStackTrace(ctx.error\x2C handleErrorFromBinding);\x0d\n    throw ctx.error;\x0d\n  }\x0d\n}\x0d\n\x0d\n// Check if the path contains null types if it is a string nor Uint8Array\x2C\x0d\n// otherwise return silently.\x0d\nconst nullCheck = hideStackFrames((path\x2C propName\x2C throwError = true) => {\x0d\n  const pathIsString = typeof path === 'string';\x0d\n  const pathIsUint8Array = isUint8Array(path);\x0d\n\x0d\n  // We can only perform meaningful checks on strings and Uint8Arrays.\x0d\n  if ((!pathIsString && !pathIsUint8Array) ||\x0d\n      (pathIsString && !StringPrototypeIncludes(path\x2C '\\u0000')) ||\x0d\n      (pathIsUint8Array && !TypedArrayPrototypeIncludes(path\x2C 0))) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  const err = new ERR_INVALID_ARG_VALUE(\x0d\n    propName\x2C\x0d\n    path\x2C\x0d\n    'must be a string or Uint8Array without null bytes'\x0d\n  );\x0d\n  if (throwError) {\x0d\n    throw err;\x0d\n  }\x0d\n  return err;\x0d\n});\x0d\n\x0d\nfunction preprocessSymlinkDestination(path\x2C type\x2C linkPath) {\x0d\n  if (!isWindows) {\x0d\n    // No preprocessing is needed on Unix.\x0d\n    return path;\x0d\n  }\x0d\n  path = '' + path;\x0d\n  if (type === 'junction') {\x0d\n    // Junctions paths need to be absolute and \\\\?\\-prefixed.\x0d\n    // A relative target is relative to the link's parent directory.\x0d\n    path = pathModule.resolve(linkPath\x2C '..'\x2C path);\x0d\n    return pathModule.toNamespacedPath(path);\x0d\n  }\x0d\n  if (pathModule.isAbsolute(path)) {\x0d\n    // If the path is absolute\x2C use the \\\\?\\-prefix to enable long filenames\x0d\n    return pathModule.toNamespacedPath(path);\x0d\n  }\x0d\n  // Windows symlinks don't tolerate forward slashes.\x0d\n  return StringPrototypeReplace(path\x2C /\\//g\x2C '\\\\');\x0d\n}\x0d\n\x0d\n// Constructor for file stats.\x0d\nfunction StatsBase(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\x0d\n                   ino\x2C size\x2C blocks) {\x0d\n  this.dev = dev;\x0d\n  this.mode = mode;\x0d\n  this.nlink = nlink;\x0d\n  this.uid = uid;\x0d\n  this.gid = gid;\x0d\n  this.rdev = rdev;\x0d\n  this.blksize = blksize;\x0d\n  this.ino = ino;\x0d\n  this.size = size;\x0d\n  this.blocks = blocks;\x0d\n}\x0d\n\x0d\nStatsBase.prototype.isDirectory = function() {\x0d\n  return this._checkModeProperty(S_IFDIR);\x0d\n};\x0d\n\x0d\nStatsBase.prototype.isFile = function() {\x0d\n  return this._checkModeProperty(S_IFREG);\x0d\n};\x0d\n\x0d\nStatsBase.prototype.isBlockDevice = function() {\x0d\n  return this._checkModeProperty(S_IFBLK);\x0d\n};\x0d\n\x0d\nStatsBase.prototype.isCharacterDevice = function() {\x0d\n  return this._checkModeProperty(S_IFCHR);\x0d\n};\x0d\n\x0d\nStatsBase.prototype.isSymbolicLink = function() {\x0d\n  return this._checkModeProperty(S_IFLNK);\x0d\n};\x0d\n\x0d\nStatsBase.prototype.isFIFO = function() {\x0d\n  return this._checkModeProperty(S_IFIFO);\x0d\n};\x0d\n\x0d\nStatsBase.prototype.isSocket = function() {\x0d\n  return this._checkModeProperty(S_IFSOCK);\x0d\n};\x0d\n\x0d\nconst kNsPerMsBigInt = 10n ** 6n;\x0d\nconst kNsPerSecBigInt = 10n ** 9n;\x0d\nconst kMsPerSec = 10 ** 3;\x0d\nconst kNsPerMs = 10 ** 6;\x0d\nfunction msFromTimeSpec(sec\x2C nsec) {\x0d\n  return sec * kMsPerSec + nsec / kNsPerMs;\x0d\n}\x0d\n\x0d\nfunction nsFromTimeSpecBigInt(sec\x2C nsec) {\x0d\n  return sec * kNsPerSecBigInt + nsec;\x0d\n}\x0d\n\x0d\n// The Date constructor performs Math.floor() to the timestamp.\x0d\n// https://www.ecma-international.org/ecma-262/#sec-timeclip\x0d\n// Since there may be a precision loss when the timestamp is\x0d\n// converted to a floating point number\x2C we manually round\x0d\n// the timestamp here before passing it to Date().\x0d\n// Refs: https://github.com/nodejs/node/pull/12607\x0d\nfunction dateFromMs(ms) {\x0d\n  return new Date(Number(ms) + 0.5);\x0d\n}\x0d\n\x0d\nfunction BigIntStats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\x0d\n                     ino\x2C size\x2C blocks\x2C\x0d\n                     atimeNs\x2C mtimeNs\x2C ctimeNs\x2C birthtimeNs) {\x0d\n  ReflectApply(StatsBase\x2C this\x2C [dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\x0d\n                                 ino\x2C size\x2C blocks]);\x0d\n\x0d\n  this.atimeMs = atimeNs / kNsPerMsBigInt;\x0d\n  this.mtimeMs = mtimeNs / kNsPerMsBigInt;\x0d\n  this.ctimeMs = ctimeNs / kNsPerMsBigInt;\x0d\n  this.birthtimeMs = birthtimeNs / kNsPerMsBigInt;\x0d\n  this.atimeNs = atimeNs;\x0d\n  this.mtimeNs = mtimeNs;\x0d\n  this.ctimeNs = ctimeNs;\x0d\n  this.birthtimeNs = birthtimeNs;\x0d\n  this.atime = dateFromMs(this.atimeMs);\x0d\n  this.mtime = dateFromMs(this.mtimeMs);\x0d\n  this.ctime = dateFromMs(this.ctimeMs);\x0d\n  this.birthtime = dateFromMs(this.birthtimeMs);\x0d\n}\x0d\n\x0d\nObjectSetPrototypeOf(BigIntStats.prototype\x2C StatsBase.prototype);\x0d\nObjectSetPrototypeOf(BigIntStats\x2C StatsBase);\x0d\n\x0d\nBigIntStats.prototype._checkModeProperty = function(property) {\x0d\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\x0d\n    property === S_IFSOCK)) {\x0d\n    return false;  // Some types are not available on Windows\x0d\n  }\x0d\n  return (this.mode & BigInt(S_IFMT)) === BigInt(property);\x0d\n};\x0d\n\x0d\nfunction Stats(dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C blksize\x2C\x0d\n               ino\x2C size\x2C blocks\x2C\x0d\n               atimeMs\x2C mtimeMs\x2C ctimeMs\x2C birthtimeMs) {\x0d\n  FunctionPrototypeCall(StatsBase\x2C this\x2C dev\x2C mode\x2C nlink\x2C uid\x2C gid\x2C rdev\x2C\x0d\n                        blksize\x2C ino\x2C size\x2C blocks);\x0d\n  this.atimeMs = atimeMs;\x0d\n  this.mtimeMs = mtimeMs;\x0d\n  this.ctimeMs = ctimeMs;\x0d\n  this.birthtimeMs = birthtimeMs;\x0d\n  this.atime = dateFromMs(atimeMs);\x0d\n  this.mtime = dateFromMs(mtimeMs);\x0d\n  this.ctime = dateFromMs(ctimeMs);\x0d\n  this.birthtime = dateFromMs(birthtimeMs);\x0d\n}\x0d\n\x0d\nObjectSetPrototypeOf(Stats.prototype\x2C StatsBase.prototype);\x0d\nObjectSetPrototypeOf(Stats\x2C StatsBase);\x0d\n\x0d\n// HACK: Workaround for https://github.com/standard-things/esm/issues/821.\x0d\n// TODO(ronag): Remove this as soon as `esm` publishes a fixed version.\x0d\nStats.prototype.isFile = StatsBase.prototype.isFile;\x0d\n\x0d\nStats.prototype._checkModeProperty = function(property) {\x0d\n  if (isWindows && (property === S_IFIFO || property === S_IFBLK ||\x0d\n    property === S_IFSOCK)) {\x0d\n    return false;  // Some types are not available on Windows\x0d\n  }\x0d\n  return (this.mode & S_IFMT) === property;\x0d\n};\x0d\n\x0d\n/**\x0d\n * @param {Float64Array | BigUint64Array} stats\x0d\n * @param {number} offset\x0d\n * @returns {BigIntStats | Stats}\x0d\n */\x0d\nfunction getStatsFromBinding(stats\x2C offset = 0) {\x0d\n  if (isBigUint64Array(stats)) {\x0d\n    return new BigIntStats(\x0d\n      stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\x0d\n      stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\x0d\n      stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\x0d\n      stats[9 + offset]\x2C\x0d\n      nsFromTimeSpecBigInt(stats[10 + offset]\x2C stats[11 + offset])\x2C\x0d\n      nsFromTimeSpecBigInt(stats[12 + offset]\x2C stats[13 + offset])\x2C\x0d\n      nsFromTimeSpecBigInt(stats[14 + offset]\x2C stats[15 + offset])\x2C\x0d\n      nsFromTimeSpecBigInt(stats[16 + offset]\x2C stats[17 + offset])\x0d\n    );\x0d\n  }\x0d\n  return new Stats(\x0d\n    stats[0 + offset]\x2C stats[1 + offset]\x2C stats[2 + offset]\x2C\x0d\n    stats[3 + offset]\x2C stats[4 + offset]\x2C stats[5 + offset]\x2C\x0d\n    stats[6 + offset]\x2C stats[7 + offset]\x2C stats[8 + offset]\x2C\x0d\n    stats[9 + offset]\x2C\x0d\n    msFromTimeSpec(stats[10 + offset]\x2C stats[11 + offset])\x2C\x0d\n    msFromTimeSpec(stats[12 + offset]\x2C stats[13 + offset])\x2C\x0d\n    msFromTimeSpec(stats[14 + offset]\x2C stats[15 + offset])\x2C\x0d\n    msFromTimeSpec(stats[16 + offset]\x2C stats[17 + offset])\x0d\n  );\x0d\n}\x0d\n\x0d\nfunction stringToFlags(flags\x2C name = 'flags') {\x0d\n  if (typeof flags === 'number') {\x0d\n    validateInt32(flags\x2C name);\x0d\n    return flags;\x0d\n  }\x0d\n\x0d\n  if (flags == null) {\x0d\n    return O_RDONLY;\x0d\n  }\x0d\n\x0d\n  switch (flags) {\x0d\n    case 'r' : return O_RDONLY;\x0d\n    case 'rs' : // Fall through.\x0d\n    case 'sr' : return O_RDONLY | O_SYNC;\x0d\n    case 'r+' : return O_RDWR;\x0d\n    case 'rs+' : // Fall through.\x0d\n    case 'sr+' : return O_RDWR | O_SYNC;\x0d\n\x0d\n    case 'w' : return O_TRUNC | O_CREAT | O_WRONLY;\x0d\n    case 'wx' : // Fall through.\x0d\n    case 'xw' : return O_TRUNC | O_CREAT | O_WRONLY | O_EXCL;\x0d\n\x0d\n    case 'w+' : return O_TRUNC | O_CREAT | O_RDWR;\x0d\n    case 'wx+': // Fall through.\x0d\n    case 'xw+': return O_TRUNC | O_CREAT | O_RDWR | O_EXCL;\x0d\n\x0d\n    case 'a' : return O_APPEND | O_CREAT | O_WRONLY;\x0d\n    case 'ax' : // Fall through.\x0d\n    case 'xa' : return O_APPEND | O_CREAT | O_WRONLY | O_EXCL;\x0d\n    case 'as' : // Fall through.\x0d\n    case 'sa' : return O_APPEND | O_CREAT | O_WRONLY | O_SYNC;\x0d\n\x0d\n    case 'a+' : return O_APPEND | O_CREAT | O_RDWR;\x0d\n    case 'ax+': // Fall through.\x0d\n    case 'xa+': return O_APPEND | O_CREAT | O_RDWR | O_EXCL;\x0d\n    case 'as+': // Fall through.\x0d\n    case 'sa+': return O_APPEND | O_CREAT | O_RDWR | O_SYNC;\x0d\n  }\x0d\n\x0d\n  throw new ERR_INVALID_ARG_VALUE('flags'\x2C flags);\x0d\n}\x0d\n\x0d\nconst stringToSymlinkType = hideStackFrames((type) => {\x0d\n  let flags = 0;\x0d\n  if (typeof type === 'string') {\x0d\n    switch (type) {\x0d\n      case 'dir':\x0d\n        flags |= UV_FS_SYMLINK_DIR;\x0d\n        break;\x0d\n      case 'junction':\x0d\n        flags |= UV_FS_SYMLINK_JUNCTION;\x0d\n        break;\x0d\n      case 'file':\x0d\n        break;\x0d\n      default:\x0d\n        throw new ERR_FS_INVALID_SYMLINK_TYPE(type);\x0d\n    }\x0d\n  }\x0d\n  return flags;\x0d\n});\x0d\n\x0d\n// converts Date or number to a fractional UNIX timestamp\x0d\nfunction toUnixTimestamp(time\x2C name = 'time') {\x0d\n  // eslint-disable-next-line eqeqeq\x0d\n  if (typeof time === 'string' && +time == time) {\x0d\n    return +time;\x0d\n  }\x0d\n  if (NumberIsFinite(time)) {\x0d\n    if (time < 0) {\x0d\n      return DateNow() / 1000;\x0d\n    }\x0d\n    return time;\x0d\n  }\x0d\n  if (isDate(time)) {\x0d\n    // Convert to 123.456 UNIX timestamp\x0d\n    return DatePrototypeGetTime(time) / 1000;\x0d\n  }\x0d\n  throw new ERR_INVALID_ARG_TYPE(name\x2C ['Date'\x2C 'Time in seconds']\x2C time);\x0d\n}\x0d\n\x0d\nconst validateOffsetLengthRead = hideStackFrames(\x0d\n  (offset\x2C length\x2C bufferLength) => {\x0d\n    if (offset < 0) {\x0d\n      throw new ERR_OUT_OF_RANGE('offset'\x2C '>= 0'\x2C offset);\x0d\n    }\x0d\n    if (length < 0) {\x0d\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\x0d\n    }\x0d\n    if (offset + length > bufferLength) {\x0d\n      throw new ERR_OUT_OF_RANGE('length'\x2C\x0d\n                                 `<= ${bufferLength - offset}`\x2C length);\x0d\n    }\x0d\n  }\x0d\n);\x0d\n\x0d\nconst validateOffsetLengthWrite = hideStackFrames(\x0d\n  (offset\x2C length\x2C byteLength) => {\x0d\n    if (offset > byteLength) {\x0d\n      throw new ERR_OUT_OF_RANGE('offset'\x2C `<= ${byteLength}`\x2C offset);\x0d\n    }\x0d\n\x0d\n    if (length > byteLength - offset) {\x0d\n      throw new ERR_OUT_OF_RANGE('length'\x2C `<= ${byteLength - offset}`\x2C length);\x0d\n    }\x0d\n\x0d\n    if (length < 0) {\x0d\n      throw new ERR_OUT_OF_RANGE('length'\x2C '>= 0'\x2C length);\x0d\n    }\x0d\n\x0d\n    validateInt32(length\x2C 'length'\x2C 0);\x0d\n  }\x0d\n);\x0d\n\x0d\nconst validatePath = hideStackFrames((path\x2C propName = 'path') => {\x0d\n  if (typeof path !== 'string' && !isUint8Array(path)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C ['string'\x2C 'Buffer'\x2C 'URL']\x2C path);\x0d\n  }\x0d\n\x0d\n  const err = nullCheck(path\x2C propName\x2C false);\x0d\n\x0d\n  if (err !== undefined) {\x0d\n    throw err;\x0d\n  }\x0d\n});\x0d\n\x0d\nconst getValidatedPath = hideStackFrames((fileURLOrPath\x2C propName = 'path') => {\x0d\n  const path = toPathIfFileURL(fileURLOrPath);\x0d\n  validatePath(path\x2C propName);\x0d\n  return path;\x0d\n});\x0d\n\x0d\nconst getValidatedFd = hideStackFrames((fd\x2C propName = 'fd') => {\x0d\n  if (ObjectIs(fd\x2C -0)) {\x0d\n    return 0;\x0d\n  }\x0d\n\x0d\n  validateInt32(fd\x2C propName\x2C 0);\x0d\n\x0d\n  return fd;\x0d\n});\x0d\n\x0d\nconst validateBufferArray = hideStackFrames((buffers\x2C propName = 'buffers') => {\x0d\n  if (!ArrayIsArray(buffers))\x0d\n    throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\x0d\n\x0d\n  for (let i = 0; i < buffers.length; i++) {\x0d\n    if (!isArrayBufferView(buffers[i]))\x0d\n      throw new ERR_INVALID_ARG_TYPE(propName\x2C 'ArrayBufferView[]'\x2C buffers);\x0d\n  }\x0d\n\x0d\n  return buffers;\x0d\n});\x0d\n\x0d\nlet nonPortableTemplateWarn = true;\x0d\n\x0d\nfunction warnOnNonPortableTemplate(template) {\x0d\n  // Template strings passed to the mkdtemp() family of functions should not\x0d\n  // end with 'X' because they are handled inconsistently across platforms.\x0d\n  if (nonPortableTemplateWarn && StringPrototypeEndsWith(template\x2C 'X')) {\x0d\n    process.emitWarning('mkdtemp() templates ending with X are not portable. ' +\x0d\n                        'For details see: https://nodejs.org/api/fs.html');\x0d\n    nonPortableTemplateWarn = false;\x0d\n  }\x0d\n}\x0d\n\x0d\nconst defaultCpOptions = {\x0d\n  dereference: false\x2C\x0d\n  errorOnExist: false\x2C\x0d\n  filter: undefined\x2C\x0d\n  force: true\x2C\x0d\n  preserveTimestamps: false\x2C\x0d\n  recursive: false\x2C\x0d\n};\x0d\n\x0d\nconst defaultRmOptions = {\x0d\n  recursive: false\x2C\x0d\n  force: false\x2C\x0d\n  retryDelay: 100\x2C\x0d\n  maxRetries: 0\x0d\n};\x0d\n\x0d\nconst defaultRmdirOptions = {\x0d\n  retryDelay: 100\x2C\x0d\n  maxRetries: 0\x2C\x0d\n  recursive: false\x2C\x0d\n};\x0d\n\x0d\nconst validateCpOptions = hideStackFrames((options) => {\x0d\n  if (options === undefined)\x0d\n    return { ...defaultCpOptions };\x0d\n  validateObject(options\x2C 'options');\x0d\n  options = { ...defaultCpOptions\x2C ...options };\x0d\n  validateBoolean(options.dereference\x2C 'options.dereference');\x0d\n  validateBoolean(options.errorOnExist\x2C 'options.errorOnExist');\x0d\n  validateBoolean(options.force\x2C 'options.force');\x0d\n  validateBoolean(options.preserveTimestamps\x2C 'options.preserveTimestamps');\x0d\n  validateBoolean(options.recursive\x2C 'options.recursive');\x0d\n  if (options.filter !== undefined) {\x0d\n    validateFunction(options.filter\x2C 'options.filter');\x0d\n  }\x0d\n  return options;\x0d\n});\x0d\n\x0d\nconst validateRmOptions = hideStackFrames((path\x2C options\x2C expectDir\x2C cb) => {\x0d\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\x0d\n  validateBoolean(options.force\x2C 'options.force');\x0d\n\x0d\n  lazyLoadFs().stat(path\x2C (err\x2C stats) => {\x0d\n    if (err) {\x0d\n      if (options.force && err.code === 'ENOENT') {\x0d\n        return cb(null\x2C options);\x0d\n      }\x0d\n      return cb(err\x2C options);\x0d\n    }\x0d\n\x0d\n    if (expectDir && !stats.isDirectory()) {\x0d\n      return cb(false);\x0d\n    }\x0d\n\x0d\n    if (stats.isDirectory() && !options.recursive) {\x0d\n      return cb(new ERR_FS_EISDIR({\x0d\n        code: 'EISDIR'\x2C\x0d\n        message: 'is a directory'\x2C\x0d\n        path\x2C\x0d\n        syscall: 'rm'\x2C\x0d\n        errno: EISDIR\x0d\n      }));\x0d\n    }\x0d\n    return cb(null\x2C options);\x0d\n  });\x0d\n});\x0d\n\x0d\nconst validateRmOptionsSync = hideStackFrames((path\x2C options\x2C expectDir) => {\x0d\n  options = validateRmdirOptions(options\x2C defaultRmOptions);\x0d\n  validateBoolean(options.force\x2C 'options.force');\x0d\n\x0d\n  if (!options.force || expectDir || !options.recursive) {\x0d\n    const isDirectory = lazyLoadFs()\x0d\n      .statSync(path\x2C { throwIfNoEntry: !options.force })?.isDirectory();\x0d\n\x0d\n    if (expectDir && !isDirectory) {\x0d\n      return false;\x0d\n    }\x0d\n\x0d\n    if (isDirectory && !options.recursive) {\x0d\n      throw new ERR_FS_EISDIR({\x0d\n        code: 'EISDIR'\x2C\x0d\n        message: 'is a directory'\x2C\x0d\n        path\x2C\x0d\n        syscall: 'rm'\x2C\x0d\n        errno: EISDIR\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return options;\x0d\n});\x0d\n\x0d\nlet recursiveRmdirWarned = process.noDeprecation;\x0d\nfunction emitRecursiveRmdirWarning() {\x0d\n  if (!recursiveRmdirWarned) {\x0d\n    process.emitWarning(\x0d\n      'In future versions of Node.js\x2C fs.rmdir(path\x2C { recursive: true }) ' +\x0d\n      'will be removed. Use fs.rm(path\x2C { recursive: true }) instead'\x2C\x0d\n      'DeprecationWarning'\x2C\x0d\n      'DEP0147'\x0d\n    );\x0d\n    recursiveRmdirWarned = true;\x0d\n  }\x0d\n}\x0d\n\x0d\nconst validateRmdirOptions = hideStackFrames(\x0d\n  (options\x2C defaults = defaultRmdirOptions) => {\x0d\n    if (options === undefined)\x0d\n      return defaults;\x0d\n    validateObject(options\x2C 'options');\x0d\n\x0d\n    options = { ...defaults\x2C ...options };\x0d\n\x0d\n    validateBoolean(options.recursive\x2C 'options.recursive');\x0d\n    validateInt32(options.retryDelay\x2C 'options.retryDelay'\x2C 0);\x0d\n    validateUint32(options.maxRetries\x2C 'options.maxRetries');\x0d\n\x0d\n    return options;\x0d\n  });\x0d\n\x0d\nconst getValidMode = hideStackFrames((mode\x2C type) => {\x0d\n  let min = kMinimumAccessMode;\x0d\n  let max = kMaximumAccessMode;\x0d\n  let def = F_OK;\x0d\n  if (type === 'copyFile') {\x0d\n    min = kMinimumCopyMode;\x0d\n    max = kMaximumCopyMode;\x0d\n    def = mode || kDefaultCopyMode;\x0d\n  } else {\x0d\n    assert(type === 'access');\x0d\n  }\x0d\n  if (mode == null) {\x0d\n    return def;\x0d\n  }\x0d\n  if (NumberIsInteger(mode) && mode >= min && mode <= max) {\x0d\n    return mode;\x0d\n  }\x0d\n  if (typeof mode !== 'number') {\x0d\n    throw new ERR_INVALID_ARG_TYPE('mode'\x2C 'integer'\x2C mode);\x0d\n  }\x0d\n  throw new ERR_OUT_OF_RANGE(\x0d\n    'mode'\x2C `an integer >= ${min} && <= ${max}`\x2C mode);\x0d\n});\x0d\n\x0d\nconst validateStringAfterArrayBufferView = hideStackFrames((buffer\x2C name) => {\x0d\n  if (typeof buffer === 'string') {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (\x0d\n    typeof buffer === 'object' &&\x0d\n    buffer !== null &&\x0d\n    typeof buffer.toString === 'function' &&\x0d\n    ObjectPrototypeHasOwnProperty(buffer\x2C 'toString')\x0d\n  ) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  throw new ERR_INVALID_ARG_TYPE(\x0d\n    name\x2C\x0d\n    ['string'\x2C 'Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\x0d\n    buffer\x0d\n  );\x0d\n});\x0d\n\x0d\nconst validatePosition = hideStackFrames((position\x2C name) => {\x0d\n  if (typeof position === 'number') {\x0d\n    validateInteger(position\x2C 'position');\x0d\n  } else if (typeof position === 'bigint') {\x0d\n    if (!(position >= -(2n ** 63n) && position <= 2n ** 63n - 1n)) {\x0d\n      throw new ERR_OUT_OF_RANGE('position'\x2C\x0d\n                                 `>= ${-(2n ** 63n)} && <= ${2n ** 63n - 1n}`\x2C\x0d\n                                 position);\x0d\n    }\x0d\n  } else {\x0d\n    throw new ERR_INVALID_ARG_TYPE('position'\x2C\x0d\n                                   ['integer'\x2C 'bigint']\x2C\x0d\n                                   position);\x0d\n  }\x0d\n});\x0d\n\x0d\nmodule.exports = {\x0d\n  constants: {\x0d\n    kIoMaxLength\x2C\x0d\n    kMaxUserId\x2C\x0d\n    kReadFileBufferLength\x2C\x0d\n    kReadFileUnknownBufferLength\x2C\x0d\n    kWriteFileMaxChunkSize\x2C\x0d\n  }\x2C\x0d\n  assertEncoding\x2C\x0d\n  BigIntStats\x2C  // for testing\x0d\n  copyObject\x2C\x0d\n  Dirent\x2C\x0d\n  emitRecursiveRmdirWarning\x2C\x0d\n  getDirent\x2C\x0d\n  getDirents\x2C\x0d\n  getOptions\x2C\x0d\n  getValidatedFd\x2C\x0d\n  getValidatedPath\x2C\x0d\n  getValidMode\x2C\x0d\n  handleErrorFromBinding\x2C\x0d\n  nullCheck\x2C\x0d\n  preprocessSymlinkDestination\x2C\x0d\n  realpathCacheKey: Symbol('realpathCacheKey')\x2C\x0d\n  getStatsFromBinding\x2C\x0d\n  stringToFlags\x2C\x0d\n  stringToSymlinkType\x2C\x0d\n  Stats\x2C\x0d\n  toUnixTimestamp\x2C\x0d\n  validateBufferArray\x2C\x0d\n  validateCpOptions\x2C\x0d\n  validateOffsetLengthRead\x2C\x0d\n  validateOffsetLengthWrite\x2C\x0d\n  validatePath\x2C\x0d\n  validatePosition\x2C\x0d\n  validateRmOptions\x2C\x0d\n  validateRmOptionsSync\x2C\x0d\n  validateRmdirOptions\x2C\x0d\n  validateStringAfterArrayBufferView\x2C\x0d\n  warnOnNonPortableTemplate\x0d\n};\x0d\n
code-source-info,0x1c1d96c7196,82,7531,8175,C0O7562C14O7656C16O7678C17O7689C23O7729C29O7774C31O7798C35O7814C42O7850C48O7890C66O7896C71O7890C72O7986C79O7995C84O8014C87O8037C92O8014C96O8065C102O8094C107O8122C115O8094C120O8157C122O8172,,
code-creation,LazyCompile,10,233330,0x1c1d96c90ee,48,assertEncoding node:internal/fs/utils:151:24,0x1d4982a14b0,~
code-source-info,0x1c1d96c90ee,82,3677,3859,C0O3693C6O3710C9O3717C14O3717C21O3761C24O3789C40O3795C45O3789C47O3858,,
code-creation,LazyCompile,10,233457,0x1c1d96c9206,20,toPathIfFileURL node:internal/url:1558:25,0x14121bf97e8,~
script-source,39,node:internal/url,'use strict';\x0d\n\x0d\nconst {\x0d\n  Array\x2C\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypeMap\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeReduce\x2C\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  FunctionPrototypeBind\x2C\x0d\n  Int8Array\x2C\x0d\n  Number\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectGetOwnPropertySymbols\x2C\x0d\n  ObjectGetPrototypeOf\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ReflectApply\x2C\x0d\n  ReflectGetOwnPropertyDescriptor\x2C\x0d\n  ReflectOwnKeys\x2C\x0d\n  String\x2C\x0d\n  StringPrototypeCharCodeAt\x2C\x0d\n  StringPrototypeIncludes\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolIterator\x2C\x0d\n  SymbolToStringTag\x2C\x0d\n  decodeURIComponent\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { inspect } = require('internal/util/inspect');\x0d\nconst {\x0d\n  encodeStr\x2C\x0d\n  hexTable\x2C\x0d\n  isHexTable\x0d\n} = require('internal/querystring');\x0d\n\x0d\nconst {\x0d\n  getConstructorOf\x2C\x0d\n  removeColors\x2C\x0d\n  toUSVString\x2C\x0d\n} = require('internal/util');\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_ARG_NOT_ITERABLE\x2C\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_INVALID_FILE_URL_HOST\x2C\x0d\n    ERR_INVALID_FILE_URL_PATH\x2C\x0d\n    ERR_INVALID_THIS\x2C\x0d\n    ERR_INVALID_TUPLE\x2C\x0d\n    ERR_INVALID_URL\x2C\x0d\n    ERR_INVALID_URL_SCHEME\x2C\x0d\n    ERR_MISSING_ARGS\x2C\x0d\n    ERR_NO_CRYPTO\x2C\x0d\n  }\x2C\x0d\n} = require('internal/errors');\x0d\nconst {\x0d\n  CHAR_AMPERSAND\x2C\x0d\n  CHAR_BACKWARD_SLASH\x2C\x0d\n  CHAR_EQUAL\x2C\x0d\n  CHAR_FORWARD_SLASH\x2C\x0d\n  CHAR_LOWERCASE_A\x2C\x0d\n  CHAR_LOWERCASE_Z\x2C\x0d\n  CHAR_PERCENT\x2C\x0d\n  CHAR_PLUS\x0d\n} = require('internal/constants');\x0d\nconst path = require('path');\x0d\n\x0d\nconst {\x0d\n  validateCallback\x2C\x0d\n  validateObject\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst querystring = require('querystring');\x0d\n\x0d\nconst { platform } = process;\x0d\nconst isWindows = platform === 'win32';\x0d\n\x0d\nconst {\x0d\n  domainToASCII: _domainToASCII\x2C\x0d\n  domainToUnicode: _domainToUnicode\x2C\x0d\n  encodeAuth\x2C\x0d\n  parse\x2C\x0d\n  setURLConstructor\x2C\x0d\n  URL_FLAGS_CANNOT_BE_BASE\x2C\x0d\n  URL_FLAGS_HAS_FRAGMENT\x2C\x0d\n  URL_FLAGS_HAS_HOST\x2C\x0d\n  URL_FLAGS_HAS_PASSWORD\x2C\x0d\n  URL_FLAGS_HAS_PATH\x2C\x0d\n  URL_FLAGS_HAS_QUERY\x2C\x0d\n  URL_FLAGS_HAS_USERNAME\x2C\x0d\n  URL_FLAGS_IS_DEFAULT_SCHEME_PORT\x2C\x0d\n  URL_FLAGS_SPECIAL\x2C\x0d\n  kFragment\x2C\x0d\n  kHost\x2C\x0d\n  kHostname\x2C\x0d\n  kPathStart\x2C\x0d\n  kPort\x2C\x0d\n  kQuery\x2C\x0d\n  kSchemeStart\x0d\n} = internalBinding('url');\x0d\n\x0d\nconst {\x0d\n  storeDataObject\x2C\x0d\n  revokeDataObject\x2C\x0d\n} = internalBinding('blob');\x0d\n\x0d\nconst context = Symbol('context');\x0d\nconst cannotBeBase = Symbol('cannot-be-base');\x0d\nconst cannotHaveUsernamePasswordPort =\x0d\n    Symbol('cannot-have-username-password-port');\x0d\nconst special = Symbol('special');\x0d\nconst searchParams = Symbol('query');\x0d\nconst kFormat = Symbol('format');\x0d\n\x0d\nlet blob;\x0d\nlet cryptoRandom;\x0d\n\x0d\nfunction lazyBlob() {\x0d\n  blob ??= require('internal/blob');\x0d\n  return blob;\x0d\n}\x0d\n\x0d\nfunction lazyCryptoRandom() {\x0d\n  try {\x0d\n    cryptoRandom ??= require('internal/crypto/random');\x0d\n  } catch {\x0d\n    // If Node.js built without crypto support\x2C we'll fall\x0d\n    // through here and handle it later.\x0d\n  }\x0d\n  return cryptoRandom;\x0d\n}\x0d\n\x0d\n// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object\x0d\nconst IteratorPrototype = ObjectGetPrototypeOf(\x0d\n  ObjectGetPrototypeOf([][SymbolIterator]())\x0d\n);\x0d\n\x0d\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#concept-origin-opaque\x0d\nconst kOpaqueOrigin = 'null';\x0d\n\x0d\n// Refs: https://html.spec.whatwg.org/multipage/browsers.html#ascii-serialisation-of-an-origin\x0d\nfunction serializeTupleOrigin(scheme\x2C host\x2C port) {\x0d\n  return `${scheme}//${host}${port === null ? '' : `:${port}`}`;\x0d\n}\x0d\n\x0d\n// This class provides the internal state of a URL object. An instance of this\x0d\n// class is stored in every URL object and is accessed internally by setters\x0d\n// and getters. It roughly corresponds to the concept of a URL record in the\x0d\n// URL Standard\x2C with a few differences. It is also the object transported to\x0d\n// the C++ binding.\x0d\n// Refs: https://url.spec.whatwg.org/#concept-url\x0d\nclass URLContext {\x0d\n  constructor() {\x0d\n    this.flags = 0;\x0d\n    this.scheme = ':';\x0d\n    this.username = '';\x0d\n    this.password = '';\x0d\n    this.host = null;\x0d\n    this.port = null;\x0d\n    this.path = [];\x0d\n    this.query = null;\x0d\n    this.fragment = null;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction isURLSearchParams(self) {\x0d\n  return self && self[searchParams] && !self[searchParams][searchParams];\x0d\n}\x0d\n\x0d\nclass URLSearchParams {\x0d\n  // URL Standard says the default value is ''\x2C but as undefined and '' have\x0d\n  // the same result\x2C undefined is used to prevent unnecessary parsing.\x0d\n  // Default parameter is necessary to keep URLSearchParams.length === 0 in\x0d\n  // accordance with Web IDL spec.\x0d\n  constructor(init = undefined) {\x0d\n    if (init === null || init === undefined) {\x0d\n      this[searchParams] = [];\x0d\n    } else if (typeof init === 'object' || typeof init === 'function') {\x0d\n      const method = init[SymbolIterator];\x0d\n      if (method === this[SymbolIterator]) {\x0d\n        // While the spec does not have this branch\x2C we can use it as a\x0d\n        // shortcut to avoid having to go through the costly generic iterator.\x0d\n        const childParams = init[searchParams];\x0d\n        this[searchParams] = childParams.slice();\x0d\n      } else if (method !== null && method !== undefined) {\x0d\n        if (typeof method !== 'function') {\x0d\n          throw new ERR_ARG_NOT_ITERABLE('Query pairs');\x0d\n        }\x0d\n\x0d\n        // Sequence<sequence<USVString>>\x0d\n        // Note: per spec we have to first exhaust the lists then process them\x0d\n        const pairs = [];\x0d\n        for (const pair of init) {\x0d\n          if ((typeof pair !== 'object' && typeof pair !== 'function') ||\x0d\n              pair === null ||\x0d\n              typeof pair[SymbolIterator] !== 'function') {\x0d\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\x0d\n          }\x0d\n          const convertedPair = [];\x0d\n          for (const element of pair)\x0d\n            ArrayPrototypePush(convertedPair\x2C toUSVString(element));\x0d\n          ArrayPrototypePush(pairs\x2C convertedPair);\x0d\n        }\x0d\n\x0d\n        this[searchParams] = [];\x0d\n        for (const pair of pairs) {\x0d\n          if (pair.length !== 2) {\x0d\n            throw new ERR_INVALID_TUPLE('Each query pair'\x2C '[name\x2C value]');\x0d\n          }\x0d\n          ArrayPrototypePush(this[searchParams]\x2C pair[0]\x2C pair[1]);\x0d\n        }\x0d\n      } else {\x0d\n        // Record<USVString\x2C USVString>\x0d\n        // Need to use reflection APIs for full spec compliance.\x0d\n        const visited = {};\x0d\n        this[searchParams] = [];\x0d\n        const keys = ReflectOwnKeys(init);\x0d\n        for (let i = 0; i < keys.length; i++) {\x0d\n          const key = keys[i];\x0d\n          const desc = ReflectGetOwnPropertyDescriptor(init\x2C key);\x0d\n          if (desc !== undefined && desc.enumerable) {\x0d\n            const typedKey = toUSVString(key);\x0d\n            const typedValue = toUSVString(init[key]);\x0d\n\x0d\n            // Two different key may result same after `toUSVString()`\x2C we only\x0d\n            // leave the later one. Refers to WPT.\x0d\n            if (visited[typedKey] !== undefined) {\x0d\n              this[searchParams][visited[typedKey]] = typedValue;\x0d\n            } else {\x0d\n              visited[typedKey] = ArrayPrototypePush(this[searchParams]\x2C\x0d\n                                                     typedKey\x2C\x0d\n                                                     typedValue) - 1;\x0d\n            }\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n    } else {\x0d\n      // USVString\x0d\n      init = toUSVString(init);\x0d\n      if (init[0] === '?') init = init.slice(1);\x0d\n      initSearchParams(this\x2C init);\x0d\n    }\x0d\n\x0d\n    // "associated url object"\x0d\n    this[context] = null;\x0d\n  }\x0d\n\x0d\n  [inspect.custom](recurseTimes\x2C ctx) {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\x0d\n      return ctx.stylize('[Object]'\x2C 'special');\x0d\n\x0d\n    const separator = '\x2C ';\x0d\n    const innerOpts = { ...ctx };\x0d\n    if (recurseTimes !== null) {\x0d\n      innerOpts.depth = recurseTimes - 1;\x0d\n    }\x0d\n    const innerInspect = (v) => inspect(v\x2C innerOpts);\x0d\n\x0d\n    const list = this[searchParams];\x0d\n    const output = [];\x0d\n    for (let i = 0; i < list.length; i += 2)\x0d\n      ArrayPrototypePush(\x0d\n        output\x2C\x0d\n        `${innerInspect(list[i])} => ${innerInspect(list[i + 1])}`);\x0d\n\x0d\n    const length = ArrayPrototypeReduce(\x0d\n      output\x2C\x0d\n      (prev\x2C cur) => prev + removeColors(cur).length + separator.length\x2C\x0d\n      -separator.length\x0d\n    );\x0d\n    if (length > ctx.breakLength) {\x0d\n      return `${this.constructor.name} {\\n` +\x0d\n      `  ${ArrayPrototypeJoin(output\x2C '\x2C\\n  ')} }`;\x0d\n    } else if (output.length) {\x0d\n      return `${this.constructor.name} { ` +\x0d\n      `${ArrayPrototypeJoin(output\x2C separator)} }`;\x0d\n    }\x0d\n    return `${this.constructor.name} {}`;\x0d\n  }\x0d\n\x0d\n  append(name\x2C value) {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    if (arguments.length < 2) {\x0d\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\x0d\n    }\x0d\n\x0d\n    name = toUSVString(name);\x0d\n    value = toUSVString(value);\x0d\n    ArrayPrototypePush(this[searchParams]\x2C name\x2C value);\x0d\n    update(this[context]\x2C this);\x0d\n  }\x0d\n\x0d\n  delete(name) {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    if (arguments.length < 1) {\x0d\n      throw new ERR_MISSING_ARGS('name');\x0d\n    }\x0d\n\x0d\n    const list = this[searchParams];\x0d\n    name = toUSVString(name);\x0d\n    for (let i = 0; i < list.length;) {\x0d\n      const cur = list[i];\x0d\n      if (cur === name) {\x0d\n        list.splice(i\x2C 2);\x0d\n      } else {\x0d\n        i += 2;\x0d\n      }\x0d\n    }\x0d\n    update(this[context]\x2C this);\x0d\n  }\x0d\n\x0d\n  get(name) {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    if (arguments.length < 1) {\x0d\n      throw new ERR_MISSING_ARGS('name');\x0d\n    }\x0d\n\x0d\n    const list = this[searchParams];\x0d\n    name = toUSVString(name);\x0d\n    for (let i = 0; i < list.length; i += 2) {\x0d\n      if (list[i] === name) {\x0d\n        return list[i + 1];\x0d\n      }\x0d\n    }\x0d\n    return null;\x0d\n  }\x0d\n\x0d\n  getAll(name) {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    if (arguments.length < 1) {\x0d\n      throw new ERR_MISSING_ARGS('name');\x0d\n    }\x0d\n\x0d\n    const list = this[searchParams];\x0d\n    const values = [];\x0d\n    name = toUSVString(name);\x0d\n    for (let i = 0; i < list.length; i += 2) {\x0d\n      if (list[i] === name) {\x0d\n        values.push(list[i + 1]);\x0d\n      }\x0d\n    }\x0d\n    return values;\x0d\n  }\x0d\n\x0d\n  has(name) {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    if (arguments.length < 1) {\x0d\n      throw new ERR_MISSING_ARGS('name');\x0d\n    }\x0d\n\x0d\n    const list = this[searchParams];\x0d\n    name = toUSVString(name);\x0d\n    for (let i = 0; i < list.length; i += 2) {\x0d\n      if (list[i] === name) {\x0d\n        return true;\x0d\n      }\x0d\n    }\x0d\n    return false;\x0d\n  }\x0d\n\x0d\n  set(name\x2C value) {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    if (arguments.length < 2) {\x0d\n      throw new ERR_MISSING_ARGS('name'\x2C 'value');\x0d\n    }\x0d\n\x0d\n    const list = this[searchParams];\x0d\n    name = toUSVString(name);\x0d\n    value = toUSVString(value);\x0d\n\x0d\n    // If there are any name-value pairs whose name is `name`\x2C in `list`\x2C set\x0d\n    // the value of the first such name-value pair to `value` and remove the\x0d\n    // others.\x0d\n    let found = false;\x0d\n    for (let i = 0; i < list.length;) {\x0d\n      const cur = list[i];\x0d\n      if (cur === name) {\x0d\n        if (!found) {\x0d\n          list[i + 1] = value;\x0d\n          found = true;\x0d\n          i += 2;\x0d\n        } else {\x0d\n          list.splice(i\x2C 2);\x0d\n        }\x0d\n      } else {\x0d\n        i += 2;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    // Otherwise\x2C append a new name-value pair whose name is `name` and value\x0d\n    // is `value`\x2C to `list`.\x0d\n    if (!found) {\x0d\n      ArrayPrototypePush(list\x2C name\x2C value);\x0d\n    }\x0d\n\x0d\n    update(this[context]\x2C this);\x0d\n  }\x0d\n\x0d\n  sort() {\x0d\n    const a = this[searchParams];\x0d\n    const len = a.length;\x0d\n\x0d\n    if (len <= 2) {\x0d\n      // Nothing needs to be done.\x0d\n    } else if (len < 100) {\x0d\n      // 100 is found through testing.\x0d\n      // Simple stable in-place insertion sort\x0d\n      // Derived from v8/src/js/array.js\x0d\n      for (let i = 2; i < len; i += 2) {\x0d\n        const curKey = a[i];\x0d\n        const curVal = a[i + 1];\x0d\n        let j;\x0d\n        for (j = i - 2; j >= 0; j -= 2) {\x0d\n          if (a[j] > curKey) {\x0d\n            a[j + 2] = a[j];\x0d\n            a[j + 3] = a[j + 1];\x0d\n          } else {\x0d\n            break;\x0d\n          }\x0d\n        }\x0d\n        a[j + 2] = curKey;\x0d\n        a[j + 3] = curVal;\x0d\n      }\x0d\n    } else {\x0d\n      // Bottom-up iterative stable merge sort\x0d\n      const lBuffer = new Array(len);\x0d\n      const rBuffer = new Array(len);\x0d\n      for (let step = 2; step < len; step *= 2) {\x0d\n        for (let start = 0; start < len - 2; start += 2 * step) {\x0d\n          const mid = start + step;\x0d\n          let end = mid + step;\x0d\n          end = end < len ? end : len;\x0d\n          if (mid > end)\x0d\n            continue;\x0d\n          merge(a\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer);\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n\x0d\n    update(this[context]\x2C this);\x0d\n  }\x0d\n\x0d\n  // https://heycam.github.io/webidl/#es-iterators\x0d\n  // Define entries here rather than [Symbol.iterator] as the function name\x0d\n  // must be set to `entries`.\x0d\n  entries() {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    return createSearchParamsIterator(this\x2C 'key+value');\x0d\n  }\x0d\n\x0d\n  forEach(callback\x2C thisArg = undefined) {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    validateCallback(callback);\x0d\n\x0d\n    let list = this[searchParams];\x0d\n\x0d\n    let i = 0;\x0d\n    while (i < list.length) {\x0d\n      const key = list[i];\x0d\n      const value = list[i + 1];\x0d\n      callback.call(thisArg\x2C value\x2C key\x2C this);\x0d\n      // In case the URL object's `search` is updated\x0d\n      list = this[searchParams];\x0d\n      i += 2;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // https://heycam.github.io/webidl/#es-iterable\x0d\n  keys() {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    return createSearchParamsIterator(this\x2C 'key');\x0d\n  }\x0d\n\x0d\n  values() {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    return createSearchParamsIterator(this\x2C 'value');\x0d\n  }\x0d\n\x0d\n  // https://heycam.github.io/webidl/#es-stringifier\x0d\n  // https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior\x0d\n  toString() {\x0d\n    if (!isURLSearchParams(this))\x0d\n      throw new ERR_INVALID_THIS('URLSearchParams');\x0d\n\x0d\n    return serializeParams(this[searchParams]);\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(URLSearchParams.prototype\x2C {\x0d\n  append: { enumerable: true }\x2C\x0d\n  delete: { enumerable: true }\x2C\x0d\n  get: { enumerable: true }\x2C\x0d\n  getAll: { enumerable: true }\x2C\x0d\n  has: { enumerable: true }\x2C\x0d\n  set: { enumerable: true }\x2C\x0d\n  sort: { enumerable: true }\x2C\x0d\n  entries: { enumerable: true }\x2C\x0d\n  forEach: { enumerable: true }\x2C\x0d\n  keys: { enumerable: true }\x2C\x0d\n  values: { enumerable: true }\x2C\x0d\n  toString: { enumerable: true }\x2C\x0d\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URLSearchParams' }\x2C\x0d\n\x0d\n  // https://heycam.github.io/webidl/#es-iterable-entries\x0d\n  [SymbolIterator]: {\x0d\n    configurable: true\x2C\x0d\n    writable: true\x2C\x0d\n    value: URLSearchParams.prototype.entries\x2C\x0d\n  }\x2C\x0d\n});\x0d\n\x0d\nfunction onParseComplete(flags\x2C protocol\x2C username\x2C password\x2C\x0d\n                         host\x2C port\x2C path\x2C query\x2C fragment) {\x0d\n  const ctx = this[context];\x0d\n  ctx.flags = flags;\x0d\n  ctx.scheme = protocol;\x0d\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\x0d\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\x0d\n  ctx.port = port;\x0d\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\x0d\n  ctx.query = query;\x0d\n  ctx.fragment = fragment;\x0d\n  ctx.host = host;\x0d\n  if (!this[searchParams]) { // Invoked from URL constructor\x0d\n    this[searchParams] = new URLSearchParams();\x0d\n    this[searchParams][context] = this;\x0d\n  }\x0d\n  initSearchParams(this[searchParams]\x2C query);\x0d\n}\x0d\n\x0d\nfunction onParseError(flags\x2C input) {\x0d\n  throw new ERR_INVALID_URL(input);\x0d\n}\x0d\n\x0d\nfunction onParseProtocolComplete(flags\x2C protocol\x2C username\x2C password\x2C\x0d\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\x0d\n  const ctx = this[context];\x0d\n  if ((flags & URL_FLAGS_SPECIAL) !== 0) {\x0d\n    ctx.flags |= URL_FLAGS_SPECIAL;\x0d\n  } else {\x0d\n    ctx.flags &= ~URL_FLAGS_SPECIAL;\x0d\n  }\x0d\n  ctx.scheme = protocol;\x0d\n  ctx.port = port;\x0d\n}\x0d\n\x0d\nfunction onParseHostnameComplete(flags\x2C protocol\x2C username\x2C password\x2C\x0d\n                                 host\x2C port\x2C path\x2C query\x2C fragment) {\x0d\n  const ctx = this[context];\x0d\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\x0d\n    ctx.host = host;\x0d\n    ctx.flags |= URL_FLAGS_HAS_HOST;\x0d\n  } else {\x0d\n    ctx.host = null;\x0d\n    ctx.flags &= ~URL_FLAGS_HAS_HOST;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction onParsePortComplete(flags\x2C protocol\x2C username\x2C password\x2C\x0d\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\x0d\n  this[context].port = port;\x0d\n}\x0d\n\x0d\nfunction onParseHostComplete(flags\x2C protocol\x2C username\x2C password\x2C\x0d\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\x0d\n  ReflectApply(onParseHostnameComplete\x2C this\x2C arguments);\x0d\n  if (port !== null || ((flags & URL_FLAGS_IS_DEFAULT_SCHEME_PORT) !== 0))\x0d\n    ReflectApply(onParsePortComplete\x2C this\x2C arguments);\x0d\n}\x0d\n\x0d\nfunction onParsePathComplete(flags\x2C protocol\x2C username\x2C password\x2C\x0d\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\x0d\n  const ctx = this[context];\x0d\n  if ((flags & URL_FLAGS_HAS_PATH) !== 0) {\x0d\n    ctx.path = path;\x0d\n    ctx.flags |= URL_FLAGS_HAS_PATH;\x0d\n  } else {\x0d\n    ctx.path = [];\x0d\n    ctx.flags &= ~URL_FLAGS_HAS_PATH;\x0d\n  }\x0d\n\x0d\n  // The C++ binding may set host to empty string.\x0d\n  if ((flags & URL_FLAGS_HAS_HOST) !== 0) {\x0d\n    ctx.host = host;\x0d\n    ctx.flags |= URL_FLAGS_HAS_HOST;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction onParseSearchComplete(flags\x2C protocol\x2C username\x2C password\x2C\x0d\n                               host\x2C port\x2C path\x2C query\x2C fragment) {\x0d\n  this[context].query = query;\x0d\n}\x0d\n\x0d\nfunction onParseHashComplete(flags\x2C protocol\x2C username\x2C password\x2C\x0d\n                             host\x2C port\x2C path\x2C query\x2C fragment) {\x0d\n  this[context].fragment = fragment;\x0d\n}\x0d\n\x0d\nfunction isURLThis(self) {\x0d\n  return (self !== undefined && self !== null && self[context] !== undefined);\x0d\n}\x0d\n\x0d\nclass URL {\x0d\n  constructor(input\x2C base = undefined) {\x0d\n    // toUSVString is not needed.\x0d\n    input = `${input}`;\x0d\n    let base_context;\x0d\n    if (base !== undefined) {\x0d\n      base_context = new URL(base)[context];\x0d\n    }\x0d\n    this[context] = new URLContext();\x0d\n    parse(input\x2C -1\x2C base_context\x2C undefined\x2C\x0d\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\x0d\n  }\x0d\n\x0d\n  get [special]() {\x0d\n    return (this[context].flags & URL_FLAGS_SPECIAL) !== 0;\x0d\n  }\x0d\n\x0d\n  get [cannotBeBase]() {\x0d\n    return (this[context].flags & URL_FLAGS_CANNOT_BE_BASE) !== 0;\x0d\n  }\x0d\n\x0d\n  // https://url.spec.whatwg.org/#cannot-have-a-username-password-port\x0d\n  get [cannotHaveUsernamePasswordPort]() {\x0d\n    const { host\x2C scheme } = this[context];\x0d\n    return ((host == null || host === '') ||\x0d\n            this[cannotBeBase] ||\x0d\n            scheme === 'file:');\x0d\n  }\x0d\n\x0d\n  [inspect.custom](depth\x2C opts) {\x0d\n    if (this == null ||\x0d\n        ObjectGetPrototypeOf(this[context]) !== URLContext.prototype) {\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    }\x0d\n\x0d\n    if (typeof depth === 'number' && depth < 0)\x0d\n      return this;\x0d\n\x0d\n    const constructor = getConstructorOf(this) || URL;\x0d\n    const obj = ObjectCreate({ constructor });\x0d\n\x0d\n    obj.href = this.href;\x0d\n    obj.origin = this.origin;\x0d\n    obj.protocol = this.protocol;\x0d\n    obj.username = this.username;\x0d\n    obj.password = this.password;\x0d\n    obj.host = this.host;\x0d\n    obj.hostname = this.hostname;\x0d\n    obj.port = this.port;\x0d\n    obj.pathname = this.pathname;\x0d\n    obj.search = this.search;\x0d\n    obj.searchParams = this.searchParams;\x0d\n    obj.hash = this.hash;\x0d\n\x0d\n    if (opts.showHidden) {\x0d\n      obj.cannotBeBase = this[cannotBeBase];\x0d\n      obj.special = this[special];\x0d\n      obj[context] = this[context];\x0d\n    }\x0d\n\x0d\n    return `${constructor.name} ${inspect(obj\x2C opts)}`;\x0d\n  }\x0d\n\x0d\n  [kFormat](options) {\x0d\n    if (options)\x0d\n      validateObject(options\x2C 'options');\x0d\n\x0d\n    options = {\x0d\n      fragment: true\x2C\x0d\n      unicode: false\x2C\x0d\n      search: true\x2C\x0d\n      auth: true\x2C\x0d\n      ...options\x0d\n    };\x0d\n    const ctx = this[context];\x0d\n    // https://url.spec.whatwg.org/#url-serializing\x0d\n    let ret = ctx.scheme;\x0d\n    if (ctx.host !== null) {\x0d\n      ret += '//';\x0d\n      const has_username = ctx.username !== '';\x0d\n      const has_password = ctx.password !== '';\x0d\n      if (options.auth && (has_username || has_password)) {\x0d\n        if (has_username)\x0d\n          ret += ctx.username;\x0d\n        if (has_password)\x0d\n          ret += `:${ctx.password}`;\x0d\n        ret += '@';\x0d\n      }\x0d\n      ret += options.unicode ?\x0d\n        domainToUnicode(ctx.host) : ctx.host;\x0d\n      if (ctx.port !== null)\x0d\n        ret += `:${ctx.port}`;\x0d\n    }\x0d\n    if (this[cannotBeBase]) {\x0d\n      ret += ctx.path[0];\x0d\n    } else {\x0d\n      if (ctx.host === null && ctx.path.length > 1 && ctx.path[0] === '') {\x0d\n        ret += '/.';\x0d\n      }\x0d\n      if (ctx.path.length) {\x0d\n        ret += '/' + ArrayPrototypeJoin(ctx.path\x2C '/');\x0d\n      }\x0d\n    }\x0d\n    if (options.search && ctx.query !== null)\x0d\n      ret += `?${ctx.query}`;\x0d\n    if (options.fragment && ctx.fragment !== null)\x0d\n      ret += `#${ctx.fragment}`;\x0d\n    return ret;\x0d\n  }\x0d\n\x0d\n  // https://heycam.github.io/webidl/#es-stringifier\x0d\n  toString() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    return this[kFormat]({});\x0d\n  }\x0d\n\x0d\n  get href() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    return this[kFormat]({});\x0d\n  }\x0d\n\x0d\n  set href(input) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    // toUSVString is not needed.\x0d\n    input = `${input}`;\x0d\n    parse(input\x2C -1\x2C undefined\x2C undefined\x2C\x0d\n          FunctionPrototypeBind(onParseComplete\x2C this)\x2C onParseError);\x0d\n  }\x0d\n\x0d\n  // readonly\x0d\n  get origin() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    // Refs: https://url.spec.whatwg.org/#concept-url-origin\x0d\n    const ctx = this[context];\x0d\n    switch (ctx.scheme) {\x0d\n      case 'blob:':\x0d\n        if (ctx.path.length > 0) {\x0d\n          try {\x0d\n            return (new URL(ctx.path[0])).origin;\x0d\n          } catch {\x0d\n            // Fall through... do nothing\x0d\n          }\x0d\n        }\x0d\n        return kOpaqueOrigin;\x0d\n      case 'ftp:':\x0d\n      case 'http:':\x0d\n      case 'https:':\x0d\n      case 'ws:':\x0d\n      case 'wss:':\x0d\n        return serializeTupleOrigin(ctx.scheme\x2C ctx.host\x2C ctx.port);\x0d\n    }\x0d\n    return kOpaqueOrigin;\x0d\n  }\x0d\n\x0d\n  get protocol() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    return this[context].scheme;\x0d\n  }\x0d\n\x0d\n  set protocol(scheme) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    // toUSVString is not needed.\x0d\n    scheme = `${scheme}`;\x0d\n    if (scheme.length === 0)\x0d\n      return;\x0d\n    const ctx = this[context];\x0d\n    parse(scheme\x2C kSchemeStart\x2C null\x2C ctx\x2C\x0d\n          FunctionPrototypeBind(onParseProtocolComplete\x2C this));\x0d\n  }\x0d\n\x0d\n  get username() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    return this[context].username;\x0d\n  }\x0d\n\x0d\n  set username(username) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    // toUSVString is not needed.\x0d\n    username = `${username}`;\x0d\n    if (this[cannotHaveUsernamePasswordPort])\x0d\n      return;\x0d\n    const ctx = this[context];\x0d\n    if (username === '') {\x0d\n      ctx.username = '';\x0d\n      ctx.flags &= ~URL_FLAGS_HAS_USERNAME;\x0d\n      return;\x0d\n    }\x0d\n    ctx.username = encodeAuth(username);\x0d\n    ctx.flags |= URL_FLAGS_HAS_USERNAME;\x0d\n  }\x0d\n\x0d\n  get password() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    return this[context].password;\x0d\n  }\x0d\n\x0d\n  set password(password) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    // toUSVString is not needed.\x0d\n    password = `${password}`;\x0d\n    if (this[cannotHaveUsernamePasswordPort])\x0d\n      return;\x0d\n    const ctx = this[context];\x0d\n    if (password === '') {\x0d\n      ctx.password = '';\x0d\n      ctx.flags &= ~URL_FLAGS_HAS_PASSWORD;\x0d\n      return;\x0d\n    }\x0d\n    ctx.password = encodeAuth(password);\x0d\n    ctx.flags |= URL_FLAGS_HAS_PASSWORD;\x0d\n  }\x0d\n\x0d\n  get host() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    const ctx = this[context];\x0d\n    let ret = ctx.host || '';\x0d\n    if (ctx.port !== null)\x0d\n      ret += `:${ctx.port}`;\x0d\n    return ret;\x0d\n  }\x0d\n\x0d\n  set host(host) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    const ctx = this[context];\x0d\n    // toUSVString is not needed.\x0d\n    host = `${host}`;\x0d\n    if (this[cannotBeBase]) {\x0d\n      // Cannot set the host if cannot-be-base is set\x0d\n      return;\x0d\n    }\x0d\n    parse(host\x2C kHost\x2C null\x2C ctx\x2C\x0d\n          FunctionPrototypeBind(onParseHostComplete\x2C this));\x0d\n  }\x0d\n\x0d\n  get hostname() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    return this[context].host || '';\x0d\n  }\x0d\n\x0d\n  set hostname(host) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    const ctx = this[context];\x0d\n    // toUSVString is not needed.\x0d\n    host = `${host}`;\x0d\n    if (this[cannotBeBase]) {\x0d\n      // Cannot set the host if cannot-be-base is set\x0d\n      return;\x0d\n    }\x0d\n    parse(host\x2C kHostname\x2C null\x2C ctx\x2C onParseHostnameComplete.bind(this));\x0d\n  }\x0d\n\x0d\n  get port() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    const port = this[context].port;\x0d\n    return port === null ? '' : String(port);\x0d\n  }\x0d\n\x0d\n  set port(port) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    // toUSVString is not needed.\x0d\n    port = `${port}`;\x0d\n    if (this[cannotHaveUsernamePasswordPort])\x0d\n      return;\x0d\n    const ctx = this[context];\x0d\n    if (port === '') {\x0d\n      ctx.port = null;\x0d\n      return;\x0d\n    }\x0d\n    parse(port\x2C kPort\x2C null\x2C ctx\x2C\x0d\n          FunctionPrototypeBind(onParsePortComplete\x2C this));\x0d\n  }\x0d\n\x0d\n  get pathname() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    const ctx = this[context];\x0d\n    if (this[cannotBeBase])\x0d\n      return ctx.path[0];\x0d\n    if (ctx.path.length === 0)\x0d\n      return '';\x0d\n    return `/${ArrayPrototypeJoin(ctx.path\x2C '/')}`;\x0d\n  }\x0d\n\x0d\n  set pathname(path) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    // toUSVString is not needed.\x0d\n    path = `${path}`;\x0d\n    if (this[cannotBeBase])\x0d\n      return;\x0d\n    parse(path\x2C kPathStart\x2C null\x2C this[context]\x2C\x0d\n          onParsePathComplete.bind(this));\x0d\n  }\x0d\n\x0d\n  get search() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    const { query } = this[context];\x0d\n    if (query === null || query === '')\x0d\n      return '';\x0d\n    return `?${query}`;\x0d\n  }\x0d\n\x0d\n  set search(search) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    const ctx = this[context];\x0d\n    search = toUSVString(search);\x0d\n    if (search === '') {\x0d\n      ctx.query = null;\x0d\n      ctx.flags &= ~URL_FLAGS_HAS_QUERY;\x0d\n    } else {\x0d\n      if (search[0] === '?') search = StringPrototypeSlice(search\x2C 1);\x0d\n      ctx.query = '';\x0d\n      ctx.flags |= URL_FLAGS_HAS_QUERY;\x0d\n      if (search) {\x0d\n        parse(search\x2C kQuery\x2C null\x2C ctx\x2C\x0d\n              FunctionPrototypeBind(onParseSearchComplete\x2C this));\x0d\n      }\x0d\n    }\x0d\n    initSearchParams(this[searchParams]\x2C search);\x0d\n  }\x0d\n\x0d\n  // readonly\x0d\n  get searchParams() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    return this[searchParams];\x0d\n  }\x0d\n\x0d\n  get hash() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    const { fragment } = this[context];\x0d\n    if (fragment === null || fragment === '')\x0d\n      return '';\x0d\n    return `#${fragment}`;\x0d\n  }\x0d\n\x0d\n  set hash(hash) {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    const ctx = this[context];\x0d\n    // toUSVString is not needed.\x0d\n    hash = `${hash}`;\x0d\n    if (!hash) {\x0d\n      ctx.fragment = null;\x0d\n      ctx.flags &= ~URL_FLAGS_HAS_FRAGMENT;\x0d\n      return;\x0d\n    }\x0d\n    if (hash[0] === '#') hash = StringPrototypeSlice(hash\x2C 1);\x0d\n    ctx.fragment = '';\x0d\n    ctx.flags |= URL_FLAGS_HAS_FRAGMENT;\x0d\n    parse(hash\x2C kFragment\x2C null\x2C ctx\x2C\x0d\n          FunctionPrototypeBind(onParseHashComplete\x2C this));\x0d\n  }\x0d\n\x0d\n  toJSON() {\x0d\n    if (!isURLThis(this))\x0d\n      throw new ERR_INVALID_THIS('URL');\x0d\n    return this[kFormat]({});\x0d\n  }\x0d\n\x0d\n  static createObjectURL(obj) {\x0d\n    const cryptoRandom = lazyCryptoRandom();\x0d\n    if (cryptoRandom === undefined)\x0d\n      throw new ERR_NO_CRYPTO();\x0d\n\x0d\n    // Yes\x2C lazy loading is annoying but because of circular\x0d\n    // references between the url\x2C internal/blob\x2C and buffer\x0d\n    // modules\x2C lazy loading here makes sure that things work.\x0d\n    const blob = lazyBlob();\x0d\n    if (!blob.isBlob(obj))\x0d\n      throw new ERR_INVALID_ARG_TYPE('obj'\x2C 'Blob'\x2C obj);\x0d\n\x0d\n    const id = cryptoRandom.randomUUID();\x0d\n\x0d\n    storeDataObject(id\x2C obj[blob.kHandle]\x2C obj.size\x2C obj.type);\x0d\n\x0d\n    return `blob:nodedata:${id}`;\x0d\n  }\x0d\n\x0d\n  static revokeObjectURL(url) {\x0d\n    url = `${url}`;\x0d\n    try {\x0d\n      const parsed = new URL(url);\x0d\n      const split = StringPrototypeSplit(parsed.pathname\x2C ':');\x0d\n      if (split.length === 2)\x0d\n        revokeDataObject(split[1]);\x0d\n    } catch {\x0d\n      // If there's an error\x2C it's ignored.\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(URL.prototype\x2C {\x0d\n  [kFormat]: { configurable: false\x2C writable: false }\x2C\x0d\n  [SymbolToStringTag]: { configurable: true\x2C value: 'URL' }\x2C\x0d\n  toString: { enumerable: true }\x2C\x0d\n  href: { enumerable: true }\x2C\x0d\n  origin: { enumerable: true }\x2C\x0d\n  protocol: { enumerable: true }\x2C\x0d\n  username: { enumerable: true }\x2C\x0d\n  password: { enumerable: true }\x2C\x0d\n  host: { enumerable: true }\x2C\x0d\n  hostname: { enumerable: true }\x2C\x0d\n  port: { enumerable: true }\x2C\x0d\n  pathname: { enumerable: true }\x2C\x0d\n  search: { enumerable: true }\x2C\x0d\n  searchParams: { enumerable: true }\x2C\x0d\n  hash: { enumerable: true }\x2C\x0d\n  toJSON: { enumerable: true }\x2C\x0d\n});\x0d\n\x0d\nfunction update(url\x2C params) {\x0d\n  if (!url)\x0d\n    return;\x0d\n\x0d\n  const ctx = url[context];\x0d\n  const serializedParams = params.toString();\x0d\n  if (serializedParams) {\x0d\n    ctx.query = serializedParams;\x0d\n    ctx.flags |= URL_FLAGS_HAS_QUERY;\x0d\n  } else {\x0d\n    ctx.query = null;\x0d\n    ctx.flags &= ~URL_FLAGS_HAS_QUERY;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction initSearchParams(url\x2C init) {\x0d\n  if (!init) {\x0d\n    url[searchParams] = [];\x0d\n    return;\x0d\n  }\x0d\n  url[searchParams] = parseParams(init);\x0d\n}\x0d\n\x0d\n// application/x-www-form-urlencoded parser\x0d\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-parser\x0d\nfunction parseParams(qs) {\x0d\n  const out = [];\x0d\n  let pairStart = 0;\x0d\n  let lastPos = 0;\x0d\n  let seenSep = false;\x0d\n  let buf = '';\x0d\n  let encoded = false;\x0d\n  let encodeCheck = 0;\x0d\n  let i;\x0d\n  for (i = 0; i < qs.length; ++i) {\x0d\n    const code = StringPrototypeCharCodeAt(qs\x2C i);\x0d\n\x0d\n    // Try matching key/value pair separator\x0d\n    if (code === CHAR_AMPERSAND) {\x0d\n      if (pairStart === i) {\x0d\n        // We saw an empty substring between pair separators\x0d\n        lastPos = pairStart = i + 1;\x0d\n        continue;\x0d\n      }\x0d\n\x0d\n      if (lastPos < i)\x0d\n        buf += qs.slice(lastPos\x2C i);\x0d\n      if (encoded)\x0d\n        buf = querystring.unescape(buf);\x0d\n      out.push(buf);\x0d\n\x0d\n      // If `buf` is the key\x2C add an empty value.\x0d\n      if (!seenSep)\x0d\n        out.push('');\x0d\n\x0d\n      seenSep = false;\x0d\n      buf = '';\x0d\n      encoded = false;\x0d\n      encodeCheck = 0;\x0d\n      lastPos = pairStart = i + 1;\x0d\n      continue;\x0d\n    }\x0d\n\x0d\n    // Try matching key/value separator (e.g. '=') if we haven't already\x0d\n    if (!seenSep && code === CHAR_EQUAL) {\x0d\n      // Key/value separator match!\x0d\n      if (lastPos < i)\x0d\n        buf += qs.slice(lastPos\x2C i);\x0d\n      if (encoded)\x0d\n        buf = querystring.unescape(buf);\x0d\n      out.push(buf);\x0d\n\x0d\n      seenSep = true;\x0d\n      buf = '';\x0d\n      encoded = false;\x0d\n      encodeCheck = 0;\x0d\n      lastPos = i + 1;\x0d\n      continue;\x0d\n    }\x0d\n\x0d\n    // Handle + and percent decoding.\x0d\n    if (code === CHAR_PLUS) {\x0d\n      if (lastPos < i)\x0d\n        buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\x0d\n      buf += ' ';\x0d\n      lastPos = i + 1;\x0d\n    } else if (!encoded) {\x0d\n      // Try to match an (valid) encoded byte (once) to minimize unnecessary\x0d\n      // calls to string decoding functions\x0d\n      if (code === CHAR_PERCENT) {\x0d\n        encodeCheck = 1;\x0d\n      } else if (encodeCheck > 0) {\x0d\n        if (isHexTable[code] === 1) {\x0d\n          if (++encodeCheck === 3) {\x0d\n            encoded = true;\x0d\n          }\x0d\n        } else {\x0d\n          encodeCheck = 0;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // Deal with any leftover key or value data\x0d\n\x0d\n  // There is a trailing &. No more processing is needed.\x0d\n  if (pairStart === i)\x0d\n    return out;\x0d\n\x0d\n  if (lastPos < i)\x0d\n    buf += StringPrototypeSlice(qs\x2C lastPos\x2C i);\x0d\n  if (encoded)\x0d\n    buf = querystring.unescape(buf);\x0d\n  ArrayPrototypePush(out\x2C buf);\x0d\n\x0d\n  // If `buf` is the key\x2C add an empty value.\x0d\n  if (!seenSep)\x0d\n    ArrayPrototypePush(out\x2C '');\x0d\n\x0d\n  return out;\x0d\n}\x0d\n\x0d\n// Adapted from querystring's implementation.\x0d\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-byte-serializer\x0d\nconst noEscape = new Int8Array([\x0d\n/*\x0d\n  0\x2C 1\x2C 2\x2C 3\x2C 4\x2C 5\x2C 6\x2C 7\x2C 8\x2C 9\x2C A\x2C B\x2C C\x2C D\x2C E\x2C F\x0d\n*/\x0d\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x00 - 0x0F\x0d\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x10 - 0x1F\x0d\n  0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C 0\x2C 0\x2C 1\x2C 1\x2C 0\x2C // 0x20 - 0x2F\x0d\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C // 0x30 - 0x3F\x0d\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x40 - 0x4F\x0d\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 1\x2C // 0x50 - 0x5F\x0d\n  0\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C // 0x60 - 0x6F\x0d\n  1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 1\x2C 0\x2C 0\x2C 0\x2C 0\x2C 0\x2C  // 0x70 - 0x7F\x0d\n]);\x0d\n\x0d\n// Special version of hexTable that uses `+` for U+0020 SPACE.\x0d\nconst paramHexTable = hexTable.slice();\x0d\nparamHexTable[0x20] = '+';\x0d\n\x0d\n// application/x-www-form-urlencoded serializer\x0d\n// Ref: https://url.spec.whatwg.org/#concept-urlencoded-serializer\x0d\nfunction serializeParams(array) {\x0d\n  const len = array.length;\x0d\n  if (len === 0)\x0d\n    return '';\x0d\n\x0d\n  const firstEncodedParam = encodeStr(array[0]\x2C noEscape\x2C paramHexTable);\x0d\n  const firstEncodedValue = encodeStr(array[1]\x2C noEscape\x2C paramHexTable);\x0d\n  let output = `${firstEncodedParam}=${firstEncodedValue}`;\x0d\n\x0d\n  for (let i = 2; i < len; i += 2) {\x0d\n    const encodedParam = encodeStr(array[i]\x2C noEscape\x2C paramHexTable);\x0d\n    const encodedValue = encodeStr(array[i + 1]\x2C noEscape\x2C paramHexTable);\x0d\n    output += `&${encodedParam}=${encodedValue}`;\x0d\n  }\x0d\n\x0d\n  return output;\x0d\n}\x0d\n\x0d\n// Mainly to mitigate func-name-matching ESLint rule\x0d\nfunction defineIDLClass(proto\x2C classStr\x2C obj) {\x0d\n  // https://heycam.github.io/webidl/#dfn-class-string\x0d\n  ObjectDefineProperty(proto\x2C SymbolToStringTag\x2C {\x0d\n    writable: false\x2C\x0d\n    enumerable: false\x2C\x0d\n    configurable: true\x2C\x0d\n    value: classStr\x0d\n  });\x0d\n\x0d\n  // https://heycam.github.io/webidl/#es-operations\x0d\n  for (const key of ObjectKeys(obj)) {\x0d\n    ObjectDefineProperty(proto\x2C key\x2C {\x0d\n      writable: true\x2C\x0d\n      enumerable: true\x2C\x0d\n      configurable: true\x2C\x0d\n      value: obj[key]\x0d\n    });\x0d\n  }\x0d\n  for (const key of ObjectGetOwnPropertySymbols(obj)) {\x0d\n    ObjectDefineProperty(proto\x2C key\x2C {\x0d\n      writable: true\x2C\x0d\n      enumerable: false\x2C\x0d\n      configurable: true\x2C\x0d\n      value: obj[key]\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\n// for merge sort\x0d\nfunction merge(out\x2C start\x2C mid\x2C end\x2C lBuffer\x2C rBuffer) {\x0d\n  const sizeLeft = mid - start;\x0d\n  const sizeRight = end - mid;\x0d\n  let l\x2C r\x2C o;\x0d\n\x0d\n  for (l = 0; l < sizeLeft; l++)\x0d\n    lBuffer[l] = out[start + l];\x0d\n  for (r = 0; r < sizeRight; r++)\x0d\n    rBuffer[r] = out[mid + r];\x0d\n\x0d\n  l = 0;\x0d\n  r = 0;\x0d\n  o = start;\x0d\n  while (l < sizeLeft && r < sizeRight) {\x0d\n    if (lBuffer[l] <= rBuffer[r]) {\x0d\n      out[o++] = lBuffer[l++];\x0d\n      out[o++] = lBuffer[l++];\x0d\n    } else {\x0d\n      out[o++] = rBuffer[r++];\x0d\n      out[o++] = rBuffer[r++];\x0d\n    }\x0d\n  }\x0d\n  while (l < sizeLeft)\x0d\n    out[o++] = lBuffer[l++];\x0d\n  while (r < sizeRight)\x0d\n    out[o++] = rBuffer[r++];\x0d\n}\x0d\n\x0d\n// https://heycam.github.io/webidl/#dfn-default-iterator-object\x0d\nfunction createSearchParamsIterator(target\x2C kind) {\x0d\n  const iterator = ObjectCreate(URLSearchParamsIteratorPrototype);\x0d\n  iterator[context] = {\x0d\n    target\x2C\x0d\n    kind\x2C\x0d\n    index: 0\x0d\n  };\x0d\n  return iterator;\x0d\n}\x0d\n\x0d\n// https://heycam.github.io/webidl/#dfn-iterator-prototype-object\x0d\nconst URLSearchParamsIteratorPrototype = ObjectCreate(IteratorPrototype);\x0d\n\x0d\ndefineIDLClass(URLSearchParamsIteratorPrototype\x2C 'URLSearchParams Iterator'\x2C {\x0d\n  next() {\x0d\n    if (!this ||\x0d\n        ObjectGetPrototypeOf(this) !== URLSearchParamsIteratorPrototype) {\x0d\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\x0d\n    }\x0d\n\x0d\n    const {\x0d\n      target\x2C\x0d\n      kind\x2C\x0d\n      index\x0d\n    } = this[context];\x0d\n    const values = target[searchParams];\x0d\n    const len = values.length;\x0d\n    if (index >= len) {\x0d\n      return {\x0d\n        value: undefined\x2C\x0d\n        done: true\x0d\n      };\x0d\n    }\x0d\n\x0d\n    const name = values[index];\x0d\n    const value = values[index + 1];\x0d\n    this[context].index = index + 2;\x0d\n\x0d\n    let result;\x0d\n    if (kind === 'key') {\x0d\n      result = name;\x0d\n    } else if (kind === 'value') {\x0d\n      result = value;\x0d\n    } else {\x0d\n      result = [name\x2C value];\x0d\n    }\x0d\n\x0d\n    return {\x0d\n      value: result\x2C\x0d\n      done: false\x0d\n    };\x0d\n  }\x2C\x0d\n  [inspect.custom](recurseTimes\x2C ctx) {\x0d\n    if (this == null || this[context] == null || this[context].target == null)\x0d\n      throw new ERR_INVALID_THIS('URLSearchParamsIterator');\x0d\n\x0d\n    if (typeof recurseTimes === 'number' && recurseTimes < 0)\x0d\n      return ctx.stylize('[Object]'\x2C 'special');\x0d\n\x0d\n    const innerOpts = { ...ctx };\x0d\n    if (recurseTimes !== null) {\x0d\n      innerOpts.depth = recurseTimes - 1;\x0d\n    }\x0d\n    const {\x0d\n      target\x2C\x0d\n      kind\x2C\x0d\n      index\x0d\n    } = this[context];\x0d\n    const output = ArrayPrototypeReduce(\x0d\n      ArrayPrototypeSlice(target[searchParams]\x2C index)\x2C\x0d\n      (prev\x2C cur\x2C i) => {\x0d\n        const key = i % 2 === 0;\x0d\n        if (kind === 'key' && key) {\x0d\n          ArrayPrototypePush(prev\x2C cur);\x0d\n        } else if (kind === 'value' && !key) {\x0d\n          ArrayPrototypePush(prev\x2C cur);\x0d\n        } else if (kind === 'key+value' && !key) {\x0d\n          ArrayPrototypePush(prev\x2C [target[searchParams][index + i - 1]\x2C cur]);\x0d\n        }\x0d\n        return prev;\x0d\n      }\x2C\x0d\n      []\x0d\n    );\x0d\n    const breakLn = inspect(output\x2C innerOpts).includes('\\n');\x0d\n    const outputStrs = ArrayPrototypeMap(output\x2C (p) => inspect(p\x2C innerOpts));\x0d\n    let outputStr;\x0d\n    if (breakLn) {\x0d\n      outputStr = `\\n  ${ArrayPrototypeJoin(outputStrs\x2C '\x2C\\n  ')}`;\x0d\n    } else {\x0d\n      outputStr = ` ${ArrayPrototypeJoin(outputStrs\x2C '\x2C ')}`;\x0d\n    }\x0d\n    return `${this[SymbolToStringTag]} {${outputStr} }`;\x0d\n  }\x0d\n});\x0d\n\x0d\nfunction domainToASCII(domain) {\x0d\n  if (arguments.length < 1)\x0d\n    throw new ERR_MISSING_ARGS('domain');\x0d\n\x0d\n  // toUSVString is not needed.\x0d\n  return _domainToASCII(`${domain}`);\x0d\n}\x0d\n\x0d\nfunction domainToUnicode(domain) {\x0d\n  if (arguments.length < 1)\x0d\n    throw new ERR_MISSING_ARGS('domain');\x0d\n\x0d\n  // toUSVString is not needed.\x0d\n  return _domainToUnicode(`${domain}`);\x0d\n}\x0d\n\x0d\n// Utility function that converts a URL object into an ordinary\x0d\n// options object as expected by the http.request and https.request\x0d\n// APIs.\x0d\nfunction urlToHttpOptions(url) {\x0d\n  const options = {\x0d\n    protocol: url.protocol\x2C\x0d\n    hostname: typeof url.hostname === 'string' &&\x0d\n              StringPrototypeStartsWith(url.hostname\x2C '[') ?\x0d\n      StringPrototypeSlice(url.hostname\x2C 1\x2C -1) :\x0d\n      url.hostname\x2C\x0d\n    hash: url.hash\x2C\x0d\n    search: url.search\x2C\x0d\n    pathname: url.pathname\x2C\x0d\n    path: `${url.pathname || ''}${url.search || ''}`\x2C\x0d\n    href: url.href\x0d\n  };\x0d\n  if (url.port !== '') {\x0d\n    options.port = Number(url.port);\x0d\n  }\x0d\n  if (url.username || url.password) {\x0d\n    options.auth = `${decodeURIComponent(url.username)}:${decodeURIComponent(url.password)}`;\x0d\n  }\x0d\n  return options;\x0d\n}\x0d\n\x0d\nconst forwardSlashRegEx = /\\//g;\x0d\n\x0d\nfunction getPathFromURLWin32(url) {\x0d\n  const hostname = url.hostname;\x0d\n  let pathname = url.pathname;\x0d\n  for (let n = 0; n < pathname.length; n++) {\x0d\n    if (pathname[n] === '%') {\x0d\n      const third = pathname.codePointAt(n + 2) | 0x20;\x0d\n      if ((pathname[n + 1] === '2' && third === 102) || // 2f 2F /\x0d\n          (pathname[n + 1] === '5' && third === 99)) {  // 5c 5C \\\x0d\n        throw new ERR_INVALID_FILE_URL_PATH(\x0d\n          'must not include encoded \\\\ or / characters'\x0d\n        );\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n  pathname = pathname.replace(forwardSlashRegEx\x2C '\\\\');\x0d\n  pathname = decodeURIComponent(pathname);\x0d\n  if (hostname !== '') {\x0d\n    // If hostname is set\x2C then we have a UNC path\x0d\n    // Pass the hostname through domainToUnicode just in case\x0d\n    // it is an IDN using punycode encoding. We do not need to worry\x0d\n    // about percent encoding because the URL parser will have\x0d\n    // already taken care of that for us. Note that this only\x0d\n    // causes IDNs with an appropriate `xn--` prefix to be decoded.\x0d\n    return `\\\\\\\\${domainToUnicode(hostname)}${pathname}`;\x0d\n  }\x0d\n  // Otherwise\x2C it's a local path that requires a drive letter\x0d\n  const letter = pathname.codePointAt(1) | 0x20;\x0d\n  const sep = pathname[2];\x0d\n  if (letter < CHAR_LOWERCASE_A || letter > CHAR_LOWERCASE_Z ||   // a..z A..Z\x0d\n      (sep !== ':')) {\x0d\n    throw new ERR_INVALID_FILE_URL_PATH('must be absolute');\x0d\n  }\x0d\n  return pathname.slice(1);\x0d\n}\x0d\n\x0d\nfunction getPathFromURLPosix(url) {\x0d\n  if (url.hostname !== '') {\x0d\n    throw new ERR_INVALID_FILE_URL_HOST(platform);\x0d\n  }\x0d\n  const pathname = url.pathname;\x0d\n  for (let n = 0; n < pathname.length; n++) {\x0d\n    if (pathname[n] === '%') {\x0d\n      const third = pathname.codePointAt(n + 2) | 0x20;\x0d\n      if (pathname[n + 1] === '2' && third === 102) {\x0d\n        throw new ERR_INVALID_FILE_URL_PATH(\x0d\n          'must not include encoded / characters'\x0d\n        );\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n  return decodeURIComponent(pathname);\x0d\n}\x0d\n\x0d\nfunction fileURLToPath(path) {\x0d\n  if (typeof path === 'string')\x0d\n    path = new URL(path);\x0d\n  else if (!isURLInstance(path))\x0d\n    throw new ERR_INVALID_ARG_TYPE('path'\x2C ['string'\x2C 'URL']\x2C path);\x0d\n  if (path.protocol !== 'file:')\x0d\n    throw new ERR_INVALID_URL_SCHEME('file');\x0d\n  return isWindows ? getPathFromURLWin32(path) : getPathFromURLPosix(path);\x0d\n}\x0d\n\x0d\n// The following characters are percent-encoded when converting from file path\x0d\n// to URL:\x0d\n// - %: The percent character is the only character not encoded by the\x0d\n//        `pathname` setter.\x0d\n// - \\: Backslash is encoded on non-windows platforms since it's a valid\x0d\n//      character but the `pathname` setters replaces it by a forward slash.\x0d\n// - LF: The newline character is stripped out by the `pathname` setter.\x0d\n//       (See whatwg/url#419)\x0d\n// - CR: The carriage return character is also stripped out by the `pathname`\x0d\n//       setter.\x0d\n// - TAB: The tab character is also stripped out by the `pathname` setter.\x0d\nconst percentRegEx = /%/g;\x0d\nconst backslashRegEx = /\\\\/g;\x0d\nconst newlineRegEx = /\\n/g;\x0d\nconst carriageReturnRegEx = /\\r/g;\x0d\nconst tabRegEx = /\\t/g;\x0d\n\x0d\nfunction encodePathChars(filepath) {\x0d\n  if (StringPrototypeIncludes(filepath\x2C '%'))\x0d\n    filepath = StringPrototypeReplace(filepath\x2C percentRegEx\x2C '%25');\x0d\n  // In posix\x2C backslash is a valid character in paths:\x0d\n  if (!isWindows && StringPrototypeIncludes(filepath\x2C '\\\\'))\x0d\n    filepath = StringPrototypeReplace(filepath\x2C backslashRegEx\x2C '%5C');\x0d\n  if (StringPrototypeIncludes(filepath\x2C '\\n'))\x0d\n    filepath = StringPrototypeReplace(filepath\x2C newlineRegEx\x2C '%0A');\x0d\n  if (StringPrototypeIncludes(filepath\x2C '\\r'))\x0d\n    filepath = StringPrototypeReplace(filepath\x2C carriageReturnRegEx\x2C '%0D');\x0d\n  if (StringPrototypeIncludes(filepath\x2C '\\t'))\x0d\n    filepath = StringPrototypeReplace(filepath\x2C tabRegEx\x2C '%09');\x0d\n  return filepath;\x0d\n}\x0d\n\x0d\nfunction pathToFileURL(filepath) {\x0d\n  const outURL = new URL('file://');\x0d\n  if (isWindows && StringPrototypeStartsWith(filepath\x2C '\\\\\\\\')) {\x0d\n    // UNC path format: \\\\server\\share\\resource\x0d\n    const paths = StringPrototypeSplit(filepath\x2C '\\\\');\x0d\n    if (paths.length <= 3) {\x0d\n      throw new ERR_INVALID_ARG_VALUE(\x0d\n        'filepath'\x2C\x0d\n        filepath\x2C\x0d\n        'Missing UNC resource path'\x0d\n      );\x0d\n    }\x0d\n    const hostname = paths[2];\x0d\n    if (hostname.length === 0) {\x0d\n      throw new ERR_INVALID_ARG_VALUE(\x0d\n        'filepath'\x2C\x0d\n        filepath\x2C\x0d\n        'Empty UNC servername'\x0d\n      );\x0d\n    }\x0d\n    outURL.hostname = domainToASCII(hostname);\x0d\n    outURL.pathname = encodePathChars(\x0d\n      ArrayPrototypeJoin(ArrayPrototypeSlice(paths\x2C 3)\x2C '/'));\x0d\n  } else {\x0d\n    let resolved = path.resolve(filepath);\x0d\n    // path.resolve strips trailing slashes so we must add them back\x0d\n    const filePathLast = StringPrototypeCharCodeAt(filepath\x2C\x0d\n                                                   filepath.length - 1);\x0d\n    if ((filePathLast === CHAR_FORWARD_SLASH ||\x0d\n         (isWindows && filePathLast === CHAR_BACKWARD_SLASH)) &&\x0d\n        resolved[resolved.length - 1] !== path.sep)\x0d\n      resolved += '/';\x0d\n    outURL.pathname = encodePathChars(resolved);\x0d\n  }\x0d\n  return outURL;\x0d\n}\x0d\n\x0d\nfunction isURLInstance(fileURLOrPath) {\x0d\n  return fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin;\x0d\n}\x0d\n\x0d\nfunction toPathIfFileURL(fileURLOrPath) {\x0d\n  if (!isURLInstance(fileURLOrPath))\x0d\n    return fileURLOrPath;\x0d\n  return fileURLToPath(fileURLOrPath);\x0d\n}\x0d\n\x0d\nfunction constructUrl(flags\x2C protocol\x2C username\x2C password\x2C\x0d\n                      host\x2C port\x2C path\x2C query\x2C fragment) {\x0d\n  const ctx = new URLContext();\x0d\n  ctx.flags = flags;\x0d\n  ctx.scheme = protocol;\x0d\n  ctx.username = (flags & URL_FLAGS_HAS_USERNAME) !== 0 ? username : '';\x0d\n  ctx.password = (flags & URL_FLAGS_HAS_PASSWORD) !== 0 ? password : '';\x0d\n  ctx.port = port;\x0d\n  ctx.path = (flags & URL_FLAGS_HAS_PATH) !== 0 ? path : [];\x0d\n  ctx.query = query;\x0d\n  ctx.fragment = fragment;\x0d\n  ctx.host = host;\x0d\n\x0d\n  const url = ObjectCreate(URL.prototype);\x0d\n  url[context] = ctx;\x0d\n  const params = new URLSearchParams();\x0d\n  url[searchParams] = params;\x0d\n  params[context] = url;\x0d\n  initSearchParams(params\x2C query);\x0d\n  return url;\x0d\n}\x0d\nsetURLConstructor(constructUrl);\x0d\n\x0d\nmodule.exports = {\x0d\n  toUSVString\x2C\x0d\n  fileURLToPath\x2C\x0d\n  pathToFileURL\x2C\x0d\n  toPathIfFileURL\x2C\x0d\n  isURLInstance\x2C\x0d\n  URL\x2C\x0d\n  URLSearchParams\x2C\x0d\n  domainToASCII\x2C\x0d\n  domainToUnicode\x2C\x0d\n  urlToHttpOptions\x2C\x0d\n  formatSymbol: kFormat\x2C\x0d\n  searchParamsSymbol: searchParams\x2C\x0d\n  encodeStr\x0d\n};\x0d\n
code-source-info,0x1c1d96c9206,39,45194,45319,C0O45215C3O45220C9O45255C11O45276C12O45280C15O45287C19O45316,,
tick,0x7ff7e82c3606,236096,0,0x0,3,0x7ff7e78fdb40,0x109c10fd747,0x109c10fd321,0x109c10fd1e3,0x109c10fd09d,0x109c10fca44,0x109c10fa8bc,0x109c10f9530,0x109c10f920a,0x109c10f83db,0x109c10f8185,0x1abee806768,0x1abee8012dd
code-creation,LazyCompile,10,236120,0x1c1d96cc526,17,isURLInstance node:internal/url:1554:23,0x14121bf9798,~
code-source-info,0x1c1d96cc526,39,45067,45166,C0O45088C3O45109C6O45134C12O45156C16O45163,,
code-creation,LazyCompile,10,236187,0x1c1d96cc686,81, node:internal/fs/utils:668:38,0x1d4982a24d0,~
code-source-info,0x1c1d96cc686,82,18830,19110,C14O18864C22O18897C25O18897C31O18924C36O18955C49O18930C54O18924C55O19023C68O19023C74O19062C76O19092C78O19092C80O19109,,
code-creation,LazyCompile,10,236259,0x1c1d96cc896,110, node:internal/fs/utils:357:35,0x1d4982a1b48,~
code-source-info,0x1c1d96cc896,82,8925,9534,C16O8990C21O9044C26O9044C31O9141C37O9164C41O9193C45O9210C51O9210C60O9262C64O9283C69O9283C76O9329C77O9336C78O9359C94O9359C100O9478C104O9501C106O9501C107O9520C109O9531,,
code-creation,LazyCompile,10,236318,0x1c1d96cca0e,16,isUint8Array node:internal/util/types:13:22,0x25ca2706f30,~
script-source,17,node:internal/util/types,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayBufferIsView\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\x0d\n} = primordials;\x0d\n\x0d\nfunction isTypedArray(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) !== undefined;\x0d\n}\x0d\n\x0d\nfunction isUint8Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8Array';\x0d\n}\x0d\n\x0d\nfunction isUint8ClampedArray(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint8ClampedArray';\x0d\n}\x0d\n\x0d\nfunction isUint16Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint16Array';\x0d\n}\x0d\n\x0d\nfunction isUint32Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Uint32Array';\x0d\n}\x0d\n\x0d\nfunction isInt8Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int8Array';\x0d\n}\x0d\n\x0d\nfunction isInt16Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int16Array';\x0d\n}\x0d\n\x0d\nfunction isInt32Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Int32Array';\x0d\n}\x0d\n\x0d\nfunction isFloat32Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float32Array';\x0d\n}\x0d\n\x0d\nfunction isFloat64Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'Float64Array';\x0d\n}\x0d\n\x0d\nfunction isBigInt64Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigInt64Array';\x0d\n}\x0d\n\x0d\nfunction isBigUint64Array(value) {\x0d\n  return TypedArrayPrototypeGetSymbolToStringTag(value) === 'BigUint64Array';\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  ...internalBinding('types')\x2C\x0d\n  isArrayBufferView: ArrayBufferIsView\x2C\x0d\n  isTypedArray\x2C\x0d\n  isUint8Array\x2C\x0d\n  isUint8ClampedArray\x2C\x0d\n  isUint16Array\x2C\x0d\n  isUint32Array\x2C\x0d\n  isInt8Array\x2C\x0d\n  isInt16Array\x2C\x0d\n  isInt32Array\x2C\x0d\n  isFloat32Array\x2C\x0d\n  isFloat64Array\x2C\x0d\n  isBigInt64Array\x2C\x0d\n  isBigUint64Array\x0d\n};\x0d\n\x0d\nlet isCryptoKey;\x0d\nlet isKeyObject;\x0d\n\x0d\nObjectDefineProperties(module.exports\x2C {\x0d\n  isKeyObject: {\x0d\n    configurable: false\x2C\x0d\n    enumerable: true\x2C\x0d\n    value(obj) {\x0d\n      if (!process.versions.openssl) {\x0d\n        return false;\x0d\n      }\x0d\n\x0d\n      if (!isKeyObject) {\x0d\n        ({ isKeyObject } = require('internal/crypto/keys'));\x0d\n      }\x0d\n\x0d\n      return isKeyObject(obj);\x0d\n    }\x0d\n  }\x2C\x0d\n  isCryptoKey: {\x0d\n    configurable: false\x2C\x0d\n    enumerable: true\x2C\x0d\n    value(obj) {\x0d\n      if (!process.versions.openssl) {\x0d\n        return false;\x0d\n      }\x0d\n\x0d\n      if (!isCryptoKey) {\x0d\n        ({ isCryptoKey } = require('internal/crypto/keys'));\x0d\n      }\x0d\n\x0d\n      return isCryptoKey(obj);\x0d\n    }\x0d\n  }\x0d\n});\x0d\n
code-source-info,0x1c1d96cca0e,17,269,356,C0O282C5O289C12O336C15O353,,
code-creation,LazyCompile,10,236510,0x1c1d96cce76,23,splitRoot node:fs:2360:33,0x1d4982991f8,~
code-source-info,0x1c1d96cce76,81,65178,65244,C0O65191C9O65218C12O65198C19O65235C22O65239,,
code-creation,LazyCompile,10,236687,0x1c1d96ccf7e,63,handleErrorFromBinding node:internal/fs/utils:340:32,0x1d4982a1af8,~
code-source-info,0x1c1d96ccf7e,82,8269,8780,C0O8288C6O8352C11O8352C16O8375C24O8375C29O8433C31O8433C32O8460C38O8692C43O8719C51O8692C56O8766C60O8756C62O8779,,
code-creation,LazyCompile,10,236758,0x1c1d96cd0f6,53,nextPart node:fs:2386:31,0x1d4982992f0,~
code-source-info,0x1c1d96cd0f6,81,65935,66186,C0O65962C4O65958C9O65995C14O65995C20O66079C22O66090C24O66086C31O66120C33O66116C38O66149C40O66158C41O65972C47O65949C50O66171C52O66181,,
code-creation,LazyCompile,10,236881,0x1c1d96cd256,34,isFileType node:fs:205:20,0x1d498296f60,~
code-source-info,0x1c1d96cd256,81,5489,5737,C0O5626C2O5631C6O5639C10O5674C15O5681C20O5698C22O5713C24O5711C30O5721C33O5734,,
code-creation,Function,11,237143,0x29be72c5240,6468,resolve node:path:158:10,0x394c9e0d510,^
code-source-info,0x29be72c5240,41,4875,9786,,,
code-creation,Function,11,237176,0x29be72c6c40,264,SafeMap node:internal/per_context/primordials:351:16,0x147335ca030,^
code-source-info,0x29be72c6c40,6,10550,10567,,,
code-creation,Function,11,237203,0x29be72c6e00,432,isWindowsDeviceRoot node:path:60:29,0x394c9e0d408,^
code-source-info,0x29be72c6e00,41,1991,2136,,,
code-creation,Function,11,237252,0x29be72c7040,2140,Module._nodeModulePaths node:internal/modules/cjs/loader:583:37,0x1abee8248d0,^
code-source-info,0x29be72c7040,103,17747,19298,,,
code-creation,Function,11,237281,0x29be72c7940,564,nextPart node:fs:2386:31,0x1d4982992f0,^
code-source-info,0x29be72c7940,81,65935,66186,,,
code-creation,LazyCompile,10,237813,0x1c1d96ce006,72,encodeRealpathResult node:fs:2373:30,0x1d4982992a0,~
code-source-info,0x1c1d96ce006,81,65524,65790,C0O65547C4O65572C10O65592C17O65601C22O65618C24O65632C25O65653C30O65660C35O65660C41O65689C48O65698C53O65719C55O65735C56O65760C61O65777C66O65760C71O65787,,
code-creation,LazyCompile,10,237896,0x1c1d96ce196,62,loadNativeModule node:internal/modules/cjs/helpers:44:26,0x1abee81e7f0,~
code-source-info,0x1c1d96ce196,102,1194,1482,C0O1231C5O1244C10O1248C15O1248C21O1266C26O1273C35O1304C43O1304C48O1432C53O1432C57O1463C59O1474C61O1481,,
code-creation,LazyCompile,10,237993,0x1c1d96ceae6,246,Module.load node:internal/modules/cjs/loader:963:33,0x1abee824c38,~
code-source-info,0x1c1d96ceae6,103,30976,31812,C0O30992C8O31038C16O30992C21O31048C26O31061C32O31048C36O31073C38O31087C42O31102C45O31122C52O31139C55O31144C60O31144C66O31122C71O31113C75O31187C78O31187C83O31266C91O31270C101O31323C106O31334C112O31349C124O31355C129O31349C130O31397C133O31404C140O31415C144O31426C150O31447C151O31459C155O31490C160O31499C165O31603C170O31640C175O31651C187O31692C192O31699C197O31699C204O31713C206O31711C211O31746C216O31755C221O31755C228O31781C233O31790C238O31790C245O31811,,
code-creation,LazyCompile,10,238128,0x1c1d96ced96,98,findLongestRegisteredExtension node:internal/modules/cjs/loader:413:40,0x1abee824150,~
code-source-info,0x1c1d96ced96,103,12225,12666,C0O12254C5O12259C10O12259C16O12286C18O12311C20O12338C22O12407C36O12360C44O12407C49O12422C51O12441C55O12451C56O12461C61O12468C63O12516C68O12535C74O12575C77O12586C84O12597C89O12617C91O12641C92O12344C95O12650C97O12663,,
code-creation,LazyCompile,10,238262,0x1c1d96cef76,415,basename node:path:749:11,0x394c9e0d7d0,~
code-source-info,0x1c1d96cef76,41,24016,26836,C0O24035C4O24065C12O24065C17O24098C25O24098C30O24145C32O24163C35O24191C37O24388C44O24395C54O24432C59O24432C65O24412C73O24480C79O24480C87O24519C89O24515C94O24540C97O24565C101O24594C107O24601C112O24612C117O24627C121O24619C126O24644C128O24652C133O24671C135O24681C136O24706C140O24713C144O24748C147O24777C151O24784C155O24791C157O24791C162O24830C167O24830C173O24875C176O24879C182O25055C186O25089C188O25099C192O25117C196O25166C198O25187C203O25356C205O25391C207O25412C211O25441C212O25452C217O25525C219O25538C222O25538C227O25534C232O25595C239O25608C244O25747C251O25915C254O25943C259O24803C264O24759C267O26024C269O26034C274O26052C281O26088C283O26096C288O26124C293O26139C307O26146C312O26185C313O26216C317O26223C321O26230C323O26230C328O26254C333O26274C336O26274C342O26258C348O26458C352O26490C354O26500C358O26516C362O26548C364O26556C369O26679C371O26710C373O26718C377O26242C382O26198C385O26746C387O26754C392O26769C394O26779C395O26785C409O26792C414O26831,,
code-creation,LazyCompile,10,238472,0x1c1d96cf476,485,Module._extensions..js node:internal/modules/cjs/loader:1106:37,0x1abee824dd8,~
code-source-info,0x1c1d96cf476,103,35658,37402,C0O35759C5O35773C10O35773C16O35793C18O35805C25O35815C34O35849C39O35862C40O35876C46O35906C51O35919C60O35919C67O35959C76O35963C83O36024C86O36024C91O36115C96O36122C103O36128C113O36135C118O36173C123O36191C128O36191C134O36230C139O36236C147O36279C152O36284C157O36296C167O36284C174O36342C179O36342C184O36384C203O36384C209O36558C212O36569C219O36575C224O36604C229O36644C235O36662C244O36662C254O36657C257O36725C261O36772C268O36807C271O36832C279O36839C283O36882C293O36839C300O36807C314O36772C321O36910C325O36969C335O36969C345O36937C352O36946C359O37033C365O37045C367O37081C376O37081C384O37127C387O37121C391O37160C403O37177C416O37186C429O37214C438O37245C443O37214C459O37269C464O37269C469O37338C471O37338C472O37371C477O37371C484O37401,,
code-creation,LazyCompile,10,238642,0x1c1d96cf8d6,376,readFileSync node:fs:450:22,0x1d498297418,~
code-source-info,0x1c1d96cf8d6,81,11832,13258,C0O11853C5O11874C10O11863C17O11919C22O11919C27O11974C35O11992C38O11995C43O12018C56O11995C62O12051C65O12051C71O12094C76O12112C79O12094C88O12128C95O12150C97O12160C99O12207C101O12254C102O12263C107O12277C112O12308C124O12317C130O12368C132O12384C133O12393C138O12419C143O12475C159O12431C165O12490C167O12497C174O12538C175O12532C182O12545C187O12407C192O12674C197O12690C207O12690C213O12716C232O12728C238O12779C239O12793C244O12811C249O12846C256O12846C263O12811C268O12884C270O12891C277O12926C278O12926C283O12571C286O12944C290O12964C295O12967C300O12967C305O12987C306O12996C311O13060C316O13076C321O13076C330O13108C332O13116C337O13147C344O13147C351O13184C357O13210C362O13227C367O13210C373O13241C375O13255,,
code-creation,LazyCompile,10,238763,0x1c1d96cfd36,30,isEncoding node:buffer:529:40,0x25ca2737010,~
code-source-info,0x1c1d96cfd36,24,15302,15437,C0O15318C6O15366C12O15373C20O15392C23O15392C28O15420C29O15434,,
code-creation,LazyCompile,10,238814,0x1c1d96cfe3e,30,normalizeEncoding node:internal/util:160:27,0x25ca2705948,~
code-source-info,0x1c1d96cfe3e,16,4365,4473,C0O4376C7O4399C14O4417C19O4430C21O4444C22O4448C25O4455C29O4470,,
code-creation,LazyCompile,10,238855,0x1c1d96cff26,9,isUint32 node:internal/validators:40:18,0x147335fcd68,~
code-source-info,0x1c1d96cff26,15,835,882,C0O848C2O872C5O861C8O879,,
code-creation,LazyCompile,10,238915,0x1c1d96d007e,113,openSync node:fs:576:18,0x1d498297600,~
code-source-info,0x1c1d96d007e,81,15029,15419,C0O15054C5O15061C11O15108C16O15108C21O15133C37O15140C44O15193C51O15195C58O15221C63O15229C70O15234C73O15245C78O15245C95O15229C101O15370C106O15370C110O15402C112O15416,,
code-creation,LazyCompile,10,238974,0x1c1d96d01fe,37, node:internal/fs/utils:680:42,0x1d4982a2520,~
code-source-info,0x1c1d96d01fe,82,19157,19296,C14O19213C19O19213C24O19248C29O19248C34O19281C36O19293,,
code-creation,LazyCompile,10,239065,0x1c1d96d05d6,515,stringToFlags node:internal/fs/utils:555:23,0x1d4982a2340,~
code-source-info,0x1c1d96d05d6,82,15623,16897,C14O15652C20O15690C25O15690C30O15723C32O15736C33O15747C38O15773C42O15789C43O15800C202O15833C206O15849C207O15901C214O15919C216O15917C219O15926C220O15944C224O15958C225O16012C232O16028C234O16026C237O16035C238O16054C245O16071C247O16069C253O16081C255O16079C258O16090C259O16142C266O16159C268O16157C274O16169C276O16167C282O16180C284O16178C287O16187C288O16207C295O16224C297O16222C303O16234C305O16232C308O16241C309O16293C316O16310C318O16308C324O16320C326O16318C332O16329C334O16327C337O16336C338O16355C345O16373C347O16371C353O16383C355O16381C358O16392C359O16444C366O16462C368O16460C374O16472C376O16470C382O16483C384O16481C387O16490C388O16542C395O16560C397O16558C403O16570C405O16568C411O16581C413O16579C416O16588C417O16608C424O16626C426O16624C432O16636C434O16634C437O16643C438O16695C445O16713C447O16711C453O16723C455O16721C461O16732C463O16730C466O16739C467O16791C474O16809C476O16807C482O16819C484O16817C490O16828C492O16826C495O16835C496O16846C509O16852C514O16846,,
code-creation,LazyCompile,10,239204,0x1c1d96d09c6,97,parseFileMode node:internal/validators:59:23,0x147335fcdb8,~
code-source-info,0x1c1d96d09c6,15,1545,1852,C0O1569C11O1587C17O1625C24O1650C27O1630C34O1677C41O1722C52O1683C57O1677C58O1745C66O1753C73O1789C89O1789C94O1836C96O1849,,
code-creation,LazyCompile,10,239277,0x1c1d96d0b96,206, node:internal/validators:84:3,0x147335fce78,~
code-source-info,0x1c1d96d0b96,15,2338,2933,C36O2481C39O2486C45O2511C51O2553C67O2559C72O2553C73O2624C78O2629C84O2664C100O2670C105O2664C106O2735C116O2774C129O2787C142O2741C147O2735C148O2814C150O2824C157O2839C162O2855C172O2894C185O2907C198O2861C203O2855C205O2932,,
code-creation,LazyCompile,10,239333,0x1c1d96d0d5e,9,isInt32 node:internal/validators:36:17,0x147335fc858,~
code-source-info,0x1c1d96d0d5e,15,769,814,C0O782C2O806C5O795C8O811,,
code-creation,LazyCompile,10,239459,0x1c1d96d0e66,66,tryStatSync node:fs:404:21,0x1d498297328,~
code-source-info,0x1c1d96d0e66,81,10761,10979,C0O10793C2O10814C7O10822C22O10822C28O10867C36O10891C38O10908C43O10911C48O10911C53O10931C58O10937C62O10931C63O10963C65O10976,,
code-creation,LazyCompile,10,239548,0x1c1d96d0fde,96,tryCreateBuffer node:fs:414:25,0x1d498297378,~
code-source-info,0x1c1d96d0fde,81,11007,11307,C0O11045C2O11058C7O11080C9O11091C11O11089C16O11114C23O11120C28O11114C29O11165C34O11181C39O11181C45O11205C57O11211C58O11240C65O11254C67O11264C72O11267C77O11267C93O11290C95O11304,,
code-creation,LazyCompile,10,239607,0x1c1d96d1136,17,allocUnsafe node:buffer:372:42,0x25ca2736b88,~
code-source-info,0x1c1d96d1136,24,11242,11300,C0O11254C5O11254C9O11275C12O11282C16O11297,,
code-creation,LazyCompile,10,239653,0x1c1d96d123e,54, node:buffer:348:36,0x25ca2736ad0,~
code-source-info,0x1c1d96d123e,24,10516,10676,C0O10531C8O10531C13O10564C14O10575C21O10591C23O10588C28O10611C33O10643C46O10617C51O10611C53O10675,,
code-creation,LazyCompile,10,239700,0x1c1d96d1366,30,validateNumber node:internal/validators:123:24,0x147335fcfb8,~
code-source-info,0x1c1d96d1366,15,3673,3785,C0O3692C6O3728C22O3734C27O3728C29O3784,,
code-creation,LazyCompile,10,239755,0x1c1d96d147e,119,allocate node:buffer:397:18,0x25ca2736cd8,~
code-source-info,0x1c1d96d147e,24,11969,12297,C0O11981C1O11990C6O12003C11O12010C16O12027C17O12036C20O12055C24O12064C27O12045C32O12079C34O12091C39O12102C41O12100C44O12088C49O12122C52O12122C55O12151C62O12166C67O12177C75O12151C81O12201C88O12215C94O12212C100O12226C103O12226C106O12244C108O12253C109O12262C114O12269C118O12294,,
code-creation,LazyCompile,10,239835,0x1c1d96d163e,86,tryReadSync node:fs:429:21,0x1d4982973c8,~
code-source-info,0x1c1d96d163e,81,11331,11576,C0O11381C2O11394C7O11419C12O11434C29O11434C35O11471C47O11477C48O11506C55O11520C57O11530C62O11533C67O11533C83O11556C85O11573,,
code-creation,LazyCompile,10,239922,0x1c1d96d1826,239,readSync node:fs:684:18,0x1d4982976d0,~
code-source-info,0x1c1d96d1826,81,17839,18811,C0O17839C2O17883C7O17888C13O17913C18O17913C22O17956C29O17963C34O18036C40O18060C52O18072C58O18088C64O18100C70O18133C75O18160C80O18189C93O18189C98O18237C105O18255C106O18266C111O18280C112O18289C113O18311C119O18322C124O18336C140O18342C145O18336C146O18468C151O18516C162O18468C167O18534C172O18561C176O18581C184O18581C189O18638C191O18660C196O18668C221O18668C227O18762C232O18762C236O18794C238O18808,,
code-creation,LazyCompile,10,240001,0x1c1d96d1a7e,52, node:internal/fs/utils:686:40,0x1d4982a2570,~
code-source-info,0x1c1d96d1a7e,82,19341,19470,C14O19371C22O19375C29O19400C30O19409C31O19420C44O19420C49O19457C51O19467,,
code-creation,LazyCompile,10,240052,0x1c1d96d1bee,51, node:internal/validators:191:40,0x147335fd1e0,~
code-source-info,0x1c1d96d1bee,15,5871,6107,C14O5905C19O5910C25O5944C30O5975C43O5950C48O5944C50O6106,,
code-creation,LazyCompile,10,240111,0x1c1d96d1d46,151, node:internal/validators:73:3,0x147335fce28,~
code-source-info,0x1c1d96d1d46,15,1900,2288,C12O1920C25O1950C32O1984C38O2022C54O2028C59O2022C60O2082C65O2087C71O2118C87O2124C92O2118C93O2178C95O2188C102O2203C107O2217C117O2256C130O2269C143O2223C148O2217C150O2287,,
code-creation,LazyCompile,10,240187,0x1c1d96d1f4e,103, node:internal/fs/utils:636:3,0x1d4982a2430,~
code-source-info,0x1c1d96d1f4e,82,17915,18305,C0O17956C1O17967C6O17981C22O17987C27O17981C28O18047C29O18058C34O18072C50O18078C55O18072C56O18138C58O18149C64O18158C69O18183C82O18273C95O18189C100O18183C102O18304,,
code-creation,LazyCompile,10,240261,0x1c1d96d2256,151, node:internal/fs/utils:886:42,0x1d4982a2890,~
code-source-info,0x1c1d96d2256,82,24872,25444,C0O24897C6O24938C14O24938C21O24987C27O25028C32O25051C35O25046C37O25043C47O25077C53O25084C56O25071C61O25100C77O25184C80O25179C98O25204C104O25211C117O25106C122O25100C125O25288C143O25294C148O25288C150O25443,,
code-creation,LazyCompile,10,240394,0x1c1d96d240e,47,closeSync node:fs:526:19,0x1d498297528,~
code-source-info,0x1c1d96d240e,81,13848,13976,C0O13858C5O13863C11O13900C13O13907C18O13915C31O13915C36O13945C41O13945C46O13975,,
code-creation,LazyCompile,10,240488,0x1c1d96d2546,162,toString node:buffer:782:46,0x25ca2738a10,~
code-source-info,0x1c1d96d2546,24,24045,24637,C0O24045C2O24087C8O24094C13O24120C20O24138C25O24120C31O24146C32O24174C37O24187C38O24197C43O24208C48O24227C50O24237C55O24250C57O24260C58O24274C65O24291C71O24320C76O24332C83O24356C90O24371C92O24379C97O24394C99O24404C100O24410C104O24455C109O24455C115O24477C116O24495C119O24495C124O24524C126O24552C133O24558C138O24552C139O24610C156O24610C161O24634,,
code-creation,LazyCompile,10,240618,0x1c1d96d2806,499,getEncodingOps node:buffer:678:24,0x25ca2738868,~
code-source-info,0x1c1d96d2806,24,20608,22457,C0O20624C10O20660C62O20690C64O20703C69O20715C74O20734C78O20739C79O20747C81O20760C86O20772C91O20791C95O20796C96O20804C101O20815C107O20860C109O20873C114O20885C119O20904C123O20909C124O20917C126O20930C131O20942C136O20961C140O20966C141O20974C143O21001C145O21014C150O21027C155O21046C159O21051C160O21059C162O21072C167O21085C172O21104C176O21110C177O21118C179O21131C184O21144C189O21163C193O21168C194O21176C199O21187C205O21232C207O21245C212O21258C217O21277C221O21282C222O21290C224O21303C229O21316C234O21335C238O21341C239O21349C241O21362C246O21375C251O21394C255O21399C256O21407C258O21434C260O21447C267O21475C270O21475C277O21512C282O21536C287O21555C291O21563C292O21571C294O21598C296O21611C303O21640C306O21640C313O21677C318O21702C323O21721C327O21729C328O21737C330O21764C332O21777C339O21802C344O21825C349O21844C353O21851C354O21859C356O21872C361O21886C366O21905C370O21912C371O21920C376O21931C382O21976C384O21989C391O22014C396O22037C401O22056C405O22063C406O22071C408O22084C413O22098C418O22117C422O22124C423O22132C425O22159C427O22172C434O22185C437O22185C444O22222C449O22242C454O22261C458O22265C459O22273C461O22300C463O22313C470O22343C473O22343C480O22380C485O22406C490O22425C494O22435C495O22443C498O22456,,
code-creation,LazyCompile,10,240766,0x1c1d96d2bee,12,slice node:buffer:593:12,0x25ca2737230,~
code-source-info,0x1c1d96d2bee,24,17194,17240,C0O17219C5O17219C11O17240,,
code-creation,LazyCompile,10,241233,0x1c1d96d35c6,499,Module._compile node:internal/modules/cjs/loader:1051:37,0x1abee824d48,~
code-source-info,0x1c1d96d35c6,103,33695,35588,C0O33724C2O33742C4O33756C11O33766C20O33785C25O33797C30O33827C35O33846C40O33855C45O33855C51O33892C56O33899C61O33908C66O33908C72O33955C86O33955C91O34028C103O34028C109O34091C111O34100C119O34104C128O34147C135O34169C141O34265C144O34277C151O34281C159O34314C162O34336C170O34361C177O34365C185O34336C193O34327C203O34562C210O34569C215O34582C221O34582C226O34569C231O34562C237O34649C242O34662C248O34734C256O34755C262O34786C264O34782C269O34809C273O34824C279O34839C285O34858C290O34886C295O34939C300O34944C305O34944C311O34982C316O34982C322O35027C324O35059C329O35089C330O35116C333O35125C339O35142C344O35149C349O35161C357O35159C363O35179C367O35208C388O35217C396O35356C401O35395C410O35434C419O35443C428O35452C437O35460C446O35470C459O35365C465O35489C469O35515C475O35526C481O35543C486O35550C490O35560C496O35571C498O35585,,
code-creation,LazyCompile,10,241410,0x1c1d96d3aee,229,maybeCacheSourceMap node:internal/source_map/source_map_cache:74:29,0x1abee81b918,~
code-source-info,0x1c1d96d3aee,100,2312,3381,C0O2382C3O2382C7O2409C10O2423C15O2427C23O2447C25O2467C26O2474C30O2489C35O2500C44O2498C54O2645C64O2655C69O2645C73O2668C74O2675C75O2698C80O2725C85O2698C91O2805C93O2836C96O2864C101O2871C106O2836C112O2907C117O2927C122O2934C127O2957C131O2989C136O3007C141O3011C148O3041C155O3073C165O3104C171O3119C175O3007C183O3250C188O3268C193O3272C201O3306C211O3337C217O3352C221O3268C228O3380,,
code-creation,LazyCompile,10,241492,0x1c1d96d454e,31,getSourceMapsEnabled node:internal/source_map/source_map_cache:43:30,0x1abee81b878,~
code-source-info,0x1c1d96d454e,100,1460,1610,C0O1468C6O1512C11O1533C17O1533C22O1512C26O1582C30O1607,,
code-creation,LazyCompile,10,241553,0x1c1d96d46c6,100,setSourceMapsEnabled node:internal/source_map/source_map_cache:50:30,0x1abee81b8c8,~
code-source-info,0x1c1d96d46c6,100,1643,2280,C0O1654C8O1654C13O1764C19O1764C24O1701C29O1728C34O1794C38O1824C42O1882C48O1882C53O1855C58O1939C64O1998C70O2161C76O2161C81O2133C86O2194C90O2253C92O2271C99O2279,,
code-creation,LazyCompile,10,241609,0x1c1d96d483e,30,validateBoolean node:internal/validators:139:25,0x147335fd058,~
code-source-info,0x1c1d96d483e,15,4199,4313,C0O4218C6O4255C22O4261C27O4255C29O4312,,
code-creation,LazyCompile,10,241704,0x1c1d96d4c36,165,wrapSafe node:internal/modules/cjs/loader:1011:18,0x1abee8243d0,~
code-source-info,0x1c1d96d4c36,103,32451,33481,C0O32451C9O32495C17O32531C22O32538C27O32538C33O32558C40O32568C45O32585C52O32603C56O32695C64O32568C70O32923C74O32943C81O32953C86O32969C98O33091C102O33108C113O32953C118O33350C130O33375C135O33387C142O33398C147O33428C157O33428C162O33463C164O33463,,
code-creation,LazyCompile,10,241893,0x1c1d96d543e,472,compileFunction node:vm:308:25,0x1d4982b4420,~
script-source,89,node:vm,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  ArrayPrototypeUnshift\x2C\x0d\n  Symbol\x2C\x0d\n  PromiseReject\x2C\x0d\n  ReflectApply\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  ContextifyScript\x2C\x0d\n  MicrotaskQueue\x2C\x0d\n  makeContext\x2C\x0d\n  isContext: _isContext\x2C\x0d\n  constants\x2C\x0d\n  compileFunction: _compileFunction\x2C\x0d\n  measureMemory: _measureMemory\x2C\x0d\n} = internalBinding('contextify');\x0d\nconst {\x0d\n  ERR_CONTEXT_NOT_INITIALIZED\x2C\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n} = require('internal/errors').codes;\x0d\nconst {\x0d\n  isArrayBufferView\x2C\x0d\n} = require('internal/util/types');\x0d\nconst {\x0d\n  validateArray\x2C\x0d\n  validateBoolean\x2C\x0d\n  validateBuffer\x2C\x0d\n  validateFunction\x2C\x0d\n  validateInt32\x2C\x0d\n  validateObject\x2C\x0d\n  validateOneOf\x2C\x0d\n  validateString\x2C\x0d\n  validateUint32\x2C\x0d\n} = require('internal/validators');\x0d\nconst {\x0d\n  kVmBreakFirstLineSymbol\x2C\x0d\n  emitExperimentalWarning\x2C\x0d\n} = require('internal/util');\x0d\nconst kParsingContext = Symbol('script parsing context');\x0d\n\x0d\nclass Script extends ContextifyScript {\x0d\n  constructor(code\x2C options = {}) {\x0d\n    code = `${code}`;\x0d\n    if (typeof options === 'string') {\x0d\n      options = { filename: options };\x0d\n    } else {\x0d\n      validateObject(options\x2C 'options');\x0d\n    }\x0d\n\x0d\n    const {\x0d\n      filename = 'evalmachine.<anonymous>'\x2C\x0d\n      lineOffset = 0\x2C\x0d\n      columnOffset = 0\x2C\x0d\n      cachedData\x2C\x0d\n      produceCachedData = false\x2C\x0d\n      importModuleDynamically\x2C\x0d\n      [kParsingContext]: parsingContext\x2C\x0d\n    } = options;\x0d\n\x0d\n    validateString(filename\x2C 'options.filename');\x0d\n    validateInt32(lineOffset\x2C 'options.lineOffset');\x0d\n    validateInt32(columnOffset\x2C 'options.columnOffset');\x0d\n    if (cachedData !== undefined && !isArrayBufferView(cachedData)) {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'options.cachedData'\x2C\x0d\n        ['Buffer'\x2C 'TypedArray'\x2C 'DataView']\x2C\x0d\n        cachedData\x0d\n      );\x0d\n    }\x0d\n    validateBoolean(produceCachedData\x2C 'options.produceCachedData');\x0d\n\x0d\n    // Calling `ReThrow()` on a native TryCatch does not generate a new\x0d\n    // abort-on-uncaught-exception check. A dummy try/catch in JS land\x0d\n    // protects against that.\x0d\n    try { // eslint-disable-line no-useless-catch\x0d\n      super(code\x2C\x0d\n            filename\x2C\x0d\n            lineOffset\x2C\x0d\n            columnOffset\x2C\x0d\n            cachedData\x2C\x0d\n            produceCachedData\x2C\x0d\n            parsingContext);\x0d\n    } catch (e) {\x0d\n      throw e; /* node-do-not-add-exception-line */\x0d\n    }\x0d\n\x0d\n    if (importModuleDynamically !== undefined) {\x0d\n      validateFunction(importModuleDynamically\x2C\x0d\n                       'options.importModuleDynamically');\x0d\n      const { importModuleDynamicallyWrap } =\x0d\n        require('internal/vm/module');\x0d\n      const { callbackMap } = internalBinding('module_wrap');\x0d\n      callbackMap.set(this\x2C {\x0d\n        importModuleDynamically:\x0d\n          importModuleDynamicallyWrap(importModuleDynamically)\x2C\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n\x0d\n  runInThisContext(options) {\x0d\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\x0d\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\x0d\n      return sigintHandlersWrap(super.runInThisContext\x2C this\x2C args);\x0d\n    }\x0d\n    return ReflectApply(super.runInThisContext\x2C this\x2C args);\x0d\n  }\x0d\n\x0d\n  runInContext(contextifiedObject\x2C options) {\x0d\n    validateContext(contextifiedObject);\x0d\n    const { breakOnSigint\x2C args } = getRunInContextArgs(options);\x0d\n    ArrayPrototypeUnshift(args\x2C contextifiedObject);\x0d\n    if (breakOnSigint && process.listenerCount('SIGINT') > 0) {\x0d\n      return sigintHandlersWrap(super.runInContext\x2C this\x2C args);\x0d\n    }\x0d\n    return ReflectApply(super.runInContext\x2C this\x2C args);\x0d\n  }\x0d\n\x0d\n  runInNewContext(contextObject\x2C options) {\x0d\n    const context = createContext(contextObject\x2C getContextOptions(options));\x0d\n    return this.runInContext(context\x2C options);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction validateContext(contextifiedObject) {\x0d\n  if (!isContext(contextifiedObject)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE('contextifiedObject'\x2C 'vm.Context'\x2C\x0d\n                                   contextifiedObject);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction getRunInContextArgs(options = {}) {\x0d\n  validateObject(options\x2C 'options');\x0d\n\x0d\n  let timeout = options.timeout;\x0d\n  if (timeout === undefined) {\x0d\n    timeout = -1;\x0d\n  } else {\x0d\n    validateUint32(timeout\x2C 'options.timeout'\x2C true);\x0d\n  }\x0d\n\x0d\n  const {\x0d\n    displayErrors = true\x2C\x0d\n    breakOnSigint = false\x2C\x0d\n    [kVmBreakFirstLineSymbol]: breakFirstLine = false\x2C\x0d\n  } = options;\x0d\n\x0d\n  validateBoolean(displayErrors\x2C 'options.displayErrors');\x0d\n  validateBoolean(breakOnSigint\x2C 'options.breakOnSigint');\x0d\n\x0d\n  return {\x0d\n    breakOnSigint\x2C\x0d\n    args: [timeout\x2C displayErrors\x2C breakOnSigint\x2C breakFirstLine]\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction getContextOptions(options) {\x0d\n  if (!options)\x0d\n    return {};\x0d\n  const contextOptions = {\x0d\n    name: options.contextName\x2C\x0d\n    origin: options.contextOrigin\x2C\x0d\n    codeGeneration: undefined\x2C\x0d\n    microtaskMode: options.microtaskMode\x2C\x0d\n  };\x0d\n  if (contextOptions.name !== undefined)\x0d\n    validateString(contextOptions.name\x2C 'options.contextName');\x0d\n  if (contextOptions.origin !== undefined)\x0d\n    validateString(contextOptions.origin\x2C 'options.contextOrigin');\x0d\n  if (options.contextCodeGeneration !== undefined) {\x0d\n    validateObject(options.contextCodeGeneration\x2C\x0d\n                   'options.contextCodeGeneration');\x0d\n    const { strings\x2C wasm } = options.contextCodeGeneration;\x0d\n    if (strings !== undefined)\x0d\n      validateBoolean(strings\x2C 'options.contextCodeGeneration.strings');\x0d\n    if (wasm !== undefined)\x0d\n      validateBoolean(wasm\x2C 'options.contextCodeGeneration.wasm');\x0d\n    contextOptions.codeGeneration = { strings\x2C wasm };\x0d\n  }\x0d\n  if (options.microtaskMode !== undefined)\x0d\n    validateString(options.microtaskMode\x2C 'options.microtaskMode');\x0d\n  return contextOptions;\x0d\n}\x0d\n\x0d\nfunction isContext(object) {\x0d\n  validateObject(object\x2C 'object'\x2C { allowArray: true });\x0d\n\x0d\n  return _isContext(object);\x0d\n}\x0d\n\x0d\nlet defaultContextNameIndex = 1;\x0d\nfunction createContext(contextObject = {}\x2C options = {}) {\x0d\n  if (isContext(contextObject)) {\x0d\n    return contextObject;\x0d\n  }\x0d\n\x0d\n  validateObject(options\x2C 'options');\x0d\n\x0d\n  const {\x0d\n    name = `VM Context ${defaultContextNameIndex++}`\x2C\x0d\n    origin\x2C\x0d\n    codeGeneration\x2C\x0d\n    microtaskMode\x0d\n  } = options;\x0d\n\x0d\n  validateString(name\x2C 'options.name');\x0d\n  if (origin !== undefined)\x0d\n    validateString(origin\x2C 'options.origin');\x0d\n  if (codeGeneration !== undefined)\x0d\n    validateObject(codeGeneration\x2C 'options.codeGeneration');\x0d\n\x0d\n  let strings = true;\x0d\n  let wasm = true;\x0d\n  if (codeGeneration !== undefined) {\x0d\n    ({ strings = true\x2C wasm = true } = codeGeneration);\x0d\n    validateBoolean(strings\x2C 'options.codeGeneration.strings');\x0d\n    validateBoolean(wasm\x2C 'options.codeGeneration.wasm');\x0d\n  }\x0d\n\x0d\n  let microtaskQueue = null;\x0d\n  if (microtaskMode !== undefined) {\x0d\n    validateOneOf(microtaskMode\x2C 'options.microtaskMode'\x2C\x0d\n                  ['afterEvaluate'\x2C undefined]);\x0d\n\x0d\n    if (microtaskMode === 'afterEvaluate')\x0d\n      microtaskQueue = new MicrotaskQueue();\x0d\n  }\x0d\n\x0d\n  makeContext(contextObject\x2C name\x2C origin\x2C strings\x2C wasm\x2C microtaskQueue);\x0d\n  return contextObject;\x0d\n}\x0d\n\x0d\nfunction createScript(code\x2C options) {\x0d\n  return new Script(code\x2C options);\x0d\n}\x0d\n\x0d\n// Remove all SIGINT listeners and re-attach them after the wrapped function\x0d\n// has executed\x2C so that caught SIGINT are handled by the listeners again.\x0d\nfunction sigintHandlersWrap(fn\x2C thisArg\x2C argsArray) {\x0d\n  const sigintListeners = process.rawListeners('SIGINT');\x0d\n\x0d\n  process.removeAllListeners('SIGINT');\x0d\n\x0d\n  try {\x0d\n    return ReflectApply(fn\x2C thisArg\x2C argsArray);\x0d\n  } finally {\x0d\n    // Add using the public methods so that the `newListener` handler of\x0d\n    // process can re-attach the listeners.\x0d\n    ArrayPrototypeForEach(sigintListeners\x2C (listener) => {\x0d\n      process.addListener('SIGINT'\x2C listener);\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction runInContext(code\x2C contextifiedObject\x2C options) {\x0d\n  validateContext(contextifiedObject);\x0d\n  if (typeof options === 'string') {\x0d\n    options = {\x0d\n      filename: options\x2C\x0d\n      [kParsingContext]: contextifiedObject\x0d\n    };\x0d\n  } else {\x0d\n    options = { ...options\x2C [kParsingContext]: contextifiedObject };\x0d\n  }\x0d\n  return createScript(code\x2C options)\x0d\n    .runInContext(contextifiedObject\x2C options);\x0d\n}\x0d\n\x0d\nfunction runInNewContext(code\x2C contextObject\x2C options) {\x0d\n  if (typeof options === 'string') {\x0d\n    options = { filename: options };\x0d\n  }\x0d\n  contextObject = createContext(contextObject\x2C getContextOptions(options));\x0d\n  options = { ...options\x2C [kParsingContext]: contextObject };\x0d\n  return createScript(code\x2C options).runInNewContext(contextObject\x2C options);\x0d\n}\x0d\n\x0d\nfunction runInThisContext(code\x2C options) {\x0d\n  if (typeof options === 'string') {\x0d\n    options = { filename: options };\x0d\n  }\x0d\n  return createScript(code\x2C options).runInThisContext(options);\x0d\n}\x0d\n\x0d\nfunction compileFunction(code\x2C params\x2C options = {}) {\x0d\n  validateString(code\x2C 'code');\x0d\n  if (params !== undefined) {\x0d\n    validateArray(params\x2C 'params');\x0d\n    ArrayPrototypeForEach(params\x2C\x0d\n                          (param\x2C i) => validateString(param\x2C `params[${i}]`));\x0d\n  }\x0d\n\x0d\n  const {\x0d\n    filename = ''\x2C\x0d\n    columnOffset = 0\x2C\x0d\n    lineOffset = 0\x2C\x0d\n    cachedData = undefined\x2C\x0d\n    produceCachedData = false\x2C\x0d\n    parsingContext = undefined\x2C\x0d\n    contextExtensions = []\x2C\x0d\n    importModuleDynamically\x2C\x0d\n  } = options;\x0d\n\x0d\n  validateString(filename\x2C 'options.filename');\x0d\n  validateUint32(columnOffset\x2C 'options.columnOffset');\x0d\n  validateUint32(lineOffset\x2C 'options.lineOffset');\x0d\n  if (cachedData !== undefined)\x0d\n    validateBuffer(cachedData\x2C 'options.cachedData');\x0d\n  validateBoolean(produceCachedData\x2C 'options.produceCachedData');\x0d\n  if (parsingContext !== undefined) {\x0d\n    if (\x0d\n      typeof parsingContext !== 'object' ||\x0d\n      parsingContext === null ||\x0d\n      !isContext(parsingContext)\x0d\n    ) {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'options.parsingContext'\x2C\x0d\n        'Context'\x2C\x0d\n        parsingContext\x0d\n      );\x0d\n    }\x0d\n  }\x0d\n  validateArray(contextExtensions\x2C 'options.contextExtensions');\x0d\n  ArrayPrototypeForEach(contextExtensions\x2C (extension\x2C i) => {\x0d\n    const name = `options.contextExtensions[${i}]`;\x0d\n    validateObject(extension\x2C name\x2C { nullable: true });\x0d\n  });\x0d\n\x0d\n  const result = _compileFunction(\x0d\n    code\x2C\x0d\n    filename\x2C\x0d\n    lineOffset\x2C\x0d\n    columnOffset\x2C\x0d\n    cachedData\x2C\x0d\n    produceCachedData\x2C\x0d\n    parsingContext\x2C\x0d\n    contextExtensions\x2C\x0d\n    params\x0d\n  );\x0d\n\x0d\n  if (produceCachedData) {\x0d\n    result.function.cachedDataProduced = result.cachedDataProduced;\x0d\n  }\x0d\n\x0d\n  if (result.cachedData) {\x0d\n    result.function.cachedData = result.cachedData;\x0d\n  }\x0d\n\x0d\n  if (importModuleDynamically !== undefined) {\x0d\n    validateFunction(importModuleDynamically\x2C\x0d\n                     'options.importModuleDynamically');\x0d\n    const { importModuleDynamicallyWrap } =\x0d\n      require('internal/vm/module');\x0d\n    const { callbackMap } = internalBinding('module_wrap');\x0d\n    const wrapped = importModuleDynamicallyWrap(importModuleDynamically);\x0d\n    const func = result.function;\x0d\n    callbackMap.set(result.cacheKey\x2C {\x0d\n      importModuleDynamically: (s\x2C _k\x2C i) => wrapped(s\x2C func\x2C i)\x2C\x0d\n    });\x0d\n  }\x0d\n\x0d\n  return result.function;\x0d\n}\x0d\n\x0d\nconst measureMemoryModes = {\x0d\n  summary: constants.measureMemory.mode.SUMMARY\x2C\x0d\n  detailed: constants.measureMemory.mode.DETAILED\x2C\x0d\n};\x0d\n\x0d\nconst measureMemoryExecutions = {\x0d\n  default: constants.measureMemory.execution.DEFAULT\x2C\x0d\n  eager: constants.measureMemory.execution.EAGER\x2C\x0d\n};\x0d\n\x0d\nfunction measureMemory(options = {}) {\x0d\n  emitExperimentalWarning('vm.measureMemory');\x0d\n  validateObject(options\x2C 'options');\x0d\n  const { mode = 'summary'\x2C execution = 'default' } = options;\x0d\n  validateOneOf(mode\x2C 'options.mode'\x2C ['summary'\x2C 'detailed']);\x0d\n  validateOneOf(execution\x2C 'options.execution'\x2C ['default'\x2C 'eager']);\x0d\n  const result = _measureMemory(measureMemoryModes[mode]\x2C\x0d\n                                measureMemoryExecutions[execution]);\x0d\n  if (result === undefined) {\x0d\n    return PromiseReject(new ERR_CONTEXT_NOT_INITIALIZED());\x0d\n  }\x0d\n  return result;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  Script\x2C\x0d\n  createContext\x2C\x0d\n  createScript\x2C\x0d\n  runInContext\x2C\x0d\n  runInNewContext\x2C\x0d\n  runInThisContext\x2C\x0d\n  isContext\x2C\x0d\n  compileFunction\x2C\x0d\n  measureMemory\x2C\x0d\n};\x0d\n\x0d\n// The vm module is patched to include vm.Module\x2C vm.SourceTextModule\x0d\n// and vm.SyntheticModule in the pre-execution phase when\x0d\n// --experimental-vm-modules is on.\x0d\n
code-source-info,0x1c1d96d543e,89,9869,12202,C10O9869C16O9903C25O9903C30O9936C34O9969C43O9969C48O10007C53O10029C59O10007C64O10141C76O10161C84O10184C92O10205C100O10234C108O10266C116O10299C125O10328C130O10374C139O10374C144O10423C153O10423C158O10480C167O10480C172O10533C176O10568C185O10568C190O10621C199O10621C204O10689C208O10730C221O10822C227O10864C244O10870C249O10864C250O11000C259O11000C264O11066C269O11088C275O11066C280O11265C312O11265C318O11454C322O11491C327O11528C331O11519C335O11569C341O11595C346O11624C350O11615C354O11646C358O11674C368O11696C379O11696C384O11848C393O11848C398O11809C403O11908C412O11908C417O11892C422O11961C426O11961C428O12040C432O12033C434O12067C439O12078C451O12122C459O12067C467O12190C471O12199,,
code-creation,LazyCompile,10,242636,0x1c1d96d6606,95, node:internal/validators:168:39,0x147335fd118,~
code-source-info,0x1c1d96d6606,15,5152,5438,C16O5189C21O5194C27O5222C43O5228C48O5222C49O5294C56O5301C61O5336C66O5359C71O5377C87O5383C92O5377C94O5437,,
code-creation,LazyCompile,10,242687,0x1c1d96d6766,27, node:vm:313:27,0x1c1d96d5110,~
code-source-info,0x1c1d96d6766,89,10064,10115,C0O10078C10O10110C21O10078C26O10115,,
code-creation,LazyCompile,10,242749,0x1c1d96d68f6,149, node:internal/validators:101:40,0x147335fcec8,~
code-source-info,0x1c1d96d68f6,15,2980,3505,C0O3012C3O3017C9O3041C15O3081C31O3087C36O3081C37O3148C42O3153C48O3186C64O3192C69O3186C70O3265C80O3319C90O3358C109O3325C114O3319C115O3397C120O3419C125O3433C141O3439C146O3433C148O3504,,
code-creation,Eval,10,242824,0x1c1d96d6c36,5, C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\no-cluster.js:1:1,0x1c1d96d6af0,~
script-source,126,C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\no-cluster.js,const cluster = require('cluster')\n\ncluster.on('fork'\x2C () => {\n  throw new Error('0x does not support clustering.')\n})\n
code-source-info,0x1c1d96d6c36,126,0,119,C0O0C4O119,,
code-creation,Function,10,242865,0x1c1d96d6d1e,29, C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\no-cluster.js:1:1,0x1c1d96d6bb0,~
code-source-info,0x1c1d96d6d1e,126,0,119,C0O16C3O16C8O44C21O44C28O118,,
code-creation,LazyCompile,10,242968,0x1c1d96d6f96,19,importModuleDynamicallyWrap node:internal/vm/module:435:37,0x109c10ef390,~
code-source-info,0x1c1d96d6f96,124,12139,12597,C0O12139C13O12209C18O12594,,
code-creation,LazyCompile,10,243060,0x1c1d96d816e,159,makeRequireFunction node:internal/modules/cjs/helpers:58:29,0x1abee81e840,~
code-source-info,0x1c1d96d816e,102,1765,3805,C0O1765C22O1802C25O1806C29O1802C31O1828C33O1840C53O1873C58O1877C69O1893C73O1873C75O1921C81O1921C83O1949C89O1958C95O1987C104O3182C109O3423C111O3439C115O3586C117O3600C121O3614C126O3637C130O3627C134O3705C137O3733C141O3724C145O3751C148O3774C152O3765C156O3787C158O3802,,
code-creation,LazyCompile,10,243141,0x1c1d96d84fe,14,require node:internal/modules/cjs/helpers:101:31,0x1c1d96d8040,~
code-source-info,0x1c1d96d84fe,102,3208,3256,C0O3224C3O3235C8O3235C13O3249,,
code-creation,LazyCompile,10,243192,0x1c1d96d8646,10, node:internal/modules/cjs/helpers:29:66,0x1abee81ea10,~
code-source-info,0x1c1d96d8646,102,838,865,C0O851C2O857C9O864,,
code-creation,LazyCompile,10,243252,0x1c1d96d87be,129,compileForPublicLoader node:internal/bootstrap/loaders:246:25,0x147335cfc78,~
code-source-info,0x1c1d96d87be,9,7789,8477,C0O7809C6O7956C16O7999C33O7962C38O7956C39O8038C44O8038C48O8081C54O8273C61O8304C69O8273C75O8329C80O8347C90O8363C93O8379C98O8363C102O8345C106O8406C111O8406C115O8432C120O8432C124O8464C128O8472,,
code-creation,Eval,10,243345,0x1c1d96d8b1e,5, node:cluster:1:1,0x1c1d96d89d8,~
script-source,127,node:cluster,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst childOrPrimary = 'NODE_UNIQUE_ID' in process.env ? 'child' : 'primary';\x0d\nmodule.exports = require(`internal/cluster/${childOrPrimary}`);\x0d\n
code-source-info,0x1c1d96d8b1e,127,0,1316,C0O0C4O1316,,
code-creation,Function,10,243434,0x1c1d96d8bc6,39, node:cluster:1:1,0x1c1d96d8a98,~
code-source-info,0x1c1d96d8bc6,127,0,1316,C0O1195C3O1223C7O1212C19O1251C24O1296C29O1268C33O1266C38O1315,,
code-creation,Eval,10,243780,0x1c1d96d9816,5, node:internal/cluster/primary:1:1,0x1c1d96d9490,~
script-source,128,node:internal/cluster/primary,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  ArrayPrototypeSome\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ObjectValues\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeMap\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst assert = require('internal/assert');\x0d\nconst { fork } = require('child_process');\x0d\nconst path = require('path');\x0d\nconst EventEmitter = require('events');\x0d\nconst RoundRobinHandle = require('internal/cluster/round_robin_handle');\x0d\nconst SharedHandle = require('internal/cluster/shared_handle');\x0d\nconst Worker = require('internal/cluster/worker');\x0d\nconst { internal\x2C sendHelper } = require('internal/cluster/utils');\x0d\nconst cluster = new EventEmitter();\x0d\nconst intercom = new EventEmitter();\x0d\nconst SCHED_NONE = 1;\x0d\nconst SCHED_RR = 2;\x0d\nconst minPort = 1024;\x0d\nconst maxPort = 65535;\x0d\nconst { validatePort } = require('internal/validators');\x0d\n\x0d\nmodule.exports = cluster;\x0d\n\x0d\nconst handles = new SafeMap();\x0d\ncluster.isWorker = false;\x0d\ncluster.isMaster = true; // Deprecated alias. Must be same as isPrimary.\x0d\ncluster.isPrimary = true;\x0d\ncluster.Worker = Worker;\x0d\ncluster.workers = {};\x0d\ncluster.settings = {};\x0d\ncluster.SCHED_NONE = SCHED_NONE;  // Leave it to the operating system.\x0d\ncluster.SCHED_RR = SCHED_RR;      // Primary distributes connections.\x0d\n\x0d\nlet ids = 0;\x0d\nlet debugPortOffset = 1;\x0d\nlet initialized = false;\x0d\n\x0d\n// XXX(bnoordhuis) Fold cluster.schedulingPolicy into cluster.settings?\x0d\nlet schedulingPolicy = process.env.NODE_CLUSTER_SCHED_POLICY;\x0d\nif (schedulingPolicy === 'rr')\x0d\n  schedulingPolicy = SCHED_RR;\x0d\nelse if (schedulingPolicy === 'none')\x0d\n  schedulingPolicy = SCHED_NONE;\x0d\nelse if (process.platform === 'win32') {\x0d\n  // Round-robin doesn't perform well on\x0d\n  // Windows due to the way IOCP is wired up.\x0d\n  schedulingPolicy = SCHED_NONE;\x0d\n} else\x0d\n  schedulingPolicy = SCHED_RR;\x0d\n\x0d\ncluster.schedulingPolicy = schedulingPolicy;\x0d\n\x0d\ncluster.setupPrimary = function(options) {\x0d\n  const settings = {\x0d\n    args: ArrayPrototypeSlice(process.argv\x2C 2)\x2C\x0d\n    exec: process.argv[1]\x2C\x0d\n    execArgv: process.execArgv\x2C\x0d\n    silent: false\x2C\x0d\n    ...cluster.settings\x2C\x0d\n    ...options\x0d\n  };\x0d\n\x0d\n  // Tell V8 to write profile data for each process to a separate file.\x0d\n  // Without --logfile=v8-%p.log\x2C everything ends up in a single\x2C unusable\x0d\n  // file. (Unusable because what V8 logs are memory addresses and each\x0d\n  // process has its own memory mappings.)\x0d\n  if (ArrayPrototypeSome(settings.execArgv\x2C\x0d\n                         (s) => StringPrototypeStartsWith(s\x2C '--prof')) &&\x0d\n      !ArrayPrototypeSome(settings.execArgv\x2C\x0d\n                          (s) => StringPrototypeStartsWith(s\x2C '--logfile='))) {\x0d\n    settings.execArgv = [...settings.execArgv\x2C '--logfile=v8-%p.log'];\x0d\n  }\x0d\n\x0d\n  cluster.settings = settings;\x0d\n\x0d\n  if (initialized === true)\x0d\n    return process.nextTick(setupSettingsNT\x2C settings);\x0d\n\x0d\n  initialized = true;\x0d\n  schedulingPolicy = cluster.schedulingPolicy;  // Freeze policy.\x0d\n  assert(schedulingPolicy === SCHED_NONE || schedulingPolicy === SCHED_RR\x2C\x0d\n         `Bad cluster.schedulingPolicy: ${schedulingPolicy}`);\x0d\n\x0d\n  process.nextTick(setupSettingsNT\x2C settings);\x0d\n\x0d\n  process.on('internalMessage'\x2C (message) => {\x0d\n    if (message.cmd !== 'NODE_DEBUG_ENABLED')\x0d\n      return;\x0d\n\x0d\n    for (const worker of ObjectValues(cluster.workers)) {\x0d\n      if (worker.state === 'online' || worker.state === 'listening') {\x0d\n        process._debugProcess(worker.process.pid);\x0d\n      } else {\x0d\n        worker.once('online'\x2C function() {\x0d\n          process._debugProcess(this.process.pid);\x0d\n        });\x0d\n      }\x0d\n    }\x0d\n  });\x0d\n};\x0d\n\x0d\n// Deprecated alias must be same as setupPrimary\x0d\ncluster.setupMaster = cluster.setupPrimary;\x0d\n\x0d\nfunction setupSettingsNT(settings) {\x0d\n  cluster.emit('setup'\x2C settings);\x0d\n}\x0d\n\x0d\nfunction createWorkerProcess(id\x2C env) {\x0d\n  const workerEnv = { ...process.env\x2C ...env\x2C NODE_UNIQUE_ID: `${id}` };\x0d\n  const execArgv = [...cluster.settings.execArgv];\x0d\n  const debugArgRegex = /--inspect(?:-brk|-port)?|--debug-port/;\x0d\n  const nodeOptions = process.env.NODE_OPTIONS || '';\x0d\n\x0d\n  if (ArrayPrototypeSome(execArgv\x2C\x0d\n                         (arg) => RegExpPrototypeTest(debugArgRegex\x2C arg)) ||\x0d\n      RegExpPrototypeTest(debugArgRegex\x2C nodeOptions)) {\x0d\n    let inspectPort;\x0d\n    if ('inspectPort' in cluster.settings) {\x0d\n      if (typeof cluster.settings.inspectPort === 'function')\x0d\n        inspectPort = cluster.settings.inspectPort();\x0d\n      else\x0d\n        inspectPort = cluster.settings.inspectPort;\x0d\n\x0d\n      validatePort(inspectPort);\x0d\n    } else {\x0d\n      inspectPort = process.debugPort + debugPortOffset;\x0d\n      if (inspectPort > maxPort)\x0d\n        inspectPort = inspectPort - maxPort + minPort - 1;\x0d\n      debugPortOffset++;\x0d\n    }\x0d\n\x0d\n    ArrayPrototypePush(execArgv\x2C `--inspect-port=${inspectPort}`);\x0d\n  }\x0d\n\x0d\n  return fork(cluster.settings.exec\x2C cluster.settings.args\x2C {\x0d\n    cwd: cluster.settings.cwd\x2C\x0d\n    env: workerEnv\x2C\x0d\n    serialization: cluster.settings.serialization\x2C\x0d\n    silent: cluster.settings.silent\x2C\x0d\n    windowsHide: cluster.settings.windowsHide\x2C\x0d\n    execArgv: execArgv\x2C\x0d\n    stdio: cluster.settings.stdio\x2C\x0d\n    gid: cluster.settings.gid\x2C\x0d\n    uid: cluster.settings.uid\x0d\n  });\x0d\n}\x0d\n\x0d\nfunction removeWorker(worker) {\x0d\n  assert(worker);\x0d\n  delete cluster.workers[worker.id];\x0d\n\x0d\n  if (ObjectKeys(cluster.workers).length === 0) {\x0d\n    assert(handles.size === 0\x2C 'Resource leak detected.');\x0d\n    intercom.emit('disconnect');\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction removeHandlesForWorker(worker) {\x0d\n  assert(worker);\x0d\n\x0d\n  handles.forEach((handle\x2C key) => {\x0d\n    if (handle.remove(worker))\x0d\n      handles.delete(key);\x0d\n  });\x0d\n}\x0d\n\x0d\ncluster.fork = function(env) {\x0d\n  cluster.setupPrimary();\x0d\n  const id = ++ids;\x0d\n  const workerProcess = createWorkerProcess(id\x2C env);\x0d\n  const worker = new Worker({\x0d\n    id: id\x2C\x0d\n    process: workerProcess\x0d\n  });\x0d\n\x0d\n  worker.on('message'\x2C function(message\x2C handle) {\x0d\n    cluster.emit('message'\x2C this\x2C message\x2C handle);\x0d\n  });\x0d\n\x0d\n  worker.process.once('exit'\x2C (exitCode\x2C signalCode) => {\x0d\n    /*\x0d\n     * Remove the worker from the workers list only\x0d\n     * if it has disconnected\x2C otherwise we might\x0d\n     * still want to access it.\x0d\n     */\x0d\n    if (!worker.isConnected()) {\x0d\n      removeHandlesForWorker(worker);\x0d\n      removeWorker(worker);\x0d\n    }\x0d\n\x0d\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\x0d\n    worker.state = 'dead';\x0d\n    worker.emit('exit'\x2C exitCode\x2C signalCode);\x0d\n    cluster.emit('exit'\x2C worker\x2C exitCode\x2C signalCode);\x0d\n  });\x0d\n\x0d\n  worker.process.once('disconnect'\x2C () => {\x0d\n    /*\x0d\n     * Now is a good time to remove the handles\x0d\n     * associated with this worker because it is\x0d\n     * not connected to the primary anymore.\x0d\n     */\x0d\n    removeHandlesForWorker(worker);\x0d\n\x0d\n    /*\x0d\n     * Remove the worker from the workers list only\x0d\n     * if its process has exited. Otherwise\x2C we might\x0d\n     * still want to access it.\x0d\n     */\x0d\n    if (worker.isDead())\x0d\n      removeWorker(worker);\x0d\n\x0d\n    worker.exitedAfterDisconnect = !!worker.exitedAfterDisconnect;\x0d\n    worker.state = 'disconnected';\x0d\n    worker.emit('disconnect');\x0d\n    cluster.emit('disconnect'\x2C worker);\x0d\n  });\x0d\n\x0d\n  worker.process.on('internalMessage'\x2C internal(worker\x2C onmessage));\x0d\n  process.nextTick(emitForkNT\x2C worker);\x0d\n  cluster.workers[worker.id] = worker;\x0d\n  return worker;\x0d\n};\x0d\n\x0d\nfunction emitForkNT(worker) {\x0d\n  cluster.emit('fork'\x2C worker);\x0d\n}\x0d\n\x0d\ncluster.disconnect = function(cb) {\x0d\n  const workers = ObjectKeys(cluster.workers);\x0d\n\x0d\n  if (workers.length === 0) {\x0d\n    process.nextTick(() => intercom.emit('disconnect'));\x0d\n  } else {\x0d\n    for (const worker of ObjectValues(cluster.workers)) {\x0d\n      if (worker.isConnected()) {\x0d\n        worker.disconnect();\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (typeof cb === 'function')\x0d\n    intercom.once('disconnect'\x2C cb);\x0d\n};\x0d\n\x0d\nconst methodMessageMapping = {\x0d\n  close\x2C\x0d\n  exitedAfterDisconnect\x2C\x0d\n  listening\x2C\x0d\n  online\x2C\x0d\n  queryServer\x2C\x0d\n};\x0d\n\x0d\nfunction onmessage(message\x2C handle) {\x0d\n  const worker = this;\x0d\n\x0d\n  const fn = methodMessageMapping[message.act];\x0d\n\x0d\n  if (typeof fn === 'function')\x0d\n    fn(worker\x2C message);\x0d\n}\x0d\n\x0d\nfunction online(worker) {\x0d\n  worker.state = 'online';\x0d\n  worker.emit('online');\x0d\n  cluster.emit('online'\x2C worker);\x0d\n}\x0d\n\x0d\nfunction exitedAfterDisconnect(worker\x2C message) {\x0d\n  worker.exitedAfterDisconnect = true;\x0d\n  send(worker\x2C { ack: message.seq });\x0d\n}\x0d\n\x0d\nfunction queryServer(worker\x2C message) {\x0d\n  // Stop processing if worker already disconnecting\x0d\n  if (worker.exitedAfterDisconnect)\x0d\n    return;\x0d\n\x0d\n  const key = `${message.address}:${message.port}:${message.addressType}:` +\x0d\n              `${message.fd}:${message.index}`;\x0d\n  let handle = handles.get(key);\x0d\n\x0d\n  if (handle === undefined) {\x0d\n    let address = message.address;\x0d\n\x0d\n    // Find shortest path for unix sockets because of the ~100 byte limit\x0d\n    if (message.port < 0 && typeof address === 'string' &&\x0d\n        process.platform !== 'win32') {\x0d\n\x0d\n      address = path.relative(process.cwd()\x2C address);\x0d\n\x0d\n      if (message.address.length < address.length)\x0d\n        address = message.address;\x0d\n    }\x0d\n\x0d\n    // UDP is exempt from round-robin connection balancing for what should\x0d\n    // be obvious reasons: it's connectionless. There is nothing to send to\x0d\n    // the workers except raw datagrams and that's pointless.\x0d\n    if (schedulingPolicy !== SCHED_RR ||\x0d\n        message.addressType === 'udp4' ||\x0d\n        message.addressType === 'udp6') {\x0d\n      handle = new SharedHandle(key\x2C address\x2C message);\x0d\n    } else {\x0d\n      handle = new RoundRobinHandle(key\x2C address\x2C message);\x0d\n    }\x0d\n\x0d\n    handles.set(key\x2C handle);\x0d\n  }\x0d\n\x0d\n  if (!handle.data)\x0d\n    handle.data = message.data;\x0d\n\x0d\n  // Set custom server data\x0d\n  handle.add(worker\x2C (errno\x2C reply\x2C handle) => {\x0d\n    const { data } = handles.get(key);\x0d\n\x0d\n    if (errno)\x0d\n      handles.delete(key);  // Gives other workers a chance to retry.\x0d\n\x0d\n    send(worker\x2C {\x0d\n      errno\x2C\x0d\n      key\x2C\x0d\n      ack: message.seq\x2C\x0d\n      data\x2C\x0d\n      ...reply\x0d\n    }\x2C handle);\x0d\n  });\x0d\n}\x0d\n\x0d\nfunction listening(worker\x2C message) {\x0d\n  const info = {\x0d\n    addressType: message.addressType\x2C\x0d\n    address: message.address\x2C\x0d\n    port: message.port\x2C\x0d\n    fd: message.fd\x0d\n  };\x0d\n\x0d\n  worker.state = 'listening';\x0d\n  worker.emit('listening'\x2C info);\x0d\n  cluster.emit('listening'\x2C worker\x2C info);\x0d\n}\x0d\n\x0d\n// Server in worker is closing\x2C remove from list. The handle may have been\x0d\n// removed by a prior call to removeHandlesForWorker() so guard against that.\x0d\nfunction close(worker\x2C message) {\x0d\n  const key = message.key;\x0d\n  const handle = handles.get(key);\x0d\n\x0d\n  if (handle && handle.remove(worker))\x0d\n    handles.delete(key);\x0d\n}\x0d\n\x0d\nfunction send(worker\x2C message\x2C handle\x2C cb) {\x0d\n  return sendHelper(worker.process\x2C message\x2C handle\x2C cb);\x0d\n}\x0d\n\x0d\n// Extend generic Worker with methods specific to the primary process.\x0d\nWorker.prototype.disconnect = function() {\x0d\n  this.exitedAfterDisconnect = true;\x0d\n  send(this\x2C { act: 'disconnect' });\x0d\n  removeHandlesForWorker(this);\x0d\n  removeWorker(this);\x0d\n  return this;\x0d\n};\x0d\n\x0d\nWorker.prototype.destroy = function(signo) {\x0d\n  const proc = this.process;\x0d\n\x0d\n  signo = signo || 'SIGTERM';\x0d\n\x0d\n  if (this.isConnected()) {\x0d\n    this.once('disconnect'\x2C () => proc.kill(signo));\x0d\n    this.disconnect();\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  proc.kill(signo);\x0d\n};\x0d\n
code-source-info,0x1c1d96d9816,128,0,11181,C0O0C4O11181,,
code-creation,Function,10,244375,0x1c1d96da1de,640, node:internal/cluster/primary:1:1,0x1c1d96d9790,~
code-source-info,0x1c1d96da1de,128,0,11181,C0O0C160O28C166O51C172O75C178O98C184O113C190O130C196O154C201O166C207O229C210O229C214O229C216O275C219O275C224O266C230O315C233O315C237O315C239O354C242O354C247O399C250O399C254O399C256O469C259O469C263O469C265O528C268O528C272O528C274O598C277O598C282O573C288O583C294O650C296O650C301O650C303O688C305O688C310O688C312O728C314O728C316O749C318O749C320O769C324O769C326O792C332O792C334O825C337O825C342O808C348O860C350O875C354O905C356O905C361O905C363O921C367O938C371O948C375O965C379O1022C383O1040C387O1049C392O1064C396O1075C400O1091C404O1098C408O1115C412O1122C417O1141C421O1194C426O1211C430O1277C431O1277C433O1303C435O1303C437O1325C438O1325C440O1431C443O1439C448O1443C452O1431C454O1471C459O1492C464O1505C466O1522C470O1540C475O1561C480O1576C482O1593C486O1613C489O1625C496O1634C501O1741C503O1758C507O1783C509O1800C511O1815C516O1840C520O1863C527O1884C531O3605C537O3635C541O3625C545O5568C552O5581C556O7323C563O7342C567O7764C574O7769C580O7779C586O7805C592O7819C598O7830C604O7764C606O10720C609O10727C618O10748C622O10918C625O10925C634O10943C639O11180,,
code-creation,Eval,10,245035,0x1c1d96dc09e,5, node:child_process:1:1,0x1c1d96dbbc8,~
script-source,129,node:child_process,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeFilter\x2C\x0d\n  ArrayPrototypeIncludes\x2C\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypeLastIndexOf\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  ArrayPrototypeSort\x2C\x0d\n  ArrayPrototypeSplice\x2C\x0d\n  ArrayPrototypeUnshift\x2C\x0d\n  Error\x2C\x0d\n  NumberIsInteger\x2C\x0d\n  ObjectAssign\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeSet\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeToUpperCase\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  promisify\x2C\x0d\n  convertToValidSignal\x2C\x0d\n  createDeferredPromise\x2C\x0d\n  getSystemErrorName\x0d\n} = require('internal/util');\x0d\nconst { isArrayBufferView } = require('internal/util/types');\x0d\nlet debug = require('internal/util/debuglog').debuglog(\x0d\n  'child_process'\x2C\x0d\n  (fn) => {\x0d\n    debug = fn;\x0d\n  }\x0d\n);\x0d\nconst { Buffer } = require('buffer');\x0d\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\x0d\n\x0d\nconst {\x0d\n  AbortError\x2C\x0d\n  codes: errorCodes\x2C\x0d\n} = require('internal/errors');\x0d\nconst {\x0d\n  ERR_INVALID_ARG_VALUE\x2C\x0d\n  ERR_CHILD_PROCESS_IPC_REQUIRED\x2C\x0d\n  ERR_CHILD_PROCESS_STDIO_MAXBUFFER\x2C\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n  ERR_OUT_OF_RANGE\x2C\x0d\n} = errorCodes;\x0d\nconst { clearTimeout\x2C setTimeout } = require('timers');\x0d\nconst { getValidatedPath } = require('internal/fs/utils');\x0d\nconst {\x0d\n  isInt32\x2C\x0d\n  validateAbortSignal\x2C\x0d\n  validateBoolean\x2C\x0d\n  validateObject\x2C\x0d\n  validateString\x2C\x0d\n} = require('internal/validators');\x0d\nconst child_process = require('internal/child_process');\x0d\nconst {\x0d\n  getValidStdio\x2C\x0d\n  setupChannel\x2C\x0d\n  ChildProcess\x2C\x0d\n  stdioStringToArray\x0d\n} = child_process;\x0d\n\x0d\nconst MAX_BUFFER = 1024 * 1024;\x0d\n\x0d\n/**\x0d\n * Spawns a new Node.js process + fork.\x0d\n * @param {string|URL} modulePath\x0d\n * @param {string[]} [args]\x0d\n * @param {{\x0d\n *   cwd?: string;\x0d\n *   detached?: boolean;\x0d\n *   env?: Object;\x0d\n *   execPath?: string;\x0d\n *   execArgv?: string[];\x0d\n *   gid?: number;\x0d\n *   serialization?: string;\x0d\n *   signal?: AbortSignal;\x0d\n *   killSignal?: string | number;\x0d\n *   silent?: boolean;\x0d\n *   stdio?: Array | string;\x0d\n *   uid?: number;\x0d\n *   windowsVerbatimArguments?: boolean;\x0d\n *   timeout?: number;\x0d\n *   }} [options]\x0d\n * @returns {ChildProcess}\x0d\n */\x0d\nfunction fork(modulePath\x2C args = []\x2C options) {\x0d\n  modulePath = getValidatedPath(modulePath\x2C 'modulePath');\x0d\n\x0d\n  // Get options and args arguments.\x0d\n  let execArgv;\x0d\n\x0d\n  if (args == null) {\x0d\n    args = [];\x0d\n  } else if (typeof args !== 'object') {\x0d\n    throw new ERR_INVALID_ARG_VALUE('args'\x2C args);\x0d\n  } else if (!ArrayIsArray(args)) {\x0d\n    options = args;\x0d\n    args = [];\x0d\n  }\x0d\n\x0d\n  if (options == null) {\x0d\n    options = {};\x0d\n  } else if (typeof options !== 'object') {\x0d\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\x0d\n  } else {\x0d\n    options = { ...options };\x0d\n  }\x0d\n\x0d\n  // Prepare arguments for fork:\x0d\n  execArgv = options.execArgv || process.execArgv;\x0d\n\x0d\n  if (execArgv === process.execArgv && process._eval != null) {\x0d\n    const index = ArrayPrototypeLastIndexOf(execArgv\x2C process._eval);\x0d\n    if (index > 0) {\x0d\n      // Remove the -e switch to avoid fork bombing ourselves.\x0d\n      execArgv = ArrayPrototypeSlice(execArgv);\x0d\n      ArrayPrototypeSplice(execArgv\x2C index - 1\x2C 2);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  args = [...execArgv\x2C modulePath\x2C ...args];\x0d\n\x0d\n  if (typeof options.stdio === 'string') {\x0d\n    options.stdio = stdioStringToArray(options.stdio\x2C 'ipc');\x0d\n  } else if (!ArrayIsArray(options.stdio)) {\x0d\n    // Use a separate fd=3 for the IPC channel. Inherit stdin\x2C stdout\x2C\x0d\n    // and stderr from the parent if silent isn't set.\x0d\n    options.stdio = stdioStringToArray(\x0d\n      options.silent ? 'pipe' : 'inherit'\x2C\x0d\n      'ipc');\x0d\n  } else if (!ArrayPrototypeIncludes(options.stdio\x2C 'ipc')) {\x0d\n    throw new ERR_CHILD_PROCESS_IPC_REQUIRED('options.stdio');\x0d\n  }\x0d\n\x0d\n  options.execPath = options.execPath || process.execPath;\x0d\n  options.shell = false;\x0d\n\x0d\n  return spawn(options.execPath\x2C args\x2C options);\x0d\n}\x0d\n\x0d\nfunction _forkChild(fd\x2C serializationMode) {\x0d\n  // set process.send()\x0d\n  const p = new Pipe(PipeConstants.IPC);\x0d\n  p.open(fd);\x0d\n  p.unref();\x0d\n  const control = setupChannel(process\x2C p\x2C serializationMode);\x0d\n  process.on('newListener'\x2C function onNewListener(name) {\x0d\n    if (name === 'message' || name === 'disconnect') control.refCounted();\x0d\n  });\x0d\n  process.on('removeListener'\x2C function onRemoveListener(name) {\x0d\n    if (name === 'message' || name === 'disconnect') control.unrefCounted();\x0d\n  });\x0d\n}\x0d\n\x0d\nfunction normalizeExecArgs(command\x2C options\x2C callback) {\x0d\n  if (typeof options === 'function') {\x0d\n    callback = options;\x0d\n    options = undefined;\x0d\n  }\x0d\n\x0d\n  // Make a shallow copy so we don't clobber the user's options object.\x0d\n  options = { ...options };\x0d\n  options.shell = typeof options.shell === 'string' ? options.shell : true;\x0d\n\x0d\n  return {\x0d\n    file: command\x2C\x0d\n    options: options\x2C\x0d\n    callback: callback\x0d\n  };\x0d\n}\x0d\n\x0d\n/**\x0d\n * Spawns a shell executing the given command.\x0d\n * @param {string} command\x0d\n * @param {{\x0d\n *   cmd?: string;\x0d\n *   env?: Object;\x0d\n *   encoding?: string;\x0d\n *   shell?: string;\x0d\n *   signal?: AbortSignal;\x0d\n *   timeout?: number;\x0d\n *   maxBuffer?: number;\x0d\n *   killSignal?: string | number;\x0d\n *   uid?: number;\x0d\n *   gid?: number;\x0d\n *   windowsHide?: boolean;\x0d\n *   }} [options]\x0d\n * @param {(\x0d\n *   error?: Error\x2C\x0d\n *   stdout?: string | Buffer\x2C\x0d\n *   stderr?: string | Buffer\x0d\n *   ) => any} [callback]\x0d\n * @returns {ChildProcess}\x0d\n */\x0d\nfunction exec(command\x2C options\x2C callback) {\x0d\n  const opts = normalizeExecArgs(command\x2C options\x2C callback);\x0d\n  return module.exports.execFile(opts.file\x2C\x0d\n                                 opts.options\x2C\x0d\n                                 opts.callback);\x0d\n}\x0d\n\x0d\nconst customPromiseExecFunction = (orig) => {\x0d\n  return (...args) => {\x0d\n    const { promise\x2C resolve\x2C reject } = createDeferredPromise();\x0d\n\x0d\n    promise.child = orig(...args\x2C (err\x2C stdout\x2C stderr) => {\x0d\n      if (err !== null) {\x0d\n        err.stdout = stdout;\x0d\n        err.stderr = stderr;\x0d\n        reject(err);\x0d\n      } else {\x0d\n        resolve({ stdout\x2C stderr });\x0d\n      }\x0d\n    });\x0d\n\x0d\n    return promise;\x0d\n  };\x0d\n};\x0d\n\x0d\nObjectDefineProperty(exec\x2C promisify.custom\x2C {\x0d\n  enumerable: false\x2C\x0d\n  value: customPromiseExecFunction(exec)\x0d\n});\x0d\n\x0d\n/**\x0d\n * Spawns the specified file as a shell.\x0d\n * @param {string} file\x0d\n * @param {string[]} [args]\x0d\n * @param {{\x0d\n *   cwd?: string;\x0d\n *   env?: Object;\x0d\n *   encoding?: string;\x0d\n *   timeout?: number;\x0d\n *   maxBuffer?: number;\x0d\n *   killSignal?: string | number;\x0d\n *   uid?: number;\x0d\n *   gid?: number;\x0d\n *   windowsHide?: boolean;\x0d\n *   windowsVerbatimArguments?: boolean;\x0d\n *   shell?: boolean | string;\x0d\n *   signal?: AbortSignal;\x0d\n *   }} [options]\x0d\n * @param {(\x0d\n *   error?: Error\x2C\x0d\n *   stdout?: string | Buffer\x2C\x0d\n *   stderr?: string | Buffer\x0d\n *   ) => any} [callback]\x0d\n * @returns {ChildProcess}\x0d\n */\x0d\nfunction execFile(file\x2C args = []\x2C options\x2C callback) {\x0d\n  if (args == null) {\x0d\n    args = [];\x0d\n  } else if (typeof args === 'object') {\x0d\n    if (!ArrayIsArray(args)) {\x0d\n      callback = options;\x0d\n      options = args;\x0d\n      args = [];\x0d\n    }\x0d\n  } else if (typeof args === 'function') {\x0d\n    callback = args;\x0d\n    options = {};\x0d\n    args = [];\x0d\n  } else {\x0d\n    throw new ERR_INVALID_ARG_VALUE('args'\x2C args);\x0d\n  }\x0d\n\x0d\n  if (options == null) {\x0d\n    options = {};\x0d\n  } else if (typeof options === 'function') {\x0d\n    callback = options;\x0d\n    options = {};\x0d\n  } else if (typeof options !== 'object') {\x0d\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\x0d\n  }\x0d\n\x0d\n  if (callback && typeof callback !== 'function') {\x0d\n    throw new ERR_INVALID_ARG_VALUE('callback'\x2C callback);\x0d\n  }\x0d\n\x0d\n  options = {\x0d\n    encoding: 'utf8'\x2C\x0d\n    timeout: 0\x2C\x0d\n    maxBuffer: MAX_BUFFER\x2C\x0d\n    killSignal: 'SIGTERM'\x2C\x0d\n    cwd: null\x2C\x0d\n    env: null\x2C\x0d\n    shell: false\x2C\x0d\n    ...options\x0d\n  };\x0d\n\x0d\n  // Validate the timeout\x2C if present.\x0d\n  validateTimeout(options.timeout);\x0d\n\x0d\n  // Validate maxBuffer\x2C if present.\x0d\n  validateMaxBuffer(options.maxBuffer);\x0d\n\x0d\n  options.killSignal = sanitizeKillSignal(options.killSignal);\x0d\n\x0d\n  const child = spawn(file\x2C args\x2C {\x0d\n    cwd: options.cwd\x2C\x0d\n    env: options.env\x2C\x0d\n    gid: options.gid\x2C\x0d\n    shell: options.shell\x2C\x0d\n    signal: options.signal\x2C\x0d\n    uid: options.uid\x2C\x0d\n    windowsHide: !!options.windowsHide\x2C\x0d\n    windowsVerbatimArguments: !!options.windowsVerbatimArguments\x0d\n  });\x0d\n\x0d\n  let encoding;\x0d\n  const _stdout = [];\x0d\n  const _stderr = [];\x0d\n  if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) {\x0d\n    encoding = options.encoding;\x0d\n  } else {\x0d\n    encoding = null;\x0d\n  }\x0d\n  let stdoutLen = 0;\x0d\n  let stderrLen = 0;\x0d\n  let killed = false;\x0d\n  let exited = false;\x0d\n  let timeoutId;\x0d\n\x0d\n  let ex = null;\x0d\n\x0d\n  let cmd = file;\x0d\n\x0d\n  function exithandler(code\x2C signal) {\x0d\n    if (exited) return;\x0d\n    exited = true;\x0d\n\x0d\n    if (timeoutId) {\x0d\n      clearTimeout(timeoutId);\x0d\n      timeoutId = null;\x0d\n    }\x0d\n\x0d\n    if (!callback) return;\x0d\n\x0d\n    // merge chunks\x0d\n    let stdout;\x0d\n    let stderr;\x0d\n    if (encoding ||\x0d\n      (\x0d\n        child.stdout &&\x0d\n        child.stdout.readableEncoding\x0d\n      )) {\x0d\n      stdout = ArrayPrototypeJoin(_stdout\x2C '');\x0d\n    } else {\x0d\n      stdout = Buffer.concat(_stdout);\x0d\n    }\x0d\n    if (encoding ||\x0d\n      (\x0d\n        child.stderr &&\x0d\n        child.stderr.readableEncoding\x0d\n      )) {\x0d\n      stderr = ArrayPrototypeJoin(_stderr\x2C '');\x0d\n    } else {\x0d\n      stderr = Buffer.concat(_stderr);\x0d\n    }\x0d\n\x0d\n    if (!ex && code === 0 && signal === null) {\x0d\n      callback(null\x2C stdout\x2C stderr);\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    if (args.length !== 0)\x0d\n      cmd += ` ${ArrayPrototypeJoin(args\x2C ' ')}`;\x0d\n\x0d\n    if (!ex) {\x0d\n      // eslint-disable-next-line no-restricted-syntax\x0d\n      ex = new Error('Command failed: ' + cmd + '\\n' + stderr);\x0d\n      ex.killed = child.killed || killed;\x0d\n      ex.code = code < 0 ? getSystemErrorName(code) : code;\x0d\n      ex.signal = signal;\x0d\n    }\x0d\n\x0d\n    ex.cmd = cmd;\x0d\n    callback(ex\x2C stdout\x2C stderr);\x0d\n  }\x0d\n\x0d\n  function errorhandler(e) {\x0d\n    ex = e;\x0d\n\x0d\n    if (child.stdout)\x0d\n      child.stdout.destroy();\x0d\n\x0d\n    if (child.stderr)\x0d\n      child.stderr.destroy();\x0d\n\x0d\n    exithandler();\x0d\n  }\x0d\n\x0d\n  function kill() {\x0d\n    if (child.stdout)\x0d\n      child.stdout.destroy();\x0d\n\x0d\n    if (child.stderr)\x0d\n      child.stderr.destroy();\x0d\n\x0d\n    killed = true;\x0d\n    try {\x0d\n      child.kill(options.killSignal);\x0d\n    } catch (e) {\x0d\n      ex = e;\x0d\n      exithandler();\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (options.timeout > 0) {\x0d\n    timeoutId = setTimeout(function delayedKill() {\x0d\n      kill();\x0d\n      timeoutId = null;\x0d\n    }\x2C options.timeout);\x0d\n  }\x0d\n\x0d\n  if (child.stdout) {\x0d\n    if (encoding)\x0d\n      child.stdout.setEncoding(encoding);\x0d\n\x0d\n    child.stdout.on('data'\x2C function onChildStdout(chunk) {\x0d\n      const encoding = child.stdout.readableEncoding;\x0d\n      const length = encoding ?\x0d\n        Buffer.byteLength(chunk\x2C encoding) :\x0d\n        chunk.length;\x0d\n      const slice = encoding ? StringPrototypeSlice :\x0d\n        (buf\x2C ...args) => buf.slice(...args);\x0d\n      stdoutLen += length;\x0d\n\x0d\n      if (stdoutLen > options.maxBuffer) {\x0d\n        const truncatedLen = options.maxBuffer - (stdoutLen - length);\x0d\n        ArrayPrototypePush(_stdout\x2C slice(chunk\x2C 0\x2C truncatedLen));\x0d\n\x0d\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout');\x0d\n        kill();\x0d\n      } else {\x0d\n        ArrayPrototypePush(_stdout\x2C chunk);\x0d\n      }\x0d\n    });\x0d\n  }\x0d\n\x0d\n  if (child.stderr) {\x0d\n    if (encoding)\x0d\n      child.stderr.setEncoding(encoding);\x0d\n\x0d\n    child.stderr.on('data'\x2C function onChildStderr(chunk) {\x0d\n      const encoding = child.stderr.readableEncoding;\x0d\n      const length = encoding ?\x0d\n        Buffer.byteLength(chunk\x2C encoding) :\x0d\n        chunk.length;\x0d\n      stderrLen += length;\x0d\n\x0d\n      if (stderrLen > options.maxBuffer) {\x0d\n        const truncatedLen = options.maxBuffer - (stderrLen - length);\x0d\n        ArrayPrototypePush(_stderr\x2C\x0d\n                           chunk.slice(0\x2C truncatedLen));\x0d\n\x0d\n        ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr');\x0d\n        kill();\x0d\n      } else {\x0d\n        _stderr.push(chunk);\x0d\n      }\x0d\n    });\x0d\n  }\x0d\n\x0d\n  child.addListener('close'\x2C exithandler);\x0d\n  child.addListener('error'\x2C errorhandler);\x0d\n\x0d\n  return child;\x0d\n}\x0d\n\x0d\nObjectDefineProperty(execFile\x2C promisify.custom\x2C {\x0d\n  enumerable: false\x2C\x0d\n  value: customPromiseExecFunction(execFile)\x0d\n});\x0d\n\x0d\nfunction normalizeSpawnArguments(file\x2C args\x2C options) {\x0d\n  validateString(file\x2C 'file');\x0d\n\x0d\n  if (file.length === 0)\x0d\n    throw new ERR_INVALID_ARG_VALUE('file'\x2C file\x2C 'cannot be empty');\x0d\n\x0d\n  if (ArrayIsArray(args)) {\x0d\n    args = ArrayPrototypeSlice(args);\x0d\n  } else if (args == null) {\x0d\n    args = [];\x0d\n  } else if (typeof args !== 'object') {\x0d\n    throw new ERR_INVALID_ARG_TYPE('args'\x2C 'object'\x2C args);\x0d\n  } else {\x0d\n    options = args;\x0d\n    args = [];\x0d\n  }\x0d\n\x0d\n  if (options === undefined)\x0d\n    options = {};\x0d\n  else\x0d\n    validateObject(options\x2C 'options');\x0d\n\x0d\n  let cwd = options.cwd;\x0d\n\x0d\n  // Validate the cwd\x2C if present.\x0d\n  if (cwd != null) {\x0d\n    cwd = getValidatedPath(cwd\x2C 'options.cwd');\x0d\n  }\x0d\n\x0d\n  // Validate detached\x2C if present.\x0d\n  if (options.detached != null) {\x0d\n    validateBoolean(options.detached\x2C 'options.detached');\x0d\n  }\x0d\n\x0d\n  // Validate the uid\x2C if present.\x0d\n  if (options.uid != null && !isInt32(options.uid)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE('options.uid'\x2C 'int32'\x2C options.uid);\x0d\n  }\x0d\n\x0d\n  // Validate the gid\x2C if present.\x0d\n  if (options.gid != null && !isInt32(options.gid)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE('options.gid'\x2C 'int32'\x2C options.gid);\x0d\n  }\x0d\n\x0d\n  // Validate the shell\x2C if present.\x0d\n  if (options.shell != null &&\x0d\n      typeof options.shell !== 'boolean' &&\x0d\n      typeof options.shell !== 'string') {\x0d\n    throw new ERR_INVALID_ARG_TYPE('options.shell'\x2C\x0d\n                                   ['boolean'\x2C 'string']\x2C options.shell);\x0d\n  }\x0d\n\x0d\n  // Validate argv0\x2C if present.\x0d\n  if (options.argv0 != null) {\x0d\n    validateString(options.argv0\x2C 'options.argv0');\x0d\n  }\x0d\n\x0d\n  // Validate windowsHide\x2C if present.\x0d\n  if (options.windowsHide != null) {\x0d\n    validateBoolean(options.windowsHide\x2C 'options.windowsHide');\x0d\n  }\x0d\n\x0d\n  // Validate windowsVerbatimArguments\x2C if present.\x0d\n  let { windowsVerbatimArguments } = options;\x0d\n  if (windowsVerbatimArguments != null) {\x0d\n    validateBoolean(windowsVerbatimArguments\x2C\x0d\n                    'options.windowsVerbatimArguments');\x0d\n  }\x0d\n\x0d\n  if (options.shell) {\x0d\n    const command = ArrayPrototypeJoin([file\x2C ...args]\x2C ' ');\x0d\n    // Set the shell\x2C switches\x2C and commands.\x0d\n    if (process.platform === 'win32') {\x0d\n      if (typeof options.shell === 'string')\x0d\n        file = options.shell;\x0d\n      else\x0d\n        file = process.env.comspec || 'cmd.exe';\x0d\n      // '/d /s /c' is used only for cmd.exe.\x0d\n      if (RegExpPrototypeTest(/^(?:.*\\\\)?cmd(?:\\.exe)?$/i\x2C file)) {\x0d\n        args = ['/d'\x2C '/s'\x2C '/c'\x2C `"${command}"`];\x0d\n        windowsVerbatimArguments = true;\x0d\n      } else {\x0d\n        args = ['-c'\x2C command];\x0d\n      }\x0d\n    } else {\x0d\n      if (typeof options.shell === 'string')\x0d\n        file = options.shell;\x0d\n      else if (process.platform === 'android')\x0d\n        file = '/system/bin/sh';\x0d\n      else\x0d\n        file = '/bin/sh';\x0d\n      args = ['-c'\x2C command];\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (typeof options.argv0 === 'string') {\x0d\n    ArrayPrototypeUnshift(args\x2C options.argv0);\x0d\n  } else {\x0d\n    ArrayPrototypeUnshift(args\x2C file);\x0d\n  }\x0d\n\x0d\n  const env = options.env || process.env;\x0d\n  const envPairs = [];\x0d\n\x0d\n  // process.env.NODE_V8_COVERAGE always propagates\x2C making it possible to\x0d\n  // collect coverage for programs that spawn with white-listed environment.\x0d\n  if (process.env.NODE_V8_COVERAGE &&\x0d\n      !ObjectPrototypeHasOwnProperty(options.env || {}\x2C 'NODE_V8_COVERAGE')) {\x0d\n    env.NODE_V8_COVERAGE = process.env.NODE_V8_COVERAGE;\x0d\n  }\x0d\n\x0d\n  let envKeys = [];\x0d\n  // Prototype values are intentionally included.\x0d\n  for (const key in env) {\x0d\n    ArrayPrototypePush(envKeys\x2C key);\x0d\n  }\x0d\n\x0d\n  if (process.platform === 'win32') {\x0d\n    // On Windows env keys are case insensitive. Filter out duplicates\x2C\x0d\n    // keeping only the first one (in lexicographic order)\x0d\n    const sawKey = new SafeSet();\x0d\n    envKeys = ArrayPrototypeFilter(\x0d\n      ArrayPrototypeSort(envKeys)\x2C\x0d\n      (key) => {\x0d\n        const uppercaseKey = StringPrototypeToUpperCase(key);\x0d\n        if (sawKey.has(uppercaseKey)) {\x0d\n          return false;\x0d\n        }\x0d\n        sawKey.add(uppercaseKey);\x0d\n        return true;\x0d\n      }\x0d\n    );\x0d\n  }\x0d\n\x0d\n  for (const key of envKeys) {\x0d\n    const value = env[key];\x0d\n    if (value !== undefined) {\x0d\n      ArrayPrototypePush(envPairs\x2C `${key}=${value}`);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return {\x0d\n    // Make a shallow copy so we don't clobber the user's options object.\x0d\n    ...options\x2C\x0d\n    args\x2C\x0d\n    cwd\x2C\x0d\n    detached: !!options.detached\x2C\x0d\n    envPairs\x2C\x0d\n    file\x2C\x0d\n    windowsHide: !!options.windowsHide\x2C\x0d\n    windowsVerbatimArguments: !!windowsVerbatimArguments\x2C\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction abortChildProcess(child\x2C killSignal) {\x0d\n  if (!child)\x0d\n    return;\x0d\n  try {\x0d\n    if (child.kill(killSignal)) {\x0d\n      child.emit('error'\x2C new AbortError());\x0d\n    }\x0d\n  } catch (err) {\x0d\n    child.emit('error'\x2C err);\x0d\n  }\x0d\n}\x0d\n\x0d\n/**\x0d\n * Spawns a new process using the given `file`.\x0d\n * @param {string} file\x0d\n * @param {string[]} [args]\x0d\n * @param {{\x0d\n *   cwd?: string;\x0d\n *   env?: Object;\x0d\n *   argv0?: string;\x0d\n *   stdio?: Array | string;\x0d\n *   detached?: boolean;\x0d\n *   uid?: number;\x0d\n *   gid?: number;\x0d\n *   serialization?: string;\x0d\n *   shell?: boolean | string;\x0d\n *   windowsVerbatimArguments?: boolean;\x0d\n *   windowsHide?: boolean;\x0d\n *   signal?: AbortSignal;\x0d\n *   timeout?: number;\x0d\n *   killSignal?: string | number;\x0d\n *   }} [options]\x0d\n * @returns {ChildProcess}\x0d\n */\x0d\nfunction spawn(file\x2C args\x2C options) {\x0d\n  options = normalizeSpawnArguments(file\x2C args\x2C options);\x0d\n  validateTimeout(options.timeout);\x0d\n  validateAbortSignal(options.signal\x2C 'options.signal');\x0d\n  const killSignal = sanitizeKillSignal(options.killSignal);\x0d\n  const child = new ChildProcess();\x0d\n\x0d\n  debug('spawn'\x2C options);\x0d\n  child.spawn(options);\x0d\n\x0d\n  if (options.timeout > 0) {\x0d\n    let timeoutId = setTimeout(() => {\x0d\n      if (timeoutId) {\x0d\n        try {\x0d\n          child.kill(killSignal);\x0d\n        } catch (err) {\x0d\n          child.emit('error'\x2C err);\x0d\n        }\x0d\n        timeoutId = null;\x0d\n      }\x0d\n    }\x2C options.timeout);\x0d\n\x0d\n    child.once('exit'\x2C () => {\x0d\n      if (timeoutId) {\x0d\n        clearTimeout(timeoutId);\x0d\n        timeoutId = null;\x0d\n      }\x0d\n    });\x0d\n  }\x0d\n\x0d\n  if (options.signal) {\x0d\n    const signal = options.signal;\x0d\n    if (signal.aborted) {\x0d\n      process.nextTick(onAbortListener);\x0d\n    } else {\x0d\n      signal.addEventListener('abort'\x2C onAbortListener\x2C { once: true });\x0d\n      child.once('exit'\x2C\x0d\n                 () => signal.removeEventListener('abort'\x2C onAbortListener));\x0d\n    }\x0d\n\x0d\n    function onAbortListener() {\x0d\n      abortChildProcess(child\x2C killSignal);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return child;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Spawns a new process synchronously using the given `file`.\x0d\n * @param {string} file\x0d\n * @param {string[]} [args]\x0d\n * @param {{\x0d\n *   cwd?: string;\x0d\n *   input?: string | Buffer | TypedArray | DataView;\x0d\n *   argv0?: string;\x0d\n *   stdio?: string | Array;\x0d\n *   env?: Object;\x0d\n *   uid?: number;\x0d\n *   gid?: number;\x0d\n *   timeout?: number;\x0d\n *   killSignal?: string | number;\x0d\n *   maxBuffer?: number;\x0d\n *   encoding?: string;\x0d\n *   shell?: boolean | string;\x0d\n *   windowsVerbatimArguments?: boolean;\x0d\n *   windowsHide?: boolean;\x0d\n *   }} [options]\x0d\n * @returns {{\x0d\n *   pid: number;\x0d\n *   output: Array;\x0d\n *   stdout: Buffer | string;\x0d\n *   stderr: Buffer | string;\x0d\n *   status: number | null;\x0d\n *   signal: string | null;\x0d\n *   error: Error;\x0d\n *   }}\x0d\n */\x0d\nfunction spawnSync(file\x2C args\x2C options) {\x0d\n  options = {\x0d\n    maxBuffer: MAX_BUFFER\x2C\x0d\n    ...normalizeSpawnArguments(file\x2C args\x2C options)\x0d\n  };\x0d\n\x0d\n  debug('spawnSync'\x2C options);\x0d\n\x0d\n  // Validate the timeout\x2C if present.\x0d\n  validateTimeout(options.timeout);\x0d\n\x0d\n  // Validate maxBuffer\x2C if present.\x0d\n  validateMaxBuffer(options.maxBuffer);\x0d\n\x0d\n  // Validate and translate the kill signal\x2C if present.\x0d\n  options.killSignal = sanitizeKillSignal(options.killSignal);\x0d\n\x0d\n  options.stdio = getValidStdio(options.stdio || 'pipe'\x2C true).stdio;\x0d\n\x0d\n  if (options.input) {\x0d\n    const stdin = options.stdio[0] = { ...options.stdio[0] };\x0d\n    stdin.input = options.input;\x0d\n  }\x0d\n\x0d\n  // We may want to pass data in on any given fd\x2C ensure it is a valid buffer\x0d\n  for (let i = 0; i < options.stdio.length; i++) {\x0d\n    const input = options.stdio[i] && options.stdio[i].input;\x0d\n    if (input != null) {\x0d\n      const pipe = options.stdio[i] = { ...options.stdio[i] };\x0d\n      if (isArrayBufferView(input)) {\x0d\n        pipe.input = input;\x0d\n      } else if (typeof input === 'string') {\x0d\n        pipe.input = Buffer.from(input\x2C options.encoding);\x0d\n      } else {\x0d\n        throw new ERR_INVALID_ARG_TYPE(`options.stdio[${i}]`\x2C\x0d\n                                       ['Buffer'\x2C\x0d\n                                        'TypedArray'\x2C\x0d\n                                        'DataView'\x2C\x0d\n                                        'string']\x2C\x0d\n                                       input);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return child_process.spawnSync(options);\x0d\n}\x0d\n\x0d\n\x0d\nfunction checkExecSyncError(ret\x2C args\x2C cmd) {\x0d\n  let err;\x0d\n  if (ret.error) {\x0d\n    err = ret.error;\x0d\n  } else if (ret.status !== 0) {\x0d\n    let msg = 'Command failed: ';\x0d\n    msg += cmd || ArrayPrototypeJoin(args\x2C ' ');\x0d\n    if (ret.stderr && ret.stderr.length > 0)\x0d\n      msg += `\\n${ret.stderr.toString()}`;\x0d\n    // eslint-disable-next-line no-restricted-syntax\x0d\n    err = new Error(msg);\x0d\n  }\x0d\n  if (err) {\x0d\n    ObjectAssign(err\x2C ret);\x0d\n  }\x0d\n  return err;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Spawns a file as a shell synchronously.\x0d\n * @param {string} command\x0d\n * @param {string[]} [args]\x0d\n * @param {{\x0d\n *   cwd?: string;\x0d\n *   input?: string | Buffer | TypedArray | DataView;\x0d\n *   stdio?: string | Array;\x0d\n *   env?: Object;\x0d\n *   uid?: number;\x0d\n *   gid?: number;\x0d\n *   timeout?: number;\x0d\n *   killSignal?: string | number;\x0d\n *   maxBuffer?: number;\x0d\n *   encoding?: string;\x0d\n *   windowsHide?: boolean;\x0d\n *   shell?: boolean | string;\x0d\n *   }} [options]\x0d\n * @returns {Buffer | string}\x0d\n */\x0d\nfunction execFileSync(command\x2C args\x2C options) {\x0d\n  options = normalizeSpawnArguments(command\x2C args\x2C options);\x0d\n\x0d\n  const inheritStderr = !options.stdio;\x0d\n  const ret = spawnSync(options.file\x2C\x0d\n                        ArrayPrototypeSlice(options.args\x2C 1)\x2C options);\x0d\n\x0d\n  if (inheritStderr && ret.stderr)\x0d\n    process.stderr.write(ret.stderr);\x0d\n\x0d\n  const err = checkExecSyncError(ret\x2C options.args\x2C undefined);\x0d\n\x0d\n  if (err)\x0d\n    throw err;\x0d\n\x0d\n  return ret.stdout;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Spawns a shell executing the given `command` synchronously.\x0d\n * @param {string} command\x0d\n * @param {{\x0d\n *   cwd?: string;\x0d\n *   input?: string | Buffer | TypedArray | DataView;\x0d\n *   stdio?: string | Array;\x0d\n *   env?: Object;\x0d\n *   shell?: string;\x0d\n *   uid?: number;\x0d\n *   gid?: number;\x0d\n *   timeout?: number;\x0d\n *   killSignal?: string | number;\x0d\n *   maxBuffer?: number;\x0d\n *   encoding?: string;\x0d\n *   windowsHide?: boolean;\x0d\n *   }} [options]\x0d\n * @returns {Buffer | string}\x0d\n */\x0d\nfunction execSync(command\x2C options) {\x0d\n  const opts = normalizeExecArgs(command\x2C options\x2C null);\x0d\n  const inheritStderr = !opts.options.stdio;\x0d\n\x0d\n  const ret = spawnSync(opts.file\x2C opts.options);\x0d\n\x0d\n  if (inheritStderr && ret.stderr)\x0d\n    process.stderr.write(ret.stderr);\x0d\n\x0d\n  const err = checkExecSyncError(ret\x2C opts.args\x2C command);\x0d\n\x0d\n  if (err)\x0d\n    throw err;\x0d\n\x0d\n  return ret.stdout;\x0d\n}\x0d\n\x0d\n\x0d\nfunction validateTimeout(timeout) {\x0d\n  if (timeout != null && !(NumberIsInteger(timeout) && timeout >= 0)) {\x0d\n    throw new ERR_OUT_OF_RANGE('timeout'\x2C 'an unsigned integer'\x2C timeout);\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nfunction validateMaxBuffer(maxBuffer) {\x0d\n  if (maxBuffer != null && !(typeof maxBuffer === 'number' && maxBuffer >= 0)) {\x0d\n    throw new ERR_OUT_OF_RANGE('options.maxBuffer'\x2C\x0d\n                               'a positive number'\x2C\x0d\n                               maxBuffer);\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nfunction sanitizeKillSignal(killSignal) {\x0d\n  if (typeof killSignal === 'string' || typeof killSignal === 'number') {\x0d\n    return convertToValidSignal(killSignal);\x0d\n  } else if (killSignal != null) {\x0d\n    throw new ERR_INVALID_ARG_TYPE('options.killSignal'\x2C\x0d\n                                   ['string'\x2C 'number']\x2C\x0d\n                                   killSignal);\x0d\n  }\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  _forkChild\x2C\x0d\n  ChildProcess\x2C\x0d\n  exec\x2C\x0d\n  execFile\x2C\x0d\n  execFileSync\x2C\x0d\n  execSync\x2C\x0d\n  fork\x2C\x0d\n  spawn\x2C\x0d\n  spawnSync\x0d\n};\x0d\n
code-source-info,0x1c1d96dc09e,129,0,25520,C0O0C4O25520,,
code-creation,Function,10,246302,0x1c1d96dcafe,748, node:child_process:1:1,0x1c1d96dc018,~
code-source-info,0x1c1d96dcafe,129,0,25520,C0O0C235O1183C241O1200C247O1225C253O1252C259O1275C265O1305C271O1328C277O1352C283O1375C289O1400C295O1426C301O1436C307O1456C313O1473C318O1498C324O1532C330O1556C336O1568C342O1593C348O1742C351O1742C356O1653C361O1667C367O1692C373O1718C379O1799C382O1799C387O1777C393O1844C396O1844C401O1877C414O1878C420O1844C422O1967C425O1967C430O1956C436O2030C439O2030C444O1995C450O2012C456O2113C459O2113C464O2074C470O2096C475O2153C481O2179C487O2214C493O2252C499O2277C505O2350C508O2350C513O2321C519O2335C525O2399C528O2399C533O2378C539O2537C542O2537C547O2441C553O2453C559O2477C565O2497C571O2516C577O2592C580O2592C584O2592C586O2715C589O2639C595O2657C601O2674C607O2691C613O2752C619O2752C621O6792C626O7214C636O7256C647O7177C652O13254C662O13296C673O13213C678O25380C688O25402C694O25417C700O25434C706O25443C712O25456C718O25473C724O25486C730O25495C736O25505C742O25395C747O25519,,
code-creation,Eval,10,247195,0x1c1d96e217e,5, node:internal/child_process:1:1,0x1c1d96e1a80,~
script-source,130,node:internal/child_process,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeReduce\x2C\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  FunctionPrototype\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  ReflectApply\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  Symbol\x2C\x0d\n  Uint8Array\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  errnoException\x2C\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_INVALID_HANDLE_TYPE\x2C\x0d\n    ERR_INVALID_SYNC_FORK_INPUT\x2C\x0d\n    ERR_IPC_CHANNEL_CLOSED\x2C\x0d\n    ERR_IPC_DISCONNECTED\x2C\x0d\n    ERR_IPC_ONE_PIPE\x2C\x0d\n    ERR_IPC_SYNC_FORK\x2C\x0d\n    ERR_MISSING_ARGS\x0d\n  }\x0d\n} = require('internal/errors');\x0d\nconst {\x0d\n  validateArray\x2C\x0d\n  validateObject\x2C\x0d\n  validateOneOf\x2C\x0d\n  validateString\x2C\x0d\n} = require('internal/validators');\x0d\nconst EventEmitter = require('events');\x0d\nconst net = require('net');\x0d\nconst dgram = require('dgram');\x0d\nconst inspect = require('internal/util/inspect').inspect;\x0d\nconst assert = require('internal/assert');\x0d\n\x0d\nconst { Process } = internalBinding('process_wrap');\x0d\nconst {\x0d\n  WriteWrap\x2C\x0d\n  kReadBytesOrError\x2C\x0d\n  kArrayBufferOffset\x2C\x0d\n  kLastWriteWasAsync\x2C\x0d\n  streamBaseState\x0d\n} = internalBinding('stream_wrap');\x0d\nconst { Pipe\x2C constants: PipeConstants } = internalBinding('pipe_wrap');\x0d\nconst { TCP } = internalBinding('tcp_wrap');\x0d\nconst { TTY } = internalBinding('tty_wrap');\x0d\nconst { UDP } = internalBinding('udp_wrap');\x0d\nconst SocketList = require('internal/socket_list');\x0d\nconst { owner_symbol } = require('internal/async_hooks').symbols;\x0d\nconst { convertToValidSignal\x2C deprecate } = require('internal/util');\x0d\nconst { isArrayBufferView } = require('internal/util/types');\x0d\nconst spawn_sync = internalBinding('spawn_sync');\x0d\nconst { kStateSymbol } = require('internal/dgram');\x0d\n\x0d\nconst {\x0d\n  UV_EACCES\x2C\x0d\n  UV_EAGAIN\x2C\x0d\n  UV_EINVAL\x2C\x0d\n  UV_EMFILE\x2C\x0d\n  UV_ENFILE\x2C\x0d\n  UV_ENOENT\x2C\x0d\n  UV_ENOSYS\x2C\x0d\n  UV_ESRCH\x0d\n} = internalBinding('uv');\x0d\n\x0d\nconst { SocketListSend\x2C SocketListReceive } = SocketList;\x0d\n\x0d\n// Lazy loaded for startup performance and to allow monkey patching of\x0d\n// internalBinding('http_parser').HTTPParser.\x0d\nlet freeParser;\x0d\nlet HTTPParser;\x0d\n\x0d\nconst MAX_HANDLE_RETRANSMISSIONS = 3;\x0d\nconst kChannelHandle = Symbol('kChannelHandle');\x0d\nconst kIsUsedAsStdio = Symbol('kIsUsedAsStdio');\x0d\nconst kPendingMessages = Symbol('kPendingMessages');\x0d\n\x0d\n// This object contain function to convert TCP objects to native handle objects\x0d\n// and back again.\x0d\nconst handleConversion = {\x0d\n  'net.Native': {\x0d\n    simultaneousAccepts: true\x2C\x0d\n\x0d\n    send(message\x2C handle\x2C options) {\x0d\n      return handle;\x0d\n    }\x2C\x0d\n\x0d\n    got(message\x2C handle\x2C emit) {\x0d\n      emit(handle);\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  'net.Server': {\x0d\n    simultaneousAccepts: true\x2C\x0d\n\x0d\n    send(message\x2C server\x2C options) {\x0d\n      return server._handle;\x0d\n    }\x2C\x0d\n\x0d\n    got(message\x2C handle\x2C emit) {\x0d\n      const server = new net.Server();\x0d\n      server.listen(handle\x2C () => {\x0d\n        emit(server);\x0d\n      });\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  'net.Socket': {\x0d\n    send(message\x2C socket\x2C options) {\x0d\n      if (!socket._handle)\x0d\n        return;\x0d\n\x0d\n      // If the socket was created by net.Server\x0d\n      if (socket.server) {\x0d\n        // The worker should keep track of the socket\x0d\n        message.key = socket.server._connectionKey;\x0d\n\x0d\n        const firstTime = !this[kChannelHandle].sockets.send[message.key];\x0d\n        const socketList = getSocketList('send'\x2C this\x2C message.key);\x0d\n\x0d\n        // The server should no longer expose a .connection property\x0d\n        // and when asked to close it should query the socket status from\x0d\n        // the workers\x0d\n        if (firstTime) socket.server._setupWorker(socketList);\x0d\n\x0d\n        // Act like socket is detached\x0d\n        if (!options.keepOpen)\x0d\n          socket.server._connections--;\x0d\n      }\x0d\n\x0d\n      const handle = socket._handle;\x0d\n\x0d\n      // Remove handle from socket object\x2C it will be closed when the socket\x0d\n      // will be sent\x0d\n      if (!options.keepOpen) {\x0d\n        handle.onread = nop;\x0d\n        socket._handle = null;\x0d\n        socket.setTimeout(0);\x0d\n\x0d\n        if (freeParser === undefined)\x0d\n          freeParser = require('_http_common').freeParser;\x0d\n        if (HTTPParser === undefined)\x0d\n          HTTPParser = require('_http_common').HTTPParser;\x0d\n\x0d\n        // In case of an HTTP connection socket\x2C release the associated\x0d\n        // resources\x0d\n        if (socket.parser && socket.parser instanceof HTTPParser) {\x0d\n          freeParser(socket.parser\x2C null\x2C socket);\x0d\n          if (socket._httpMessage)\x0d\n            socket._httpMessage.detachSocket(socket);\x0d\n        }\x0d\n      }\x0d\n\x0d\n      return handle;\x0d\n    }\x2C\x0d\n\x0d\n    postSend(message\x2C handle\x2C options\x2C callback\x2C target) {\x0d\n      // Store the handle after successfully sending it\x2C so it can be closed\x0d\n      // when the NODE_HANDLE_ACK is received. If the handle could not be sent\x2C\x0d\n      // just close it.\x0d\n      if (handle && !options.keepOpen) {\x0d\n        if (target) {\x0d\n          // There can only be one _pendingMessage as passing handles are\x0d\n          // processed one at a time: handles are stored in _handleQueue while\x0d\n          // waiting for the NODE_HANDLE_ACK of the current passing handle.\x0d\n          assert(!target._pendingMessage);\x0d\n          target._pendingMessage =\x0d\n              { callback\x2C message\x2C handle\x2C options\x2C retransmissions: 0 };\x0d\n        } else {\x0d\n          handle.close();\x0d\n        }\x0d\n      }\x0d\n    }\x2C\x0d\n\x0d\n    got(message\x2C handle\x2C emit) {\x0d\n      const socket = new net.Socket({\x0d\n        handle: handle\x2C\x0d\n        readable: true\x2C\x0d\n        writable: true\x0d\n      });\x0d\n\x0d\n      // If the socket was created by net.Server we will track the socket\x0d\n      if (message.key) {\x0d\n\x0d\n        // Add socket to connections list\x0d\n        const socketList = getSocketList('got'\x2C this\x2C message.key);\x0d\n        socketList.add({\x0d\n          socket: socket\x0d\n        });\x0d\n      }\x0d\n\x0d\n      emit(socket);\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  'dgram.Native': {\x0d\n    simultaneousAccepts: false\x2C\x0d\n\x0d\n    send(message\x2C handle\x2C options) {\x0d\n      return handle;\x0d\n    }\x2C\x0d\n\x0d\n    got(message\x2C handle\x2C emit) {\x0d\n      emit(handle);\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  'dgram.Socket': {\x0d\n    simultaneousAccepts: false\x2C\x0d\n\x0d\n    send(message\x2C socket\x2C options) {\x0d\n      message.dgramType = socket.type;\x0d\n\x0d\n      return socket[kStateSymbol].handle;\x0d\n    }\x2C\x0d\n\x0d\n    got(message\x2C handle\x2C emit) {\x0d\n      const socket = new dgram.Socket(message.dgramType);\x0d\n\x0d\n      socket.bind(handle\x2C () => {\x0d\n        emit(socket);\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n};\x0d\n\x0d\nfunction stdioStringToArray(stdio\x2C channel) {\x0d\n  const options = [];\x0d\n\x0d\n  switch (stdio) {\x0d\n    case 'ignore':\x0d\n    case 'overlapped':\x0d\n    case 'pipe': ArrayPrototypePush(options\x2C stdio\x2C stdio\x2C stdio); break;\x0d\n    case 'inherit': ArrayPrototypePush(options\x2C 0\x2C 1\x2C 2); break;\x0d\n    default:\x0d\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\x0d\n  }\x0d\n\x0d\n  if (channel) ArrayPrototypePush(options\x2C channel);\x0d\n\x0d\n  return options;\x0d\n}\x0d\n\x0d\nfunction ChildProcess() {\x0d\n  FunctionPrototypeCall(EventEmitter\x2C this);\x0d\n\x0d\n  this._closesNeeded = 1;\x0d\n  this._closesGot = 0;\x0d\n  this.connected = false;\x0d\n\x0d\n  this.signalCode = null;\x0d\n  this.exitCode = null;\x0d\n  this.killed = false;\x0d\n  this.spawnfile = null;\x0d\n\x0d\n  this._handle = new Process();\x0d\n  this._handle[owner_symbol] = this;\x0d\n\x0d\n  this._handle.onexit = (exitCode\x2C signalCode) => {\x0d\n    if (signalCode) {\x0d\n      this.signalCode = signalCode;\x0d\n    } else {\x0d\n      this.exitCode = exitCode;\x0d\n    }\x0d\n\x0d\n    if (this.stdin) {\x0d\n      this.stdin.destroy();\x0d\n    }\x0d\n\x0d\n    this._handle.close();\x0d\n    this._handle = null;\x0d\n\x0d\n    if (exitCode < 0) {\x0d\n      const syscall = this.spawnfile ? 'spawn ' + this.spawnfile : 'spawn';\x0d\n      const err = errnoException(exitCode\x2C syscall);\x0d\n\x0d\n      if (this.spawnfile)\x0d\n        err.path = this.spawnfile;\x0d\n\x0d\n      err.spawnargs = ArrayPrototypeSlice(this.spawnargs\x2C 1);\x0d\n      this.emit('error'\x2C err);\x0d\n    } else {\x0d\n      this.emit('exit'\x2C this.exitCode\x2C this.signalCode);\x0d\n    }\x0d\n\x0d\n    // If any of the stdio streams have not been touched\x2C\x0d\n    // then pull all the data through so that it can get the\x0d\n    // eof and emit a 'close' event.\x0d\n    // Do it on nextTick so that the user has one last chance\x0d\n    // to consume the output\x2C if for example they only want to\x0d\n    // start reading the data once the process exits.\x0d\n    process.nextTick(flushStdio\x2C this);\x0d\n\x0d\n    maybeClose(this);\x0d\n  };\x0d\n}\x0d\nObjectSetPrototypeOf(ChildProcess.prototype\x2C EventEmitter.prototype);\x0d\nObjectSetPrototypeOf(ChildProcess\x2C EventEmitter);\x0d\n\x0d\n\x0d\nfunction flushStdio(subprocess) {\x0d\n  const stdio = subprocess.stdio;\x0d\n\x0d\n  if (stdio == null) return;\x0d\n\x0d\n  for (let i = 0; i < stdio.length; i++) {\x0d\n    const stream = stdio[i];\x0d\n    // TODO(addaleax): This doesn't necessarily account for all the ways in\x0d\n    // which data can be read from a stream\x2C e.g. being consumed on the\x0d\n    // native layer directly as a StreamBase.\x0d\n    if (!stream || !stream.readable || stream[kIsUsedAsStdio]) {\x0d\n      continue;\x0d\n    }\x0d\n    stream.resume();\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nfunction createSocket(pipe\x2C readable) {\x0d\n  return net.Socket({ handle: pipe\x2C readable });\x0d\n}\x0d\n\x0d\n\x0d\nfunction getHandleWrapType(stream) {\x0d\n  if (stream instanceof Pipe) return 'pipe';\x0d\n  if (stream instanceof TTY) return 'tty';\x0d\n  if (stream instanceof TCP) return 'tcp';\x0d\n  if (stream instanceof UDP) return 'udp';\x0d\n\x0d\n  return false;\x0d\n}\x0d\n\x0d\nfunction closePendingHandle(target) {\x0d\n  target._pendingMessage.handle.close();\x0d\n  target._pendingMessage = null;\x0d\n}\x0d\n\x0d\n\x0d\nChildProcess.prototype.spawn = function(options) {\x0d\n  let i = 0;\x0d\n\x0d\n  validateObject(options\x2C 'options');\x0d\n\x0d\n  // If no `stdio` option was given - use default\x0d\n  let stdio = options.stdio || 'pipe';\x0d\n\x0d\n  stdio = getValidStdio(stdio\x2C false);\x0d\n\x0d\n  const ipc = stdio.ipc;\x0d\n  const ipcFd = stdio.ipcFd;\x0d\n  stdio = options.stdio = stdio.stdio;\x0d\n\x0d\n\x0d\n  validateOneOf(options.serialization\x2C 'options.serialization'\x2C\x0d\n                [undefined\x2C 'json'\x2C 'advanced']);\x0d\n  const serialization = options.serialization || 'json';\x0d\n\x0d\n  if (ipc !== undefined) {\x0d\n    // Let child process know about opened IPC channel\x0d\n    if (options.envPairs === undefined)\x0d\n      options.envPairs = [];\x0d\n    else\x0d\n      validateArray(options.envPairs\x2C 'options.envPairs');\x0d\n\x0d\n    ArrayPrototypePush(options.envPairs\x2C `NODE_CHANNEL_FD=${ipcFd}`);\x0d\n    ArrayPrototypePush(options.envPairs\x2C\x0d\n                       `NODE_CHANNEL_SERIALIZATION_MODE=${serialization}`);\x0d\n  }\x0d\n\x0d\n  validateString(options.file\x2C 'options.file');\x0d\n  this.spawnfile = options.file;\x0d\n\x0d\n  if (options.args === undefined) {\x0d\n    this.spawnargs = [];\x0d\n  } else {\x0d\n    validateArray(options.args\x2C 'options.args');\x0d\n    this.spawnargs = options.args;\x0d\n  }\x0d\n\x0d\n  const err = this._handle.spawn(options);\x0d\n\x0d\n  // Run-time errors should emit an error\x2C not throw an exception.\x0d\n  if (err === UV_EACCES ||\x0d\n      err === UV_EAGAIN ||\x0d\n      err === UV_EMFILE ||\x0d\n      err === UV_ENFILE ||\x0d\n      err === UV_ENOENT) {\x0d\n    process.nextTick(onErrorNT\x2C this\x2C err);\x0d\n\x0d\n    // There is no point in continuing when we've hit EMFILE or ENFILE\x0d\n    // because we won't be able to set up the stdio file descriptors.\x0d\n    if (err === UV_EMFILE || err === UV_ENFILE)\x0d\n      return err;\x0d\n  } else if (err) {\x0d\n    // Close all opened fds on error\x0d\n    for (i = 0; i < stdio.length; i++) {\x0d\n      const stream = stdio[i];\x0d\n      if (stream.type === 'pipe') {\x0d\n        stream.handle.close();\x0d\n      }\x0d\n    }\x0d\n\x0d\n    this._handle.close();\x0d\n    this._handle = null;\x0d\n    throw errnoException(err\x2C 'spawn');\x0d\n  } else {\x0d\n    process.nextTick(onSpawnNT\x2C this);\x0d\n  }\x0d\n\x0d\n  this.pid = this._handle.pid;\x0d\n\x0d\n  for (i = 0; i < stdio.length; i++) {\x0d\n    const stream = stdio[i];\x0d\n    if (stream.type === 'ignore') continue;\x0d\n\x0d\n    if (stream.ipc) {\x0d\n      this._closesNeeded++;\x0d\n      continue;\x0d\n    }\x0d\n\x0d\n    // The stream is already cloned and piped\x2C thus stop its readable side\x2C\x0d\n    // otherwise we might attempt to read from the stream when at the same time\x0d\n    // the child process does.\x0d\n    if (stream.type === 'wrap') {\x0d\n      stream.handle.reading = false;\x0d\n      stream.handle.readStop();\x0d\n      stream._stdio.pause();\x0d\n      stream._stdio.readableFlowing = false;\x0d\n      stream._stdio._readableState.reading = false;\x0d\n      stream._stdio[kIsUsedAsStdio] = true;\x0d\n      continue;\x0d\n    }\x0d\n\x0d\n    if (stream.handle) {\x0d\n      stream.socket = createSocket(this.pid !== 0 ?\x0d\n        stream.handle : null\x2C i > 0);\x0d\n\x0d\n      if (i > 0 && this.pid !== 0) {\x0d\n        this._closesNeeded++;\x0d\n        stream.socket.on('close'\x2C () => {\x0d\n          maybeClose(this);\x0d\n        });\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  this.stdin = stdio.length >= 1 && stdio[0].socket !== undefined ?\x0d\n    stdio[0].socket : null;\x0d\n  this.stdout = stdio.length >= 2 && stdio[1].socket !== undefined ?\x0d\n    stdio[1].socket : null;\x0d\n  this.stderr = stdio.length >= 3 && stdio[2].socket !== undefined ?\x0d\n    stdio[2].socket : null;\x0d\n\x0d\n  this.stdio = [];\x0d\n\x0d\n  for (i = 0; i < stdio.length; i++)\x0d\n    ArrayPrototypePush(this.stdio\x2C\x0d\n                       stdio[i].socket === undefined ? null : stdio[i].socket);\x0d\n\x0d\n  // Add .send() method and start listening for IPC data\x0d\n  if (ipc !== undefined) setupChannel(this\x2C ipc\x2C serialization);\x0d\n\x0d\n  return err;\x0d\n};\x0d\n\x0d\n\x0d\nfunction onErrorNT(self\x2C err) {\x0d\n  self._handle.onexit(err);\x0d\n}\x0d\n\x0d\n\x0d\nfunction onSpawnNT(self) {\x0d\n  self.emit('spawn');\x0d\n}\x0d\n\x0d\n\x0d\nChildProcess.prototype.kill = function(sig) {\x0d\n\x0d\n  const signal = sig === 0 ? sig :\x0d\n    convertToValidSignal(sig === undefined ? 'SIGTERM' : sig);\x0d\n\x0d\n  if (this._handle) {\x0d\n    const err = this._handle.kill(signal);\x0d\n    if (err === 0) {\x0d\n      /* Success. */\x0d\n      this.killed = true;\x0d\n      return true;\x0d\n    }\x0d\n    if (err === UV_ESRCH) {\x0d\n      /* Already dead. */\x0d\n    } else if (err === UV_EINVAL || err === UV_ENOSYS) {\x0d\n      /* The underlying platform doesn't support this signal. */\x0d\n      throw errnoException(err\x2C 'kill');\x0d\n    } else {\x0d\n      /* Other error\x2C almost certainly EPERM. */\x0d\n      this.emit('error'\x2C errnoException(err\x2C 'kill'));\x0d\n    }\x0d\n  }\x0d\n\x0d\n  /* Kill didn't succeed. */\x0d\n  return false;\x0d\n};\x0d\n\x0d\n\x0d\nChildProcess.prototype.ref = function() {\x0d\n  if (this._handle) this._handle.ref();\x0d\n};\x0d\n\x0d\n\x0d\nChildProcess.prototype.unref = function() {\x0d\n  if (this._handle) this._handle.unref();\x0d\n};\x0d\n\x0d\nclass Control extends EventEmitter {\x0d\n  #channel = null;\x0d\n  #refs = 0;\x0d\n  #refExplicitlySet = false;\x0d\n\x0d\n  constructor(channel) {\x0d\n    super();\x0d\n    this.#channel = channel;\x0d\n    this[kPendingMessages] = [];\x0d\n  }\x0d\n\x0d\n  // The methods keeping track of the counter are being used to track the\x0d\n  // listener count on the child process object as well as when writes are\x0d\n  // in progress. Once the user has explicitly requested a certain state\x2C these\x0d\n  // methods become no-ops in order to not interfere with the user's intentions.\x0d\n  refCounted() {\x0d\n    if (++this.#refs === 1 && !this.#refExplicitlySet) {\x0d\n      this.#channel.ref();\x0d\n    }\x0d\n  }\x0d\n\x0d\n  unrefCounted() {\x0d\n    if (--this.#refs === 0 && !this.#refExplicitlySet) {\x0d\n      this.#channel.unref();\x0d\n      this.emit('unref');\x0d\n    }\x0d\n  }\x0d\n\x0d\n  ref() {\x0d\n    this.#refExplicitlySet = true;\x0d\n    this.#channel.ref();\x0d\n  }\x0d\n\x0d\n  unref() {\x0d\n    this.#refExplicitlySet = true;\x0d\n    this.#channel.unref();\x0d\n  }\x0d\n\x0d\n  get fd() {\x0d\n    return this.#channel ? this.#channel.fd : undefined;\x0d\n  }\x0d\n}\x0d\n\x0d\nconst channelDeprecationMsg = '_channel is deprecated. ' +\x0d\n                              'Use ChildProcess.channel instead.';\x0d\n\x0d\nlet serialization;\x0d\nfunction setupChannel(target\x2C channel\x2C serializationMode) {\x0d\n  const control = new Control(channel);\x0d\n  target.channel = control;\x0d\n  target[kChannelHandle] = channel;\x0d\n\x0d\n  ObjectDefineProperty(target\x2C '_channel'\x2C {\x0d\n    get: deprecate(() => {\x0d\n      return target.channel;\x0d\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\x0d\n    set: deprecate((val) => {\x0d\n      target.channel = val;\x0d\n    }\x2C channelDeprecationMsg\x2C 'DEP0129')\x2C\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x0d\n  });\x0d\n\x0d\n  target._handleQueue = null;\x0d\n  target._pendingMessage = null;\x0d\n\x0d\n  if (serialization === undefined)\x0d\n    serialization = require('internal/child_process/serialization');\x0d\n  const {\x0d\n    initMessageChannel\x2C\x0d\n    parseChannelMessages\x2C\x0d\n    writeChannelMessage\x0d\n  } = serialization[serializationMode];\x0d\n\x0d\n  let pendingHandle = null;\x0d\n  initMessageChannel(channel);\x0d\n  channel.pendingHandle = null;\x0d\n  channel.onread = function(arrayBuffer) {\x0d\n    const recvHandle = channel.pendingHandle;\x0d\n    channel.pendingHandle = null;\x0d\n    if (arrayBuffer) {\x0d\n      const nread = streamBaseState[kReadBytesOrError];\x0d\n      const offset = streamBaseState[kArrayBufferOffset];\x0d\n      const pool = new Uint8Array(arrayBuffer\x2C offset\x2C nread);\x0d\n      if (recvHandle)\x0d\n        pendingHandle = recvHandle;\x0d\n\x0d\n      for (const message of parseChannelMessages(channel\x2C pool)) {\x0d\n        // There will be at most one NODE_HANDLE message in every chunk we\x0d\n        // read because SCM_RIGHTS messages don't get coalesced. Make sure\x0d\n        // that we deliver the handle with the right message however.\x0d\n        if (isInternal(message)) {\x0d\n          if (message.cmd === 'NODE_HANDLE') {\x0d\n            handleMessage(message\x2C pendingHandle\x2C true);\x0d\n            pendingHandle = null;\x0d\n          } else {\x0d\n            handleMessage(message\x2C undefined\x2C true);\x0d\n          }\x0d\n        } else {\x0d\n          handleMessage(message\x2C undefined\x2C false);\x0d\n        }\x0d\n      }\x0d\n    } else {\x0d\n      this.buffering = false;\x0d\n      target.disconnect();\x0d\n      channel.onread = nop;\x0d\n      channel.close();\x0d\n      target.channel = null;\x0d\n      maybeClose(target);\x0d\n    }\x0d\n  };\x0d\n\x0d\n  // Object where socket lists will live\x0d\n  channel.sockets = { got: {}\x2C send: {} };\x0d\n\x0d\n  // Handlers will go through this\x0d\n  target.on('internalMessage'\x2C function(message\x2C handle) {\x0d\n    // Once acknowledged - continue sending handles.\x0d\n    if (message.cmd === 'NODE_HANDLE_ACK' ||\x0d\n        message.cmd === 'NODE_HANDLE_NACK') {\x0d\n\x0d\n      if (target._pendingMessage) {\x0d\n        if (message.cmd === 'NODE_HANDLE_ACK') {\x0d\n          closePendingHandle(target);\x0d\n        } else if (target._pendingMessage.retransmissions++ ===\x0d\n                   MAX_HANDLE_RETRANSMISSIONS) {\x0d\n          closePendingHandle(target);\x0d\n          process.emitWarning('Handle did not reach the receiving process ' +\x0d\n                              'correctly'\x2C 'SentHandleNotReceivedWarning');\x0d\n        }\x0d\n      }\x0d\n\x0d\n      assert(ArrayIsArray(target._handleQueue));\x0d\n      const queue = target._handleQueue;\x0d\n      target._handleQueue = null;\x0d\n\x0d\n      if (target._pendingMessage) {\x0d\n        target._send(target._pendingMessage.message\x2C\x0d\n                     target._pendingMessage.handle\x2C\x0d\n                     target._pendingMessage.options\x2C\x0d\n                     target._pendingMessage.callback);\x0d\n      }\x0d\n\x0d\n      for (let i = 0; i < queue.length; i++) {\x0d\n        const args = queue[i];\x0d\n        target._send(args.message\x2C args.handle\x2C args.options\x2C args.callback);\x0d\n      }\x0d\n\x0d\n      // Process a pending disconnect (if any).\x0d\n      if (!target.connected && target.channel && !target._handleQueue)\x0d\n        target._disconnect();\x0d\n\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    if (message.cmd !== 'NODE_HANDLE') return;\x0d\n\x0d\n    // It is possible that the handle is not received because of some error on\x0d\n    // ancillary data reception such as MSG_CTRUNC. In this case\x2C report the\x0d\n    // sender about it by sending a NODE_HANDLE_NACK message.\x0d\n    if (!handle)\x0d\n      return target._send({ cmd: 'NODE_HANDLE_NACK' }\x2C null\x2C true);\x0d\n\x0d\n    // Acknowledge handle receival. Don't emit error events (for example if\x0d\n    // the other side has disconnected) because this call to send() is not\x0d\n    // initiated by the user and it shouldn't be fatal to be unable to ACK\x0d\n    // a message.\x0d\n    target._send({ cmd: 'NODE_HANDLE_ACK' }\x2C null\x2C true);\x0d\n\x0d\n    const obj = handleConversion[message.type];\x0d\n\x0d\n    // Update simultaneous accepts on Windows\x0d\n    if (process.platform === 'win32') {\x0d\n      handle.setSimultaneousAccepts(false);\x0d\n    }\x0d\n\x0d\n    // Convert handle object\x0d\n    obj.got.call(this\x2C message\x2C handle\x2C (handle) => {\x0d\n      handleMessage(message.msg\x2C handle\x2C isInternal(message.msg));\x0d\n    });\x0d\n  });\x0d\n\x0d\n  target.on('newListener'\x2C function() {\x0d\n\x0d\n    process.nextTick(() => {\x0d\n      if (!target.channel || !target.listenerCount('message'))\x0d\n        return;\x0d\n\x0d\n      const messages = target.channel[kPendingMessages];\x0d\n      const { length } = messages;\x0d\n      if (!length) return;\x0d\n\x0d\n      for (let i = 0; i < length; i++) {\x0d\n        ReflectApply(target.emit\x2C target\x2C messages[i]);\x0d\n      }\x0d\n\x0d\n      target.channel[kPendingMessages] = [];\x0d\n    });\x0d\n  });\x0d\n\x0d\n  target.send = function(message\x2C handle\x2C options\x2C callback) {\x0d\n    if (typeof handle === 'function') {\x0d\n      callback = handle;\x0d\n      handle = undefined;\x0d\n      options = undefined;\x0d\n    } else if (typeof options === 'function') {\x0d\n      callback = options;\x0d\n      options = undefined;\x0d\n    } else if (options !== undefined) {\x0d\n      validateObject(options\x2C 'options');\x0d\n    }\x0d\n\x0d\n    options = { swallowErrors: false\x2C ...options };\x0d\n\x0d\n    if (this.connected) {\x0d\n      return this._send(message\x2C handle\x2C options\x2C callback);\x0d\n    }\x0d\n    const ex = new ERR_IPC_CHANNEL_CLOSED();\x0d\n    if (typeof callback === 'function') {\x0d\n      process.nextTick(callback\x2C ex);\x0d\n    } else {\x0d\n      process.nextTick(() => this.emit('error'\x2C ex));\x0d\n    }\x0d\n    return false;\x0d\n  };\x0d\n\x0d\n  target._send = function(message\x2C handle\x2C options\x2C callback) {\x0d\n    assert(this.connected || this.channel);\x0d\n\x0d\n    if (message === undefined)\x0d\n      throw new ERR_MISSING_ARGS('message');\x0d\n\x0d\n    // Non-serializable messages should not reach the remote\x0d\n    // end point; as any failure in the stringification there\x0d\n    // will result in error message that is weakly consumable.\x0d\n    // So perform a final check on message prior to sending.\x0d\n    if (typeof message !== 'string' &&\x0d\n        typeof message !== 'object' &&\x0d\n        typeof message !== 'number' &&\x0d\n        typeof message !== 'boolean') {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'message'\x2C ['string'\x2C 'object'\x2C 'number'\x2C 'boolean']\x2C message);\x0d\n    }\x0d\n\x0d\n    // Support legacy function signature\x0d\n    if (typeof options === 'boolean') {\x0d\n      options = { swallowErrors: options };\x0d\n    }\x0d\n\x0d\n    let obj;\x0d\n\x0d\n    // Package messages with a handle object\x0d\n    if (handle) {\x0d\n      // This message will be handled by an internalMessage event handler\x0d\n      message = {\x0d\n        cmd: 'NODE_HANDLE'\x2C\x0d\n        type: null\x2C\x0d\n        msg: message\x0d\n      };\x0d\n\x0d\n      if (handle instanceof net.Socket) {\x0d\n        message.type = 'net.Socket';\x0d\n      } else if (handle instanceof net.Server) {\x0d\n        message.type = 'net.Server';\x0d\n      } else if (handle instanceof TCP || handle instanceof Pipe) {\x0d\n        message.type = 'net.Native';\x0d\n      } else if (handle instanceof dgram.Socket) {\x0d\n        message.type = 'dgram.Socket';\x0d\n      } else if (handle instanceof UDP) {\x0d\n        message.type = 'dgram.Native';\x0d\n      } else {\x0d\n        throw new ERR_INVALID_HANDLE_TYPE();\x0d\n      }\x0d\n\x0d\n      // Queue-up message and handle if we haven't received ACK yet.\x0d\n      if (this._handleQueue) {\x0d\n        ArrayPrototypePush(this._handleQueue\x2C {\x0d\n          callback: callback\x2C\x0d\n          handle: handle\x2C\x0d\n          options: options\x2C\x0d\n          message: message.msg\x2C\x0d\n        });\x0d\n        return this._handleQueue.length === 1;\x0d\n      }\x0d\n\x0d\n      obj = handleConversion[message.type];\x0d\n\x0d\n      // convert TCP object to native handle object\x0d\n      handle = ReflectApply(handleConversion[message.type].send\x2C\x0d\n                            target\x2C [message\x2C handle\x2C options]);\x0d\n\x0d\n      // If handle was sent twice\x2C or it is impossible to get native handle\x0d\n      // out of it - just send a text without the handle.\x0d\n      if (!handle)\x0d\n        message = message.msg;\x0d\n\x0d\n      // Update simultaneous accepts on Windows\x0d\n      if (obj.simultaneousAccepts && process.platform === 'win32') {\x0d\n        handle.setSimultaneousAccepts(true);\x0d\n      }\x0d\n    } else if (this._handleQueue &&\x0d\n               !(message && (message.cmd === 'NODE_HANDLE_ACK' ||\x0d\n                             message.cmd === 'NODE_HANDLE_NACK'))) {\x0d\n      // Queue request anyway to avoid out-of-order messages.\x0d\n      ArrayPrototypePush(this._handleQueue\x2C {\x0d\n        callback: callback\x2C\x0d\n        handle: null\x2C\x0d\n        options: options\x2C\x0d\n        message: message\x2C\x0d\n      });\x0d\n      return this._handleQueue.length === 1;\x0d\n    }\x0d\n\x0d\n    const req = new WriteWrap();\x0d\n\x0d\n    const err = writeChannelMessage(channel\x2C req\x2C message\x2C handle);\x0d\n    const wasAsyncWrite = streamBaseState[kLastWriteWasAsync];\x0d\n\x0d\n    if (err === 0) {\x0d\n      if (handle) {\x0d\n        if (!this._handleQueue)\x0d\n          this._handleQueue = [];\x0d\n        if (obj && obj.postSend)\x0d\n          obj.postSend(message\x2C handle\x2C options\x2C callback\x2C target);\x0d\n      }\x0d\n\x0d\n      if (wasAsyncWrite) {\x0d\n        req.oncomplete = () => {\x0d\n          control.unrefCounted();\x0d\n          if (typeof callback === 'function')\x0d\n            callback(null);\x0d\n        };\x0d\n        control.refCounted();\x0d\n      } else if (typeof callback === 'function') {\x0d\n        process.nextTick(callback\x2C null);\x0d\n      }\x0d\n    } else {\x0d\n      // Cleanup handle on error\x0d\n      if (obj && obj.postSend)\x0d\n        obj.postSend(message\x2C handle\x2C options\x2C callback);\x0d\n\x0d\n      if (!options.swallowErrors) {\x0d\n        const ex = errnoException(err\x2C 'write');\x0d\n        if (typeof callback === 'function') {\x0d\n          process.nextTick(callback\x2C ex);\x0d\n        } else {\x0d\n          process.nextTick(() => this.emit('error'\x2C ex));\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n\x0d\n    /* If the primary is > 2 read() calls behind\x2C please stop sending. */\x0d\n    return channel.writeQueueSize < (65536 * 2);\x0d\n  };\x0d\n\x0d\n  // Connected will be set to false immediately when a disconnect() is\x0d\n  // requested\x2C even though the channel might still be alive internally to\x0d\n  // process queued messages. The three states are distinguished as follows:\x0d\n  // - disconnect() never requested: channel is not null and connected\x0d\n  //   is true\x0d\n  // - disconnect() requested\x2C messages in the queue: channel is not null\x0d\n  //   and connected is false\x0d\n  // - disconnect() requested\x2C channel actually disconnected: channel is\x0d\n  //   null and connected is false\x0d\n  target.connected = true;\x0d\n\x0d\n  target.disconnect = function() {\x0d\n    if (!this.connected) {\x0d\n      this.emit('error'\x2C new ERR_IPC_DISCONNECTED());\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    // Do not allow any new messages to be written.\x0d\n    this.connected = false;\x0d\n\x0d\n    // If there are no queued messages\x2C disconnect immediately. Otherwise\x2C\x0d\n    // postpone the disconnect so that it happens internally after the\x0d\n    // queue is flushed.\x0d\n    if (!this._handleQueue)\x0d\n      this._disconnect();\x0d\n  };\x0d\n\x0d\n  target._disconnect = function() {\x0d\n    assert(this.channel);\x0d\n\x0d\n    // This marks the fact that the channel is actually disconnected.\x0d\n    this.channel = null;\x0d\n    this[kChannelHandle] = null;\x0d\n\x0d\n    if (this._pendingMessage)\x0d\n      closePendingHandle(this);\x0d\n\x0d\n    let fired = false;\x0d\n    function finish() {\x0d\n      if (fired) return;\x0d\n      fired = true;\x0d\n\x0d\n      channel.close();\x0d\n      target.emit('disconnect');\x0d\n    }\x0d\n\x0d\n    // If a message is being read\x2C then wait for it to complete.\x0d\n    if (channel.buffering) {\x0d\n      this.once('message'\x2C finish);\x0d\n      this.once('internalMessage'\x2C finish);\x0d\n\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    process.nextTick(finish);\x0d\n  };\x0d\n\x0d\n  function emit(event\x2C message\x2C handle) {\x0d\n    if ('internalMessage' === event || target.listenerCount('message')) {\x0d\n      target.emit(event\x2C message\x2C handle);\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    ArrayPrototypePush(\x0d\n      target.channel[kPendingMessages]\x2C\x0d\n      [event\x2C message\x2C handle]\x0d\n    );\x0d\n  }\x0d\n\x0d\n  function handleMessage(message\x2C handle\x2C internal) {\x0d\n    if (!target.channel)\x0d\n      return;\x0d\n\x0d\n    const eventName = (internal ? 'internalMessage' : 'message');\x0d\n\x0d\n    process.nextTick(emit\x2C eventName\x2C message\x2C handle);\x0d\n  }\x0d\n\x0d\n  channel.readStart();\x0d\n  return control;\x0d\n}\x0d\n\x0d\nconst INTERNAL_PREFIX = 'NODE_';\x0d\nfunction isInternal(message) {\x0d\n  return (message !== null &&\x0d\n          typeof message === 'object' &&\x0d\n          typeof message.cmd === 'string' &&\x0d\n          message.cmd.length > INTERNAL_PREFIX.length &&\x0d\n          StringPrototypeSlice(message.cmd\x2C 0\x2C INTERNAL_PREFIX.length) ===\x0d\n            INTERNAL_PREFIX);\x0d\n}\x0d\n\x0d\nconst nop = FunctionPrototype;\x0d\n\x0d\nfunction getValidStdio(stdio\x2C sync) {\x0d\n  let ipc;\x0d\n  let ipcFd;\x0d\n\x0d\n  // Replace shortcut with an array\x0d\n  if (typeof stdio === 'string') {\x0d\n    stdio = stdioStringToArray(stdio);\x0d\n  } else if (!ArrayIsArray(stdio)) {\x0d\n    throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\x0d\n  }\x0d\n\x0d\n  // At least 3 stdio will be created\x0d\n  // Don't concat() a new Array() because it would be sparse\x2C and\x0d\n  // stdio.reduce() would skip the sparse elements of stdio.\x0d\n  // See https://stackoverflow.com/a/5501711/3561\x0d\n  while (stdio.length < 3) ArrayPrototypePush(stdio\x2C undefined);\x0d\n\x0d\n  // Translate stdio into C++-readable form\x0d\n  // (i.e. PipeWraps or fds)\x0d\n  stdio = ArrayPrototypeReduce(stdio\x2C (acc\x2C stdio\x2C i) => {\x0d\n    function cleanup() {\x0d\n      for (let i = 0; i < acc.length; i++) {\x0d\n        if ((acc[i].type === 'pipe' || acc[i].type === 'ipc') && acc[i].handle)\x0d\n          acc[i].handle.close();\x0d\n      }\x0d\n    }\x0d\n\x0d\n    // Defaults\x0d\n    if (stdio == null) {\x0d\n      stdio = i < 3 ? 'pipe' : 'ignore';\x0d\n    }\x0d\n\x0d\n    if (stdio === 'ignore') {\x0d\n      ArrayPrototypePush(acc\x2C { type: 'ignore' });\x0d\n    } else if (stdio === 'pipe' || stdio === 'overlapped' ||\x0d\n               (typeof stdio === 'number' && stdio < 0)) {\x0d\n      const a = {\x0d\n        type: stdio === 'overlapped' ? 'overlapped' : 'pipe'\x2C\x0d\n        readable: i === 0\x2C\x0d\n        writable: i !== 0\x0d\n      };\x0d\n\x0d\n      if (!sync)\x0d\n        a.handle = new Pipe(PipeConstants.SOCKET);\x0d\n\x0d\n      ArrayPrototypePush(acc\x2C a);\x0d\n    } else if (stdio === 'ipc') {\x0d\n      if (sync || ipc !== undefined) {\x0d\n        // Cleanup previously created pipes\x0d\n        cleanup();\x0d\n        if (!sync)\x0d\n          throw new ERR_IPC_ONE_PIPE();\x0d\n        else\x0d\n          throw new ERR_IPC_SYNC_FORK();\x0d\n      }\x0d\n\x0d\n      ipc = new Pipe(PipeConstants.IPC);\x0d\n      ipcFd = i;\x0d\n\x0d\n      ArrayPrototypePush(acc\x2C {\x0d\n        type: 'pipe'\x2C\x0d\n        handle: ipc\x2C\x0d\n        ipc: true\x0d\n      });\x0d\n    } else if (stdio === 'inherit') {\x0d\n      ArrayPrototypePush(acc\x2C {\x0d\n        type: 'inherit'\x2C\x0d\n        fd: i\x0d\n      });\x0d\n    } else if (typeof stdio === 'number' || typeof stdio.fd === 'number') {\x0d\n      ArrayPrototypePush(acc\x2C {\x0d\n        type: 'fd'\x2C\x0d\n        fd: typeof stdio === 'number' ? stdio : stdio.fd\x0d\n      });\x0d\n    } else if (getHandleWrapType(stdio) || getHandleWrapType(stdio.handle) ||\x0d\n               getHandleWrapType(stdio._handle)) {\x0d\n      const handle = getHandleWrapType(stdio) ?\x0d\n        stdio :\x0d\n        getHandleWrapType(stdio.handle) ? stdio.handle : stdio._handle;\x0d\n\x0d\n      ArrayPrototypePush(acc\x2C {\x0d\n        type: 'wrap'\x2C\x0d\n        wrapType: getHandleWrapType(handle)\x2C\x0d\n        handle: handle\x2C\x0d\n        _stdio: stdio\x0d\n      });\x0d\n    } else if (isArrayBufferView(stdio) || typeof stdio === 'string') {\x0d\n      if (!sync) {\x0d\n        cleanup();\x0d\n        throw new ERR_INVALID_SYNC_FORK_INPUT(inspect(stdio));\x0d\n      }\x0d\n    } else {\x0d\n      // Cleanup\x0d\n      cleanup();\x0d\n      throw new ERR_INVALID_ARG_VALUE('stdio'\x2C stdio);\x0d\n    }\x0d\n\x0d\n    return acc;\x0d\n  }\x2C []);\x0d\n\x0d\n  return { stdio\x2C ipc\x2C ipcFd };\x0d\n}\x0d\n\x0d\n\x0d\nfunction getSocketList(type\x2C worker\x2C key) {\x0d\n  const sockets = worker[kChannelHandle].sockets[type];\x0d\n  let socketList = sockets[key];\x0d\n  if (!socketList) {\x0d\n    const Construct = type === 'send' ? SocketListSend : SocketListReceive;\x0d\n    socketList = sockets[key] = new Construct(worker\x2C key);\x0d\n  }\x0d\n  return socketList;\x0d\n}\x0d\n\x0d\n\x0d\nfunction maybeClose(subprocess) {\x0d\n  subprocess._closesGot++;\x0d\n\x0d\n  if (subprocess._closesGot === subprocess._closesNeeded) {\x0d\n    subprocess.emit('close'\x2C subprocess.exitCode\x2C subprocess.signalCode);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction spawnSync(options) {\x0d\n  const result = spawn_sync.spawn(options);\x0d\n\x0d\n  if (result.output && options.encoding && options.encoding !== 'buffer') {\x0d\n    for (let i = 0; i < result.output.length; i++) {\x0d\n      if (!result.output[i])\x0d\n        continue;\x0d\n      result.output[i] = result.output[i].toString(options.encoding);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  result.stdout = result.output && result.output[1];\x0d\n  result.stderr = result.output && result.output[2];\x0d\n\x0d\n  if (result.error) {\x0d\n    result.error = errnoException(result.error\x2C 'spawnSync ' + options.file);\x0d\n    result.error.path = options.file;\x0d\n    result.error.spawnargs = ArrayPrototypeSlice(options.args\x2C 1);\x0d\n  }\x0d\n\x0d\n  return result;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  ChildProcess\x2C\x0d\n  kChannelHandle\x2C\x0d\n  setupChannel\x2C\x0d\n  getValidStdio\x2C\x0d\n  stdioStringToArray\x2C\x0d\n  spawnSync\x0d\n};\x0d\n
code-source-info,0x1c1d96e217e,130,0,32530,C0O0C4O32530,,
code-creation,Function,10,248788,0x1c1d96e379e,1265, node:internal/child_process:1:1,0x1c1d96e20f8,~
code-source-info,0x1c1d96e379e,130,0,32530,C0O0C296O28C302O45C308O68C314O93C320O117C325O139C331O165C337O190C342O215C348O232C354O257C359O268C365O594C371O594C376O312C387O345C393O372C399O400C405O430C411O464C417O493C423O520C429O543C435O567C441O710C447O710C452O634C458O652C464O671C470O689C476O764C482O764C486O764C488O796C494O796C498O796C500O827C506O827C510O827C512O862C518O862C523O894C527O862C529O920C535O920C539O920C541O971C544O971C549O959C555O1119C558O1119C563O1016C569O1030C575O1052C581O1075C587O1098C593O1195C596O1195C601O1160C607O1177C613O1242C616O1242C621O1234C627O1288C630O1288C635O1280C641O1334C644O1334C649O1326C655O1383C661O1383C666O1442C672O1442C677O1473C682O1425C688O1528C694O1528C699O1492C705O1514C711O1585C717O1585C722O1563C728O1637C731O1637C735O1637C737O1694C743O1694C748O1677C754O1847C757O1847C762O1735C768O1749C774O1763C780O1777C786O1791C792O1805C798O1819C804O1833C810O1881C816O1897C822O2057C823O2057C825O2074C826O2074C828O2124C830O2124C832O2151C835O2151C839O2151C841O2201C844O2201C848O2201C850O2253C853O2253C857O2253C859O2410C864O2429C869O2470C877O2540C891O2622C896O2663C904O2741C918O2913C923O2920C931O4529C939O5300C953O5801C958O5843C966O5913C980O5997C985O6039C993O6172C1009O2410C1011O8250C1019O8274C1024O8216C1029O8287C1032O8287C1037O9314C1046O9330C1050O13171C1059O13186C1063O13898C1072O13912C1076O13990C1085O14006C1137O14093C1193O14071C1195O15143C1200O15170C1203O15143C1205O15247C1206O15247C1208O27774C1210O27774C1212O28117C1214O28117C1216O32399C1223O32421C1229O32438C1235O32457C1241O32474C1247O32492C1253O32515C1259O32414C1264O32529,,
code-creation,Function,10,248951,0x1c1d96e3f16,35,<instance_members_initializer> node:internal/child_process:523:3,0x1c1d96e2e60,~
code-source-info,0x1c1d96e3f16,130,14111,14170,C3O14122C16O14139C26O14165C34O14170,,
code-creation,Eval,10,250042,0x1c1d96e80f6,5, node:net:1:1,0x1c1d96e7918,~
script-source,131,node:net,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeIndexOf\x2C\x0d\n  Boolean\x2C\x0d\n  Error\x2C\x0d\n  Number\x2C\x0d\n  NumberIsNaN\x2C\x0d\n  NumberParseInt\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  Symbol\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst EventEmitter = require('events');\x0d\nconst stream = require('stream');\x0d\nlet debug = require('internal/util/debuglog').debuglog('net'\x2C (fn) => {\x0d\n  debug = fn;\x0d\n});\x0d\nconst {\x0d\n  isIP\x2C\x0d\n  isIPv4\x2C\x0d\n  isIPv6\x2C\x0d\n  normalizedArgsSymbol\x2C\x0d\n  makeSyncWrite\x0d\n} = require('internal/net');\x0d\nconst assert = require('internal/assert');\x0d\nconst {\x0d\n  UV_EADDRINUSE\x2C\x0d\n  UV_EINVAL\x2C\x0d\n  UV_ENOTCONN\x0d\n} = internalBinding('uv');\x0d\n\x0d\nconst { Buffer } = require('buffer');\x0d\nconst { guessHandleType } = internalBinding('util');\x0d\nconst { ShutdownWrap } = internalBinding('stream_wrap');\x0d\nconst {\x0d\n  TCP\x2C\x0d\n  TCPConnectWrap\x2C\x0d\n  constants: TCPConstants\x0d\n} = internalBinding('tcp_wrap');\x0d\nconst {\x0d\n  Pipe\x2C\x0d\n  PipeConnectWrap\x2C\x0d\n  constants: PipeConstants\x0d\n} = internalBinding('pipe_wrap');\x0d\nconst {\x0d\n  newAsyncId\x2C\x0d\n  defaultTriggerAsyncIdScope\x2C\x0d\n  symbols: { async_id_symbol\x2C owner_symbol }\x0d\n} = require('internal/async_hooks');\x0d\nconst {\x0d\n  writevGeneric\x2C\x0d\n  writeGeneric\x2C\x0d\n  onStreamRead\x2C\x0d\n  kAfterAsyncWrite\x2C\x0d\n  kHandle\x2C\x0d\n  kUpdateTimer\x2C\x0d\n  setStreamTimeout\x2C\x0d\n  kBuffer\x2C\x0d\n  kBufferCb\x2C\x0d\n  kBufferGen\x0d\n} = require('internal/stream_base_commons');\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_INVALID_ADDRESS_FAMILY\x2C\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n    ERR_INVALID_FD_TYPE\x2C\x0d\n    ERR_INVALID_IP_ADDRESS\x2C\x0d\n    ERR_SERVER_ALREADY_LISTEN\x2C\x0d\n    ERR_SERVER_NOT_RUNNING\x2C\x0d\n    ERR_SOCKET_CLOSED\x2C\x0d\n    ERR_MISSING_ARGS\x2C\x0d\n  }\x2C\x0d\n  errnoException\x2C\x0d\n  exceptionWithHostPort\x2C\x0d\n  uvExceptionWithHostPort\x0d\n} = require('internal/errors');\x0d\nconst { isUint8Array } = require('internal/util/types');\x0d\nconst {\x0d\n  validateAbortSignal\x2C\x0d\n  validateFunction\x2C\x0d\n  validateInt32\x2C\x0d\n  validateNumber\x2C\x0d\n  validatePort\x2C\x0d\n  validateString\x0d\n} = require('internal/validators');\x0d\nconst kLastWriteQueueSize = Symbol('lastWriteQueueSize');\x0d\nconst {\x0d\n  DTRACE_NET_SERVER_CONNECTION\x2C\x0d\n  DTRACE_NET_STREAM_END\x0d\n} = require('internal/dtrace');\x0d\n\x0d\n// Lazy loaded to improve startup performance.\x0d\nlet cluster;\x0d\nlet dns;\x0d\nlet BlockList;\x0d\nlet SocketAddress;\x0d\n\x0d\nconst { clearTimeout } = require('timers');\x0d\nconst { kTimeout } = require('internal/timers');\x0d\n\x0d\nconst DEFAULT_IPV4_ADDR = '0.0.0.0';\x0d\nconst DEFAULT_IPV6_ADDR = '::';\x0d\n\x0d\nconst isWindows = process.platform === 'win32';\x0d\n\x0d\nconst noop = () => {};\x0d\n\x0d\nfunction getFlags(ipv6Only) {\x0d\n  return ipv6Only === true ? TCPConstants.UV_TCP_IPV6ONLY : 0;\x0d\n}\x0d\n\x0d\nfunction createHandle(fd\x2C is_server) {\x0d\n  validateInt32(fd\x2C 'fd'\x2C 0);\x0d\n  const type = guessHandleType(fd);\x0d\n  if (type === 'PIPE') {\x0d\n    return new Pipe(\x0d\n      is_server ? PipeConstants.SERVER : PipeConstants.SOCKET\x0d\n    );\x0d\n  }\x0d\n\x0d\n  if (type === 'TCP') {\x0d\n    return new TCP(\x0d\n      is_server ? TCPConstants.SERVER : TCPConstants.SOCKET\x0d\n    );\x0d\n  }\x0d\n\x0d\n  throw new ERR_INVALID_FD_TYPE(type);\x0d\n}\x0d\n\x0d\n\x0d\nfunction getNewAsyncId(handle) {\x0d\n  return (!handle || typeof handle.getAsyncId !== 'function') ?\x0d\n    newAsyncId() : handle.getAsyncId();\x0d\n}\x0d\n\x0d\n\x0d\nfunction isPipeName(s) {\x0d\n  return typeof s === 'string' && toNumber(s) === false;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Creates a new TCP or IPC server\x0d\n * @param {{\x0d\n *   allowHalfOpen?: boolean;\x0d\n *   pauseOnConnect?: boolean;\x0d\n *   }} [options]\x0d\n * @param {Function} [connectionListener]\x0d\n * @returns {Server}\x0d\n */\x0d\n\x0d\nfunction createServer(options\x2C connectionListener) {\x0d\n  return new Server(options\x2C connectionListener);\x0d\n}\x0d\n\x0d\n\x0d\n// Target API:\x0d\n//\x0d\n// let s = net.connect({port: 80\x2C host: 'google.com'}\x2C function() {\x0d\n//   ...\x0d\n// });\x0d\n//\x0d\n// There are various forms:\x0d\n//\x0d\n// connect(options\x2C [cb])\x0d\n// connect(port\x2C [host]\x2C [cb])\x0d\n// connect(path\x2C [cb]);\x0d\n//\x0d\nfunction connect(...args) {\x0d\n  const normalized = normalizeArgs(args);\x0d\n  const options = normalized[0];\x0d\n  debug('createConnection'\x2C normalized);\x0d\n  const socket = new Socket(options);\x0d\n\x0d\n  if (options.timeout) {\x0d\n    socket.setTimeout(options.timeout);\x0d\n  }\x0d\n\x0d\n  return socket.connect(normalized);\x0d\n}\x0d\n\x0d\n\x0d\n// Returns an array [options\x2C cb]\x2C where options is an object\x2C\x0d\n// cb is either a function or null.\x0d\n// Used to normalize arguments of Socket.prototype.connect() and\x0d\n// Server.prototype.listen(). Possible combinations of parameters:\x0d\n//   (options[...][\x2C cb])\x0d\n//   (path[...][\x2C cb])\x0d\n//   ([port][\x2C host][...][\x2C cb])\x0d\n// For Socket.prototype.connect()\x2C the [...] part is ignored\x0d\n// For Server.prototype.listen()\x2C the [...] part is [\x2C backlog]\x0d\n// but will not be handled here (handled in listen())\x0d\nfunction normalizeArgs(args) {\x0d\n  let arr;\x0d\n\x0d\n  if (args.length === 0) {\x0d\n    arr = [{}\x2C null];\x0d\n    arr[normalizedArgsSymbol] = true;\x0d\n    return arr;\x0d\n  }\x0d\n\x0d\n  const arg0 = args[0];\x0d\n  let options = {};\x0d\n  if (typeof arg0 === 'object' && arg0 !== null) {\x0d\n    // (options[...][\x2C cb])\x0d\n    options = arg0;\x0d\n  } else if (isPipeName(arg0)) {\x0d\n    // (path[...][\x2C cb])\x0d\n    options.path = arg0;\x0d\n  } else {\x0d\n    // ([port][\x2C host][...][\x2C cb])\x0d\n    options.port = arg0;\x0d\n    if (args.length > 1 && typeof args[1] === 'string') {\x0d\n      options.host = args[1];\x0d\n    }\x0d\n  }\x0d\n\x0d\n  const cb = args[args.length - 1];\x0d\n  if (typeof cb !== 'function')\x0d\n    arr = [options\x2C null];\x0d\n  else\x0d\n    arr = [options\x2C cb];\x0d\n\x0d\n  arr[normalizedArgsSymbol] = true;\x0d\n  return arr;\x0d\n}\x0d\n\x0d\n\x0d\n// Called when creating new Socket\x2C or when re-using a closed Socket\x0d\nfunction initSocketHandle(self) {\x0d\n  self._undestroy();\x0d\n  self._sockname = null;\x0d\n\x0d\n  // Handle creation may be deferred to bind() or connect() time.\x0d\n  if (self._handle) {\x0d\n    self._handle[owner_symbol] = self;\x0d\n    self._handle.onread = onStreamRead;\x0d\n    self[async_id_symbol] = getNewAsyncId(self._handle);\x0d\n\x0d\n    let userBuf = self[kBuffer];\x0d\n    if (userBuf) {\x0d\n      const bufGen = self[kBufferGen];\x0d\n      if (bufGen !== null) {\x0d\n        userBuf = bufGen();\x0d\n        if (!isUint8Array(userBuf))\x0d\n          return;\x0d\n        self[kBuffer] = userBuf;\x0d\n      }\x0d\n      self._handle.useUserBuffer(userBuf);\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nconst kBytesRead = Symbol('kBytesRead');\x0d\nconst kBytesWritten = Symbol('kBytesWritten');\x0d\nconst kSetNoDelay = Symbol('kSetNoDelay');\x0d\n\x0d\nfunction Socket(options) {\x0d\n  if (!(this instanceof Socket)) return new Socket(options);\x0d\n  if (options?.objectMode) {\x0d\n    throw new ERR_INVALID_ARG_VALUE(\x0d\n      'options.objectMode'\x2C\x0d\n      options.objectMode\x2C\x0d\n      'is not supported'\x0d\n    );\x0d\n  } else if (options?.readableObjectMode || options?.writableObjectMode) {\x0d\n    throw new ERR_INVALID_ARG_VALUE(\x0d\n      `options.${\x0d\n        options.readableObjectMode ? 'readableObjectMode' : 'writableObjectMode'\x0d\n      }`\x2C\x0d\n      options.readableObjectMode || options.writableObjectMode\x2C\x0d\n      'is not supported'\x0d\n    );\x0d\n  }\x0d\n\x0d\n  this.connecting = false;\x0d\n  // Problem with this is that users can supply their own handle\x2C that may not\x0d\n  // have _handle.getAsyncId(). In this case an[async_id_symbol] should\x0d\n  // probably be supplied by async_hooks.\x0d\n  this[async_id_symbol] = -1;\x0d\n  this._hadError = false;\x0d\n  this[kHandle] = null;\x0d\n  this._parent = null;\x0d\n  this._host = null;\x0d\n  this[kSetNoDelay] = false;\x0d\n  this[kLastWriteQueueSize] = 0;\x0d\n  this[kTimeout] = null;\x0d\n  this[kBuffer] = null;\x0d\n  this[kBufferCb] = null;\x0d\n  this[kBufferGen] = null;\x0d\n\x0d\n  if (typeof options === 'number')\x0d\n    options = { fd: options }; // Legacy interface.\x0d\n  else\x0d\n    options = { ...options };\x0d\n\x0d\n  // Default to *not* allowing half open sockets.\x0d\n  options.allowHalfOpen = Boolean(options.allowHalfOpen);\x0d\n  // For backwards compat do not emit close on destroy.\x0d\n  options.emitClose = false;\x0d\n  options.autoDestroy = true;\x0d\n  // Handle strings directly.\x0d\n  options.decodeStrings = false;\x0d\n  stream.Duplex.call(this\x2C options);\x0d\n\x0d\n  if (options.handle) {\x0d\n    this._handle = options.handle; // private\x0d\n    this[async_id_symbol] = getNewAsyncId(this._handle);\x0d\n  } else if (options.fd !== undefined) {\x0d\n    const { fd } = options;\x0d\n    let err;\x0d\n\x0d\n    // createHandle will throw ERR_INVALID_FD_TYPE if `fd` is not\x0d\n    // a valid `PIPE` or `TCP` descriptor\x0d\n    this._handle = createHandle(fd\x2C false);\x0d\n\x0d\n    err = this._handle.open(fd);\x0d\n\x0d\n    // While difficult to fabricate\x2C in some architectures\x0d\n    // `open` may return an error code for valid file descriptors\x0d\n    // which cannot be opened. This is difficult to test as most\x0d\n    // un-openable fds will throw on `createHandle`\x0d\n    if (err)\x0d\n      throw errnoException(err\x2C 'open');\x0d\n\x0d\n    this[async_id_symbol] = this._handle.getAsyncId();\x0d\n\x0d\n    if ((fd === 1 || fd === 2) &&\x0d\n        (this._handle instanceof Pipe) && isWindows) {\x0d\n      // Make stdout and stderr blocking on Windows\x0d\n      err = this._handle.setBlocking(true);\x0d\n      if (err)\x0d\n        throw errnoException(err\x2C 'setBlocking');\x0d\n\x0d\n      this._writev = null;\x0d\n      this._write = makeSyncWrite(fd);\x0d\n      // makeSyncWrite adjusts this value like the original handle would\x2C so\x0d\n      // we need to let it do that by turning it into a writable\x2C own\x0d\n      // property.\x0d\n      ObjectDefineProperty(this._handle\x2C 'bytesWritten'\x2C {\x0d\n        value: 0\x2C writable: true\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n\x0d\n  const onread = options.onread;\x0d\n  if (onread !== null && typeof onread === 'object' &&\x0d\n      (isUint8Array(onread.buffer) || typeof onread.buffer === 'function') &&\x0d\n      typeof onread.callback === 'function') {\x0d\n    if (typeof onread.buffer === 'function') {\x0d\n      this[kBuffer] = true;\x0d\n      this[kBufferGen] = onread.buffer;\x0d\n    } else {\x0d\n      this[kBuffer] = onread.buffer;\x0d\n    }\x0d\n    this[kBufferCb] = onread.callback;\x0d\n  }\x0d\n\x0d\n  // Shut down the socket when we're finished with it.\x0d\n  this.on('end'\x2C onReadableStreamEnd);\x0d\n\x0d\n  initSocketHandle(this);\x0d\n\x0d\n  this._pendingData = null;\x0d\n  this._pendingEncoding = '';\x0d\n\x0d\n  // If we have a handle\x2C then start the flow of data into the\x0d\n  // buffer.  if not\x2C then this will happen when we connect\x0d\n  if (this._handle && options.readable !== false) {\x0d\n    if (options.pauseOnCreate) {\x0d\n      // Stop the handle from reading and pause the stream\x0d\n      this._handle.reading = false;\x0d\n      this._handle.readStop();\x0d\n      this.readableFlowing = false;\x0d\n    } else if (!options.manualStart) {\x0d\n      this.read(0);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // Reserve properties\x0d\n  this.server = null;\x0d\n  this._server = null;\x0d\n\x0d\n  // Used after `.destroy()`\x0d\n  this[kBytesRead] = 0;\x0d\n  this[kBytesWritten] = 0;\x0d\n}\x0d\nObjectSetPrototypeOf(Socket.prototype\x2C stream.Duplex.prototype);\x0d\nObjectSetPrototypeOf(Socket\x2C stream.Duplex);\x0d\n\x0d\n// Refresh existing timeouts.\x0d\nSocket.prototype._unrefTimer = function _unrefTimer() {\x0d\n  for (let s = this; s !== null; s = s._parent) {\x0d\n    if (s[kTimeout])\x0d\n      s[kTimeout].refresh();\x0d\n  }\x0d\n};\x0d\n\x0d\n\x0d\n// The user has called .end()\x2C and all the bytes have been\x0d\n// sent out to the other side.\x0d\nSocket.prototype._final = function(cb) {\x0d\n  // If still connecting - defer handling `_final` until 'connect' will happen\x0d\n  if (this.pending) {\x0d\n    debug('_final: not yet connected');\x0d\n    return this.once('connect'\x2C () => this._final(cb));\x0d\n  }\x0d\n\x0d\n  if (!this._handle)\x0d\n    return cb();\x0d\n\x0d\n  debug('_final: not ended\x2C call shutdown()');\x0d\n\x0d\n  const req = new ShutdownWrap();\x0d\n  req.oncomplete = afterShutdown;\x0d\n  req.handle = this._handle;\x0d\n  req.callback = cb;\x0d\n  const err = this._handle.shutdown(req);\x0d\n\x0d\n  if (err === 1 || err === UV_ENOTCONN)  // synchronous finish\x0d\n    return cb();\x0d\n  else if (err !== 0)\x0d\n    return cb(errnoException(err\x2C 'shutdown'));\x0d\n};\x0d\n\x0d\nfunction afterShutdown() {\x0d\n  const self = this.handle[owner_symbol];\x0d\n\x0d\n  debug('afterShutdown destroyed=%j'\x2C self.destroyed\x2C\x0d\n        self._readableState);\x0d\n\x0d\n  this.callback();\x0d\n}\x0d\n\x0d\n// Provide a better error message when we call end() as a result\x0d\n// of the other side sending a FIN.  The standard 'write after end'\x0d\n// is overly vague\x2C and makes it seem like the user's code is to blame.\x0d\nfunction writeAfterFIN(chunk\x2C encoding\x2C cb) {\x0d\n  if (!this.writableEnded) {\x0d\n    return stream.Duplex.prototype.write.call(this\x2C chunk\x2C encoding\x2C cb);\x0d\n  }\x0d\n\x0d\n  if (typeof encoding === 'function') {\x0d\n    cb = encoding;\x0d\n    encoding = null;\x0d\n  }\x0d\n\x0d\n  // eslint-disable-next-line no-restricted-syntax\x0d\n  const er = new Error('This socket has been ended by the other party');\x0d\n  er.code = 'EPIPE';\x0d\n  if (typeof cb === 'function') {\x0d\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C process.nextTick\x2C cb\x2C er);\x0d\n  }\x0d\n  this.destroy(er);\x0d\n\x0d\n  return false;\x0d\n}\x0d\n\x0d\nSocket.prototype.setTimeout = setStreamTimeout;\x0d\n\x0d\n\x0d\nSocket.prototype._onTimeout = function() {\x0d\n  const handle = this._handle;\x0d\n  const lastWriteQueueSize = this[kLastWriteQueueSize];\x0d\n  if (lastWriteQueueSize > 0 && handle) {\x0d\n    // `lastWriteQueueSize !== writeQueueSize` means there is\x0d\n    // an active write in progress\x2C so we suppress the timeout.\x0d\n    const { writeQueueSize } = handle;\x0d\n    if (lastWriteQueueSize !== writeQueueSize) {\x0d\n      this[kLastWriteQueueSize] = writeQueueSize;\x0d\n      this._unrefTimer();\x0d\n      return;\x0d\n    }\x0d\n  }\x0d\n  debug('_onTimeout');\x0d\n  this.emit('timeout');\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.setNoDelay = function(enable) {\x0d\n  if (!this._handle) {\x0d\n    this.once('connect'\x2C\x0d\n              enable ? this.setNoDelay : () => this.setNoDelay(enable));\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  // Backwards compatibility: assume true when `enable` is omitted\x0d\n  const newValue = enable === undefined ? true : !!enable;\x0d\n  if (this._handle.setNoDelay && newValue !== this[kSetNoDelay]) {\x0d\n    this[kSetNoDelay] = newValue;\x0d\n    this._handle.setNoDelay(newValue);\x0d\n  }\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.setKeepAlive = function(setting\x2C msecs) {\x0d\n  if (!this._handle) {\x0d\n    this.once('connect'\x2C () => this.setKeepAlive(setting\x2C msecs));\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  if (this._handle.setKeepAlive)\x0d\n    this._handle.setKeepAlive(setting\x2C ~~(msecs / 1000));\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.address = function() {\x0d\n  return this._getsockname();\x0d\n};\x0d\n\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C '_connecting'\x2C {\x0d\n  get: function() {\x0d\n    return this.connecting;\x0d\n  }\x0d\n});\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C 'pending'\x2C {\x0d\n  get() {\x0d\n    return !this._handle || this.connecting;\x0d\n  }\x2C\x0d\n  configurable: true\x0d\n});\x0d\n\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C 'readyState'\x2C {\x0d\n  get: function() {\x0d\n    if (this.connecting) {\x0d\n      return 'opening';\x0d\n    } else if (this.readable && this.writable) {\x0d\n      return 'open';\x0d\n    } else if (this.readable && !this.writable) {\x0d\n      return 'readOnly';\x0d\n    } else if (!this.readable && this.writable) {\x0d\n      return 'writeOnly';\x0d\n    }\x0d\n    return 'closed';\x0d\n  }\x0d\n});\x0d\n\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C 'bufferSize'\x2C {\x0d\n  get: function() {\x0d\n    if (this._handle) {\x0d\n      return this.writableLength;\x0d\n    }\x0d\n  }\x0d\n});\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C kUpdateTimer\x2C {\x0d\n  get: function() {\x0d\n    return this._unrefTimer;\x0d\n  }\x0d\n});\x0d\n\x0d\n\x0d\nfunction tryReadStart(socket) {\x0d\n  // Not already reading\x2C start the flow\x0d\n  debug('Socket._handle.readStart');\x0d\n  socket._handle.reading = true;\x0d\n  const err = socket._handle.readStart();\x0d\n  if (err)\x0d\n    socket.destroy(errnoException(err\x2C 'read'));\x0d\n}\x0d\n\x0d\n// Just call handle.readStart until we have enough in the buffer\x0d\nSocket.prototype._read = function(n) {\x0d\n  debug('_read');\x0d\n\x0d\n  if (this.connecting || !this._handle) {\x0d\n    debug('_read wait for connection');\x0d\n    this.once('connect'\x2C () => this._read(n));\x0d\n  } else if (!this._handle.reading) {\x0d\n    tryReadStart(this);\x0d\n  }\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.end = function(data\x2C encoding\x2C callback) {\x0d\n  stream.Duplex.prototype.end.call(this\x2C\x0d\n                                   data\x2C encoding\x2C callback);\x0d\n  DTRACE_NET_STREAM_END(this);\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.pause = function() {\x0d\n  if (this[kBuffer] && !this.connecting && this._handle &&\x0d\n      this._handle.reading) {\x0d\n    this._handle.reading = false;\x0d\n    if (!this.destroyed) {\x0d\n      const err = this._handle.readStop();\x0d\n      if (err)\x0d\n        this.destroy(errnoException(err\x2C 'read'));\x0d\n    }\x0d\n  }\x0d\n  return stream.Duplex.prototype.pause.call(this);\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.resume = function() {\x0d\n  if (this[kBuffer] && !this.connecting && this._handle &&\x0d\n      !this._handle.reading) {\x0d\n    tryReadStart(this);\x0d\n  }\x0d\n  return stream.Duplex.prototype.resume.call(this);\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.read = function(n) {\x0d\n  if (this[kBuffer] && !this.connecting && this._handle &&\x0d\n      !this._handle.reading) {\x0d\n    tryReadStart(this);\x0d\n  }\x0d\n  return stream.Duplex.prototype.read.call(this\x2C n);\x0d\n};\x0d\n\x0d\n\x0d\n// Called when the 'end' event is emitted.\x0d\nfunction onReadableStreamEnd() {\x0d\n  if (!this.allowHalfOpen) {\x0d\n    this.write = writeAfterFIN;\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nSocket.prototype.destroySoon = function() {\x0d\n  if (this.writable)\x0d\n    this.end();\x0d\n\x0d\n  if (this.writableFinished)\x0d\n    this.destroy();\x0d\n  else\x0d\n    this.once('finish'\x2C this.destroy);\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype._destroy = function(exception\x2C cb) {\x0d\n  debug('destroy');\x0d\n\x0d\n  this.connecting = false;\x0d\n\x0d\n  for (let s = this; s !== null; s = s._parent) {\x0d\n    clearTimeout(s[kTimeout]);\x0d\n  }\x0d\n\x0d\n  debug('close');\x0d\n  if (this._handle) {\x0d\n    if (this !== process.stderr)\x0d\n      debug('close handle');\x0d\n    const isException = exception ? true : false;\x0d\n    // `bytesRead` and `kBytesWritten` should be accessible after `.destroy()`\x0d\n    this[kBytesRead] = this._handle.bytesRead;\x0d\n    this[kBytesWritten] = this._handle.bytesWritten;\x0d\n\x0d\n    this._handle.close(() => {\x0d\n      debug('emit close');\x0d\n      this.emit('close'\x2C isException);\x0d\n    });\x0d\n    this._handle.onread = noop;\x0d\n    this._handle = null;\x0d\n    this._sockname = null;\x0d\n    cb(exception);\x0d\n  } else {\x0d\n    cb(exception);\x0d\n    process.nextTick(emitCloseNT\x2C this);\x0d\n  }\x0d\n\x0d\n  if (this._server) {\x0d\n    debug('has server');\x0d\n    this._server._connections--;\x0d\n    if (this._server._emitCloseIfDrained) {\x0d\n      this._server._emitCloseIfDrained();\x0d\n    }\x0d\n  }\x0d\n};\x0d\n\x0d\nSocket.prototype._getpeername = function() {\x0d\n  if (!this._handle || !this._handle.getpeername) {\x0d\n    return this._peername || {};\x0d\n  } else if (!this._peername) {\x0d\n    this._peername = {};\x0d\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\x0d\n    this._handle.getpeername(this._peername);\x0d\n  }\x0d\n  return this._peername;\x0d\n};\x0d\n\x0d\nfunction protoGetter(name\x2C callback) {\x0d\n  ObjectDefineProperty(Socket.prototype\x2C name\x2C {\x0d\n    configurable: false\x2C\x0d\n    enumerable: true\x2C\x0d\n    get: callback\x0d\n  });\x0d\n}\x0d\n\x0d\nprotoGetter('bytesRead'\x2C function bytesRead() {\x0d\n  return this._handle ? this._handle.bytesRead : this[kBytesRead];\x0d\n});\x0d\n\x0d\nprotoGetter('remoteAddress'\x2C function remoteAddress() {\x0d\n  return this._getpeername().address;\x0d\n});\x0d\n\x0d\nprotoGetter('remoteFamily'\x2C function remoteFamily() {\x0d\n  return this._getpeername().family;\x0d\n});\x0d\n\x0d\nprotoGetter('remotePort'\x2C function remotePort() {\x0d\n  return this._getpeername().port;\x0d\n});\x0d\n\x0d\n\x0d\nSocket.prototype._getsockname = function() {\x0d\n  if (!this._handle || !this._handle.getsockname) {\x0d\n    return {};\x0d\n  } else if (!this._sockname) {\x0d\n    this._sockname = {};\x0d\n    // FIXME(bnoordhuis) Throw when the return value is not 0?\x0d\n    this._handle.getsockname(this._sockname);\x0d\n  }\x0d\n  return this._sockname;\x0d\n};\x0d\n\x0d\n\x0d\nprotoGetter('localAddress'\x2C function localAddress() {\x0d\n  return this._getsockname().address;\x0d\n});\x0d\n\x0d\n\x0d\nprotoGetter('localPort'\x2C function localPort() {\x0d\n  return this._getsockname().port;\x0d\n});\x0d\n\x0d\n\x0d\nSocket.prototype[kAfterAsyncWrite] = function() {\x0d\n  this[kLastWriteQueueSize] = 0;\x0d\n};\x0d\n\x0d\nSocket.prototype._writeGeneric = function(writev\x2C data\x2C encoding\x2C cb) {\x0d\n  // If we are still connecting\x2C then buffer this for later.\x0d\n  // The Writable logic will buffer up any more writes while\x0d\n  // waiting for this one to be done.\x0d\n  if (this.connecting) {\x0d\n    this._pendingData = data;\x0d\n    this._pendingEncoding = encoding;\x0d\n    this.once('connect'\x2C function connect() {\x0d\n      this._writeGeneric(writev\x2C data\x2C encoding\x2C cb);\x0d\n    });\x0d\n    return;\x0d\n  }\x0d\n  this._pendingData = null;\x0d\n  this._pendingEncoding = '';\x0d\n\x0d\n  if (!this._handle) {\x0d\n    cb(new ERR_SOCKET_CLOSED());\x0d\n    return false;\x0d\n  }\x0d\n\x0d\n  this._unrefTimer();\x0d\n\x0d\n  let req;\x0d\n  if (writev)\x0d\n    req = writevGeneric(this\x2C data\x2C cb);\x0d\n  else\x0d\n    req = writeGeneric(this\x2C data\x2C encoding\x2C cb);\x0d\n  if (req.async)\x0d\n    this[kLastWriteQueueSize] = req.bytes;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype._writev = function(chunks\x2C cb) {\x0d\n  this._writeGeneric(true\x2C chunks\x2C ''\x2C cb);\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype._write = function(data\x2C encoding\x2C cb) {\x0d\n  this._writeGeneric(false\x2C data\x2C encoding\x2C cb);\x0d\n};\x0d\n\x0d\n\x0d\n// Legacy alias. Having this is probably being overly cautious\x2C but it doesn't\x0d\n// really hurt anyone either. This can probably be removed safely if desired.\x0d\nprotoGetter('_bytesDispatched'\x2C function _bytesDispatched() {\x0d\n  return this._handle ? this._handle.bytesWritten : this[kBytesWritten];\x0d\n});\x0d\n\x0d\nprotoGetter('bytesWritten'\x2C function bytesWritten() {\x0d\n  let bytes = this._bytesDispatched;\x0d\n  const data = this._pendingData;\x0d\n  const encoding = this._pendingEncoding;\x0d\n  const writableBuffer = this.writableBuffer;\x0d\n\x0d\n  if (!writableBuffer)\x0d\n    return undefined;\x0d\n\x0d\n  for (const el of writableBuffer) {\x0d\n    bytes += el.chunk instanceof Buffer ?\x0d\n      el.chunk.length :\x0d\n      Buffer.byteLength(el.chunk\x2C el.encoding);\x0d\n  }\x0d\n\x0d\n  if (ArrayIsArray(data)) {\x0d\n    // Was a writev\x2C iterate over chunks to get total length\x0d\n    for (let i = 0; i < data.length; i++) {\x0d\n      const chunk = data[i];\x0d\n\x0d\n      if (data.allBuffers || chunk instanceof Buffer)\x0d\n        bytes += chunk.length;\x0d\n      else\x0d\n        bytes += Buffer.byteLength(chunk.chunk\x2C chunk.encoding);\x0d\n    }\x0d\n  } else if (data) {\x0d\n    // Writes are either a string or a Buffer.\x0d\n    if (typeof data !== 'string')\x0d\n      bytes += data.length;\x0d\n    else\x0d\n      bytes += Buffer.byteLength(data\x2C encoding);\x0d\n  }\x0d\n\x0d\n  return bytes;\x0d\n});\x0d\n\x0d\n\x0d\nfunction checkBindError(err\x2C port\x2C handle) {\x0d\n  // EADDRINUSE may not be reported until we call listen() or connect().\x0d\n  // To complicate matters\x2C a failed bind() followed by listen() or connect()\x0d\n  // will implicitly bind to a random port. Ergo\x2C check that the socket is\x0d\n  // bound to the expected port before calling listen() or connect().\x0d\n  //\x0d\n  // FIXME(bnoordhuis) Doesn't work for pipe handles\x2C they don't have a\x0d\n  // getsockname() method. Non-issue for now\x2C the cluster module doesn't\x0d\n  // really support pipes anyway.\x0d\n  if (err === 0 && port > 0 && handle.getsockname) {\x0d\n    const out = {};\x0d\n    err = handle.getsockname(out);\x0d\n    if (err === 0 && port !== out.port) {\x0d\n      debug(`checkBindError\x2C bound to ${out.port} instead of ${port}`);\x0d\n      err = UV_EADDRINUSE;\x0d\n    }\x0d\n  }\x0d\n  return err;\x0d\n}\x0d\n\x0d\n\x0d\nfunction internalConnect(\x0d\n  self\x2C address\x2C port\x2C addressType\x2C localAddress\x2C localPort\x2C flags) {\x0d\n  // TODO return promise from Socket.prototype.connect which\x0d\n  // wraps _connectReq.\x0d\n\x0d\n  assert(self.connecting);\x0d\n\x0d\n  let err;\x0d\n\x0d\n  if (localAddress || localPort) {\x0d\n    if (addressType === 4) {\x0d\n      localAddress = localAddress || DEFAULT_IPV4_ADDR;\x0d\n      err = self._handle.bind(localAddress\x2C localPort);\x0d\n    } else { // addressType === 6\x0d\n      localAddress = localAddress || DEFAULT_IPV6_ADDR;\x0d\n      err = self._handle.bind6(localAddress\x2C localPort\x2C flags);\x0d\n    }\x0d\n    debug('binding to localAddress: %s and localPort: %d (addressType: %d)'\x2C\x0d\n          localAddress\x2C localPort\x2C addressType);\x0d\n\x0d\n    err = checkBindError(err\x2C localPort\x2C self._handle);\x0d\n    if (err) {\x0d\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C localAddress\x2C localPort);\x0d\n      self.destroy(ex);\x0d\n      return;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (addressType === 6 || addressType === 4) {\x0d\n    const req = new TCPConnectWrap();\x0d\n    req.oncomplete = afterConnect;\x0d\n    req.address = address;\x0d\n    req.port = port;\x0d\n    req.localAddress = localAddress;\x0d\n    req.localPort = localPort;\x0d\n\x0d\n    if (addressType === 4)\x0d\n      err = self._handle.connect(req\x2C address\x2C port);\x0d\n    else\x0d\n      err = self._handle.connect6(req\x2C address\x2C port);\x0d\n  } else {\x0d\n    const req = new PipeConnectWrap();\x0d\n    req.address = address;\x0d\n    req.oncomplete = afterConnect;\x0d\n\x0d\n    err = self._handle.connect(req\x2C address\x2C afterConnect);\x0d\n  }\x0d\n\x0d\n  if (err) {\x0d\n    const sockname = self._getsockname();\x0d\n    let details;\x0d\n\x0d\n    if (sockname) {\x0d\n      details = sockname.address + ':' + sockname.port;\x0d\n    }\x0d\n\x0d\n    const ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port\x2C details);\x0d\n    self.destroy(ex);\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nSocket.prototype.connect = function(...args) {\x0d\n  let normalized;\x0d\n  // If passed an array\x2C it's treated as an array of arguments that have\x0d\n  // already been normalized (so we don't normalize more than once). This has\x0d\n  // been solved before in https://github.com/nodejs/node/pull/12342\x2C but was\x0d\n  // reverted as it had unintended side effects.\x0d\n  if (ArrayIsArray(args[0]) && args[0][normalizedArgsSymbol]) {\x0d\n    normalized = args[0];\x0d\n  } else {\x0d\n    normalized = normalizeArgs(args);\x0d\n  }\x0d\n  const options = normalized[0];\x0d\n  const cb = normalized[1];\x0d\n\x0d\n  // options.port === null will be checked later.\x0d\n  if (options.port === undefined && options.path == null)\x0d\n    throw new ERR_MISSING_ARGS(['options'\x2C 'port'\x2C 'path']);\x0d\n\x0d\n  if (this.write !== Socket.prototype.write)\x0d\n    this.write = Socket.prototype.write;\x0d\n\x0d\n  if (this.destroyed) {\x0d\n    this._handle = null;\x0d\n    this._peername = null;\x0d\n    this._sockname = null;\x0d\n  }\x0d\n\x0d\n  const { path } = options;\x0d\n  const pipe = !!path;\x0d\n  debug('pipe'\x2C pipe\x2C path);\x0d\n\x0d\n  if (!this._handle) {\x0d\n    this._handle = pipe ?\x0d\n      new Pipe(PipeConstants.SOCKET) :\x0d\n      new TCP(TCPConstants.SOCKET);\x0d\n    initSocketHandle(this);\x0d\n  }\x0d\n\x0d\n  if (cb !== null) {\x0d\n    this.once('connect'\x2C cb);\x0d\n  }\x0d\n\x0d\n  this._unrefTimer();\x0d\n\x0d\n  this.connecting = true;\x0d\n\x0d\n  if (pipe) {\x0d\n    validateString(path\x2C 'options.path');\x0d\n    defaultTriggerAsyncIdScope(\x0d\n      this[async_id_symbol]\x2C internalConnect\x2C this\x2C path\x0d\n    );\x0d\n  } else {\x0d\n    lookupAndConnect(this\x2C options);\x0d\n  }\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nfunction lookupAndConnect(self\x2C options) {\x0d\n  const { localAddress\x2C localPort } = options;\x0d\n  const host = options.host || 'localhost';\x0d\n  let { port } = options;\x0d\n\x0d\n  if (localAddress && !isIP(localAddress)) {\x0d\n    throw new ERR_INVALID_IP_ADDRESS(localAddress);\x0d\n  }\x0d\n\x0d\n  if (localPort) {\x0d\n    validateNumber(localPort\x2C 'options.localPort');\x0d\n  }\x0d\n\x0d\n  if (typeof port !== 'undefined') {\x0d\n    if (typeof port !== 'number' && typeof port !== 'string') {\x0d\n      throw new ERR_INVALID_ARG_TYPE('options.port'\x2C\x0d\n                                     ['number'\x2C 'string']\x2C port);\x0d\n    }\x0d\n    validatePort(port);\x0d\n  }\x0d\n  port |= 0;\x0d\n\x0d\n  // If host is an IP\x2C skip performing a lookup\x0d\n  const addressType = isIP(host);\x0d\n  if (addressType) {\x0d\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C process.nextTick\x2C () => {\x0d\n      if (self.connecting)\x0d\n        defaultTriggerAsyncIdScope(\x0d\n          self[async_id_symbol]\x2C\x0d\n          internalConnect\x2C\x0d\n          self\x2C host\x2C port\x2C addressType\x2C localAddress\x2C localPort\x0d\n        );\x0d\n    });\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (options.lookup !== undefined)\x0d\n    validateFunction(options.lookup\x2C 'options.lookup');\x0d\n\x0d\n  if (dns === undefined) dns = require('dns');\x0d\n  const dnsopts = {\x0d\n    family: options.family\x2C\x0d\n    hints: options.hints || 0\x0d\n  };\x0d\n\x0d\n  if (!isWindows &&\x0d\n      dnsopts.family !== 4 &&\x0d\n      dnsopts.family !== 6 &&\x0d\n      dnsopts.hints === 0) {\x0d\n    dnsopts.hints = dns.ADDRCONFIG;\x0d\n  }\x0d\n\x0d\n  debug('connect: find host'\x2C host);\x0d\n  debug('connect: dns options'\x2C dnsopts);\x0d\n  self._host = host;\x0d\n  const lookup = options.lookup || dns.lookup;\x0d\n  defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C function() {\x0d\n    lookup(host\x2C dnsopts\x2C function emitLookup(err\x2C ip\x2C addressType) {\x0d\n      self.emit('lookup'\x2C err\x2C ip\x2C addressType\x2C host);\x0d\n\x0d\n      // It's possible we were destroyed while looking this up.\x0d\n      // XXX it would be great if we could cancel the promise returned by\x0d\n      // the look up.\x0d\n      if (!self.connecting) return;\x0d\n\x0d\n      if (err) {\x0d\n        // net.createConnection() creates a net.Socket object and immediately\x0d\n        // calls net.Socket.connect() on it (that's us). There are no event\x0d\n        // listeners registered yet so defer the error event to the next tick.\x0d\n        process.nextTick(connectErrorNT\x2C self\x2C err);\x0d\n      } else if (!isIP(ip)) {\x0d\n        err = new ERR_INVALID_IP_ADDRESS(ip);\x0d\n        process.nextTick(connectErrorNT\x2C self\x2C err);\x0d\n      } else if (addressType !== 4 && addressType !== 6) {\x0d\n        err = new ERR_INVALID_ADDRESS_FAMILY(addressType\x2C\x0d\n                                             options.host\x2C\x0d\n                                             options.port);\x0d\n        process.nextTick(connectErrorNT\x2C self\x2C err);\x0d\n      } else {\x0d\n        self._unrefTimer();\x0d\n        defaultTriggerAsyncIdScope(\x0d\n          self[async_id_symbol]\x2C\x0d\n          internalConnect\x2C\x0d\n          self\x2C ip\x2C port\x2C addressType\x2C localAddress\x2C localPort\x0d\n        );\x0d\n      }\x0d\n    });\x0d\n  });\x0d\n}\x0d\n\x0d\n\x0d\nfunction connectErrorNT(self\x2C err) {\x0d\n  self.destroy(err);\x0d\n}\x0d\n\x0d\n\x0d\nSocket.prototype.ref = function() {\x0d\n  if (!this._handle) {\x0d\n    this.once('connect'\x2C this.ref);\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  if (typeof this._handle.ref === 'function') {\x0d\n    this._handle.ref();\x0d\n  }\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.unref = function() {\x0d\n  if (!this._handle) {\x0d\n    this.once('connect'\x2C this.unref);\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  if (typeof this._handle.unref === 'function') {\x0d\n    this._handle.unref();\x0d\n  }\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nfunction afterConnect(status\x2C handle\x2C req\x2C readable\x2C writable) {\x0d\n  const self = handle[owner_symbol];\x0d\n\x0d\n  // Callback may come after call to destroy\x0d\n  if (self.destroyed) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  debug('afterConnect');\x0d\n\x0d\n  assert(self.connecting);\x0d\n  self.connecting = false;\x0d\n  self._sockname = null;\x0d\n\x0d\n  if (status === 0) {\x0d\n    if (self.readable && !readable) {\x0d\n      self.push(null);\x0d\n      self.read();\x0d\n    }\x0d\n    if (self.writable && !writable) {\x0d\n      self.end();\x0d\n    }\x0d\n    self._unrefTimer();\x0d\n\x0d\n    self.emit('connect');\x0d\n    self.emit('ready');\x0d\n\x0d\n    // Start the first read\x2C or get an immediate EOF.\x0d\n    // this doesn't actually consume any bytes\x2C because len=0.\x0d\n    if (readable && !self.isPaused())\x0d\n      self.read(0);\x0d\n\x0d\n  } else {\x0d\n    self.connecting = false;\x0d\n    let details;\x0d\n    if (req.localAddress && req.localPort) {\x0d\n      details = req.localAddress + ':' + req.localPort;\x0d\n    }\x0d\n    const ex = exceptionWithHostPort(status\x2C\x0d\n                                     'connect'\x2C\x0d\n                                     req.address\x2C\x0d\n                                     req.port\x2C\x0d\n                                     details);\x0d\n    if (details) {\x0d\n      ex.localAddress = req.localAddress;\x0d\n      ex.localPort = req.localPort;\x0d\n    }\x0d\n    self.destroy(ex);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction addAbortSignalOption(self\x2C options) {\x0d\n  if (options?.signal === undefined) {\x0d\n    return;\x0d\n  }\x0d\n  validateAbortSignal(options.signal\x2C 'options.signal');\x0d\n  const { signal } = options;\x0d\n  const onAborted = () => {\x0d\n    self.close();\x0d\n  };\x0d\n  if (signal.aborted) {\x0d\n    process.nextTick(onAborted);\x0d\n  } else {\x0d\n    signal.addEventListener('abort'\x2C onAborted);\x0d\n    self.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction Server(options\x2C connectionListener) {\x0d\n  if (!(this instanceof Server))\x0d\n    return new Server(options\x2C connectionListener);\x0d\n\x0d\n  EventEmitter.call(this);\x0d\n\x0d\n  if (typeof options === 'function') {\x0d\n    connectionListener = options;\x0d\n    options = {};\x0d\n    this.on('connection'\x2C connectionListener);\x0d\n  } else if (options == null || typeof options === 'object') {\x0d\n    options = { ...options };\x0d\n\x0d\n    if (typeof connectionListener === 'function') {\x0d\n      this.on('connection'\x2C connectionListener);\x0d\n    }\x0d\n  } else {\x0d\n    throw new ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\x0d\n  }\x0d\n\x0d\n  this._connections = 0;\x0d\n\x0d\n  this[async_id_symbol] = -1;\x0d\n  this._handle = null;\x0d\n  this._usingWorkers = false;\x0d\n  this._workers = [];\x0d\n  this._unref = false;\x0d\n\x0d\n  this.allowHalfOpen = options.allowHalfOpen || false;\x0d\n  this.pauseOnConnect = !!options.pauseOnConnect;\x0d\n}\x0d\nObjectSetPrototypeOf(Server.prototype\x2C EventEmitter.prototype);\x0d\nObjectSetPrototypeOf(Server\x2C EventEmitter);\x0d\n\x0d\n\x0d\nfunction toNumber(x) { return (x = Number(x)) >= 0 ? x : false; }\x0d\n\x0d\n// Returns handle if it can be created\x2C or error code if it can't\x0d\nfunction createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\x0d\n  let err = 0;\x0d\n  // Assign handle in listen\x2C and clean up if bind or listen fails\x0d\n  let handle;\x0d\n\x0d\n  let isTCP = false;\x0d\n  if (typeof fd === 'number' && fd >= 0) {\x0d\n    try {\x0d\n      handle = createHandle(fd\x2C true);\x0d\n    } catch (e) {\x0d\n      // Not a fd we can listen on.  This will trigger an error.\x0d\n      debug('listen invalid fd=%d:'\x2C fd\x2C e.message);\x0d\n      return UV_EINVAL;\x0d\n    }\x0d\n\x0d\n    err = handle.open(fd);\x0d\n    if (err)\x0d\n      return err;\x0d\n\x0d\n    assert(!address && !port);\x0d\n  } else if (port === -1 && addressType === -1) {\x0d\n    handle = new Pipe(PipeConstants.SERVER);\x0d\n    if (isWindows) {\x0d\n      const instances = NumberParseInt(process.env.NODE_PENDING_PIPE_INSTANCES);\x0d\n      if (!NumberIsNaN(instances)) {\x0d\n        handle.setPendingInstances(instances);\x0d\n      }\x0d\n    }\x0d\n  } else {\x0d\n    handle = new TCP(TCPConstants.SERVER);\x0d\n    isTCP = true;\x0d\n  }\x0d\n\x0d\n  if (address || port || isTCP) {\x0d\n    debug('bind to'\x2C address || 'any');\x0d\n    if (!address) {\x0d\n      // Try binding to ipv6 first\x0d\n      err = handle.bind6(DEFAULT_IPV6_ADDR\x2C port\x2C flags);\x0d\n      if (err) {\x0d\n        handle.close();\x0d\n        // Fallback to ipv4\x0d\n        return createServerHandle(DEFAULT_IPV4_ADDR\x2C port);\x0d\n      }\x0d\n    } else if (addressType === 6) {\x0d\n      err = handle.bind6(address\x2C port\x2C flags);\x0d\n    } else {\x0d\n      err = handle.bind(address\x2C port);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (err) {\x0d\n    handle.close();\x0d\n    return err;\x0d\n  }\x0d\n\x0d\n  return handle;\x0d\n}\x0d\n\x0d\nfunction setupListenHandle(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags) {\x0d\n  debug('setupListenHandle'\x2C address\x2C port\x2C addressType\x2C backlog\x2C fd);\x0d\n\x0d\n  // If there is not yet a handle\x2C we need to create one and bind.\x0d\n  // In the case of a server sent via IPC\x2C we don't need to do this.\x0d\n  if (this._handle) {\x0d\n    debug('setupListenHandle: have a handle already');\x0d\n  } else {\x0d\n    debug('setupListenHandle: create a handle');\x0d\n\x0d\n    let rval = null;\x0d\n\x0d\n    // Try to bind to the unspecified IPv6 address\x2C see if IPv6 is available\x0d\n    if (!address && typeof fd !== 'number') {\x0d\n      rval = createServerHandle(DEFAULT_IPV6_ADDR\x2C port\x2C 6\x2C fd\x2C flags);\x0d\n\x0d\n      if (typeof rval === 'number') {\x0d\n        rval = null;\x0d\n        address = DEFAULT_IPV4_ADDR;\x0d\n        addressType = 4;\x0d\n      } else {\x0d\n        address = DEFAULT_IPV6_ADDR;\x0d\n        addressType = 6;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (rval === null)\x0d\n      rval = createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\x0d\n\x0d\n    if (typeof rval === 'number') {\x0d\n      const error = uvExceptionWithHostPort(rval\x2C 'listen'\x2C address\x2C port);\x0d\n      process.nextTick(emitErrorNT\x2C this\x2C error);\x0d\n      return;\x0d\n    }\x0d\n    this._handle = rval;\x0d\n  }\x0d\n\x0d\n  this[async_id_symbol] = getNewAsyncId(this._handle);\x0d\n  this._handle.onconnection = onconnection;\x0d\n  this._handle[owner_symbol] = this;\x0d\n\x0d\n  // Use a backlog of 512 entries. We pass 511 to the listen() call because\x0d\n  // the kernel does: backlogsize = roundup_pow_of_two(backlogsize + 1);\x0d\n  // which will thus give us a backlog of 512 entries.\x0d\n  const err = this._handle.listen(backlog || 511);\x0d\n\x0d\n  if (err) {\x0d\n    const ex = uvExceptionWithHostPort(err\x2C 'listen'\x2C address\x2C port);\x0d\n    this._handle.close();\x0d\n    this._handle = null;\x0d\n    defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\x0d\n                               process.nextTick\x2C\x0d\n                               emitErrorNT\x2C\x0d\n                               this\x2C\x0d\n                               ex);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  // Generate connection key\x2C this should be unique to the connection\x0d\n  this._connectionKey = addressType + ':' + address + ':' + port;\x0d\n\x0d\n  // Unref the handle if the server was unref'ed prior to listening\x0d\n  if (this._unref)\x0d\n    this.unref();\x0d\n\x0d\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\x0d\n                             process.nextTick\x2C\x0d\n                             emitListeningNT\x2C\x0d\n                             this);\x0d\n}\x0d\n\x0d\nServer.prototype._listen2 = setupListenHandle;  // legacy alias\x0d\n\x0d\nfunction emitErrorNT(self\x2C err) {\x0d\n  self.emit('error'\x2C err);\x0d\n}\x0d\n\x0d\n\x0d\nfunction emitListeningNT(self) {\x0d\n  // Ensure handle hasn't closed\x0d\n  if (self._handle)\x0d\n    self.emit('listening');\x0d\n}\x0d\n\x0d\n\x0d\nfunction listenInCluster(server\x2C address\x2C port\x2C addressType\x2C\x0d\n                         backlog\x2C fd\x2C exclusive\x2C flags) {\x0d\n  exclusive = !!exclusive;\x0d\n\x0d\n  if (cluster === undefined) cluster = require('cluster');\x0d\n\x0d\n  if (cluster.isPrimary || exclusive) {\x0d\n    // Will create a new handle\x0d\n    // _listen2 sets up the listened handle\x2C it is still named like this\x0d\n    // to avoid breaking code that wraps this method\x0d\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  const serverQuery = {\x0d\n    address: address\x2C\x0d\n    port: port\x2C\x0d\n    addressType: addressType\x2C\x0d\n    fd: fd\x2C\x0d\n    flags\x2C\x0d\n  };\x0d\n\x0d\n  // Get the primary's server handle\x2C and listen on it\x0d\n  cluster._getServer(server\x2C serverQuery\x2C listenOnPrimaryHandle);\x0d\n\x0d\n  function listenOnPrimaryHandle(err\x2C handle) {\x0d\n    err = checkBindError(err\x2C port\x2C handle);\x0d\n\x0d\n    if (err) {\x0d\n      const ex = exceptionWithHostPort(err\x2C 'bind'\x2C address\x2C port);\x0d\n      return server.emit('error'\x2C ex);\x0d\n    }\x0d\n\x0d\n    // Reuse primary's server handle\x0d\n    server._handle = handle;\x0d\n    // _listen2 sets up the listened handle\x2C it is still named like this\x0d\n    // to avoid breaking code that wraps this method\x0d\n    server._listen2(address\x2C port\x2C addressType\x2C backlog\x2C fd\x2C flags);\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nServer.prototype.listen = function(...args) {\x0d\n  const normalized = normalizeArgs(args);\x0d\n  let options = normalized[0];\x0d\n  const cb = normalized[1];\x0d\n\x0d\n  if (this._handle) {\x0d\n    throw new ERR_SERVER_ALREADY_LISTEN();\x0d\n  }\x0d\n\x0d\n  if (cb !== null) {\x0d\n    this.once('listening'\x2C cb);\x0d\n  }\x0d\n  const backlogFromArgs =\x0d\n    // (handle\x2C backlog) or (path\x2C backlog) or (port\x2C backlog)\x0d\n    toNumber(args.length > 1 && args[1]) ||\x0d\n    toNumber(args.length > 2 && args[2]);  // (port\x2C host\x2C backlog)\x0d\n\x0d\n  options = options._handle || options.handle || options;\x0d\n  const flags = getFlags(options.ipv6Only);\x0d\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a handle\x0d\n  if (options instanceof TCP) {\x0d\n    this._handle = options;\x0d\n    this[async_id_symbol] = this._handle.getAsyncId();\x0d\n    listenInCluster(this\x2C null\x2C -1\x2C -1\x2C backlogFromArgs);\x0d\n    return this;\x0d\n  }\x0d\n  addAbortSignalOption(this\x2C options);\x0d\n  // (handle[\x2C backlog][\x2C cb]) where handle is an object with a fd\x0d\n  if (typeof options.fd === 'number' && options.fd >= 0) {\x0d\n    listenInCluster(this\x2C null\x2C null\x2C null\x2C backlogFromArgs\x2C options.fd);\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is omitted\x2C\x0d\n  // that is\x2C listen()\x2C listen(null)\x2C listen(cb)\x2C or listen(null\x2C cb)\x0d\n  // or (options[\x2C cb]) where options.port is explicitly set as undefined or\x0d\n  // null\x2C bind to an arbitrary unused port\x0d\n  if (args.length === 0 || typeof args[0] === 'function' ||\x0d\n      (typeof options.port === 'undefined' && 'port' in options) ||\x0d\n      options.port === null) {\x0d\n    options.port = 0;\x0d\n  }\x0d\n  // ([port][\x2C host][\x2C backlog][\x2C cb]) where port is specified\x0d\n  // or (options[\x2C cb]) where options.port is specified\x0d\n  // or if options.port is normalized as 0 before\x0d\n  let backlog;\x0d\n  if (typeof options.port === 'number' || typeof options.port === 'string') {\x0d\n    validatePort(options.port\x2C 'options.port');\x0d\n    backlog = options.backlog || backlogFromArgs;\x0d\n    // start TCP server listening on host:port\x0d\n    if (options.host) {\x0d\n      lookupAndListen(this\x2C options.port | 0\x2C options.host\x2C backlog\x2C\x0d\n                      options.exclusive\x2C flags);\x0d\n    } else { // Undefined host\x2C listens on unspecified address\x0d\n      // Default addressType 4 will be used to search for primary server\x0d\n      listenInCluster(this\x2C null\x2C options.port | 0\x2C 4\x2C\x0d\n                      backlog\x2C undefined\x2C options.exclusive);\x0d\n    }\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  // (path[\x2C backlog][\x2C cb]) or (options[\x2C cb])\x0d\n  // where path or options.path is a UNIX domain socket or Windows pipe\x0d\n  if (options.path && isPipeName(options.path)) {\x0d\n    const pipeName = this._pipeName = options.path;\x0d\n    backlog = options.backlog || backlogFromArgs;\x0d\n    listenInCluster(this\x2C pipeName\x2C -1\x2C -1\x2C\x0d\n                    backlog\x2C undefined\x2C options.exclusive);\x0d\n\x0d\n    if (!this._handle) {\x0d\n      // Failed and an error shall be emitted in the next tick.\x0d\n      // Therefore\x2C we directly return.\x0d\n      return this;\x0d\n    }\x0d\n\x0d\n    let mode = 0;\x0d\n    if (options.readableAll === true)\x0d\n      mode |= PipeConstants.UV_READABLE;\x0d\n    if (options.writableAll === true)\x0d\n      mode |= PipeConstants.UV_WRITABLE;\x0d\n    if (mode !== 0) {\x0d\n      const err = this._handle.fchmod(mode);\x0d\n      if (err) {\x0d\n        this._handle.close();\x0d\n        this._handle = null;\x0d\n        throw errnoException(err\x2C 'uv_pipe_chmod');\x0d\n      }\x0d\n    }\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  if (!(('port' in options) || ('path' in options))) {\x0d\n    throw new ERR_INVALID_ARG_VALUE('options'\x2C options\x2C\x0d\n                                    'must have the property "port" or "path"');\x0d\n  }\x0d\n\x0d\n  throw new ERR_INVALID_ARG_VALUE('options'\x2C options);\x0d\n};\x0d\n\x0d\nfunction lookupAndListen(self\x2C port\x2C address\x2C backlog\x2C exclusive\x2C flags) {\x0d\n  if (dns === undefined) dns = require('dns');\x0d\n  dns.lookup(address\x2C function doListen(err\x2C ip\x2C addressType) {\x0d\n    if (err) {\x0d\n      self.emit('error'\x2C err);\x0d\n    } else {\x0d\n      addressType = ip ? addressType : 4;\x0d\n      listenInCluster(self\x2C ip\x2C port\x2C addressType\x2C\x0d\n                      backlog\x2C undefined\x2C exclusive\x2C flags);\x0d\n    }\x0d\n  });\x0d\n}\x0d\n\x0d\nObjectDefineProperty(Server.prototype\x2C 'listening'\x2C {\x0d\n  get: function() {\x0d\n    return !!this._handle;\x0d\n  }\x2C\x0d\n  configurable: true\x2C\x0d\n  enumerable: true\x0d\n});\x0d\n\x0d\nServer.prototype.address = function() {\x0d\n  if (this._handle && this._handle.getsockname) {\x0d\n    const out = {};\x0d\n    const err = this._handle.getsockname(out);\x0d\n    if (err) {\x0d\n      throw errnoException(err\x2C 'address');\x0d\n    }\x0d\n    return out;\x0d\n  } else if (this._pipeName) {\x0d\n    return this._pipeName;\x0d\n  }\x0d\n  return null;\x0d\n};\x0d\n\x0d\nfunction onconnection(err\x2C clientHandle) {\x0d\n  const handle = this;\x0d\n  const self = handle[owner_symbol];\x0d\n\x0d\n  debug('onconnection');\x0d\n\x0d\n  if (err) {\x0d\n    self.emit('error'\x2C errnoException(err\x2C 'accept'));\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (self.maxConnections && self._connections >= self.maxConnections) {\x0d\n    clientHandle.close();\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  const socket = new Socket({\x0d\n    handle: clientHandle\x2C\x0d\n    allowHalfOpen: self.allowHalfOpen\x2C\x0d\n    pauseOnCreate: self.pauseOnConnect\x2C\x0d\n    readable: true\x2C\x0d\n    writable: true\x0d\n  });\x0d\n\x0d\n  self._connections++;\x0d\n  socket.server = self;\x0d\n  socket._server = self;\x0d\n\x0d\n  DTRACE_NET_SERVER_CONNECTION(socket);\x0d\n  self.emit('connection'\x2C socket);\x0d\n}\x0d\n\x0d\n/**\x0d\n * Gets the number of concurrent connections on the server\x0d\n * @param {Function} cb\x0d\n * @returns {Server}\x0d\n */\x0d\n\x0d\nServer.prototype.getConnections = function(cb) {\x0d\n  const self = this;\x0d\n\x0d\n  function end(err\x2C connections) {\x0d\n    defaultTriggerAsyncIdScope(self[async_id_symbol]\x2C\x0d\n                               process.nextTick\x2C\x0d\n                               cb\x2C\x0d\n                               err\x2C\x0d\n                               connections);\x0d\n  }\x0d\n\x0d\n  if (!this._usingWorkers) {\x0d\n    end(null\x2C this._connections);\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  // Poll workers\x0d\n  let left = this._workers.length;\x0d\n  let total = this._connections;\x0d\n\x0d\n  function oncount(err\x2C count) {\x0d\n    if (err) {\x0d\n      left = -1;\x0d\n      return end(err);\x0d\n    }\x0d\n\x0d\n    total += count;\x0d\n    if (--left === 0) return end(null\x2C total);\x0d\n  }\x0d\n\x0d\n  for (let n = 0; n < this._workers.length; n++) {\x0d\n    this._workers[n].getConnections(oncount);\x0d\n  }\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nServer.prototype.close = function(cb) {\x0d\n  if (typeof cb === 'function') {\x0d\n    if (!this._handle) {\x0d\n      this.once('close'\x2C function close() {\x0d\n        cb(new ERR_SERVER_NOT_RUNNING());\x0d\n      });\x0d\n    } else {\x0d\n      this.once('close'\x2C cb);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (this._handle) {\x0d\n    this._handle.close();\x0d\n    this._handle = null;\x0d\n  }\x0d\n\x0d\n  if (this._usingWorkers) {\x0d\n    let left = this._workers.length;\x0d\n    const onWorkerClose = () => {\x0d\n      if (--left !== 0) return;\x0d\n\x0d\n      this._connections = 0;\x0d\n      this._emitCloseIfDrained();\x0d\n    };\x0d\n\x0d\n    // Increment connections to be sure that\x2C even if all sockets will be closed\x0d\n    // during polling of workers\x2C `close` event will be emitted only once.\x0d\n    this._connections++;\x0d\n\x0d\n    // Poll workers\x0d\n    for (let n = 0; n < this._workers.length; n++)\x0d\n      this._workers[n].close(onWorkerClose);\x0d\n  } else {\x0d\n    this._emitCloseIfDrained();\x0d\n  }\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\nServer.prototype._emitCloseIfDrained = function() {\x0d\n  debug('SERVER _emitCloseIfDrained');\x0d\n\x0d\n  if (this._handle || this._connections) {\x0d\n    debug('SERVER handle? %j   connections? %d'\x2C\x0d\n          !!this._handle\x2C this._connections);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\x0d\n                             process.nextTick\x2C\x0d\n                             emitCloseNT\x2C\x0d\n                             this);\x0d\n};\x0d\n\x0d\n\x0d\nfunction emitCloseNT(self) {\x0d\n  debug('SERVER: emit close');\x0d\n  self.emit('close');\x0d\n}\x0d\n\x0d\n\x0d\nServer.prototype[EventEmitter.captureRejectionSymbol] = function(\x0d\n  err\x2C event\x2C sock) {\x0d\n\x0d\n  switch (event) {\x0d\n    case 'connection':\x0d\n      sock.destroy(err);\x0d\n      break;\x0d\n    default:\x0d\n      this.emit('error'\x2C err);\x0d\n  }\x0d\n};\x0d\n\x0d\n\x0d\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\x0d\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\x0d\nObjectDefineProperty(TCP.prototype\x2C 'owner'\x2C {\x0d\n  get() { return this[owner_symbol]; }\x2C\x0d\n  set(v) { return this[owner_symbol] = v; }\x0d\n});\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\x0d\n  get() { return this[kHandle]; }\x2C\x0d\n  set(v) { return this[kHandle] = v; }\x0d\n});\x0d\n\x0d\nServer.prototype._setupWorker = function(socketList) {\x0d\n  this._usingWorkers = true;\x0d\n  this._workers.push(socketList);\x0d\n  socketList.once('exit'\x2C (socketList) => {\x0d\n    const index = ArrayPrototypeIndexOf(this._workers\x2C socketList);\x0d\n    this._workers.splice(index\x2C 1);\x0d\n  });\x0d\n};\x0d\n\x0d\nServer.prototype.ref = function() {\x0d\n  this._unref = false;\x0d\n\x0d\n  if (this._handle)\x0d\n    this._handle.ref();\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\nServer.prototype.unref = function() {\x0d\n  this._unref = true;\x0d\n\x0d\n  if (this._handle)\x0d\n    this._handle.unref();\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\nlet _setSimultaneousAccepts;\x0d\nlet warnSimultaneousAccepts = true;\x0d\n\x0d\nif (isWindows) {\x0d\n  let simultaneousAccepts;\x0d\n\x0d\n  _setSimultaneousAccepts = function(handle) {\x0d\n    if (warnSimultaneousAccepts) {\x0d\n      process.emitWarning(\x0d\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\x0d\n        'DeprecationWarning'\x2C 'DEP0121');\x0d\n      warnSimultaneousAccepts = false;\x0d\n    }\x0d\n    if (handle === undefined) {\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    if (simultaneousAccepts === undefined) {\x0d\n      simultaneousAccepts = (process.env.NODE_MANY_ACCEPTS &&\x0d\n                             process.env.NODE_MANY_ACCEPTS !== '0');\x0d\n    }\x0d\n\x0d\n    if (handle._simultaneousAccepts !== simultaneousAccepts) {\x0d\n      handle.setSimultaneousAccepts(!!simultaneousAccepts);\x0d\n      handle._simultaneousAccepts = simultaneousAccepts;\x0d\n    }\x0d\n  };\x0d\n} else {\x0d\n  _setSimultaneousAccepts = function() {\x0d\n    if (warnSimultaneousAccepts) {\x0d\n      process.emitWarning(\x0d\n        'net._setSimultaneousAccepts() is deprecated and will be removed.'\x2C\x0d\n        'DeprecationWarning'\x2C 'DEP0121');\x0d\n      warnSimultaneousAccepts = false;\x0d\n    }\x0d\n  };\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  _createServerHandle: createServerHandle\x2C\x0d\n  _normalizeArgs: normalizeArgs\x2C\x0d\n  _setSimultaneousAccepts\x2C\x0d\n  get BlockList() {\x0d\n    BlockList ??= require('internal/blocklist').BlockList;\x0d\n    return BlockList;\x0d\n  }\x2C\x0d\n  get SocketAddress() {\x0d\n    SocketAddress ??= require('internal/socketaddress').SocketAddress;\x0d\n    return SocketAddress;\x0d\n  }\x2C\x0d\n  connect\x2C\x0d\n  createConnection: connect\x2C\x0d\n  createServer\x2C\x0d\n  isIP: isIP\x2C\x0d\n  isIPv4: isIPv4\x2C\x0d\n  isIPv6: isIPv6\x2C\x0d\n  Server\x2C\x0d\n  Socket\x2C\x0d\n  Stream: Socket\x2C // Legacy naming\x0d\n};\x0d\n
code-source-info,0x1c1d96e80f6,131,0,49462,C0O0C4O49462,,
code-creation,Function,10,252795,0x1c1d96eafc6,2513, node:net:1:1,0x1c1d96e8070,~
code-source-info,0x1c1d96eafc6,131,0,49462,C0O0C411O1183C417O1200C423O1226C429O1238C435O1248C441O1259C447O1275C453O1294C459O1319C464O1344C469O1394C475O1394C479O1394C481O1429C487O1429C491O1429C493O1461C499O1461C504O1494C518O1495C524O1461C526O1628C532O1628C537O1553C543O1562C548O1573C553O1584C559O1609C565O1669C571O1669C575O1669C577O1758C580O1758C585O1709C591O1727C597O1741C603O1803C609O1803C614O1792C620O1851C623O1851C628O1831C634O1902C637O1902C642O1885C648O2002C651O2002C656O1946C662O1954C668O1984C674O2102C677O2102C682O2043C688O2052C694O2083C700O2238C706O2238C711O2144C717O2159C728O2201C734O2218C740O2448C746O2448C751O2283C757O2301C763O2318C769O2335C774O2356C780O2368C785O2385C790O2406C796O2418C802O2432C808O2844C814O2844C819O2844C824O2515C830O2548C836O2575C842O2603C848O2629C854O2658C860O2690C866O2719C872O2743C878O2770C884O2789C890O2815C896O2898C902O2898C907O2881C913O3061C919O3061C924O2942C930O2966C936O2987C942O3005C948O3024C954O3041C960O3122C963O3122C967O3122C969O3224C975O3224C980O3164C986O3197C992O3307C993O3307C995O3321C996O3321C998O3331C999O3331C1001O3347C1002O3347C1004O3390C1010O3390C1015O3373C1021O3431C1027O3431C1032O3418C1038O3488C1040O3488C1042O3526C1044O3526C1046O3553C1049O3561C1056O3570C1059O3553C1061O3599C1065O3599C1067O7199C1070O7199C1074O7199C1076O7244C1079O7244C1083O7244C1085O7290C1088O7290C1092O7290C1094O11513C1097O11541C1105O11559C1110O11566C1115O11513C1120O11579C1126O11615C1131O11579C1136O11658C1139O11665C1148O11687C1152O11923C1155O11930C1164O11947C1168O13550C1171O13557C1178O13578C1182O13603C1185O13610C1194O13631C1198O14159C1201O14166C1210O14187C1214O14660C1217O14667C1226O14690C1230O14956C1233O14963C1242O14981C1246O15036C1252O15064C1266O15100C1274O15036C1279O15155C1285O15183C1299O15210C1307O15155C1312O15302C1318O15330C1332O15365C1340O15302C1345O15702C1351O15730C1365O15765C1373O15702C1378O15858C1384O15886C1389O15897C1395O15921C1406O15858C1411O16302C1414O16309C1423O16325C1427O16572C1430O16579C1439O16593C1443O16794C1446O16801C1455O16817C1459O17171C1462O17178C1471O17195C1475O17394C1478O17401C1487O17416C1491O17770C1494O17777C1503O17799C1507O17963C1510O17970C1519O17989C1523O18988C1526O18995C1535O19018C1539O19498C1547O19498C1552O19622C1560O19622C1565O19725C1573O19725C1578O19825C1586O19825C1596O19921C1599O19928C1608O19951C1616O20245C1624O20245C1634O20348C1642O20348C1652O20442C1655O20449C1660O20459C1664O20477C1672O20533C1675O20540C1684O20564C1692O21363C1695O21370C1704O21388C1712O21467C1715O21474C1724O21491C1732O21742C1740O21742C1750O21886C1758O21886C1768O25478C1771O25485C1780O25503C1788O30058C1791O30065C1800O30079C1808O30286C1811O30293C1820O30309C1828O33157C1831O33185C1843O33209C1852O33157C1862O33222C1868O33222C1878O37343C1881O37350C1892O37369C1900O38873C1903O38880C1916O38897C1924O42966C1930O42994C1951O43028C1963O42966C1973O43126C1976O43133C1989O43151C1997O44273C2000O44280C2013O44305C2021O45102C2024O45109C2037O45125C2045O46036C2048O46043C2061O46073C2069O46573C2072O46580C2084O46603C2097O46627C2105O46960C2111O46985C2132O47010C2144O47051C2156O46960C2166O47101C2172O47129C2189O47156C2201O47192C2213O47101C2223O47237C2226O47244C2239O47267C2247O47522C2250O47529C2263O47543C2271O47655C2274O47662C2287O47678C2295O47795C2297O47851C2298O47851C2300O47860C2311O47884C2312O47884C2314O47910C2323O48640C2328O48922C2338O48965C2348O49004C2358O49022C2368O49290C2378O49320C2388O49332C2398O49355C2408O49372C2418O49391C2428O49402C2438O49413C2448O49432C2503O48937C2512O49461,,
tick,0x7ff7e82b7850,253138,1,0x7ff7e72b78a0,3,0x7ff7e7cd7240,0x29be72c488a,0x29be72c4597,0x1c1d96e398c,0x29be72c4958,0x29be72c4597,0x1c1d96dcd42,0x29be72c4958,0x29be72c4597,0x1c1d96da2b9,0x29be72c4958,0x29be72c4597,0x1c1d96d8be3,0x29be72c4958,0x1c1d96d87ea,0x1c1d96ce1cb,0x109c10f95d6,0x109c10f920a,0x1c1d96d8506,0x1c1d96d6d21,0x1c1d96d3791,0x1c1d96cf653,0x1c1d96ceb76,0x109c10f963f,0x109c10f920a,0x109c10f83db,0x109c10f8185,0x1abee806768,0x1abee8012dd
code-creation,Eval,10,253422,0x1c1d96f077e,5, node:internal/net:1:1,0x1c1d96f05b8,~
script-source,132,node:internal/net,'use strict';\x0d\n\x0d\nconst {\x0d\n  RegExp\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  Symbol\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst Buffer = require('buffer').Buffer;\x0d\nconst { writeBuffer } = internalBinding('fs');\x0d\nconst errors = require('internal/errors');\x0d\n\x0d\n// IPv4 Segment\x0d\nconst v4Seg = '(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])';\x0d\nconst v4Str = `(${v4Seg}[.]){3}${v4Seg}`;\x0d\nconst IPv4Reg = new RegExp(`^${v4Str}$`);\x0d\n\x0d\n// IPv6 Segment\x0d\nconst v6Seg = '(?:[0-9a-fA-F]{1\x2C4})';\x0d\nconst IPv6Reg = new RegExp('^(' +\x0d\n  `(?:${v6Seg}:){7}(?:${v6Seg}|:)|` +\x0d\n  `(?:${v6Seg}:){6}(?:${v4Str}|:${v6Seg}|:)|` +\x0d\n  `(?:${v6Seg}:){5}(?::${v4Str}|(:${v6Seg}){1\x2C2}|:)|` +\x0d\n  `(?:${v6Seg}:){4}(?:(:${v6Seg}){0\x2C1}:${v4Str}|(:${v6Seg}){1\x2C3}|:)|` +\x0d\n  `(?:${v6Seg}:){3}(?:(:${v6Seg}){0\x2C2}:${v4Str}|(:${v6Seg}){1\x2C4}|:)|` +\x0d\n  `(?:${v6Seg}:){2}(?:(:${v6Seg}){0\x2C3}:${v4Str}|(:${v6Seg}){1\x2C5}|:)|` +\x0d\n  `(?:${v6Seg}:){1}(?:(:${v6Seg}){0\x2C4}:${v4Str}|(:${v6Seg}){1\x2C6}|:)|` +\x0d\n  `(?::((?::${v6Seg}){0\x2C5}:${v4Str}|(?::${v6Seg}){1\x2C7}|:))` +\x0d\n')(%[0-9a-zA-Z-.:]{1\x2C})?$');\x0d\n\x0d\nfunction isIPv4(s) {\x0d\n  return RegExpPrototypeTest(IPv4Reg\x2C s);\x0d\n}\x0d\n\x0d\nfunction isIPv6(s) {\x0d\n  return RegExpPrototypeTest(IPv6Reg\x2C s);\x0d\n}\x0d\n\x0d\nfunction isIP(s) {\x0d\n  if (isIPv4(s)) return 4;\x0d\n  if (isIPv6(s)) return 6;\x0d\n  return 0;\x0d\n}\x0d\n\x0d\nfunction makeSyncWrite(fd) {\x0d\n  return function(chunk\x2C enc\x2C cb) {\x0d\n    if (enc !== 'buffer')\x0d\n      chunk = Buffer.from(chunk\x2C enc);\x0d\n\x0d\n    this._handle.bytesWritten += chunk.length;\x0d\n\x0d\n    const ctx = {};\x0d\n    writeBuffer(fd\x2C chunk\x2C 0\x2C chunk.length\x2C null\x2C undefined\x2C ctx);\x0d\n    if (ctx.errno !== undefined) {\x0d\n      const ex = errors.uvException(ctx);\x0d\n      ex.errno = ctx.errno;\x0d\n      return cb(ex);\x0d\n    }\x0d\n    cb();\x0d\n  };\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  isIP\x2C\x0d\n  isIPv4\x2C\x0d\n  isIPv6\x2C\x0d\n  makeSyncWrite\x2C\x0d\n  normalizedArgsSymbol: Symbol('normalizedArgs')\x0d\n};\x0d\n
code-source-info,0x1c1d96f077e,132,0,1818,C0O0C4O1818,,
code-creation,Function,10,253547,0x1c1d96f0b6e,617, node:internal/net:1:1,0x1c1d96f06f8,~
code-source-info,0x1c1d96f0b6e,132,0,1818,C0O0C45O28C50O39C56O63C61O107C64O107C69O124C73O107C75O158C78O158C83O142C89O197C92O197C96O197C98O259C101O330C106O334C119O349C124O375C129O390C142O375C147O375C149O435C152O476C160O503C173O519C183O492C192O542C205O558C218O568C228O531C237O591C250O608C263O619C273O580C282O648C295O666C308O681C321O692C331O637C340O721C353O739C366O754C379O765C389O710C398O794C411O812C424O827C437O838C447O783C456O867C469O885C482O900C495O911C505O856C514O946C527O961C540O974C550O929C556O992C562O476C567O476C569O1695C576O1717C582O1726C588O1737C594O1748C601O1788C611O1710C616O1817,,
code-creation,Eval,10,253831,0x1c1d96f25de,5, node:internal/dtrace:1:1,0x1c1d96f2498,~
script-source,133,node:internal/dtrace,'use strict';\x0d\n\x0d\nconst config = internalBinding('config');\x0d\n\x0d\nconst {\x0d\n  DTRACE_HTTP_CLIENT_REQUEST = () => {}\x2C\x0d\n  DTRACE_HTTP_CLIENT_RESPONSE = () => {}\x2C\x0d\n  DTRACE_HTTP_SERVER_REQUEST = () => {}\x2C\x0d\n  DTRACE_HTTP_SERVER_RESPONSE = () => {}\x2C\x0d\n  DTRACE_NET_SERVER_CONNECTION = () => {}\x2C\x0d\n  DTRACE_NET_STREAM_END = () => {}\x0d\n} = (config.hasDtrace ? internalBinding('dtrace') : {});\x0d\n\x0d\nmodule.exports = {\x0d\n  DTRACE_HTTP_CLIENT_REQUEST\x2C\x0d\n  DTRACE_HTTP_CLIENT_RESPONSE\x2C\x0d\n  DTRACE_HTTP_SERVER_REQUEST\x2C\x0d\n  DTRACE_HTTP_SERVER_RESPONSE\x2C\x0d\n  DTRACE_NET_SERVER_CONNECTION\x2C\x0d\n  DTRACE_NET_STREAM_END\x0d\n};\x0d\n
code-source-info,0x1c1d96f25de,133,0,589,C0O0C4O589,,
code-creation,Function,10,253893,0x1c1d96f2ab6,140, node:internal/dtrace:1:1,0x1c1d96f2558,~
code-source-info,0x1c1d96f2ab6,133,0,589,C0O32C3O32C8O333C17O345C25O73C36O115C47O158C58O200C69O243C80O287C91O381C98O403C104O434C110O466C116O497C122O529C128O562C134O396C139O588,,
code-creation,LazyCompile,10,254133,0x1c1d96f392e,34,protoGetter node:net:718:21,0x1c1d96e8538,~
code-source-info,0x1c1d96f392e,131,19348,19494,C0O19370C8O19398C13O19409C20O19476C27O19370C33O19493,,
code-creation,Eval,10,254824,0x1c1d96f8b26,5, node:dgram:1:1,0x1c1d96f85b0,~
script-source,134,node:dgram,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  Array\x2C\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  FunctionPrototypeBind\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  ReflectApply\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst errors = require('internal/errors');\x0d\nconst {\x0d\n  kStateSymbol\x2C\x0d\n  _createSocketHandle\x2C\x0d\n  newHandle\x2C\x0d\n} = require('internal/dgram');\x0d\nconst { guessHandleType } = internalBinding('util');\x0d\nconst {\x0d\n  ERR_BUFFER_OUT_OF_BOUNDS\x2C\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n  ERR_MISSING_ARGS\x2C\x0d\n  ERR_SOCKET_ALREADY_BOUND\x2C\x0d\n  ERR_SOCKET_BAD_BUFFER_SIZE\x2C\x0d\n  ERR_SOCKET_BUFFER_SIZE\x2C\x0d\n  ERR_SOCKET_DGRAM_IS_CONNECTED\x2C\x0d\n  ERR_SOCKET_DGRAM_NOT_CONNECTED\x2C\x0d\n  ERR_SOCKET_DGRAM_NOT_RUNNING\x2C\x0d\n  ERR_INVALID_FD_TYPE\x0d\n} = errors.codes;\x0d\nconst {\x0d\n  isInt32\x2C\x0d\n  validateAbortSignal\x2C\x0d\n  validateString\x2C\x0d\n  validateNumber\x2C\x0d\n  validatePort\x2C\x0d\n} = require('internal/validators');\x0d\nconst { Buffer } = require('buffer');\x0d\nconst { deprecate } = require('internal/util');\x0d\nconst { isArrayBufferView } = require('internal/util/types');\x0d\nconst EventEmitter = require('events');\x0d\nconst {\x0d\n  defaultTriggerAsyncIdScope\x2C\x0d\n  symbols: { async_id_symbol\x2C owner_symbol }\x0d\n} = require('internal/async_hooks');\x0d\nconst { UV_UDP_REUSEADDR } = internalBinding('constants').os;\x0d\n\x0d\nconst {\x0d\n  constants: { UV_UDP_IPV6ONLY }\x2C\x0d\n  UDP\x2C\x0d\n  SendWrap\x0d\n} = internalBinding('udp_wrap');\x0d\n\x0d\nconst BIND_STATE_UNBOUND = 0;\x0d\nconst BIND_STATE_BINDING = 1;\x0d\nconst BIND_STATE_BOUND = 2;\x0d\n\x0d\nconst CONNECT_STATE_DISCONNECTED = 0;\x0d\nconst CONNECT_STATE_CONNECTING = 1;\x0d\nconst CONNECT_STATE_CONNECTED = 2;\x0d\n\x0d\nconst RECV_BUFFER = true;\x0d\nconst SEND_BUFFER = false;\x0d\n\x0d\n// Lazily loaded\x0d\nlet _cluster = null;\x0d\nfunction lazyLoadCluster() {\x0d\n  if (!_cluster) _cluster = require('cluster');\x0d\n  return _cluster;\x0d\n}\x0d\n\x0d\nconst errnoException = errors.errnoException;\x0d\nconst exceptionWithHostPort = errors.exceptionWithHostPort;\x0d\n\x0d\n\x0d\nfunction Socket(type\x2C listener) {\x0d\n  FunctionPrototypeCall(EventEmitter\x2C this);\x0d\n  let lookup;\x0d\n  let recvBufferSize;\x0d\n  let sendBufferSize;\x0d\n\x0d\n  let options;\x0d\n  if (type !== null && typeof type === 'object') {\x0d\n    options = type;\x0d\n    type = options.type;\x0d\n    lookup = options.lookup;\x0d\n    recvBufferSize = options.recvBufferSize;\x0d\n    sendBufferSize = options.sendBufferSize;\x0d\n  }\x0d\n\x0d\n  const handle = newHandle(type\x2C lookup);\x0d\n  handle[owner_symbol] = this;\x0d\n\x0d\n  this[async_id_symbol] = handle.getAsyncId();\x0d\n  this.type = type;\x0d\n\x0d\n  if (typeof listener === 'function')\x0d\n    this.on('message'\x2C listener);\x0d\n\x0d\n  this[kStateSymbol] = {\x0d\n    handle\x2C\x0d\n    receiving: false\x2C\x0d\n    bindState: BIND_STATE_UNBOUND\x2C\x0d\n    connectState: CONNECT_STATE_DISCONNECTED\x2C\x0d\n    queue: undefined\x2C\x0d\n    reuseAddr: options && options.reuseAddr\x2C // Use UV_UDP_REUSEADDR if true.\x0d\n    ipv6Only: options && options.ipv6Only\x2C\x0d\n    recvBufferSize\x2C\x0d\n    sendBufferSize\x0d\n  };\x0d\n\x0d\n  if (options?.signal !== undefined) {\x0d\n    const { signal } = options;\x0d\n    validateAbortSignal(signal\x2C 'options.signal');\x0d\n    const onAborted = () => {\x0d\n      this.close();\x0d\n    };\x0d\n    if (signal.aborted) {\x0d\n      onAborted();\x0d\n    } else {\x0d\n      signal.addEventListener('abort'\x2C onAborted);\x0d\n      this.once('close'\x2C () => signal.removeEventListener('abort'\x2C onAborted));\x0d\n    }\x0d\n  }\x0d\n}\x0d\nObjectSetPrototypeOf(Socket.prototype\x2C EventEmitter.prototype);\x0d\nObjectSetPrototypeOf(Socket\x2C EventEmitter);\x0d\n\x0d\n\x0d\nfunction createSocket(type\x2C listener) {\x0d\n  return new Socket(type\x2C listener);\x0d\n}\x0d\n\x0d\n\x0d\nfunction startListening(socket) {\x0d\n  const state = socket[kStateSymbol];\x0d\n\x0d\n  state.handle.onmessage = onMessage;\x0d\n  // Todo: handle errors\x0d\n  state.handle.recvStart();\x0d\n  state.receiving = true;\x0d\n  state.bindState = BIND_STATE_BOUND;\x0d\n\x0d\n  if (state.recvBufferSize)\x0d\n    bufferSize(socket\x2C state.recvBufferSize\x2C RECV_BUFFER);\x0d\n\x0d\n  if (state.sendBufferSize)\x0d\n    bufferSize(socket\x2C state.sendBufferSize\x2C SEND_BUFFER);\x0d\n\x0d\n  socket.emit('listening');\x0d\n}\x0d\n\x0d\nfunction replaceHandle(self\x2C newHandle) {\x0d\n  const state = self[kStateSymbol];\x0d\n  const oldHandle = state.handle;\x0d\n\x0d\n  // Set up the handle that we got from primary.\x0d\n  newHandle.lookup = oldHandle.lookup;\x0d\n  newHandle.bind = oldHandle.bind;\x0d\n  newHandle.send = oldHandle.send;\x0d\n  newHandle[owner_symbol] = self;\x0d\n\x0d\n  // Replace the existing handle by the handle we got from primary.\x0d\n  oldHandle.close();\x0d\n  state.handle = newHandle;\x0d\n  // Check if the udp handle was connected and set the state accordingly\x0d\n  if (isConnected(self))\x0d\n    state.connectState = CONNECT_STATE_CONNECTED;\x0d\n}\x0d\n\x0d\nfunction bufferSize(self\x2C size\x2C buffer) {\x0d\n  if (size >>> 0 !== size)\x0d\n    throw new ERR_SOCKET_BAD_BUFFER_SIZE();\x0d\n\x0d\n  const ctx = {};\x0d\n  const ret = self[kStateSymbol].handle.bufferSize(size\x2C buffer\x2C ctx);\x0d\n  if (ret === undefined) {\x0d\n    throw new ERR_SOCKET_BUFFER_SIZE(ctx);\x0d\n  }\x0d\n  return ret;\x0d\n}\x0d\n\x0d\n// Query primary process to get the server handle and utilize it.\x0d\nfunction bindServerHandle(self\x2C options\x2C errCb) {\x0d\n  const cluster = lazyLoadCluster();\x0d\n\x0d\n  const state = self[kStateSymbol];\x0d\n  cluster._getServer(self\x2C options\x2C (err\x2C handle) => {\x0d\n    if (err) {\x0d\n      errCb(err);\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    if (!state.handle) {\x0d\n      // Handle has been closed in the mean time.\x0d\n      return handle.close();\x0d\n    }\x0d\n\x0d\n    replaceHandle(self\x2C handle);\x0d\n    startListening(self);\x0d\n  });\x0d\n}\x0d\n\x0d\nSocket.prototype.bind = function(port_\x2C address_ /* \x2C callback */) {\x0d\n  let port = port_;\x0d\n\x0d\n  healthCheck(this);\x0d\n  const state = this[kStateSymbol];\x0d\n\x0d\n  if (state.bindState !== BIND_STATE_UNBOUND)\x0d\n    throw new ERR_SOCKET_ALREADY_BOUND();\x0d\n\x0d\n  state.bindState = BIND_STATE_BINDING;\x0d\n\x0d\n  const cb = arguments.length && arguments[arguments.length - 1];\x0d\n  if (typeof cb === 'function') {\x0d\n    function removeListeners() {\x0d\n      this.removeListener('error'\x2C removeListeners);\x0d\n      this.removeListener('listening'\x2C onListening);\x0d\n    }\x0d\n\x0d\n    function onListening() {\x0d\n      FunctionPrototypeCall(removeListeners\x2C this);\x0d\n      FunctionPrototypeCall(cb\x2C this);\x0d\n    }\x0d\n\x0d\n    this.on('error'\x2C removeListeners);\x0d\n    this.on('listening'\x2C onListening);\x0d\n  }\x0d\n\x0d\n  if (port !== null &&\x0d\n      typeof port === 'object' &&\x0d\n      typeof port.recvStart === 'function') {\x0d\n    replaceHandle(this\x2C port);\x0d\n    startListening(this);\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  // Open an existing fd instead of creating a new one.\x0d\n  if (port !== null && typeof port === 'object' &&\x0d\n      isInt32(port.fd) && port.fd > 0) {\x0d\n    const fd = port.fd;\x0d\n    const exclusive = !!port.exclusive;\x0d\n    const state = this[kStateSymbol];\x0d\n\x0d\n    const cluster = lazyLoadCluster();\x0d\n\x0d\n    if (cluster.isWorker && !exclusive) {\x0d\n      bindServerHandle(this\x2C {\x0d\n        address: null\x2C\x0d\n        port: null\x2C\x0d\n        addressType: this.type\x2C\x0d\n        fd\x2C\x0d\n        flags: null\x0d\n      }\x2C (err) => {\x0d\n        // Callback to handle error.\x0d\n        const ex = errnoException(err\x2C 'open');\x0d\n        state.bindState = BIND_STATE_UNBOUND;\x0d\n        this.emit('error'\x2C ex);\x0d\n      });\x0d\n      return this;\x0d\n    }\x0d\n\x0d\n    const type = guessHandleType(fd);\x0d\n    if (type !== 'UDP')\x0d\n      throw new ERR_INVALID_FD_TYPE(type);\x0d\n    const err = state.handle.open(fd);\x0d\n\x0d\n    if (err)\x0d\n      throw errnoException(err\x2C 'open');\x0d\n\x0d\n    // Check if the udp handle was connected and set the state accordingly\x0d\n    if (isConnected(this))\x0d\n      state.connectState = CONNECT_STATE_CONNECTED;\x0d\n\x0d\n    startListening(this);\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  let address;\x0d\n  let exclusive;\x0d\n\x0d\n  if (port !== null && typeof port === 'object') {\x0d\n    address = port.address || '';\x0d\n    exclusive = !!port.exclusive;\x0d\n    port = port.port;\x0d\n  } else {\x0d\n    address = typeof address_ === 'function' ? '' : address_;\x0d\n    exclusive = false;\x0d\n  }\x0d\n\x0d\n  // Defaulting address for bind to all interfaces\x0d\n  if (!address) {\x0d\n    if (this.type === 'udp4')\x0d\n      address = '0.0.0.0';\x0d\n    else\x0d\n      address = '::';\x0d\n  }\x0d\n\x0d\n  // Resolve address first\x0d\n  state.handle.lookup(address\x2C (err\x2C ip) => {\x0d\n    if (err) {\x0d\n      state.bindState = BIND_STATE_UNBOUND;\x0d\n      this.emit('error'\x2C err);\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    const cluster = lazyLoadCluster();\x0d\n\x0d\n    let flags = 0;\x0d\n    if (state.reuseAddr)\x0d\n      flags |= UV_UDP_REUSEADDR;\x0d\n    if (state.ipv6Only)\x0d\n      flags |= UV_UDP_IPV6ONLY;\x0d\n\x0d\n    if (cluster.isWorker && !exclusive) {\x0d\n      bindServerHandle(this\x2C {\x0d\n        address: ip\x2C\x0d\n        port: port\x2C\x0d\n        addressType: this.type\x2C\x0d\n        fd: -1\x2C\x0d\n        flags: flags\x0d\n      }\x2C (err) => {\x0d\n        // Callback to handle error.\x0d\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\x0d\n        state.bindState = BIND_STATE_UNBOUND;\x0d\n        this.emit('error'\x2C ex);\x0d\n      });\x0d\n    } else {\x0d\n      if (!state.handle)\x0d\n        return; // Handle has been closed in the mean time\x0d\n\x0d\n      const err = state.handle.bind(ip\x2C port || 0\x2C flags);\x0d\n      if (err) {\x0d\n        const ex = exceptionWithHostPort(err\x2C 'bind'\x2C ip\x2C port);\x0d\n        state.bindState = BIND_STATE_UNBOUND;\x0d\n        this.emit('error'\x2C ex);\x0d\n        // Todo: close?\x0d\n        return;\x0d\n      }\x0d\n\x0d\n      startListening(this);\x0d\n    }\x0d\n  });\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\nSocket.prototype.connect = function(port\x2C address\x2C callback) {\x0d\n  port = validatePort(port\x2C 'Port'\x2C false);\x0d\n  if (typeof address === 'function') {\x0d\n    callback = address;\x0d\n    address = '';\x0d\n  } else if (address === undefined) {\x0d\n    address = '';\x0d\n  }\x0d\n\x0d\n  validateString(address\x2C 'address');\x0d\n\x0d\n  const state = this[kStateSymbol];\x0d\n\x0d\n  if (state.connectState !== CONNECT_STATE_DISCONNECTED)\x0d\n    throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\x0d\n\x0d\n  state.connectState = CONNECT_STATE_CONNECTING;\x0d\n  if (state.bindState === BIND_STATE_UNBOUND)\x0d\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\x0d\n\x0d\n  if (state.bindState !== BIND_STATE_BOUND) {\x0d\n    enqueue(this\x2C FunctionPrototypeBind(_connect\x2C this\x2C\x0d\n                                        port\x2C address\x2C callback));\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  ReflectApply(_connect\x2C this\x2C [port\x2C address\x2C callback]);\x0d\n};\x0d\n\x0d\n\x0d\nfunction _connect(port\x2C address\x2C callback) {\x0d\n  const state = this[kStateSymbol];\x0d\n  if (callback)\x0d\n    this.once('connect'\x2C callback);\x0d\n\x0d\n  const afterDns = (ex\x2C ip) => {\x0d\n    defaultTriggerAsyncIdScope(\x0d\n      this[async_id_symbol]\x2C\x0d\n      doConnect\x2C\x0d\n      ex\x2C this\x2C ip\x2C address\x2C port\x2C callback\x0d\n    );\x0d\n  };\x0d\n\x0d\n  state.handle.lookup(address\x2C afterDns);\x0d\n}\x0d\n\x0d\n\x0d\nfunction doConnect(ex\x2C self\x2C ip\x2C address\x2C port\x2C callback) {\x0d\n  const state = self[kStateSymbol];\x0d\n  if (!state.handle)\x0d\n    return;\x0d\n\x0d\n  if (!ex) {\x0d\n    const err = state.handle.connect(ip\x2C port);\x0d\n    if (err) {\x0d\n      ex = exceptionWithHostPort(err\x2C 'connect'\x2C address\x2C port);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (ex) {\x0d\n    state.connectState = CONNECT_STATE_DISCONNECTED;\x0d\n    return process.nextTick(() => {\x0d\n      if (callback) {\x0d\n        self.removeListener('connect'\x2C callback);\x0d\n        callback(ex);\x0d\n      } else {\x0d\n        self.emit('error'\x2C ex);\x0d\n      }\x0d\n    });\x0d\n  }\x0d\n\x0d\n  state.connectState = CONNECT_STATE_CONNECTED;\x0d\n  process.nextTick(() => self.emit('connect'));\x0d\n}\x0d\n\x0d\n\x0d\nSocket.prototype.disconnect = function() {\x0d\n  const state = this[kStateSymbol];\x0d\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\x0d\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\x0d\n\x0d\n  const err = state.handle.disconnect();\x0d\n  if (err)\x0d\n    throw errnoException(err\x2C 'connect');\x0d\n  else\x0d\n    state.connectState = CONNECT_STATE_DISCONNECTED;\x0d\n};\x0d\n\x0d\n\x0d\n// Thin wrapper around `send`\x2C here for compatibility with dgram_legacy.js\x0d\nSocket.prototype.sendto = function(buffer\x2C\x0d\n                                   offset\x2C\x0d\n                                   length\x2C\x0d\n                                   port\x2C\x0d\n                                   address\x2C\x0d\n                                   callback) {\x0d\n  validateNumber(offset\x2C 'offset');\x0d\n  validateNumber(length\x2C 'length');\x0d\n  validateNumber(port\x2C 'port');\x0d\n  validateString(address\x2C 'address');\x0d\n\x0d\n  this.send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback);\x0d\n};\x0d\n\x0d\n\x0d\nfunction sliceBuffer(buffer\x2C offset\x2C length) {\x0d\n  if (typeof buffer === 'string') {\x0d\n    buffer = Buffer.from(buffer);\x0d\n  } else if (!isArrayBufferView(buffer)) {\x0d\n    throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\x0d\n                                   ['Buffer'\x2C\x0d\n                                    'TypedArray'\x2C\x0d\n                                    'DataView'\x2C\x0d\n                                    'string']\x2C\x0d\n                                   buffer);\x0d\n  }\x0d\n\x0d\n  offset = offset >>> 0;\x0d\n  length = length >>> 0;\x0d\n  if (offset > buffer.byteLength) {\x0d\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('offset');\x0d\n  }\x0d\n\x0d\n  if (offset + length > buffer.byteLength) {\x0d\n    throw new ERR_BUFFER_OUT_OF_BOUNDS('length');\x0d\n  }\x0d\n\x0d\n  return Buffer.from(buffer.buffer\x2C buffer.byteOffset + offset\x2C length);\x0d\n}\x0d\n\x0d\n\x0d\nfunction fixBufferList(list) {\x0d\n  const newlist = new Array(list.length);\x0d\n\x0d\n  for (let i = 0\x2C l = list.length; i < l; i++) {\x0d\n    const buf = list[i];\x0d\n    if (typeof buf === 'string')\x0d\n      newlist[i] = Buffer.from(buf);\x0d\n    else if (!isArrayBufferView(buf))\x0d\n      return null;\x0d\n    else\x0d\n      newlist[i] = Buffer.from(buf.buffer\x2C buf.byteOffset\x2C buf.byteLength);\x0d\n  }\x0d\n\x0d\n  return newlist;\x0d\n}\x0d\n\x0d\n\x0d\nfunction enqueue(self\x2C toEnqueue) {\x0d\n  const state = self[kStateSymbol];\x0d\n\x0d\n  // If the send queue hasn't been initialized yet\x2C do it\x2C and install an\x0d\n  // event handler that flushes the send queue after binding is done.\x0d\n  if (state.queue === undefined) {\x0d\n    state.queue = [];\x0d\n    self.once(EventEmitter.errorMonitor\x2C onListenError);\x0d\n    self.once('listening'\x2C onListenSuccess);\x0d\n  }\x0d\n  ArrayPrototypePush(state.queue\x2C toEnqueue);\x0d\n}\x0d\n\x0d\n\x0d\nfunction onListenSuccess() {\x0d\n  this.removeListener(EventEmitter.errorMonitor\x2C onListenError);\x0d\n  FunctionPrototypeCall(clearQueue\x2C this);\x0d\n}\x0d\n\x0d\n\x0d\nfunction onListenError(err) {\x0d\n  this.removeListener('listening'\x2C onListenSuccess);\x0d\n  this[kStateSymbol].queue = undefined;\x0d\n}\x0d\n\x0d\n\x0d\nfunction clearQueue() {\x0d\n  const state = this[kStateSymbol];\x0d\n  const queue = state.queue;\x0d\n  state.queue = undefined;\x0d\n\x0d\n  // Flush the send queue.\x0d\n  for (const queueEntry of queue)\x0d\n    queueEntry();\x0d\n}\x0d\n\x0d\nfunction isConnected(self) {\x0d\n  try {\x0d\n    self.remoteAddress();\x0d\n    return true;\x0d\n  } catch {\x0d\n    return false;\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\n// valid combinations\x0d\n// For connectionless sockets\x0d\n// send(buffer\x2C offset\x2C length\x2C port\x2C address\x2C callback)\x0d\n// send(buffer\x2C offset\x2C length\x2C port\x2C address)\x0d\n// send(buffer\x2C offset\x2C length\x2C port\x2C callback)\x0d\n// send(buffer\x2C offset\x2C length\x2C port)\x0d\n// send(bufferOrList\x2C port\x2C address\x2C callback)\x0d\n// send(bufferOrList\x2C port\x2C address)\x0d\n// send(bufferOrList\x2C port\x2C callback)\x0d\n// send(bufferOrList\x2C port)\x0d\n// For connected sockets\x0d\n// send(buffer\x2C offset\x2C length\x2C callback)\x0d\n// send(buffer\x2C offset\x2C length)\x0d\n// send(bufferOrList\x2C callback)\x0d\n// send(bufferOrList)\x0d\nSocket.prototype.send = function(buffer\x2C\x0d\n                                 offset\x2C\x0d\n                                 length\x2C\x0d\n                                 port\x2C\x0d\n                                 address\x2C\x0d\n                                 callback) {\x0d\n\x0d\n  let list;\x0d\n  const state = this[kStateSymbol];\x0d\n  const connected = state.connectState === CONNECT_STATE_CONNECTED;\x0d\n  if (!connected) {\x0d\n    if (address || (port && typeof port !== 'function')) {\x0d\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\x0d\n    } else {\x0d\n      callback = port;\x0d\n      port = offset;\x0d\n      address = length;\x0d\n    }\x0d\n  } else {\x0d\n    if (typeof length === 'number') {\x0d\n      buffer = sliceBuffer(buffer\x2C offset\x2C length);\x0d\n      if (typeof port === 'function') {\x0d\n        callback = port;\x0d\n        port = null;\x0d\n      }\x0d\n    } else {\x0d\n      callback = offset;\x0d\n    }\x0d\n\x0d\n    if (port || address)\x0d\n      throw new ERR_SOCKET_DGRAM_IS_CONNECTED();\x0d\n  }\x0d\n\x0d\n  if (!ArrayIsArray(buffer)) {\x0d\n    if (typeof buffer === 'string') {\x0d\n      list = [ Buffer.from(buffer) ];\x0d\n    } else if (!isArrayBufferView(buffer)) {\x0d\n      throw new ERR_INVALID_ARG_TYPE('buffer'\x2C\x0d\n                                     ['Buffer'\x2C\x0d\n                                      'TypedArray'\x2C\x0d\n                                      'DataView'\x2C\x0d\n                                      'string']\x2C\x0d\n                                     buffer);\x0d\n    } else {\x0d\n      list = [ buffer ];\x0d\n    }\x0d\n  } else if (!(list = fixBufferList(buffer))) {\x0d\n    throw new ERR_INVALID_ARG_TYPE('buffer list arguments'\x2C\x0d\n                                   ['Buffer'\x2C\x0d\n                                    'TypedArray'\x2C\x0d\n                                    'DataView'\x2C\x0d\n                                    'string']\x2C\x0d\n                                   buffer);\x0d\n  }\x0d\n\x0d\n  if (!connected)\x0d\n    port = validatePort(port\x2C 'Port'\x2C false);\x0d\n\x0d\n  // Normalize callback so it's either a function or undefined but not anything\x0d\n  // else.\x0d\n  if (typeof callback !== 'function')\x0d\n    callback = undefined;\x0d\n\x0d\n  if (typeof address === 'function') {\x0d\n    callback = address;\x0d\n    address = undefined;\x0d\n  } else if (address != null) {\x0d\n    validateString(address\x2C 'address');\x0d\n  }\x0d\n\x0d\n  healthCheck(this);\x0d\n\x0d\n  if (state.bindState === BIND_STATE_UNBOUND)\x0d\n    this.bind({ port: 0\x2C exclusive: true }\x2C null);\x0d\n\x0d\n  if (list.length === 0)\x0d\n    ArrayPrototypePush(list\x2C Buffer.alloc(0));\x0d\n\x0d\n  // If the socket hasn't been bound yet\x2C push the outbound packet onto the\x0d\n  // send queue and send after binding is complete.\x0d\n  if (state.bindState !== BIND_STATE_BOUND) {\x0d\n    enqueue(this\x2C FunctionPrototypeBind(this.send\x2C this\x2C\x0d\n                                        list\x2C port\x2C address\x2C callback));\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  const afterDns = (ex\x2C ip) => {\x0d\n    defaultTriggerAsyncIdScope(\x0d\n      this[async_id_symbol]\x2C\x0d\n      doSend\x2C\x0d\n      ex\x2C this\x2C ip\x2C list\x2C address\x2C port\x2C callback\x0d\n    );\x0d\n  };\x0d\n\x0d\n  if (!connected) {\x0d\n    state.handle.lookup(address\x2C afterDns);\x0d\n  } else {\x0d\n    afterDns(null\x2C null);\x0d\n  }\x0d\n};\x0d\n\x0d\nfunction doSend(ex\x2C self\x2C ip\x2C list\x2C address\x2C port\x2C callback) {\x0d\n  const state = self[kStateSymbol];\x0d\n\x0d\n  if (ex) {\x0d\n    if (typeof callback === 'function') {\x0d\n      process.nextTick(callback\x2C ex);\x0d\n      return;\x0d\n    }\x0d\n\x0d\n    process.nextTick(() => self.emit('error'\x2C ex));\x0d\n    return;\x0d\n  } else if (!state.handle) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  const req = new SendWrap();\x0d\n  req.list = list;  // Keep reference alive.\x0d\n  req.address = address;\x0d\n  req.port = port;\x0d\n  if (callback) {\x0d\n    req.callback = callback;\x0d\n    req.oncomplete = afterSend;\x0d\n  }\x0d\n\x0d\n  let err;\x0d\n  if (port)\x0d\n    err = state.handle.send(req\x2C list\x2C list.length\x2C port\x2C ip\x2C !!callback);\x0d\n  else\x0d\n    err = state.handle.send(req\x2C list\x2C list.length\x2C !!callback);\x0d\n\x0d\n  if (err >= 1) {\x0d\n    // Synchronous finish. The return code is msg_length + 1 so that we can\x0d\n    // distinguish between synchronous success and asynchronous success.\x0d\n    if (callback)\x0d\n      process.nextTick(callback\x2C null\x2C err - 1);\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (err && callback) {\x0d\n    // Don't emit as error\x2C dgram_legacy.js compatibility\x0d\n    const ex = exceptionWithHostPort(err\x2C 'send'\x2C address\x2C port);\x0d\n    process.nextTick(callback\x2C ex);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction afterSend(err\x2C sent) {\x0d\n  if (err) {\x0d\n    err = exceptionWithHostPort(err\x2C 'send'\x2C this.address\x2C this.port);\x0d\n  } else {\x0d\n    err = null;\x0d\n  }\x0d\n\x0d\n  this.callback(err\x2C sent);\x0d\n}\x0d\n\x0d\nSocket.prototype.close = function(callback) {\x0d\n  const state = this[kStateSymbol];\x0d\n  const queue = state.queue;\x0d\n\x0d\n  if (typeof callback === 'function')\x0d\n    this.on('close'\x2C callback);\x0d\n\x0d\n  if (queue !== undefined) {\x0d\n    ArrayPrototypePush(queue\x2C FunctionPrototypeBind(this.close\x2C this));\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  healthCheck(this);\x0d\n  stopReceiving(this);\x0d\n  state.handle.close();\x0d\n  state.handle = null;\x0d\n  defaultTriggerAsyncIdScope(this[async_id_symbol]\x2C\x0d\n                             process.nextTick\x2C\x0d\n                             socketCloseNT\x2C\x0d\n                             this);\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nfunction socketCloseNT(self) {\x0d\n  self.emit('close');\x0d\n}\x0d\n\x0d\n\x0d\nSocket.prototype.address = function() {\x0d\n  healthCheck(this);\x0d\n\x0d\n  const out = {};\x0d\n  const err = this[kStateSymbol].handle.getsockname(out);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'getsockname');\x0d\n  }\x0d\n\x0d\n  return out;\x0d\n};\x0d\n\x0d\nSocket.prototype.remoteAddress = function() {\x0d\n  healthCheck(this);\x0d\n\x0d\n  const state = this[kStateSymbol];\x0d\n  if (state.connectState !== CONNECT_STATE_CONNECTED)\x0d\n    throw new ERR_SOCKET_DGRAM_NOT_CONNECTED();\x0d\n\x0d\n  const out = {};\x0d\n  const err = state.handle.getpeername(out);\x0d\n  if (err)\x0d\n    throw errnoException(err\x2C 'getpeername');\x0d\n\x0d\n  return out;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.setBroadcast = function(arg) {\x0d\n  const err = this[kStateSymbol].handle.setBroadcast(arg ? 1 : 0);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'setBroadcast');\x0d\n  }\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.setTTL = function(ttl) {\x0d\n  validateNumber(ttl\x2C 'ttl');\x0d\n\x0d\n  const err = this[kStateSymbol].handle.setTTL(ttl);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'setTTL');\x0d\n  }\x0d\n\x0d\n  return ttl;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.setMulticastTTL = function(ttl) {\x0d\n  validateNumber(ttl\x2C 'ttl');\x0d\n\x0d\n  const err = this[kStateSymbol].handle.setMulticastTTL(ttl);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'setMulticastTTL');\x0d\n  }\x0d\n\x0d\n  return ttl;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.setMulticastLoopback = function(arg) {\x0d\n  const err = this[kStateSymbol].handle.setMulticastLoopback(arg ? 1 : 0);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'setMulticastLoopback');\x0d\n  }\x0d\n\x0d\n  return arg; // 0.4 compatibility\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.setMulticastInterface = function(interfaceAddress) {\x0d\n  healthCheck(this);\x0d\n  validateString(interfaceAddress\x2C 'interfaceAddress');\x0d\n\x0d\n  const err = this[kStateSymbol].handle.setMulticastInterface(interfaceAddress);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'setMulticastInterface');\x0d\n  }\x0d\n};\x0d\n\x0d\nSocket.prototype.addMembership = function(multicastAddress\x2C\x0d\n                                          interfaceAddress) {\x0d\n  healthCheck(this);\x0d\n\x0d\n  if (!multicastAddress) {\x0d\n    throw new ERR_MISSING_ARGS('multicastAddress');\x0d\n  }\x0d\n\x0d\n  const { handle } = this[kStateSymbol];\x0d\n  const err = handle.addMembership(multicastAddress\x2C interfaceAddress);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'addMembership');\x0d\n  }\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.dropMembership = function(multicastAddress\x2C\x0d\n                                           interfaceAddress) {\x0d\n  healthCheck(this);\x0d\n\x0d\n  if (!multicastAddress) {\x0d\n    throw new ERR_MISSING_ARGS('multicastAddress');\x0d\n  }\x0d\n\x0d\n  const { handle } = this[kStateSymbol];\x0d\n  const err = handle.dropMembership(multicastAddress\x2C interfaceAddress);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'dropMembership');\x0d\n  }\x0d\n};\x0d\n\x0d\nSocket.prototype.addSourceSpecificMembership = function(sourceAddress\x2C\x0d\n                                                        groupAddress\x2C\x0d\n                                                        interfaceAddress) {\x0d\n  healthCheck(this);\x0d\n\x0d\n  validateString(sourceAddress\x2C 'sourceAddress');\x0d\n  validateString(groupAddress\x2C 'groupAddress');\x0d\n\x0d\n  const err =\x0d\n    this[kStateSymbol].handle.addSourceSpecificMembership(sourceAddress\x2C\x0d\n                                                          groupAddress\x2C\x0d\n                                                          interfaceAddress);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'addSourceSpecificMembership');\x0d\n  }\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.dropSourceSpecificMembership = function(sourceAddress\x2C\x0d\n                                                         groupAddress\x2C\x0d\n                                                         interfaceAddress) {\x0d\n  healthCheck(this);\x0d\n\x0d\n  validateString(sourceAddress\x2C 'sourceAddress');\x0d\n  validateString(groupAddress\x2C 'groupAddress');\x0d\n\x0d\n  const err =\x0d\n    this[kStateSymbol].handle.dropSourceSpecificMembership(sourceAddress\x2C\x0d\n                                                           groupAddress\x2C\x0d\n                                                           interfaceAddress);\x0d\n  if (err) {\x0d\n    throw errnoException(err\x2C 'dropSourceSpecificMembership');\x0d\n  }\x0d\n};\x0d\n\x0d\n\x0d\nfunction healthCheck(socket) {\x0d\n  if (!socket[kStateSymbol].handle) {\x0d\n    // Error message from dgram_legacy.js.\x0d\n    throw new ERR_SOCKET_DGRAM_NOT_RUNNING();\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nfunction stopReceiving(socket) {\x0d\n  const state = socket[kStateSymbol];\x0d\n\x0d\n  if (!state.receiving)\x0d\n    return;\x0d\n\x0d\n  state.handle.recvStop();\x0d\n  state.receiving = false;\x0d\n}\x0d\n\x0d\n\x0d\nfunction onMessage(nread\x2C handle\x2C buf\x2C rinfo) {\x0d\n  const self = handle[owner_symbol];\x0d\n  if (nread < 0) {\x0d\n    return self.emit('error'\x2C errnoException(nread\x2C 'recvmsg'));\x0d\n  }\x0d\n  rinfo.size = buf.length; // compatibility\x0d\n  self.emit('message'\x2C buf\x2C rinfo);\x0d\n}\x0d\n\x0d\n\x0d\nSocket.prototype.ref = function() {\x0d\n  const handle = this[kStateSymbol].handle;\x0d\n\x0d\n  if (handle)\x0d\n    handle.ref();\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.unref = function() {\x0d\n  const handle = this[kStateSymbol].handle;\x0d\n\x0d\n  if (handle)\x0d\n    handle.unref();\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.setRecvBufferSize = function(size) {\x0d\n  bufferSize(this\x2C size\x2C RECV_BUFFER);\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.setSendBufferSize = function(size) {\x0d\n  bufferSize(this\x2C size\x2C SEND_BUFFER);\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.getRecvBufferSize = function() {\x0d\n  return bufferSize(this\x2C 0\x2C RECV_BUFFER);\x0d\n};\x0d\n\x0d\n\x0d\nSocket.prototype.getSendBufferSize = function() {\x0d\n  return bufferSize(this\x2C 0\x2C SEND_BUFFER);\x0d\n};\x0d\n\x0d\n\x0d\n// Deprecated private APIs.\x0d\nObjectDefineProperty(Socket.prototype\x2C '_handle'\x2C {\x0d\n  get: deprecate(function() {\x0d\n    return this[kStateSymbol].handle;\x0d\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\x2C\x0d\n  set: deprecate(function(val) {\x0d\n    this[kStateSymbol].handle = val;\x0d\n  }\x2C 'Socket.prototype._handle is deprecated'\x2C 'DEP0112')\x0d\n});\x0d\n\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C '_receiving'\x2C {\x0d\n  get: deprecate(function() {\x0d\n    return this[kStateSymbol].receiving;\x0d\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\x2C\x0d\n  set: deprecate(function(val) {\x0d\n    this[kStateSymbol].receiving = val;\x0d\n  }\x2C 'Socket.prototype._receiving is deprecated'\x2C 'DEP0112')\x0d\n});\x0d\n\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C '_bindState'\x2C {\x0d\n  get: deprecate(function() {\x0d\n    return this[kStateSymbol].bindState;\x0d\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\x2C\x0d\n  set: deprecate(function(val) {\x0d\n    this[kStateSymbol].bindState = val;\x0d\n  }\x2C 'Socket.prototype._bindState is deprecated'\x2C 'DEP0112')\x0d\n});\x0d\n\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C '_queue'\x2C {\x0d\n  get: deprecate(function() {\x0d\n    return this[kStateSymbol].queue;\x0d\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\x2C\x0d\n  set: deprecate(function(val) {\x0d\n    this[kStateSymbol].queue = val;\x0d\n  }\x2C 'Socket.prototype._queue is deprecated'\x2C 'DEP0112')\x0d\n});\x0d\n\x0d\n\x0d\nObjectDefineProperty(Socket.prototype\x2C '_reuseAddr'\x2C {\x0d\n  get: deprecate(function() {\x0d\n    return this[kStateSymbol].reuseAddr;\x0d\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\x2C\x0d\n  set: deprecate(function(val) {\x0d\n    this[kStateSymbol].reuseAddr = val;\x0d\n  }\x2C 'Socket.prototype._reuseAddr is deprecated'\x2C 'DEP0112')\x0d\n});\x0d\n\x0d\n\x0d\nSocket.prototype._healthCheck = deprecate(function() {\x0d\n  healthCheck(this);\x0d\n}\x2C 'Socket.prototype._healthCheck() is deprecated'\x2C 'DEP0112');\x0d\n\x0d\n\x0d\nSocket.prototype._stopReceiving = deprecate(function() {\x0d\n  stopReceiving(this);\x0d\n}\x2C 'Socket.prototype._stopReceiving() is deprecated'\x2C 'DEP0112');\x0d\n\x0d\n\x0d\n// Legacy alias on the C++ wrapper object. This is not public API\x2C so we may\x0d\n// want to runtime-deprecate it at some point. There's no hurry\x2C though.\x0d\nObjectDefineProperty(UDP.prototype\x2C 'owner'\x2C {\x0d\n  get() { return this[owner_symbol]; }\x2C\x0d\n  set(v) { return this[owner_symbol] = v; }\x0d\n});\x0d\n\x0d\n\x0d\nmodule.exports = {\x0d\n  _createSocketHandle: deprecate(\x0d\n    _createSocketHandle\x2C\x0d\n    'dgram._createSocketHandle() is deprecated'\x2C\x0d\n    'DEP0112'\x0d\n  )\x2C\x0d\n  createSocket\x2C\x0d\n  Socket\x0d\n};\x0d\n
code-source-info,0x1c1d96f8b26,134,0,28703,C0O0C4O28703,,
code-creation,Function,10,256336,0x1c1d96faa8e,1507, node:dgram:1:1,0x1c1d96f8aa0,~
code-source-info,0x1c1d96faa8e,134,0,28703,C0O0C276O1183C282O1193C288O1210C294O1233C300O1259C306O1285C311O1310C316O1335C322O1385C328O1385C333O1482C339O1482C344O1425C350O1442C355O1466C361O1538C364O1538C369O1518C375O1871C380O1575C386O1604C392O1629C398O1650C404O1679C410O1710C416O1737C422O1771C428O1806C434O1839C440O1983C446O1983C451O1890C457O1902C463O1926C469O1945C475O1964C481O2035C487O2035C492O2024C498O2077C504O2077C509O2063C514O2134C520O2134C525O2112C531O2188C537O2188C541O2188C543O2298C549O2298C554O2219C565O2261C571O2278C577O2361C580O2361C585O2389C590O2340C596O2465C599O2465C604O2465C609O2421C615O2443C620O2451C626O2524C627O2524C629O2555C631O2555C633O2584C635O2584C637O2625C638O2625C640O2662C642O2662C644O2698C646O2698C648O2724C649O2724C651O2751C652O2751C654O2794C655O2794C657O2935C661O2928C663O2989C667O2982C669O4363C672O4391C680O4415C685O4363C690O4428C696O4428C701O6414C704O6421C713O6436C717O10182C720O10189C729O10207C733O12078C736O12085C745O12106C749O12508C752O12515C761O12532C765O15808C768O15815C777O15830C781O20203C784O20210C793O20226C797O20887C800O20894C809O20912C813O21119C816O21126C825O21150C829O21482C832O21489C841O21512C845O21674C848O21681C857O21698C861O21890C864O21897C873O21923C877O22133C880O22140C889O22171C893O22387C896O22394C905O22426C909O22703C912O22710C921O22734C925O23130C928O23137C937O23162C941O23559C944O23566C953O23604C957O24235C960O24242C969O24281C973O25537C976O25544C985O25558C989O25681C992O25688C1001O25704C1005O25829C1008O25836C1017O25864C1021O25932C1024O25939C1033O25967C1037O26035C1040O26042C1049O26070C1053O26138C1056O26145C1065O26173C1069O26270C1072O26298C1085O26330C1096O26330C1105O26460C1116O26460C1125O26270C1130O26593C1133O26621C1146O26656C1157O26656C1166O26792C1177O26792C1186O26593C1191O26931C1194O26959C1207O26994C1218O26994C1227O27130C1238O27130C1247O26931C1252O27269C1255O27297C1268O27328C1279O27328C1288O27456C1299O27456C1308O27269C1313O27587C1316O27615C1329O27650C1340O27650C1349O27786C1360O27786C1369O27587C1374O27925C1377O27932C1382O27957C1393O27957C1398O27955C1402O28072C1405O28079C1410O28106C1421O28106C1426O28104C1430O28402C1443O28427C1451O28468C1459O28377C1464O28520C1478O28563C1489O28674C1495O28691C1501O28535C1506O28702,,
code-creation,Eval,10,256764,0x1c1d96fdf46,5, node:internal/dgram:1:1,0x1c1d96fdd40,~
script-source,135,node:internal/dgram,'use strict';\x0d\n\x0d\nconst {\x0d\n  FunctionPrototypeBind\x2C\x0d\n  Symbol\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { codes } = require('internal/errors');\x0d\nconst { UDP } = internalBinding('udp_wrap');\x0d\nconst { guessHandleType } = internalBinding('util');\x0d\nconst {\x0d\n  isInt32\x2C\x0d\n  validateFunction\x2C\x0d\n} = require('internal/validators');\x0d\nconst { UV_EINVAL } = internalBinding('uv');\x0d\nconst {\x0d\n  ERR_SOCKET_BAD_TYPE\x2C\x0d\n} = codes;\x0d\nconst kStateSymbol = Symbol('state symbol');\x0d\nlet dns;  // Lazy load for startup performance.\x0d\n\x0d\n\x0d\nfunction lookup4(lookup\x2C address\x2C callback) {\x0d\n  return lookup(address || '127.0.0.1'\x2C 4\x2C callback);\x0d\n}\x0d\n\x0d\n\x0d\nfunction lookup6(lookup\x2C address\x2C callback) {\x0d\n  return lookup(address || '::1'\x2C 6\x2C callback);\x0d\n}\x0d\n\x0d\nfunction newHandle(type\x2C lookup) {\x0d\n  if (lookup === undefined) {\x0d\n    if (dns === undefined) {\x0d\n      dns = require('dns');\x0d\n    }\x0d\n\x0d\n    lookup = dns.lookup;\x0d\n  } else {\x0d\n    validateFunction(lookup\x2C 'lookup');\x0d\n  }\x0d\n\x0d\n  if (type === 'udp4') {\x0d\n    const handle = new UDP();\x0d\n\x0d\n    handle.lookup = FunctionPrototypeBind(lookup4\x2C handle\x2C lookup);\x0d\n    return handle;\x0d\n  }\x0d\n\x0d\n  if (type === 'udp6') {\x0d\n    const handle = new UDP();\x0d\n\x0d\n    handle.lookup = FunctionPrototypeBind(lookup6\x2C handle\x2C lookup);\x0d\n    handle.bind = handle.bind6;\x0d\n    handle.connect = handle.connect6;\x0d\n    handle.send = handle.send6;\x0d\n    return handle;\x0d\n  }\x0d\n\x0d\n  throw new ERR_SOCKET_BAD_TYPE();\x0d\n}\x0d\n\x0d\n\x0d\nfunction _createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags) {\x0d\n  const handle = newHandle(addressType);\x0d\n  let err;\x0d\n\x0d\n  if (isInt32(fd) && fd > 0) {\x0d\n    const type = guessHandleType(fd);\x0d\n    if (type !== 'UDP') {\x0d\n      err = UV_EINVAL;\x0d\n    } else {\x0d\n      err = handle.open(fd);\x0d\n    }\x0d\n  } else if (port || address) {\x0d\n    err = handle.bind(address\x2C port || 0\x2C flags);\x0d\n  }\x0d\n\x0d\n  if (err) {\x0d\n    handle.close();\x0d\n    return err;\x0d\n  }\x0d\n\x0d\n  return handle;\x0d\n}\x0d\n\x0d\n\x0d\nmodule.exports = {\x0d\n  kStateSymbol\x2C\x0d\n  _createSocketHandle\x2C\x0d\n  newHandle\x0d\n};\x0d\n
code-source-info,0x1c1d96fdf46,135,0,1941,C0O0C4O1941,,
code-creation,Function,10,256900,0x1c1d96fe20e,196, node:internal/dgram:1:1,0x1c1d96fdec0,~
code-source-info,0x1c1d96fe20e,135,0,1941,C0O0C56O28C62O54C67O101C73O101C78O91C83O146C86O146C91O138C97O204C100O204C105O184C111O276C117O276C122O241C128O253C134O331C137O331C142O317C148O366C154O421C157O421C162O450C163O450C165O1863C172O1885C178O1902C184O1926C190O1878C195O1940,,
code-creation,Function,11,257141,0x29be72c7c00,1384,deprecate node:internal/util:96:19,0x25ca2705698,^
code-source-info,0x29be72c7c00,16,2503,3720,,,
code-creation,Function,11,257173,0x29be72c8200,292,validateString node:internal/validators:118:24,0x147335fcf18,^
code-source-info,0x29be72c8200,15,3534,3646,,,
code-creation,Function,11,257214,0x29be72c83c0,2032,toNamespacedPath node:path:618:19,0x394c9e0d6f8,^
code-source-info,0x29be72c83c0,41,20086,21201,,,
code-creation,Function,11,257240,0x29be72c8c40,336,isFileType node:fs:205:20,0x1d498296f60,^
code-source-info,0x29be72c8c40,81,5489,5737,,,
new,MemoryChunk,0x30632480000,262144
code-creation,Eval,10,257481,0x109c10ffd2e,5, node:internal/socket_list:1:1,0x109c10ffbd8,~
script-source,136,node:internal/socket_list,'use strict';\x0d\n\x0d\nconst { ERR_CHILD_CLOSED_BEFORE_REPLY } = require('internal/errors').codes;\x0d\n\x0d\nconst EventEmitter = require('events');\x0d\n\x0d\n// This object keeps track of the sockets that are sent\x0d\nclass SocketListSend extends EventEmitter {\x0d\n  constructor(child\x2C key) {\x0d\n    super();\x0d\n    this.key = key;\x0d\n    this.child = child;\x0d\n    child.once('exit'\x2C () => this.emit('exit'\x2C this));\x0d\n  }\x0d\n\x0d\n  _request(msg\x2C cmd\x2C swallowErrors\x2C callback) {\x0d\n    const self = this;\x0d\n\x0d\n    if (!this.child.connected) return onclose();\x0d\n    this.child._send(msg\x2C undefined\x2C swallowErrors);\x0d\n\x0d\n    function onclose() {\x0d\n      self.child.removeListener('internalMessage'\x2C onreply);\x0d\n      callback(new ERR_CHILD_CLOSED_BEFORE_REPLY());\x0d\n    }\x0d\n\x0d\n    function onreply(msg) {\x0d\n      if (!(msg.cmd === cmd && msg.key === self.key)) return;\x0d\n      self.child.removeListener('disconnect'\x2C onclose);\x0d\n      self.child.removeListener('internalMessage'\x2C onreply);\x0d\n\x0d\n      callback(null\x2C msg);\x0d\n    }\x0d\n\x0d\n    this.child.once('disconnect'\x2C onclose);\x0d\n    this.child.on('internalMessage'\x2C onreply);\x0d\n  }\x0d\n\x0d\n  close(callback) {\x0d\n    this._request({\x0d\n      cmd: 'NODE_SOCKET_NOTIFY_CLOSE'\x2C\x0d\n      key: this.key\x0d\n    }\x2C 'NODE_SOCKET_ALL_CLOSED'\x2C true\x2C callback);\x0d\n  }\x0d\n\x0d\n  getConnections(callback) {\x0d\n    this._request({\x0d\n      cmd: 'NODE_SOCKET_GET_COUNT'\x2C\x0d\n      key: this.key\x0d\n    }\x2C 'NODE_SOCKET_COUNT'\x2C false\x2C (err\x2C msg) => {\x0d\n      if (err) return callback(err);\x0d\n      callback(null\x2C msg.count);\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\n// This object keeps track of the sockets that are received\x0d\nclass SocketListReceive extends EventEmitter {\x0d\n  constructor(child\x2C key) {\x0d\n    super();\x0d\n\x0d\n    this.connections = 0;\x0d\n    this.key = key;\x0d\n    this.child = child;\x0d\n\x0d\n    function onempty(self) {\x0d\n      if (!self.child.connected) return;\x0d\n\x0d\n      self.child._send({\x0d\n        cmd: 'NODE_SOCKET_ALL_CLOSED'\x2C\x0d\n        key: self.key\x0d\n      }\x2C undefined\x2C true);\x0d\n    }\x0d\n\x0d\n    this.child.on('internalMessage'\x2C (msg) => {\x0d\n      if (msg.key !== this.key) return;\x0d\n\x0d\n      if (msg.cmd === 'NODE_SOCKET_NOTIFY_CLOSE') {\x0d\n        // Already empty\x0d\n        if (this.connections === 0) return onempty(this);\x0d\n\x0d\n        // Wait for sockets to get closed\x0d\n        this.once('empty'\x2C onempty);\x0d\n      } else if (msg.cmd === 'NODE_SOCKET_GET_COUNT') {\x0d\n        if (!this.child.connected) return;\x0d\n        this.child._send({\x0d\n          cmd: 'NODE_SOCKET_COUNT'\x2C\x0d\n          key: this.key\x2C\x0d\n          count: this.connections\x0d\n        });\x0d\n      }\x0d\n    });\x0d\n  }\x0d\n\x0d\n  add(obj) {\x0d\n    this.connections++;\x0d\n\x0d\n    // Notify the previous owner of the socket about its state change\x0d\n    obj.socket.once('close'\x2C () => {\x0d\n      this.connections--;\x0d\n\x0d\n      if (this.connections === 0) this.emit('empty'\x2C this);\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nmodule.exports = { SocketListSend\x2C SocketListReceive };\x0d\n
code-source-info,0x109c10ffd2e,136,0,2813,C0O0C4O2813,,
code-creation,Function,10,257651,0x306324814b6,126, node:internal/socket_list:1:1,0x109c10ffca8,~
code-source-info,0x306324814b6,136,0,2813,C0O0C8O59C11O59C16O85C21O25C27O117C30O117C35O225C73O1583C101O2756C108O2775C114O2791C120O2771C125O2812,,
code-creation,LazyCompile,10,257867,0x30632481ea6,14,customPromiseExecFunction node:child_process:230:35,0x1c1d96dc680,~
code-source-info,0x30632481ea6,129,6792,7172,C0O6792C9O6807C13O7169,,
code-creation,Eval,10,258042,0x3063248410e,5, node:internal/cluster/round_robin_handle:1:1,0x30632483ef8,~
script-source,137,node:internal/cluster/round_robin_handle,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  Boolean\x2C\x0d\n  ObjectCreate\x2C\x0d\n  SafeMap\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst assert = require('internal/assert');\x0d\nconst net = require('net');\x0d\nconst { sendHelper } = require('internal/cluster/utils');\x0d\nconst { append\x2C init\x2C isEmpty\x2C peek\x2C remove } = require('internal/linkedlist');\x0d\nconst { constants } = internalBinding('tcp_wrap');\x0d\n\x0d\nmodule.exports = RoundRobinHandle;\x0d\n\x0d\nfunction RoundRobinHandle(key\x2C address\x2C { port\x2C fd\x2C flags }) {\x0d\n  this.key = key;\x0d\n  this.all = new SafeMap();\x0d\n  this.free = new SafeMap();\x0d\n  this.handles = init(ObjectCreate(null));\x0d\n  this.handle = null;\x0d\n  this.server = net.createServer(assert.fail);\x0d\n\x0d\n  if (fd >= 0)\x0d\n    this.server.listen({ fd });\x0d\n  else if (port >= 0) {\x0d\n    this.server.listen({\x0d\n      port\x2C\x0d\n      host: address\x2C\x0d\n      // Currently\x2C net module only supports `ipv6Only` option in `flags`.\x0d\n      ipv6Only: Boolean(flags & constants.UV_TCP_IPV6ONLY)\x2C\x0d\n    });\x0d\n  } else\x0d\n    this.server.listen(address);  // UNIX socket path.\x0d\n\x0d\n  this.server.once('listening'\x2C () => {\x0d\n    this.handle = this.server._handle;\x0d\n    this.handle.onconnection = (err\x2C handle) => this.distribute(err\x2C handle);\x0d\n    this.server._handle = null;\x0d\n    this.server = null;\x0d\n  });\x0d\n}\x0d\n\x0d\nRoundRobinHandle.prototype.add = function(worker\x2C send) {\x0d\n  assert(this.all.has(worker.id) === false);\x0d\n  this.all.set(worker.id\x2C worker);\x0d\n\x0d\n  const done = () => {\x0d\n    if (this.handle.getsockname) {\x0d\n      const out = {};\x0d\n      this.handle.getsockname(out);\x0d\n      // TODO(bnoordhuis) Check err.\x0d\n      send(null\x2C { sockname: out }\x2C null);\x0d\n    } else {\x0d\n      send(null\x2C null\x2C null);  // UNIX socket.\x0d\n    }\x0d\n\x0d\n    this.handoff(worker);  // In case there are connections pending.\x0d\n  };\x0d\n\x0d\n  if (this.server === null)\x0d\n    return done();\x0d\n\x0d\n  // Still busy binding.\x0d\n  this.server.once('listening'\x2C done);\x0d\n  this.server.once('error'\x2C (err) => {\x0d\n    send(err.errno\x2C null);\x0d\n  });\x0d\n};\x0d\n\x0d\nRoundRobinHandle.prototype.remove = function(worker) {\x0d\n  const existed = this.all.delete(worker.id);\x0d\n\x0d\n  if (!existed)\x0d\n    return false;\x0d\n\x0d\n  this.free.delete(worker.id);\x0d\n\x0d\n  if (this.all.size !== 0)\x0d\n    return false;\x0d\n\x0d\n  while (!isEmpty(this.handles)) {\x0d\n    const handle = peek(this.handles);\x0d\n    handle.close();\x0d\n    remove(handle);\x0d\n  }\x0d\n\x0d\n  this.handle.close();\x0d\n  this.handle = null;\x0d\n  return true;\x0d\n};\x0d\n\x0d\nRoundRobinHandle.prototype.distribute = function(err\x2C handle) {\x0d\n  append(this.handles\x2C handle);\x0d\n  // eslint-disable-next-line node-core/no-array-destructuring\x0d\n  const [ workerEntry ] = this.free; // this.free is a SafeMap\x0d\n\x0d\n  if (ArrayIsArray(workerEntry)) {\x0d\n    const { 0: workerId\x2C 1: worker } = workerEntry;\x0d\n    this.free.delete(workerId);\x0d\n    this.handoff(worker);\x0d\n  }\x0d\n};\x0d\n\x0d\nRoundRobinHandle.prototype.handoff = function(worker) {\x0d\n  if (!this.all.has(worker.id)) {\x0d\n    return;  // Worker is closing (or has closed) the server.\x0d\n  }\x0d\n\x0d\n  const handle = peek(this.handles);\x0d\n\x0d\n  if (handle === null) {\x0d\n    this.free.set(worker.id\x2C worker);  // Add to ready queue again.\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  remove(handle);\x0d\n\x0d\n  const message = { act: 'newconn'\x2C key: this.key };\x0d\n\x0d\n  sendHelper(worker.process\x2C message\x2C handle\x2C (reply) => {\x0d\n    if (reply.accepted)\x0d\n      handle.close();\x0d\n    else\x0d\n      this.distribute(0\x2C handle);  // Worker is shutting down. Send to another.\x0d\n\x0d\n    this.handoff(worker);\x0d\n  });\x0d\n};\x0d\n
code-source-info,0x3063248410e,137,0,3380,C0O0C4O3380,,
code-creation,Function,10,258272,0x306324844d6,217, node:internal/cluster/round_robin_handle:1:1,0x30632484088,~
code-source-info,0x306324844d6,137,0,3380,C0O0C49O28C55O45C61O57C67O74C73O119C76O119C80O119C82O160C85O160C89O160C91O200C94O200C99O185C105O284C108O284C113O244C119O252C125O258C131O267C137O273C143O339C146O339C151O325C157O371C159O386C163O1264C172O1278C176O1956C185O1973C189O2376C198O2397C202O2764C211O2782C216O3379,,
code-creation,Eval,10,258426,0x30632484dee,5, node:internal/cluster/utils:1:1,0x30632484c78,~
script-source,138,node:internal/cluster/utils,'use strict';\x0d\n\x0d\nconst {\x0d\n  ReflectApply\x2C\x0d\n  SafeMap\x2C\x0d\n} = primordials;\x0d\n\x0d\nmodule.exports = {\x0d\n  sendHelper\x2C\x0d\n  internal\x0d\n};\x0d\n\x0d\nconst callbacks = new SafeMap();\x0d\nlet seq = 0;\x0d\n\x0d\nfunction sendHelper(proc\x2C message\x2C handle\x2C cb) {\x0d\n  if (!proc.connected)\x0d\n    return false;\x0d\n\x0d\n  // Mark message as internal. See INTERNAL_PREFIX\x0d\n  // in lib/internal/child_process.js\x0d\n  message = { cmd: 'NODE_CLUSTER'\x2C ...message\x2C seq };\x0d\n\x0d\n  if (typeof cb === 'function')\x0d\n    callbacks.set(seq\x2C cb);\x0d\n\x0d\n  seq += 1;\x0d\n  return proc.send(message\x2C handle);\x0d\n}\x0d\n\x0d\n// Returns an internalMessage listener that hands off normal messages\x0d\n// to the callback but intercepts and redirects ACK messages.\x0d\nfunction internal(worker\x2C cb) {\x0d\n  return function onInternalMessage(message\x2C handle) {\x0d\n    if (message.cmd !== 'NODE_CLUSTER')\x0d\n      return;\x0d\n\x0d\n    let fn = cb;\x0d\n\x0d\n    if (message.ack !== undefined) {\x0d\n      const callback = callbacks.get(message.ack);\x0d\n\x0d\n      if (callback !== undefined) {\x0d\n        fn = callback;\x0d\n        callbacks.delete(message.ack);\x0d\n      }\x0d\n    }\x0d\n\x0d\n    ReflectApply(fn\x2C worker\x2C arguments);\x0d\n  };\x0d\n}\x0d\n
code-source-info,0x30632484dee,138,0,1104,C0O0C4O1104,,
code-creation,Function,10,258514,0x30632484fae,72, node:internal/cluster/utils:1:1,0x30632484d68,~
code-source-info,0x30632484fae,138,0,1104,C0O0C24O28C30O45C35O75C42O97C48O112C54O90C58O146C60O146C65O146C67O172C68O172C71O1103,,
code-creation,Eval,10,258652,0x306324855be,5, node:internal/cluster/shared_handle:1:1,0x30632485438,~
script-source,139,node:internal/cluster/shared_handle,'use strict';\x0d\nconst { SafeMap } = primordials;\x0d\nconst assert = require('internal/assert');\x0d\nconst dgram = require('internal/dgram');\x0d\nconst net = require('net');\x0d\n\x0d\nmodule.exports = SharedHandle;\x0d\n\x0d\nfunction SharedHandle(key\x2C address\x2C { port\x2C addressType\x2C fd\x2C flags }) {\x0d\n  this.key = key;\x0d\n  this.workers = new SafeMap();\x0d\n  this.handle = null;\x0d\n  this.errno = 0;\x0d\n\x0d\n  let rval;\x0d\n  if (addressType === 'udp4' || addressType === 'udp6')\x0d\n    rval = dgram._createSocketHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\x0d\n  else\x0d\n    rval = net._createServerHandle(address\x2C port\x2C addressType\x2C fd\x2C flags);\x0d\n\x0d\n  if (typeof rval === 'number')\x0d\n    this.errno = rval;\x0d\n  else\x0d\n    this.handle = rval;\x0d\n}\x0d\n\x0d\nSharedHandle.prototype.add = function(worker\x2C send) {\x0d\n  assert(!this.workers.has(worker.id));\x0d\n  this.workers.set(worker.id\x2C worker);\x0d\n  send(this.errno\x2C null\x2C this.handle);\x0d\n};\x0d\n\x0d\nSharedHandle.prototype.remove = function(worker) {\x0d\n  if (!this.workers.has(worker.id))\x0d\n    return false;\x0d\n\x0d\n  this.workers.delete(worker.id);\x0d\n\x0d\n  if (this.workers.size !== 0)\x0d\n    return false;\x0d\n\x0d\n  this.handle.close();\x0d\n  this.handle = null;\x0d\n  return true;\x0d\n};\x0d\n
code-source-info,0x306324855be,139,0,1147,C0O0C4O1147,,
code-creation,Function,10,258770,0x306324857f6,89, node:internal/cluster/shared_handle:1:1,0x30632485538,~
code-source-info,0x306324857f6,139,0,1147,C0O0C22O23C28O64C31O64C35O64C37O107C40O107C44O107C46O147C49O147C53O147C55O166C57O181C61O711C70O725C74O893C83O910C88O1146,,
code-creation,Eval,10,258916,0x30632485dbe,5, node:internal/cluster/worker:1:1,0x30632485c48,~
script-source,140,node:internal/cluster/worker,'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  ReflectApply\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst EventEmitter = require('events');\x0d\n\x0d\nmodule.exports = Worker;\x0d\n\x0d\n// Common Worker implementation shared between the cluster primary and workers.\x0d\nfunction Worker(options) {\x0d\n  if (!(this instanceof Worker))\x0d\n    return new Worker(options);\x0d\n\x0d\n  ReflectApply(EventEmitter\x2C this\x2C []);\x0d\n\x0d\n  if (options === null || typeof options !== 'object')\x0d\n    options = {};\x0d\n\x0d\n  this.exitedAfterDisconnect = undefined;\x0d\n\x0d\n  this.state = options.state || 'none';\x0d\n  this.id = options.id | 0;\x0d\n\x0d\n  if (options.process) {\x0d\n    this.process = options.process;\x0d\n    this.process.on('error'\x2C (code\x2C signal) =>\x0d\n      this.emit('error'\x2C code\x2C signal)\x0d\n    );\x0d\n    this.process.on('message'\x2C (message\x2C handle) =>\x0d\n      this.emit('message'\x2C message\x2C handle)\x0d\n    );\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectSetPrototypeOf(Worker.prototype\x2C EventEmitter.prototype);\x0d\nObjectSetPrototypeOf(Worker\x2C EventEmitter);\x0d\n\x0d\nWorker.prototype.kill = function() {\x0d\n  ReflectApply(this.destroy\x2C this\x2C arguments);\x0d\n};\x0d\n\x0d\nWorker.prototype.send = function() {\x0d\n  return ReflectApply(this.process.send\x2C this.process\x2C arguments);\x0d\n};\x0d\n\x0d\nWorker.prototype.isDead = function() {\x0d\n  return this.process.exitCode != null || this.process.signalCode != null;\x0d\n};\x0d\n\x0d\nWorker.prototype.isConnected = function() {\x0d\n  return this.process.connected;\x0d\n};\x0d\n
code-source-info,0x30632485dbe,140,0,1370,C0O0C4O1370,,
code-creation,Function,10,259014,0x30632486126,141, node:internal/cluster/worker:1:1,0x30632485d38,~
code-source-info,0x30632486126,140,0,1370,C0O0C17O28C22O53C28O109C31O109C35O109C37O131C39O146C43O849C46O877C54O901C59O849C64O914C70O914C75O961C78O968C87O983C91O1053C94O1060C103O1075C107O1165C110O1172C119O1189C123O1287C126O1294C135O1316C140O1369,,
code-creation,LazyCompile,10,259119,0x30632486676,21,EventEmitter node:events:207:22,0x25ca272ad18,~
code-source-info,0x30632486676,23,6453,6503,C0O6465C3O6478C8O6483C13O6483C20O6502,,
code-creation,LazyCompile,10,259190,0x306324867be,149,EventEmitter.init node:events:324:29,0x25ca272b110,~
code-source-info,0x306324867be,23,9839,10447,C0O9862C6O9899C13O9911C16O9911C21O9937C25O9907C30O9954C32O9969C37O9969C41O9967C45O9994C46O10012C50O10053C60O10046C64O10088C71O10096C80O10124C85O10145C93O10124C98O10199C100O10204C105O10216C108O10229C113O10216C117O10214C123O10389C125O10394C131O10419C138O10429C140O10428C143O10404C148O10446,,
code-creation,LazyCompile,10,259345,0x30632486bd6,151,getESMFacade node:internal/bootstrap/loaders:264:15,0x147335cfcf0,~
code-source-info,0x30632486bd6,9,8495,9141,C0O8495C8O8514C14O8534C18O8541C19O8570C29O8570C34O8555C39O8619C42O8632C51O8664C53O8664C55O8695C62O8720C67O8695C72O8738C82O8738C87O8787C89O8840C102O8801C107O8799C111O9052C116O9059C121O9059C125O9084C130O9091C140O9091C146O9129C150O9136,,
code-creation,LazyCompile,10,259447,0x30632486fbe,40, node:internal/bootstrap/loaders:273:15,0x30632486ad0,~
code-source-info,0x30632486fbe,9,8868,8976,C0O8882C5O8895C10O8895C14O8924C24O8945C27O8958C32O8924C39O8975,,
code-creation,LazyCompile,10,259510,0x30632487116,89,syncExports node:internal/bootstrap/loaders:287:14,0x147335cfd60,~
code-source-info,0x30632487116,9,9454,9797,C0O9483C5O9509C11O9539C13O9552C17O9544C22O9595C24O9600C28O9614C30O9629C35O9644C37O9668C42O9675C51O9728C54O9740C59O9766C67O9728C73O9675C79O9561C84O9526C88O9796,,
code-creation,LazyCompile,10,259570,0x3063248727e,35,getOwn node:internal/bootstrap/loaders:180:16,0x147335cf9f8,~
code-source-info,0x3063248727e,9,5677,5835,C0O5714C5O5721C14O5776C26O5776C34O5832,,
code-creation,RegExp,3,259735,0x29be72c8e40,1616,(?:^|\\/)\\.?\\.$
code-creation,RegExp,3,260013,0x29be72c9540,1676,^(?:[a-zA-Z]:|[\\\\/]{2}[^\\\\/]+[\\\\/][^\\\\/]+)?[\\\\/]*
code-creation,Function,11,260260,0x29be72c9c80,3524,dirname node:path:653:10,0x394c9e0d768,^
code-source-info,0x29be72c9c80,41,21280,23908,,,
code-creation,Function,11,260293,0x29be72cab00,320,getOwn node:internal/bootstrap/loaders:180:16,0x147335cf9f8,^
code-source-info,0x29be72cab00,9,5677,5835,,,
code-creation,Function,11,260322,0x29be72cacc0,684,syncExports node:internal/bootstrap/loaders:287:14,0x147335cfd60,^
code-source-info,0x29be72cacc0,9,9454,9797,,,
code-creation,Eval,10,260627,0x30632487d5e,5, C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\redir-stdout.js:1:1,0x30632487bb8,~
script-source,141,C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\redir-stdout.js,'use strict'\nconst net = require('net')\n\nlet isWorker = false\ntry {\n  // Skip redirecting stdout in Worker threads.\n  isWorker = !require('worker_threads').isMainThread\n} catch (e) {}\n\nif (!isWorker) {\n  const socket = new net.Socket({\n    fd: 3\x2C\n    readable: false\x2C\n    writable: true\n  })\n  Object.defineProperty(process\x2C 'stdout'\x2C {\n    configurable: true\x2C\n    enumerable: true\x2C\n    get: () => socket\n  })\n  Object.defineProperty(process.stdout\x2C 'fd'\x2C {\n    value: socket._handle.fd\n  })\n}\n
code-source-info,0x30632487d5e,141,0,494,C0O0C4O494,,
code-creation,Function,10,260686,0x30632488006,157, C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\redir-stdout.js:1:1,0x30632487cd8,~
code-source-info,0x30632488006,141,0,494,C0O25C3O25C8O56C13O118C16O130C21O155C30O127C42O185C53O227C65O219C70O219C72O294C76O301C81O316C93O392C101O301C106O412C110O419C115O434C119O442C135O476C140O484C148O419C156O493,,
code-creation,LazyCompile,10,260803,0x306324884f6,37,get BlockList node:net:1775:16,0x1c1d96ea468,~
code-source-info,0x306324884f6,131,49063,49155,C0O49073C14O49087C19O49116C26O49083C32O49133C36O49150,,
code-creation,Eval,10,260988,0x306324889ae,5, node:internal/blocklist:1:1,0x306324887c8,~
script-source,142,node:internal/blocklist,'use strict';\x0d\n\x0d\nconst {\x0d\n  Boolean\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  Symbol\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  BlockList: BlockListHandle\x2C\x0d\n} = internalBinding('block_list');\x0d\n\x0d\nconst {\x0d\n  customInspectSymbol: kInspect\x2C\x0d\n} = require('internal/util');\x0d\n\x0d\nconst {\x0d\n  SocketAddress\x2C\x0d\n  kHandle: kSocketAddressHandle\x2C\x0d\n} = require('internal/socketaddress');\x0d\n\x0d\nconst {\x0d\n  JSTransferable\x2C\x0d\n  kClone\x2C\x0d\n  kDeserialize\x2C\x0d\n} = require('internal/worker/js_transferable');\x0d\n\x0d\nconst { inspect } = require('internal/util/inspect');\x0d\n\x0d\nconst kHandle = Symbol('kHandle');\x0d\nconst { owner_symbol } = internalBinding('symbols');\x0d\n\x0d\nconst {\x0d\n  ERR_INVALID_ARG_VALUE\x2C\x0d\n} = require('internal/errors').codes;\x0d\n\x0d\nconst { validateInt32\x2C validateString } = require('internal/validators');\x0d\n\x0d\nclass BlockList extends JSTransferable {\x0d\n  constructor() {\x0d\n    super();\x0d\n    this[kHandle] = new BlockListHandle();\x0d\n    this[kHandle][owner_symbol] = this;\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    if (depth < 0)\x0d\n      return this;\x0d\n\x0d\n    const opts = {\x0d\n      ...options\x2C\x0d\n      depth: options.depth == null ? null : options.depth - 1\x0d\n    };\x0d\n\x0d\n    return `BlockList ${inspect({\x0d\n      rules: this.rules\x0d\n    }\x2C opts)}`;\x0d\n  }\x0d\n\x0d\n  addAddress(address\x2C family = 'ipv4') {\x0d\n    if (!SocketAddress.isSocketAddress(address)) {\x0d\n      validateString(address\x2C 'address');\x0d\n      validateString(family\x2C 'family');\x0d\n      address = new SocketAddress({\x0d\n        address\x2C\x0d\n        family\x2C\x0d\n      });\x0d\n    }\x0d\n    this[kHandle].addAddress(address[kSocketAddressHandle]);\x0d\n  }\x0d\n\x0d\n  addRange(start\x2C end\x2C family = 'ipv4') {\x0d\n    if (!SocketAddress.isSocketAddress(start)) {\x0d\n      validateString(start\x2C 'start');\x0d\n      validateString(family\x2C 'family');\x0d\n      start = new SocketAddress({\x0d\n        address: start\x2C\x0d\n        family\x2C\x0d\n      });\x0d\n    }\x0d\n    if (!SocketAddress.isSocketAddress(end)) {\x0d\n      validateString(end\x2C 'end');\x0d\n      validateString(family\x2C 'family');\x0d\n      end = new SocketAddress({\x0d\n        address: end\x2C\x0d\n        family\x2C\x0d\n      });\x0d\n    }\x0d\n    const ret = this[kHandle].addRange(\x0d\n      start[kSocketAddressHandle]\x2C\x0d\n      end[kSocketAddressHandle]);\x0d\n    if (ret === false)\x0d\n      throw new ERR_INVALID_ARG_VALUE('start'\x2C start\x2C 'must come before end');\x0d\n  }\x0d\n\x0d\n  addSubnet(network\x2C prefix\x2C family = 'ipv4') {\x0d\n    if (!SocketAddress.isSocketAddress(network)) {\x0d\n      validateString(network\x2C 'network');\x0d\n      validateString(family\x2C 'family');\x0d\n      network = new SocketAddress({\x0d\n        address: network\x2C\x0d\n        family\x2C\x0d\n      });\x0d\n    }\x0d\n    switch (network.family) {\x0d\n      case 'ipv4':\x0d\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 32);\x0d\n        break;\x0d\n      case 'ipv6':\x0d\n        validateInt32(prefix\x2C 'prefix'\x2C 0\x2C 128);\x0d\n        break;\x0d\n    }\x0d\n    this[kHandle].addSubnet(network[kSocketAddressHandle]\x2C prefix);\x0d\n  }\x0d\n\x0d\n  check(address\x2C family = 'ipv4') {\x0d\n    if (!SocketAddress.isSocketAddress(address)) {\x0d\n      validateString(address\x2C 'address');\x0d\n      validateString(family\x2C 'family');\x0d\n      try {\x0d\n        address = new SocketAddress({\x0d\n          address\x2C\x0d\n          family\x2C\x0d\n        });\x0d\n      } catch {\x0d\n        // Ignore the error. If it's not a valid address\x2C return false.\x0d\n        return false;\x0d\n      }\x0d\n    }\x0d\n    return Boolean(this[kHandle].check(address[kSocketAddressHandle]));\x0d\n  }\x0d\n\x0d\n  get rules() {\x0d\n    return this[kHandle].getRules();\x0d\n  }\x0d\n\x0d\n  [kClone]() {\x0d\n    const handle = this[kHandle];\x0d\n    return {\x0d\n      data: { handle }\x2C\x0d\n      deserializeInfo: 'internal/blocklist:InternalBlockList'\x2C\x0d\n    };\x0d\n  }\x0d\n\x0d\n  [kDeserialize]({ handle }) {\x0d\n    this[kHandle] = handle;\x0d\n    this[kHandle][owner_symbol] = this;\x0d\n  }\x0d\n}\x0d\n\x0d\nclass InternalBlockList extends JSTransferable {\x0d\n  constructor(handle) {\x0d\n    super();\x0d\n    this[kHandle] = handle;\x0d\n    if (handle !== undefined)\x0d\n      handle[owner_symbol] = this;\x0d\n  }\x0d\n}\x0d\n\x0d\nInternalBlockList.prototype.constructor = BlockList.prototype.constructor;\x0d\nObjectSetPrototypeOf(InternalBlockList.prototype\x2C BlockList.prototype);\x0d\n\x0d\nmodule.exports = {\x0d\n  BlockList\x2C\x0d\n  InternalBlockList\x2C\x0d\n};\x0d\n
code-source-info,0x306324889ae,142,0,4043,C0O0C4O4043,,
code-creation,Function,10,261249,0x306324893b6,359, node:internal/blocklist:1:1,0x30632488928,~
code-source-info,0x306324893b6,142,0,4043,C0O0C35O28C41O40C46O65C51O137C54O137C59O115C65O218C68O218C73O203C78O312C81O312C86O258C92O285C98O410C101O410C106O361C111O380C116O391C121O477C124O477C129O465C135O530C138O530C142O530C144O575C147O575C152O558C158O645C161O645C166O671C171O617C177O724C180O724C185O690C191O705C197O783C204O929C241O3359C251O3528C278O3669C301O3850C306O3884C311O3894C315O3872C319O3947C324O3968C329O3908C334O3983C341O4005C347O4019C353O3998C358O4042,,
code-creation,Eval,10,261533,0x3063248ac86,5, node:internal/socketaddress:1:1,0x3063248aa90,~
script-source,143,node:internal/socketaddress,'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  Symbol\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  SocketAddress: _SocketAddress\x2C\x0d\n  AF_INET\x2C\x0d\n  AF_INET6\x2C\x0d\n} = internalBinding('block_list');\x0d\n\x0d\nconst {\x0d\n  validateObject\x2C\x0d\n  validateString\x2C\x0d\n  validatePort\x2C\x0d\n  validateUint32\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_VALUE\x2C\x0d\n  }\x2C\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  customInspectSymbol: kInspect\x2C\x0d\n} = require('internal/util');\x0d\n\x0d\nconst { inspect } = require('internal/util/inspect');\x0d\n\x0d\nconst {\x0d\n  JSTransferable\x2C\x0d\n  kClone\x2C\x0d\n  kDeserialize\x2C\x0d\n} = require('internal/worker/js_transferable');\x0d\n\x0d\nconst kHandle = Symbol('kHandle');\x0d\nconst kDetail = Symbol('kDetail');\x0d\n\x0d\nclass SocketAddress extends JSTransferable {\x0d\n  static isSocketAddress(value) {\x0d\n    return value?.[kHandle] !== undefined;\x0d\n  }\x0d\n\x0d\n  constructor(options = {}) {\x0d\n    super();\x0d\n    validateObject(options\x2C 'options');\x0d\n    let { family = 'ipv4' } = options;\x0d\n    const {\x0d\n      address = (family === 'ipv4' ? '127.0.0.1' : '::')\x2C\x0d\n      port = 0\x2C\x0d\n      flowlabel = 0\x2C\x0d\n    } = options;\x0d\n\x0d\n    let type;\x0d\n    if (typeof family?.toLowerCase === 'function')\x0d\n      family = family.toLowerCase();\x0d\n    switch (family) {\x0d\n      case 'ipv4':\x0d\n        type = AF_INET;\x0d\n        break;\x0d\n      case 'ipv6':\x0d\n        type = AF_INET6;\x0d\n        break;\x0d\n      default:\x0d\n        throw new ERR_INVALID_ARG_VALUE('options.family'\x2C options.family);\x0d\n    }\x0d\n\x0d\n    validateString(address\x2C 'options.address');\x0d\n    validatePort(port\x2C 'options.port');\x0d\n    validateUint32(flowlabel\x2C 'options.flowlabel'\x2C false);\x0d\n\x0d\n    this[kHandle] = new _SocketAddress(address\x2C port\x2C type\x2C flowlabel);\x0d\n    this[kDetail] = this[kHandle].detail({\x0d\n      address: undefined\x2C\x0d\n      port: undefined\x2C\x0d\n      family: undefined\x2C\x0d\n      flowlabel: undefined\x2C\x0d\n    });\x0d\n  }\x0d\n\x0d\n  get address() {\x0d\n    return this[kDetail].address;\x0d\n  }\x0d\n\x0d\n  get port() {\x0d\n    return this[kDetail].port;\x0d\n  }\x0d\n\x0d\n  get family() {\x0d\n    return this[kDetail].family === AF_INET ? 'ipv4' : 'ipv6';\x0d\n  }\x0d\n\x0d\n  get flowlabel() {\x0d\n    // The flow label can be changed internally.\x0d\n    return this[kHandle].flowlabel();\x0d\n  }\x0d\n\x0d\n  [kInspect](depth\x2C options) {\x0d\n    if (depth < 0)\x0d\n      return this;\x0d\n\x0d\n    const opts = {\x0d\n      ...options\x2C\x0d\n      depth: options.depth == null ? null : options.depth - 1\x0d\n    };\x0d\n\x0d\n    return `SocketAddress ${inspect(this.toJSON()\x2C opts)}`;\x0d\n  }\x0d\n\x0d\n  [kClone]() {\x0d\n    const handle = this[kHandle];\x0d\n    return {\x0d\n      data: { handle }\x2C\x0d\n      deserializeInfo: 'internal/socketaddress:InternalSocketAddress'\x2C\x0d\n    };\x0d\n  }\x0d\n\x0d\n  [kDeserialize]({ handle }) {\x0d\n    this[kHandle] = handle;\x0d\n    this[kDetail] = handle.detail({\x0d\n      address: undefined\x2C\x0d\n      port: undefined\x2C\x0d\n      family: undefined\x2C\x0d\n      flowlabel: undefined\x2C\x0d\n    });\x0d\n  }\x0d\n\x0d\n  toJSON() {\x0d\n    return {\x0d\n      address: this.address\x2C\x0d\n      port: this.port\x2C\x0d\n      family: this.family\x2C\x0d\n      flowlabel: this.flowlabel\x2C\x0d\n    };\x0d\n  }\x0d\n}\x0d\n\x0d\nclass InternalSocketAddress extends JSTransferable {\x0d\n  constructor(handle) {\x0d\n    super();\x0d\n    this[kHandle] = handle;\x0d\n  }\x0d\n}\x0d\n\x0d\nInternalSocketAddress.prototype.constructor =\x0d\n  SocketAddress.prototype.constructor;\x0d\nObjectSetPrototypeOf(InternalSocketAddress.prototype\x2C SocketAddress.prototype);\x0d\n\x0d\nmodule.exports = {\x0d\n  SocketAddress\x2C\x0d\n  InternalSocketAddress\x2C\x0d\n  kHandle\x2C\x0d\n};\x0d\n
code-source-info,0x3063248ac86,143,0,3363,C0O0C4O3363,,
code-creation,Function,10,261750,0x3063248b7ae,366, node:internal/socketaddress:1:1,0x3063248ac00,~
code-source-info,0x3063248b7ae,143,0,3363,C0O0C38O28C43O53C48O154C51O154C56O108C62O127C68O139C74O275C77O275C82O199C88O218C94O237C100O254C106O369C109O369C114O369C119O335C125O447C128O447C133O432C138O496C141O496C146O484C152O593C155O593C160O544C165O563C170O574C175O656C178O656C182O656C184O692C187O692C191O692C193O742C226O2171C236O2425C246O2602C279O3017C302O3135C307O3176C312O3186C316O3157C320O3243C325O3268C330O3200C335O3283C342O3305C348O3323C354O3349C360O3298C365O3362,,
code-creation,LazyCompile,10,261927,0x3063248c23e,37,get SocketAddress node:net:1779:20,0x1c1d96ea4e0,~
code-source-info,0x3063248c23e,131,49177,49285,C0O49187C14O49205C19O49238C26O49201C32O49259C36O49280,,
code-creation,Eval,10,262028,0x3063248c5fe,5, node:worker_threads:1:1,0x3063248c4b8,~
script-source,144,node:worker_threads,'use strict';\x0d\n\x0d\nconst {\x0d\n  isMainThread\x2C\x0d\n  SHARE_ENV\x2C\x0d\n  resourceLimits\x2C\x0d\n  setEnvironmentData\x2C\x0d\n  getEnvironmentData\x2C\x0d\n  threadId\x2C\x0d\n  Worker\x0d\n} = require('internal/worker');\x0d\n\x0d\nconst {\x0d\n  MessagePort\x2C\x0d\n  MessageChannel\x2C\x0d\n  moveMessagePortToContext\x2C\x0d\n  receiveMessageOnPort\x2C\x0d\n  BroadcastChannel\x2C\x0d\n} = require('internal/worker/io');\x0d\n\x0d\nconst {\x0d\n  markAsUntransferable\x2C\x0d\n} = require('internal/buffer');\x0d\n\x0d\nmodule.exports = {\x0d\n  isMainThread\x2C\x0d\n  MessagePort\x2C\x0d\n  MessageChannel\x2C\x0d\n  markAsUntransferable\x2C\x0d\n  moveMessagePortToContext\x2C\x0d\n  receiveMessageOnPort\x2C\x0d\n  resourceLimits\x2C\x0d\n  threadId\x2C\x0d\n  SHARE_ENV\x2C\x0d\n  Worker\x2C\x0d\n  parentPort: null\x2C\x0d\n  workerData: null\x2C\x0d\n  BroadcastChannel\x2C\x0d\n  setEnvironmentData\x2C\x0d\n  getEnvironmentData\x2C\x0d\n};\x0d\n
code-source-info,0x3063248c5fe,144,0,727,C0O0C4O727,,
code-creation,Function,10,262106,0x3063248c80e,180, node:worker_threads:1:1,0x3063248c578,~
code-source-info,0x3063248c80e,144,0,727,C0O149C3O149C8O28C13O45C18O59C23O78C28O101C33O124C38O137C43O303C46O303C51O191C56O207C61O226C66O255C71O280C76O375C79O375C84O348C89O406C96O428C102O445C108O461C114O480C120O505C126O534C132O559C138O578C144O591C150O605C156O658C162O679C168O702C174O421C179O726,,
code-creation,Eval,10,262601,0x3063248d7b6,5, node:internal/worker:1:1,0x3063248d1d8,~
script-source,145,node:internal/worker,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  ArrayPrototypeMap\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  Float64Array\x2C\x0d\n  FunctionPrototypeBind\x2C\x0d\n  JSONStringify\x2C\x0d\n  MathMax\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectEntries\x2C\x0d\n  Promise\x2C\x0d\n  PromiseResolve\x2C\x0d\n  ReflectApply\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeArrayIterator\x2C\x0d\n  SafeMap\x2C\x0d\n  String\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolFor\x2C\x0d\n  TypedArrayPrototypeFill\x2C\x0d\n  Uint32Array\x2C\x0d\n  globalThis: { Atomics\x2C SharedArrayBuffer }\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst EventEmitter = require('events');\x0d\nconst assert = require('internal/assert');\x0d\nconst path = require('path');\x0d\nconst { now } = require('internal/perf/utils');\x0d\n\x0d\nconst errorCodes = require('internal/errors').codes;\x0d\nconst {\x0d\n  ERR_WORKER_NOT_RUNNING\x2C\x0d\n  ERR_WORKER_PATH\x2C\x0d\n  ERR_WORKER_UNSERIALIZABLE_ERROR\x2C\x0d\n  ERR_WORKER_INVALID_EXEC_ARGV\x2C\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n  ERR_INVALID_ARG_VALUE\x2C\x0d\n} = errorCodes;\x0d\nconst { getOptionValue } = require('internal/options');\x0d\n\x0d\nconst workerIo = require('internal/worker/io');\x0d\nconst {\x0d\n  drainMessagePort\x2C\x0d\n  MessageChannel\x2C\x0d\n  messageTypes\x2C\x0d\n  kPort\x2C\x0d\n  kIncrementsPortRef\x2C\x0d\n  kWaitingStreams\x2C\x0d\n  kStdioWantsMoreDataCallback\x2C\x0d\n  setupPortReferencing\x2C\x0d\n  ReadableWorkerStdio\x2C\x0d\n  WritableWorkerStdio\x0d\n} = workerIo;\x0d\nconst { deserializeError } = require('internal/error_serdes');\x0d\nconst { fileURLToPath\x2C isURLInstance\x2C pathToFileURL } = require('internal/url');\x0d\nconst { validateArray } = require('internal/validators');\x0d\n\x0d\nconst {\x0d\n  ownsProcessState\x2C\x0d\n  isMainThread\x2C\x0d\n  resourceLimits: resourceLimitsRaw\x2C\x0d\n  threadId\x2C\x0d\n  Worker: WorkerImpl\x2C\x0d\n  kMaxYoungGenerationSizeMb\x2C\x0d\n  kMaxOldGenerationSizeMb\x2C\x0d\n  kCodeRangeSizeMb\x2C\x0d\n  kStackSizeMb\x2C\x0d\n  kTotalResourceLimitCount\x0d\n} = internalBinding('worker');\x0d\n\x0d\nconst kHandle = Symbol('kHandle');\x0d\nconst kPublicPort = Symbol('kPublicPort');\x0d\nconst kDispose = Symbol('kDispose');\x0d\nconst kOnExit = Symbol('kOnExit');\x0d\nconst kOnMessage = Symbol('kOnMessage');\x0d\nconst kOnCouldNotSerializeErr = Symbol('kOnCouldNotSerializeErr');\x0d\nconst kOnErrorMessage = Symbol('kOnErrorMessage');\x0d\nconst kParentSideStdio = Symbol('kParentSideStdio');\x0d\nconst kLoopStartTime = Symbol('kLoopStartTime');\x0d\nconst kIsOnline = Symbol('kIsOnline');\x0d\n\x0d\nconst SHARE_ENV = SymbolFor('nodejs.worker_threads.SHARE_ENV');\x0d\nlet debug = require('internal/util/debuglog').debuglog('worker'\x2C (fn) => {\x0d\n  debug = fn;\x0d\n});\x0d\n\x0d\nlet cwdCounter;\x0d\n\x0d\nconst environmentData = new SafeMap();\x0d\n\x0d\nif (isMainThread) {\x0d\n  cwdCounter = new Uint32Array(new SharedArrayBuffer(4));\x0d\n  const originalChdir = process.chdir;\x0d\n  process.chdir = function(path) {\x0d\n    Atomics.add(cwdCounter\x2C 0\x2C 1);\x0d\n    originalChdir(path);\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction setEnvironmentData(key\x2C value) {\x0d\n  if (value === undefined)\x0d\n    environmentData.delete(key);\x0d\n  else\x0d\n    environmentData.set(key\x2C value);\x0d\n}\x0d\n\x0d\nfunction getEnvironmentData(key) {\x0d\n  return environmentData.get(key);\x0d\n}\x0d\n\x0d\nfunction assignEnvironmentData(data) {\x0d\n  if (data === undefined) return;\x0d\n  data.forEach((value\x2C key) => {\x0d\n    environmentData.set(key\x2C value);\x0d\n  });\x0d\n}\x0d\n\x0d\nclass Worker extends EventEmitter {\x0d\n  constructor(filename\x2C options = {}) {\x0d\n    super();\x0d\n    debug(`[${threadId}] create new worker`\x2C filename\x2C options);\x0d\n    if (options.execArgv)\x0d\n      validateArray(options.execArgv\x2C 'options.execArgv');\x0d\n\x0d\n    let argv;\x0d\n    if (options.argv) {\x0d\n      validateArray(options.argv\x2C 'options.argv');\x0d\n      argv = ArrayPrototypeMap(options.argv\x2C String);\x0d\n    }\x0d\n\x0d\n    let url\x2C doEval;\x0d\n    if (options.eval) {\x0d\n      if (typeof filename !== 'string') {\x0d\n        throw new ERR_INVALID_ARG_VALUE(\x0d\n          'options.eval'\x2C\x0d\n          options.eval\x2C\x0d\n          'must be false when \\'filename\\' is not a string'\x0d\n        );\x0d\n      }\x0d\n      url = null;\x0d\n      doEval = 'classic';\x0d\n    } else if (isURLInstance(filename) && filename.protocol === 'data:') {\x0d\n      url = null;\x0d\n      doEval = 'module';\x0d\n      filename = `import ${JSONStringify(`${filename}`)}`;\x0d\n    } else {\x0d\n      doEval = false;\x0d\n      if (isURLInstance(filename)) {\x0d\n        url = filename;\x0d\n        filename = fileURLToPath(filename);\x0d\n      } else if (typeof filename !== 'string') {\x0d\n        throw new ERR_INVALID_ARG_TYPE(\x0d\n          'filename'\x2C\x0d\n          ['string'\x2C 'URL']\x2C\x0d\n          filename\x0d\n        );\x0d\n      } else if (path.isAbsolute(filename) ||\x0d\n                 RegExpPrototypeTest(/^\\.\\.?[\\\\/]/\x2C filename)) {\x0d\n        filename = path.resolve(filename);\x0d\n        url = pathToFileURL(filename);\x0d\n      } else {\x0d\n        throw new ERR_WORKER_PATH(filename);\x0d\n      }\x0d\n    }\x0d\n\x0d\n    let env;\x0d\n    if (typeof options.env === 'object' && options.env !== null) {\x0d\n      env = ObjectCreate(null);\x0d\n      ArrayPrototypeForEach(\x0d\n        ObjectEntries(options.env)\x2C\x0d\n        ({ 0: key\x2C 1: value }) => { env[key] = `${value}`; }\x0d\n      );\x0d\n    } else if (options.env == null) {\x0d\n      env = process.env;\x0d\n    } else if (options.env !== SHARE_ENV) {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'options.env'\x2C\x0d\n        ['object'\x2C 'undefined'\x2C 'null'\x2C 'worker_threads.SHARE_ENV']\x2C\x0d\n        options.env);\x0d\n    }\x0d\n\x0d\n    // Set up the C++ handle for the worker\x2C as well as some internal wiring.\x0d\n    this[kHandle] = new WorkerImpl(url\x2C\x0d\n                                   env === process.env ? null : env\x2C\x0d\n                                   options.execArgv\x2C\x0d\n                                   parseResourceLimits(options.resourceLimits)\x2C\x0d\n                                   !!(options.trackUnmanagedFds ?? true));\x0d\n    if (this[kHandle].invalidExecArgv) {\x0d\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(this[kHandle].invalidExecArgv);\x0d\n    }\x0d\n    if (this[kHandle].invalidNodeOptions) {\x0d\n      throw new ERR_WORKER_INVALID_EXEC_ARGV(\x0d\n        this[kHandle].invalidNodeOptions\x2C 'invalid NODE_OPTIONS env variable');\x0d\n    }\x0d\n    this[kHandle].onexit = (code\x2C customErr\x2C customErrReason) => {\x0d\n      this[kOnExit](code\x2C customErr\x2C customErrReason);\x0d\n    };\x0d\n    this[kPort] = this[kHandle].messagePort;\x0d\n    this[kPort].on('message'\x2C (data) => this[kOnMessage](data));\x0d\n    this[kPort].start();\x0d\n    this[kPort].unref();\x0d\n    this[kPort][kWaitingStreams] = 0;\x0d\n    debug(`[${threadId}] created Worker with ID ${this.threadId}`);\x0d\n\x0d\n    let stdin = null;\x0d\n    if (options.stdin)\x0d\n      stdin = new WritableWorkerStdio(this[kPort]\x2C 'stdin');\x0d\n    const stdout = new ReadableWorkerStdio(this[kPort]\x2C 'stdout');\x0d\n    if (!options.stdout) {\x0d\n      stdout[kIncrementsPortRef] = false;\x0d\n      pipeWithoutWarning(stdout\x2C process.stdout);\x0d\n    }\x0d\n    const stderr = new ReadableWorkerStdio(this[kPort]\x2C 'stderr');\x0d\n    if (!options.stderr) {\x0d\n      stderr[kIncrementsPortRef] = false;\x0d\n      pipeWithoutWarning(stderr\x2C process.stderr);\x0d\n    }\x0d\n\x0d\n    this[kParentSideStdio] = { stdin\x2C stdout\x2C stderr };\x0d\n\x0d\n    const { port1\x2C port2 } = new MessageChannel();\x0d\n    const transferList = [port2];\x0d\n    // If transferList is provided.\x0d\n    if (options.transferList)\x0d\n      ArrayPrototypePush(transferList\x2C\x0d\n                         ...new SafeArrayIterator(options.transferList));\x0d\n\x0d\n    this[kPublicPort] = port1;\x0d\n    ArrayPrototypeForEach(['message'\x2C 'messageerror']\x2C (event) => {\x0d\n      this[kPublicPort].on(event\x2C (message) => this.emit(event\x2C message));\x0d\n    });\x0d\n    setupPortReferencing(this[kPublicPort]\x2C this\x2C 'message');\x0d\n    this[kPort].postMessage({\x0d\n      argv\x2C\x0d\n      type: messageTypes.LOAD_SCRIPT\x2C\x0d\n      filename\x2C\x0d\n      doEval\x2C\x0d\n      cwdCounter: cwdCounter || workerIo.sharedCwdCounter\x2C\x0d\n      workerData: options.workerData\x2C\x0d\n      environmentData\x2C\x0d\n      publicPort: port2\x2C\x0d\n      manifestURL: getOptionValue('--experimental-policy') ?\x0d\n        require('internal/process/policy').url :\x0d\n        null\x2C\x0d\n      manifestSrc: getOptionValue('--experimental-policy') ?\x0d\n        require('internal/process/policy').src :\x0d\n        null\x2C\x0d\n      hasStdin: !!options.stdin\x0d\n    }\x2C transferList);\x0d\n    // Use this to cache the Worker's loopStart value once available.\x0d\n    this[kLoopStartTime] = -1;\x0d\n    this[kIsOnline] = false;\x0d\n    this.performance = {\x0d\n      eventLoopUtilization: FunctionPrototypeBind(eventLoopUtilization\x2C this)\x2C\x0d\n    };\x0d\n    // Actually start the new thread now that everything is in place.\x0d\n    this[kHandle].startThread();\x0d\n\x0d\n    process.nextTick(() => process.emit('worker'\x2C this));\x0d\n  }\x0d\n\x0d\n  [kOnExit](code\x2C customErr\x2C customErrReason) {\x0d\n    debug(`[${threadId}] hears end event for Worker ${this.threadId}`);\x0d\n    drainMessagePort(this[kPublicPort]);\x0d\n    drainMessagePort(this[kPort]);\x0d\n    this.removeAllListeners('message');\x0d\n    this.removeAllListeners('messageerrors');\x0d\n    this[kPublicPort].unref();\x0d\n    this[kPort].unref();\x0d\n    this[kDispose]();\x0d\n    if (customErr) {\x0d\n      debug(`[${threadId}] failing with custom error ${customErr} \\\x0d\n        and with reason ${customErrReason}`);\x0d\n      this.emit('error'\x2C new errorCodes[customErr](customErrReason));\x0d\n    }\x0d\n    this.emit('exit'\x2C code);\x0d\n    this.removeAllListeners();\x0d\n  }\x0d\n\x0d\n  [kOnCouldNotSerializeErr]() {\x0d\n    this.emit('error'\x2C new ERR_WORKER_UNSERIALIZABLE_ERROR());\x0d\n  }\x0d\n\x0d\n  [kOnErrorMessage](serialized) {\x0d\n    // This is what is called for uncaught exceptions.\x0d\n    const error = deserializeError(serialized);\x0d\n    this.emit('error'\x2C error);\x0d\n  }\x0d\n\x0d\n  [kOnMessage](message) {\x0d\n    switch (message.type) {\x0d\n      case messageTypes.UP_AND_RUNNING:\x0d\n        this[kIsOnline] = true;\x0d\n        return this.emit('online');\x0d\n      case messageTypes.COULD_NOT_SERIALIZE_ERROR:\x0d\n        return this[kOnCouldNotSerializeErr]();\x0d\n      case messageTypes.ERROR_MESSAGE:\x0d\n        return this[kOnErrorMessage](message.error);\x0d\n      case messageTypes.STDIO_PAYLOAD:\x0d\n      {\x0d\n        const { stream\x2C chunks } = message;\x0d\n        const readable = this[kParentSideStdio][stream];\x0d\n        ArrayPrototypeForEach(chunks\x2C ({ chunk\x2C encoding }) => {\x0d\n          readable.push(chunk\x2C encoding);\x0d\n        });\x0d\n        return;\x0d\n      }\x0d\n      case messageTypes.STDIO_WANTS_MORE_DATA:\x0d\n      {\x0d\n        const { stream } = message;\x0d\n        return this[kParentSideStdio][stream][kStdioWantsMoreDataCallback]();\x0d\n      }\x0d\n    }\x0d\n\x0d\n    assert.fail(`Unknown worker message type ${message.type}`);\x0d\n  }\x0d\n\x0d\n  [kDispose]() {\x0d\n    this[kHandle].onexit = null;\x0d\n    this[kHandle] = null;\x0d\n    this[kPort] = null;\x0d\n    this[kPublicPort] = null;\x0d\n\x0d\n    const { stdout\x2C stderr } = this[kParentSideStdio];\x0d\n\x0d\n    if (!stdout.readableEnded) {\x0d\n      debug(`[${threadId}] explicitly closes stdout for ${this.threadId}`);\x0d\n      stdout.push(null);\x0d\n    }\x0d\n    if (!stderr.readableEnded) {\x0d\n      debug(`[${threadId}] explicitly closes stderr for ${this.threadId}`);\x0d\n      stderr.push(null);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  postMessage(...args) {\x0d\n    if (this[kPublicPort] === null) return;\x0d\n\x0d\n    ReflectApply(this[kPublicPort].postMessage\x2C this[kPublicPort]\x2C args);\x0d\n  }\x0d\n\x0d\n  terminate(callback) {\x0d\n    debug(`[${threadId}] terminates Worker with ID ${this.threadId}`);\x0d\n\x0d\n    this.ref();\x0d\n\x0d\n    if (typeof callback === 'function') {\x0d\n      process.emitWarning(\x0d\n        'Passing a callback to worker.terminate() is deprecated. ' +\x0d\n        'It returns a Promise instead.'\x2C\x0d\n        'DeprecationWarning'\x2C 'DEP0132');\x0d\n      if (this[kHandle] === null) return PromiseResolve();\x0d\n      this.once('exit'\x2C (exitCode) => callback(null\x2C exitCode));\x0d\n    }\x0d\n\x0d\n    if (this[kHandle] === null) return PromiseResolve();\x0d\n\x0d\n    this[kHandle].stopThread();\x0d\n\x0d\n    // Do not use events.once() here\x2C because the 'exit' event will always be\x0d\n    // emitted regardless of any errors\x2C and the point is to only resolve\x0d\n    // once the thread has actually stopped.\x0d\n    return new Promise((resolve) => {\x0d\n      this.once('exit'\x2C resolve);\x0d\n    });\x0d\n  }\x0d\n\x0d\n  ref() {\x0d\n    if (this[kHandle] === null) return;\x0d\n\x0d\n    this[kHandle].ref();\x0d\n    this[kPublicPort].ref();\x0d\n  }\x0d\n\x0d\n  unref() {\x0d\n    if (this[kHandle] === null) return;\x0d\n\x0d\n    this[kHandle].unref();\x0d\n    this[kPublicPort].unref();\x0d\n  }\x0d\n\x0d\n  get threadId() {\x0d\n    if (this[kHandle] === null) return -1;\x0d\n\x0d\n    return this[kHandle].threadId;\x0d\n  }\x0d\n\x0d\n  get stdin() {\x0d\n    return this[kParentSideStdio].stdin;\x0d\n  }\x0d\n\x0d\n  get stdout() {\x0d\n    return this[kParentSideStdio].stdout;\x0d\n  }\x0d\n\x0d\n  get stderr() {\x0d\n    return this[kParentSideStdio].stderr;\x0d\n  }\x0d\n\x0d\n  get resourceLimits() {\x0d\n    if (this[kHandle] === null) return {};\x0d\n\x0d\n    return makeResourceLimits(this[kHandle].getResourceLimits());\x0d\n  }\x0d\n\x0d\n  getHeapSnapshot() {\x0d\n    const heapSnapshotTaker = this[kHandle] && this[kHandle].takeHeapSnapshot();\x0d\n    return new Promise((resolve\x2C reject) => {\x0d\n      if (!heapSnapshotTaker) return reject(new ERR_WORKER_NOT_RUNNING());\x0d\n      heapSnapshotTaker.ondone = (handle) => {\x0d\n        const { HeapSnapshotStream } = require('internal/heap_utils');\x0d\n        resolve(new HeapSnapshotStream(handle));\x0d\n      };\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction pipeWithoutWarning(source\x2C dest) {\x0d\n  const sourceMaxListeners = source._maxListeners;\x0d\n  const destMaxListeners = dest._maxListeners;\x0d\n  source.setMaxListeners(Infinity);\x0d\n  dest.setMaxListeners(Infinity);\x0d\n\x0d\n  source.pipe(dest);\x0d\n\x0d\n  source._maxListeners = sourceMaxListeners;\x0d\n  dest._maxListeners = destMaxListeners;\x0d\n}\x0d\n\x0d\nconst resourceLimitsArray = new Float64Array(kTotalResourceLimitCount);\x0d\nfunction parseResourceLimits(obj) {\x0d\n  const ret = resourceLimitsArray;\x0d\n  TypedArrayPrototypeFill(ret\x2C -1);\x0d\n  if (typeof obj !== 'object' || obj === null) return ret;\x0d\n\x0d\n  if (typeof obj.maxOldGenerationSizeMb === 'number')\x0d\n    ret[kMaxOldGenerationSizeMb] = MathMax(obj.maxOldGenerationSizeMb\x2C 2);\x0d\n  if (typeof obj.maxYoungGenerationSizeMb === 'number')\x0d\n    ret[kMaxYoungGenerationSizeMb] = obj.maxYoungGenerationSizeMb;\x0d\n  if (typeof obj.codeRangeSizeMb === 'number')\x0d\n    ret[kCodeRangeSizeMb] = obj.codeRangeSizeMb;\x0d\n  if (typeof obj.stackSizeMb === 'number')\x0d\n    ret[kStackSizeMb] = obj.stackSizeMb;\x0d\n  return ret;\x0d\n}\x0d\n\x0d\nfunction makeResourceLimits(float64arr) {\x0d\n  return {\x0d\n    maxYoungGenerationSizeMb: float64arr[kMaxYoungGenerationSizeMb]\x2C\x0d\n    maxOldGenerationSizeMb: float64arr[kMaxOldGenerationSizeMb]\x2C\x0d\n    codeRangeSizeMb: float64arr[kCodeRangeSizeMb]\x2C\x0d\n    stackSizeMb: float64arr[kStackSizeMb]\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction eventLoopUtilization(util1\x2C util2) {\x0d\n  // TODO(trevnorris): Works to solve the thread-safe read/write issue of\x0d\n  // loopTime\x2C but has the drawback that it can't be set until the event loop\x0d\n  // has had a chance to turn. So it will be impossible to read the ELU of\x0d\n  // a worker thread immediately after it's been created.\x0d\n  if (!this[kIsOnline] || !this[kHandle]) {\x0d\n    return { idle: 0\x2C active: 0\x2C utilization: 0 };\x0d\n  }\x0d\n\x0d\n  // Cache loopStart\x2C since it's only written to once.\x0d\n  if (this[kLoopStartTime] === -1) {\x0d\n    this[kLoopStartTime] = this[kHandle].loopStartTime();\x0d\n    if (this[kLoopStartTime] === -1)\x0d\n      return { idle: 0\x2C active: 0\x2C utilization: 0 };\x0d\n  }\x0d\n\x0d\n  if (util2) {\x0d\n    const idle = util1.idle - util2.idle;\x0d\n    const active = util1.active - util2.active;\x0d\n    return { idle\x2C active\x2C utilization: active / (idle + active) };\x0d\n  }\x0d\n\x0d\n  const idle = this[kHandle].loopIdleTime();\x0d\n\x0d\n  // Using performance.now() here is fine since it's always the time from\x0d\n  // the beginning of the process\x2C and is why it needs to be offset by the\x0d\n  // loopStart time (which is also calculated from the beginning of the\x0d\n  // process).\x0d\n  const active = now() - this[kLoopStartTime] - idle;\x0d\n\x0d\n  if (!util1) {\x0d\n    return { idle\x2C active\x2C utilization: active / (idle + active) };\x0d\n  }\x0d\n\x0d\n  const idle_delta = idle - util1.idle;\x0d\n  const active_delta = active - util1.active;\x0d\n  const utilization = active_delta / (idle_delta + active_delta);\x0d\n  return { idle: idle_delta\x2C active: active_delta\x2C utilization };\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  ownsProcessState\x2C\x0d\n  isMainThread\x2C\x0d\n  SHARE_ENV\x2C\x0d\n  resourceLimits:\x0d\n    !isMainThread ? makeResourceLimits(resourceLimitsRaw) : {}\x2C\x0d\n  setEnvironmentData\x2C\x0d\n  getEnvironmentData\x2C\x0d\n  assignEnvironmentData\x2C\x0d\n  threadId\x2C\x0d\n  Worker\x2C\x0d\n};\x0d\n
code-source-info,0x3063248d7b6,145,0,15857,C0O0C4O15857,,
code-creation,Function,10,263379,0x3063248eb06,1185, node:internal/worker:1:1,0x3063248d730,~
code-source-info,0x3063248eb06,145,0,15857,C0O0C244O28C250O54C256O76C262O99C267O116C273O142C279O160C285O172C291O189C297O207C303O219C309O238C315O255C321O279C327O301C332O313C338O324C343O335C348O349C354O377C365O407C371O416C376O479C384O479C389O514C397O514C401O514C403O556C411O556C415O556C417O590C425O590C431O582C437O644C445O644C451O670C455O644C457O859C461O690C467O717C473O737C479O773C485O806C491O831C497O899C505O899C511O880C517O948C525O948C529O948C531O1207C535O991C541O1012C547O1031C553O1048C559O1058C565O1081C571O1101C577O1133C583O1158C589O1182C595O1247C603O1247C609O1226C615O1338C623O1338C629O1290C635O1305C641O1320C647O1390C655O1390C661O1372C667O1674C671O1674C677O1436C682O1457C687O1490C692O1512C698O1533C704O1548C710O1578C716O1606C722O1627C728O1644C733O1720C737O1720C741O1720C743O1760C747O1760C751O1760C753O1801C757O1801C761O1801C763O1838C767O1838C771O1838C773O1877C777O1877C781O1877C783O1932C787O1932C791O1932C793O1992C797O1992C801O1992C803O2045C807O2045C811O2045C813O2097C817O2097C821O2097C823O2142C827O2142C831O2142C833O2184C837O2184C841O2184C843O2243C851O2243C857O2276C873O2277C879O2243C881O2333C882O2333C884O2372C886O2372C891O2372C893O2390C904O2413C910O2442C919O2426C924O2424C928O2494C934O2502C938O2494C940O2512C950O2526C956O3032C966O8230C976O8884C986O8988C996O9167C1006O10092C1092O13086C1094O13086C1099O13086C1101O15601C1109O15623C1115O15644C1121O15661C1130O15697C1136O15712C1149O15759C1155O15782C1161O15805C1167O15831C1173O15844C1179O15616C1184O15856,,
code-creation,Eval,10,263788,0x30632490a36,5, node:internal/error_serdes:1:1,0x30632490770,~
script-source,146,node:internal/error_serdes,'use strict';\x0d\n\x0d\nconst Buffer = require('buffer').Buffer;\x0d\nconst {\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  Error\x2C\x0d\n  EvalError\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  ObjectAssign\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectGetOwnPropertyDescriptor\x2C\x0d\n  ObjectGetOwnPropertyNames\x2C\x0d\n  ObjectGetPrototypeOf\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ObjectPrototypeToString\x2C\x0d\n  RangeError\x2C\x0d\n  ReferenceError\x2C\x0d\n  SafeSet\x2C\x0d\n  SymbolToStringTag\x2C\x0d\n  SyntaxError\x2C\x0d\n  TypeError\x2C\x0d\n  URIError\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst kSerializedError = 0;\x0d\nconst kSerializedObject = 1;\x0d\nconst kInspectedError = 2;\x0d\n\x0d\nconst errors = {\x0d\n  Error\x2C TypeError\x2C RangeError\x2C URIError\x2C SyntaxError\x2C ReferenceError\x2C EvalError\x0d\n};\x0d\nconst errorConstructorNames = new SafeSet(ObjectKeys(errors));\x0d\n\x0d\nfunction TryGetAllProperties(object\x2C target = object) {\x0d\n  const all = ObjectCreate(null);\x0d\n  if (object === null)\x0d\n    return all;\x0d\n  ObjectAssign(all\x2C\x0d\n               TryGetAllProperties(ObjectGetPrototypeOf(object)\x2C target));\x0d\n  const keys = ObjectGetOwnPropertyNames(object);\x0d\n  ArrayPrototypeForEach(keys\x2C (key) => {\x0d\n    let descriptor;\x0d\n    try {\x0d\n      descriptor = ObjectGetOwnPropertyDescriptor(object\x2C key);\x0d\n    } catch { return; }\x0d\n    const getter = descriptor.get;\x0d\n    if (getter && key !== '__proto__') {\x0d\n      try {\x0d\n        descriptor.value = FunctionPrototypeCall(getter\x2C target);\x0d\n      } catch {}\x0d\n    }\x0d\n    if ('value' in descriptor && typeof descriptor.value !== 'function') {\x0d\n      delete descriptor.get;\x0d\n      delete descriptor.set;\x0d\n      all[key] = descriptor;\x0d\n    }\x0d\n  });\x0d\n  return all;\x0d\n}\x0d\n\x0d\nfunction GetConstructors(object) {\x0d\n  const constructors = [];\x0d\n\x0d\n  for (let current = object;\x0d\n    current !== null;\x0d\n    current = ObjectGetPrototypeOf(current)) {\x0d\n    const desc = ObjectGetOwnPropertyDescriptor(current\x2C 'constructor');\x0d\n    if (desc && desc.value) {\x0d\n      ObjectDefineProperty(constructors\x2C constructors.length\x2C {\x0d\n        value: desc.value\x2C enumerable: true\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return constructors;\x0d\n}\x0d\n\x0d\nfunction GetName(object) {\x0d\n  const desc = ObjectGetOwnPropertyDescriptor(object\x2C 'name');\x0d\n  return desc && desc.value;\x0d\n}\x0d\n\x0d\nlet internalUtilInspect;\x0d\nfunction inspect(...args) {\x0d\n  if (!internalUtilInspect) {\x0d\n    internalUtilInspect = require('internal/util/inspect');\x0d\n  }\x0d\n  return internalUtilInspect.inspect(...args);\x0d\n}\x0d\n\x0d\nlet serialize;\x0d\nfunction serializeError(error) {\x0d\n  if (!serialize) serialize = require('v8').serialize;\x0d\n  try {\x0d\n    if (typeof error === 'object' &&\x0d\n        ObjectPrototypeToString(error) === '[object Error]') {\x0d\n      const constructors = GetConstructors(error);\x0d\n      for (let i = 0; i < constructors.length; i++) {\x0d\n        const name = GetName(constructors[i]);\x0d\n        if (errorConstructorNames.has(name)) {\x0d\n          const serialized = serialize({\x0d\n            constructor: name\x2C\x0d\n            properties: TryGetAllProperties(error)\x0d\n          });\x0d\n          return Buffer.concat([Buffer.from([kSerializedError])\x2C serialized]);\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n  } catch {}\x0d\n  try {\x0d\n    const serialized = serialize(error);\x0d\n    return Buffer.concat([Buffer.from([kSerializedObject])\x2C serialized]);\x0d\n  } catch {}\x0d\n  return Buffer.concat([Buffer.from([kInspectedError])\x2C\x0d\n                        Buffer.from(inspect(error)\x2C 'utf8')]);\x0d\n}\x0d\n\x0d\nlet deserialize;\x0d\nfunction deserializeError(error) {\x0d\n  if (!deserialize) deserialize = require('v8').deserialize;\x0d\n  switch (error[0]) {\x0d\n    case kSerializedError: {\x0d\n      const { constructor\x2C properties } = deserialize(error.subarray(1));\x0d\n      const ctor = errors[constructor];\x0d\n      ObjectDefineProperty(properties\x2C SymbolToStringTag\x2C {\x0d\n        value: { value: 'Error'\x2C configurable: true }\x2C\x0d\n        enumerable: true\x0d\n      });\x0d\n      return ObjectCreate(ctor.prototype\x2C properties);\x0d\n    }\x0d\n    case kSerializedObject:\x0d\n      return deserialize(error.subarray(1));\x0d\n    case kInspectedError: {\x0d\n      const buf = Buffer.from(error.buffer\x2C\x0d\n                              error.byteOffset + 1\x2C\x0d\n                              error.byteLength - 1);\x0d\n      return buf.toString('utf8');\x0d\n    }\x0d\n  }\x0d\n  require('assert').fail('This should not happen');\x0d\n}\x0d\n\x0d\nmodule.exports = { serializeError\x2C deserializeError };\x0d\n
code-source-info,0x30632490a36,146,0,4190,C0O0C4O4190,,
code-creation,Function,10,264052,0x30632490e56,335, node:internal/error_serdes:1:1,0x306324909b0,~
code-source-info,0x30632490e56,146,0,4190,C0O0C100O32C106O32C111O49C115O32C117O70C123O96C128O106C133O120C139O146C145O163C151O180C157O205C163O240C169O270C175O295C180O310C186O338C191O353C196O372C201O384C207O406C212O422C217O436C222O492C223O492C225O522C227O522C229O550C231O550C233O571C240O576C246O583C252O594C258O606C264O616C270O629C276O645C282O571C284O690C287O702C294O690C299O690C301O2121C302O2121C304O2326C305O2326C307O3274C308O3274C310O4134C317O4153C323O4169C329O4149C334O4189,,
code-creation,LazyCompile,10,264429,0x30632492086,793,Socket node:net:283:16,0x1c1d96e83a8,~
code-source-info,0x30632492086,131,7331,11511,C0O7346C2O7357C7O7377C12O7384C17O7404C18O7408C25O7419C34O7440C42O7517C52O7446C57O7440C58O7573C65O7584C81O7615C90O7644C98O7713C115O7804C121O7834C131O7650C136O7644C137O7898C138O7914C142O8122C144O8127C149O8144C153O8153C154O8168C158O8180C160O8185C164O8194C168O8205C169O8218C173O8229C174O8240C178O8251C180O8256C184O8269C188O8281C190O8286C194O8307C198O8315C200O8320C204O8330C208O8341C210O8346C214O8355C218O8366C220O8371C224O8382C228O8393C230O8398C234O8410C238O8423C244O8461C251O8477C262O8522C268O8604C270O8628C273O8644C278O8628C282O8626C286O8720C287O8738C291O8750C292O8770C296O8812C297O8834C301O8846C306O8853C311O8860C316O8860C322O8898C328O8936C332O8926C336O8960C338O8965C344O9003C349O8984C353O8982C359O9035C365O9068C370O9093C372O9215C377O9230C382O9228C386O9273C391O9281C396O9281C402O9544C404O9560C412O9566C417O9560C418O9602C420O9607C423O9631C428O9639C433O9639C437O9624C441O9660C443O9668C450O9680C455O9705C462O9724C464O9713C471O9733C475O9817C480O9825C487O9825C493O9851C495O9869C503O9875C508O9869C509O9920C510O9933C514O9948C516O9962C519O9962C523O9960C527O10157C532O10183C545O10157C550O10295C555O10306C565O10367C568O10387C573O10367C579O10412C587O10459C595O10509C603O10541C605O10546C609O10555C613O10570C615O10575C618O10596C622O10587C628O10625C630O10630C633O10648C637O10639C641O10668C643O10673C646O10693C650O10684C654O10774C665O10774C671O10811C674O10811C678O10840C679O10858C683O10869C685O10891C689O11036C695O11055C701O11064C706O11094C712O11183C718O11199C722O11220C727O11228C732O11228C736O11247C737O11268C743O11302C749O11329C756O11329C761O11380C762O11392C766O11403C767O11416C771O11459C773O11464C777O11476C781O11484C783O11489C787O11504C792O11510,,
code-creation,LazyCompile,10,264659,0x30632492756,169,Duplex node:internal/streams/duplex:52:16,0x394c9e38940,~
script-source,56,node:internal/streams/duplex,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n// a duplex stream is just a stream that is both readable and writable.\x0d\n// Since JS doesn't have multiple prototype inheritance\x2C this class\x0d\n// prototypically inherits from Readable\x2C and then parasitically from\x0d\n// Writable.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectGetOwnPropertyDescriptor\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n} = primordials;\x0d\n\x0d\nmodule.exports = Duplex;\x0d\n\x0d\nconst Readable = require('internal/streams/readable');\x0d\nconst Writable = require('internal/streams/writable');\x0d\n\x0d\nObjectSetPrototypeOf(Duplex.prototype\x2C Readable.prototype);\x0d\nObjectSetPrototypeOf(Duplex\x2C Readable);\x0d\n\x0d\n{\x0d\n  // Allow the keys array to be GC'ed.\x0d\n  for (const method of ObjectKeys(Writable.prototype)) {\x0d\n    if (!Duplex.prototype[method])\x0d\n      Duplex.prototype[method] = Writable.prototype[method];\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction Duplex(options) {\x0d\n  if (!(this instanceof Duplex))\x0d\n    return new Duplex(options);\x0d\n\x0d\n  Readable.call(this\x2C options);\x0d\n  Writable.call(this\x2C options);\x0d\n\x0d\n  if (options) {\x0d\n    this.allowHalfOpen = options.allowHalfOpen !== false;\x0d\n\x0d\n    if (options.readable === false) {\x0d\n      this._readableState.readable = false;\x0d\n      this._readableState.ended = true;\x0d\n      this._readableState.endEmitted = true;\x0d\n    }\x0d\n\x0d\n    if (options.writable === false) {\x0d\n      this._writableState.writable = false;\x0d\n      this._writableState.ending = true;\x0d\n      this._writableState.ended = true;\x0d\n      this._writableState.finished = true;\x0d\n    }\x0d\n  } else {\x0d\n    this.allowHalfOpen = true;\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(Duplex.prototype\x2C {\x0d\n  writable:\x0d\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writable')\x2C\x0d\n  writableHighWaterMark:\x0d\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableHighWaterMark')\x2C\x0d\n  writableObjectMode:\x0d\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableObjectMode')\x2C\x0d\n  writableBuffer:\x0d\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableBuffer')\x2C\x0d\n  writableLength:\x0d\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableLength')\x2C\x0d\n  writableFinished:\x0d\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableFinished')\x2C\x0d\n  writableCorked:\x0d\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableCorked')\x2C\x0d\n  writableEnded:\x0d\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableEnded')\x2C\x0d\n  writableNeedDrain:\x0d\n    ObjectGetOwnPropertyDescriptor(Writable.prototype\x2C 'writableNeedDrain')\x2C\x0d\n\x0d\n  destroyed: {\x0d\n    get() {\x0d\n      if (this._readableState === undefined ||\x0d\n        this._writableState === undefined) {\x0d\n        return false;\x0d\n      }\x0d\n      return this._readableState.destroyed && this._writableState.destroyed;\x0d\n    }\x2C\x0d\n    set(value) {\x0d\n      // Backward compatibility\x2C the user is explicitly\x0d\n      // managing destroyed.\x0d\n      if (this._readableState && this._writableState) {\x0d\n        this._readableState.destroyed = value;\x0d\n        this._writableState.destroyed = value;\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n});\x0d\n\x0d\nlet webStreamsAdapters;\x0d\n\x0d\n// Lazy to avoid circular references\x0d\nfunction lazyWebStreams() {\x0d\n  if (webStreamsAdapters === undefined)\x0d\n    webStreamsAdapters = require('internal/webstreams/adapters');\x0d\n  return webStreamsAdapters;\x0d\n}\x0d\n\x0d\nDuplex.fromWeb = function(pair\x2C options) {\x0d\n  return lazyWebStreams().newStreamDuplexFromReadableWritablePair(\x0d\n    pair\x2C\x0d\n    options);\x0d\n};\x0d\n\x0d\nDuplex.toWeb = function(duplex) {\x0d\n  return lazyWebStreams().newReadableWritablePairFromDuplex(duplex);\x0d\n};\x0d\n\x0d\nlet duplexify;\x0d\n\x0d\nDuplex.from = function(body) {\x0d\n  if (!duplexify) {\x0d\n    duplexify = require('internal/streams/duplexify');\x0d\n  }\x0d\n  return duplexify(body\x2C 'body');\x0d\n};\x0d\n
code-source-info,0x30632492756,56,2002,2679,C0O2017C2O2028C7O2053C12O2060C17O2080C18O2086C23O2095C28O2095C34O2119C39O2128C44O2128C50O2154C54O2203C60O2217C64O2193C68O2247C74O2256C79O2281C85O2305C89O2326C95O2347C99O2367C105O2393C109O2427C115O2436C120O2461C126O2485C130O2506C136O2528C140O2548C146O2569C150O2589C156O2613C162O2645C163O2664C168O2678,,
code-creation,LazyCompile,10,265053,0x30632492efe,220,Readable node:internal/streams/readable:186:18,0x13c5c2cc4c0,~
script-source,57,node:internal/streams/readable,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeIndexOf\x2C\x0d\n  NumberIsInteger\x2C\x0d\n  NumberIsNaN\x2C\x0d\n  NumberParseInt\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  Promise\x2C\x0d\n  SafeSet\x2C\x0d\n  SymbolAsyncIterator\x2C\x0d\n  Symbol\x0d\n} = primordials;\x0d\n\x0d\nmodule.exports = Readable;\x0d\nReadable.ReadableState = ReadableState;\x0d\n\x0d\nconst EE = require('events');\x0d\nconst { Stream\x2C prependListener } = require('internal/streams/legacy');\x0d\nconst { Buffer } = require('buffer');\x0d\n\x0d\nconst {\x0d\n  addAbortSignal\x2C\x0d\n} = require('internal/streams/add-abort-signal');\x0d\nconst eos = require('internal/streams/end-of-stream');\x0d\n\x0d\nlet debug = require('internal/util/debuglog').debuglog('stream'\x2C (fn) => {\x0d\n  debug = fn;\x0d\n});\x0d\nconst BufferList = require('internal/streams/buffer_list');\x0d\nconst destroyImpl = require('internal/streams/destroy');\x0d\nconst {\x0d\n  getHighWaterMark\x2C\x0d\n  getDefaultHighWaterMark\x0d\n} = require('internal/streams/state');\x0d\n\x0d\nconst {\x0d\n  aggregateTwoErrors\x2C\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_METHOD_NOT_IMPLEMENTED\x2C\x0d\n    ERR_OUT_OF_RANGE\x2C\x0d\n    ERR_STREAM_PUSH_AFTER_EOF\x2C\x0d\n    ERR_STREAM_UNSHIFT_AFTER_END_EVENT\x2C\x0d\n  }\x0d\n} = require('internal/errors');\x0d\nconst { validateObject } = require('internal/validators');\x0d\n\x0d\nconst kPaused = Symbol('kPaused');\x0d\n\x0d\nconst { StringDecoder } = require('string_decoder');\x0d\nconst from = require('internal/streams/from');\x0d\n\x0d\nObjectSetPrototypeOf(Readable.prototype\x2C Stream.prototype);\x0d\nObjectSetPrototypeOf(Readable\x2C Stream);\x0d\nconst nop = () => {};\x0d\n\x0d\nconst { errorOrDestroy } = destroyImpl;\x0d\n\x0d\nfunction ReadableState(options\x2C stream\x2C isDuplex) {\x0d\n  // Duplex streams are both readable and writable\x2C but share\x0d\n  // the same options object.\x0d\n  // However\x2C some cases require setting options to different\x0d\n  // values for the readable and the writable sides of the duplex stream.\x0d\n  // These options can be provided separately as readableXXX and writableXXX.\x0d\n  if (typeof isDuplex !== 'boolean')\x0d\n    isDuplex = stream instanceof Stream.Duplex;\x0d\n\x0d\n  // Object stream flag. Used to make read(n) ignore n and to\x0d\n  // make all the buffer merging and length checks go away.\x0d\n  this.objectMode = !!(options && options.objectMode);\x0d\n\x0d\n  if (isDuplex)\x0d\n    this.objectMode = this.objectMode ||\x0d\n      !!(options && options.readableObjectMode);\x0d\n\x0d\n  // The point at which it stops calling _read() to fill the buffer\x0d\n  // Note: 0 is a valid value\x2C means "don't call _read preemptively ever"\x0d\n  this.highWaterMark = options ?\x0d\n    getHighWaterMark(this\x2C options\x2C 'readableHighWaterMark'\x2C isDuplex) :\x0d\n    getDefaultHighWaterMark(false);\x0d\n\x0d\n  // A linked list is used to store data chunks instead of an array because the\x0d\n  // linked list can remove elements from the beginning faster than\x0d\n  // array.shift().\x0d\n  this.buffer = new BufferList();\x0d\n  this.length = 0;\x0d\n  this.pipes = [];\x0d\n  this.flowing = null;\x0d\n  this.ended = false;\x0d\n  this.endEmitted = false;\x0d\n  this.reading = false;\x0d\n\x0d\n  // Stream is still being constructed and cannot be\x0d\n  // destroyed until construction finished or failed.\x0d\n  // Async construction is opt in\x2C therefore we start as\x0d\n  // constructed.\x0d\n  this.constructed = true;\x0d\n\x0d\n  // A flag to be able to tell if the event 'readable'/'data' is emitted\x0d\n  // immediately\x2C or on a later tick.  We set this to true at first\x2C because\x0d\n  // any actions that shouldn't happen until "later" should generally also\x0d\n  // not happen before the first read call.\x0d\n  this.sync = true;\x0d\n\x0d\n  // Whenever we return null\x2C then we set a flag to say\x0d\n  // that we're awaiting a 'readable' event emission.\x0d\n  this.needReadable = false;\x0d\n  this.emittedReadable = false;\x0d\n  this.readableListening = false;\x0d\n  this.resumeScheduled = false;\x0d\n  this[kPaused] = null;\x0d\n\x0d\n  // True if the error was already emitted and should not be thrown again.\x0d\n  this.errorEmitted = false;\x0d\n\x0d\n  // Should close be emitted on destroy. Defaults to true.\x0d\n  this.emitClose = !options || options.emitClose !== false;\x0d\n\x0d\n  // Should .destroy() be called after 'end' (and potentially 'finish').\x0d\n  this.autoDestroy = !options || options.autoDestroy !== false;\x0d\n\x0d\n  // Has it been destroyed.\x0d\n  this.destroyed = false;\x0d\n\x0d\n  // Indicates whether the stream has errored. When true no further\x0d\n  // _read calls\x2C 'data' or 'readable' events should occur. This is needed\x0d\n  // since when autoDestroy is disabled we need a way to tell whether the\x0d\n  // stream has failed.\x0d\n  this.errored = null;\x0d\n\x0d\n  // Indicates whether the stream has finished destroying.\x0d\n  this.closed = false;\x0d\n\x0d\n  // True if close has been emitted or would have been emitted\x0d\n  // depending on emitClose.\x0d\n  this.closeEmitted = false;\x0d\n\x0d\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\x0d\n  // encoding is 'binary' so we have to make this configurable.\x0d\n  // Everything else in the universe uses 'utf8'\x2C though.\x0d\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\x0d\n\x0d\n  // Ref the piped dest which we need a drain event on it\x0d\n  // type: null | Writable | Set<Writable>.\x0d\n  this.awaitDrainWriters = null;\x0d\n  this.multiAwaitDrain = false;\x0d\n\x0d\n  // If true\x2C a maybeReadMore has been scheduled.\x0d\n  this.readingMore = false;\x0d\n\x0d\n  this.dataEmitted = false;\x0d\n\x0d\n  this.decoder = null;\x0d\n  this.encoding = null;\x0d\n  if (options && options.encoding) {\x0d\n    this.decoder = new StringDecoder(options.encoding);\x0d\n    this.encoding = options.encoding;\x0d\n  }\x0d\n}\x0d\n\x0d\n\x0d\nfunction Readable(options) {\x0d\n  if (!(this instanceof Readable))\x0d\n    return new Readable(options);\x0d\n\x0d\n  // Checking for a Stream.Duplex instance is faster here instead of inside\x0d\n  // the ReadableState constructor\x2C at least with V8 6.5.\x0d\n  const isDuplex = this instanceof Stream.Duplex;\x0d\n\x0d\n  this._readableState = new ReadableState(options\x2C this\x2C isDuplex);\x0d\n\x0d\n  if (options) {\x0d\n    if (typeof options.read === 'function')\x0d\n      this._read = options.read;\x0d\n\x0d\n    if (typeof options.destroy === 'function')\x0d\n      this._destroy = options.destroy;\x0d\n\x0d\n    if (typeof options.construct === 'function')\x0d\n      this._construct = options.construct;\x0d\n\x0d\n    if (options.signal && !isDuplex)\x0d\n      addAbortSignal(options.signal\x2C this);\x0d\n  }\x0d\n\x0d\n  Stream.call(this\x2C options);\x0d\n\x0d\n  destroyImpl.construct(this\x2C () => {\x0d\n    if (this._readableState.needReadable) {\x0d\n      maybeReadMore(this\x2C this._readableState);\x0d\n    }\x0d\n  });\x0d\n}\x0d\n\x0d\nReadable.prototype.destroy = destroyImpl.destroy;\x0d\nReadable.prototype._undestroy = destroyImpl.undestroy;\x0d\nReadable.prototype._destroy = function(err\x2C cb) {\x0d\n  cb(err);\x0d\n};\x0d\n\x0d\nReadable.prototype[EE.captureRejectionSymbol] = function(err) {\x0d\n  this.destroy(err);\x0d\n};\x0d\n\x0d\n// Manually shove something into the read() buffer.\x0d\n// This returns true if the highWaterMark has not been hit yet\x2C\x0d\n// similar to how Writable.write() returns true if you should\x0d\n// write() some more.\x0d\nReadable.prototype.push = function(chunk\x2C encoding) {\x0d\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C false);\x0d\n};\x0d\n\x0d\n// Unshift should *always* be something directly out of read().\x0d\nReadable.prototype.unshift = function(chunk\x2C encoding) {\x0d\n  return readableAddChunk(this\x2C chunk\x2C encoding\x2C true);\x0d\n};\x0d\n\x0d\nfunction readableAddChunk(stream\x2C chunk\x2C encoding\x2C addToFront) {\x0d\n  debug('readableAddChunk'\x2C chunk);\x0d\n  const state = stream._readableState;\x0d\n\x0d\n  let err;\x0d\n  if (!state.objectMode) {\x0d\n    if (typeof chunk === 'string') {\x0d\n      encoding = encoding || state.defaultEncoding;\x0d\n      if (state.encoding !== encoding) {\x0d\n        if (addToFront && state.encoding) {\x0d\n          // When unshifting\x2C if state.encoding is set\x2C we have to save\x0d\n          // the string in the BufferList with the state encoding.\x0d\n          chunk = Buffer.from(chunk\x2C encoding).toString(state.encoding);\x0d\n        } else {\x0d\n          chunk = Buffer.from(chunk\x2C encoding);\x0d\n          encoding = '';\x0d\n        }\x0d\n      }\x0d\n    } else if (chunk instanceof Buffer) {\x0d\n      encoding = '';\x0d\n    } else if (Stream._isUint8Array(chunk)) {\x0d\n      chunk = Stream._uint8ArrayToBuffer(chunk);\x0d\n      encoding = '';\x0d\n    } else if (chunk != null) {\x0d\n      err = new ERR_INVALID_ARG_TYPE(\x0d\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (err) {\x0d\n    errorOrDestroy(stream\x2C err);\x0d\n  } else if (chunk === null) {\x0d\n    state.reading = false;\x0d\n    onEofChunk(stream\x2C state);\x0d\n  } else if (state.objectMode || (chunk && chunk.length > 0)) {\x0d\n    if (addToFront) {\x0d\n      if (state.endEmitted)\x0d\n        errorOrDestroy(stream\x2C new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());\x0d\n      else if (state.destroyed || state.errored)\x0d\n        return false;\x0d\n      else\x0d\n        addChunk(stream\x2C state\x2C chunk\x2C true);\x0d\n    } else if (state.ended) {\x0d\n      errorOrDestroy(stream\x2C new ERR_STREAM_PUSH_AFTER_EOF());\x0d\n    } else if (state.destroyed || state.errored) {\x0d\n      return false;\x0d\n    } else {\x0d\n      state.reading = false;\x0d\n      if (state.decoder && !encoding) {\x0d\n        chunk = state.decoder.write(chunk);\x0d\n        if (state.objectMode || chunk.length !== 0)\x0d\n          addChunk(stream\x2C state\x2C chunk\x2C false);\x0d\n        else\x0d\n          maybeReadMore(stream\x2C state);\x0d\n      } else {\x0d\n        addChunk(stream\x2C state\x2C chunk\x2C false);\x0d\n      }\x0d\n    }\x0d\n  } else if (!addToFront) {\x0d\n    state.reading = false;\x0d\n    maybeReadMore(stream\x2C state);\x0d\n  }\x0d\n\x0d\n  // We can push more data if we are below the highWaterMark.\x0d\n  // Also\x2C if we have no data yet\x2C we can stand some more bytes.\x0d\n  // This is to work around cases where hwm=0\x2C such as the repl.\x0d\n  return !state.ended &&\x0d\n    (state.length < state.highWaterMark || state.length === 0);\x0d\n}\x0d\n\x0d\nfunction addChunk(stream\x2C state\x2C chunk\x2C addToFront) {\x0d\n  if (state.flowing && state.length === 0 && !state.sync &&\x0d\n      stream.listenerCount('data') > 0) {\x0d\n    // Use the guard to avoid creating `Set()` repeatedly\x0d\n    // when we have multiple pipes.\x0d\n    if (state.multiAwaitDrain) {\x0d\n      state.awaitDrainWriters.clear();\x0d\n    } else {\x0d\n      state.awaitDrainWriters = null;\x0d\n    }\x0d\n\x0d\n    state.dataEmitted = true;\x0d\n    stream.emit('data'\x2C chunk);\x0d\n  } else {\x0d\n    // Update the buffer info.\x0d\n    state.length += state.objectMode ? 1 : chunk.length;\x0d\n    if (addToFront)\x0d\n      state.buffer.unshift(chunk);\x0d\n    else\x0d\n      state.buffer.push(chunk);\x0d\n\x0d\n    if (state.needReadable)\x0d\n      emitReadable(stream);\x0d\n  }\x0d\n  maybeReadMore(stream\x2C state);\x0d\n}\x0d\n\x0d\nReadable.prototype.isPaused = function() {\x0d\n  const state = this._readableState;\x0d\n  return state[kPaused] === true || state.flowing === false;\x0d\n};\x0d\n\x0d\n// Backwards compatibility.\x0d\nReadable.prototype.setEncoding = function(enc) {\x0d\n  const decoder = new StringDecoder(enc);\x0d\n  this._readableState.decoder = decoder;\x0d\n  // If setEncoding(null)\x2C decoder.encoding equals utf8.\x0d\n  this._readableState.encoding = this._readableState.decoder.encoding;\x0d\n\x0d\n  const buffer = this._readableState.buffer;\x0d\n  // Iterate over current buffer to convert already stored Buffers:\x0d\n  let content = '';\x0d\n  for (const data of buffer) {\x0d\n    content += decoder.write(data);\x0d\n  }\x0d\n  buffer.clear();\x0d\n  if (content !== '')\x0d\n    buffer.push(content);\x0d\n  this._readableState.length = content.length;\x0d\n  return this;\x0d\n};\x0d\n\x0d\n// Don't raise the hwm > 1GB.\x0d\nconst MAX_HWM = 0x40000000;\x0d\nfunction computeNewHighWaterMark(n) {\x0d\n  if (n > MAX_HWM) {\x0d\n    throw new ERR_OUT_OF_RANGE('size'\x2C '<= 1GiB'\x2C n);\x0d\n  } else {\x0d\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\x0d\n    // tiny amounts.\x0d\n    n--;\x0d\n    n |= n >>> 1;\x0d\n    n |= n >>> 2;\x0d\n    n |= n >>> 4;\x0d\n    n |= n >>> 8;\x0d\n    n |= n >>> 16;\x0d\n    n++;\x0d\n  }\x0d\n  return n;\x0d\n}\x0d\n\x0d\n// This function is designed to be inlinable\x2C so please take care when making\x0d\n// changes to the function body.\x0d\nfunction howMuchToRead(n\x2C state) {\x0d\n  if (n <= 0 || (state.length === 0 && state.ended))\x0d\n    return 0;\x0d\n  if (state.objectMode)\x0d\n    return 1;\x0d\n  if (NumberIsNaN(n)) {\x0d\n    // Only flow one buffer at a time.\x0d\n    if (state.flowing && state.length)\x0d\n      return state.buffer.first().length;\x0d\n    return state.length;\x0d\n  }\x0d\n  if (n <= state.length)\x0d\n    return n;\x0d\n  return state.ended ? state.length : 0;\x0d\n}\x0d\n\x0d\n// You can override either this method\x2C or the async _read(n) below.\x0d\nReadable.prototype.read = function(n) {\x0d\n  debug('read'\x2C n);\x0d\n  // Same as parseInt(undefined\x2C 10)\x2C however V8 7.3 performance regressed\x0d\n  // in this scenario\x2C so we are doing it manually.\x0d\n  if (n === undefined) {\x0d\n    n = NaN;\x0d\n  } else if (!NumberIsInteger(n)) {\x0d\n    n = NumberParseInt(n\x2C 10);\x0d\n  }\x0d\n  const state = this._readableState;\x0d\n  const nOrig = n;\x0d\n\x0d\n  // If we're asking for more than the current hwm\x2C then raise the hwm.\x0d\n  if (n > state.highWaterMark)\x0d\n    state.highWaterMark = computeNewHighWaterMark(n);\x0d\n\x0d\n  if (n !== 0)\x0d\n    state.emittedReadable = false;\x0d\n\x0d\n  // If we're doing read(0) to trigger a readable event\x2C but we\x0d\n  // already have a bunch of data in the buffer\x2C then just trigger\x0d\n  // the 'readable' event and move on.\x0d\n  if (n === 0 &&\x0d\n      state.needReadable &&\x0d\n      ((state.highWaterMark !== 0 ?\x0d\n        state.length >= state.highWaterMark :\x0d\n        state.length > 0) ||\x0d\n       state.ended)) {\x0d\n    debug('read: emitReadable'\x2C state.length\x2C state.ended);\x0d\n    if (state.length === 0 && state.ended)\x0d\n      endReadable(this);\x0d\n    else\x0d\n      emitReadable(this);\x0d\n    return null;\x0d\n  }\x0d\n\x0d\n  n = howMuchToRead(n\x2C state);\x0d\n\x0d\n  // If we've ended\x2C and we're now clear\x2C then finish it up.\x0d\n  if (n === 0 && state.ended) {\x0d\n    if (state.length === 0)\x0d\n      endReadable(this);\x0d\n    return null;\x0d\n  }\x0d\n\x0d\n  // All the actual chunk generation logic needs to be\x0d\n  // *below* the call to _read.  The reason is that in certain\x0d\n  // synthetic stream cases\x2C such as passthrough streams\x2C _read\x0d\n  // may be a completely synchronous operation which may change\x0d\n  // the state of the read buffer\x2C providing enough data when\x0d\n  // before there was *not* enough.\x0d\n  //\x0d\n  // So\x2C the steps are:\x0d\n  // 1. Figure out what the state of things will be after we do\x0d\n  // a read from the buffer.\x0d\n  //\x0d\n  // 2. If that resulting state will trigger a _read\x2C then call _read.\x0d\n  // Note that this may be asynchronous\x2C or synchronous.  Yes\x2C it is\x0d\n  // deeply ugly to write APIs this way\x2C but that still doesn't mean\x0d\n  // that the Readable class should behave improperly\x2C as streams are\x0d\n  // designed to be sync/async agnostic.\x0d\n  // Take note if the _read call is sync or async (ie\x2C if the read call\x0d\n  // has returned yet)\x2C so that we know whether or not it's safe to emit\x0d\n  // 'readable' etc.\x0d\n  //\x0d\n  // 3. Actually pull the requested chunks out of the buffer and return.\x0d\n\x0d\n  // if we need a readable event\x2C then we need to do some reading.\x0d\n  let doRead = state.needReadable;\x0d\n  debug('need readable'\x2C doRead);\x0d\n\x0d\n  // If we currently have less than the highWaterMark\x2C then also read some.\x0d\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\x0d\n    doRead = true;\x0d\n    debug('length less than watermark'\x2C doRead);\x0d\n  }\x0d\n\x0d\n  // However\x2C if we've ended\x2C then there's no point\x2C if we're already\x0d\n  // reading\x2C then it's unnecessary\x2C if we're constructing we have to wait\x2C\x0d\n  // and if we're destroyed or errored\x2C then it's not allowed\x2C\x0d\n  if (state.ended || state.reading || state.destroyed || state.errored ||\x0d\n      !state.constructed) {\x0d\n    doRead = false;\x0d\n    debug('reading\x2C ended or constructing'\x2C doRead);\x0d\n  } else if (doRead) {\x0d\n    debug('do read');\x0d\n    state.reading = true;\x0d\n    state.sync = true;\x0d\n    // If the length is currently zero\x2C then we *need* a readable event.\x0d\n    if (state.length === 0)\x0d\n      state.needReadable = true;\x0d\n\x0d\n    // Call internal read method\x0d\n    try {\x0d\n      const result = this._read(state.highWaterMark);\x0d\n      if (result != null) {\x0d\n        const then = result.then;\x0d\n        if (typeof then === 'function') {\x0d\n          then.call(\x0d\n            result\x2C\x0d\n            nop\x2C\x0d\n            function(err) {\x0d\n              errorOrDestroy(this\x2C err);\x0d\n            });\x0d\n        }\x0d\n      }\x0d\n    } catch (err) {\x0d\n      errorOrDestroy(this\x2C err);\x0d\n    }\x0d\n\x0d\n    state.sync = false;\x0d\n    // If _read pushed data synchronously\x2C then `reading` will be false\x2C\x0d\n    // and we need to re-evaluate how much data we can return to the user.\x0d\n    if (!state.reading)\x0d\n      n = howMuchToRead(nOrig\x2C state);\x0d\n  }\x0d\n\x0d\n  let ret;\x0d\n  if (n > 0)\x0d\n    ret = fromList(n\x2C state);\x0d\n  else\x0d\n    ret = null;\x0d\n\x0d\n  if (ret === null) {\x0d\n    state.needReadable = state.length <= state.highWaterMark;\x0d\n    n = 0;\x0d\n  } else {\x0d\n    state.length -= n;\x0d\n    if (state.multiAwaitDrain) {\x0d\n      state.awaitDrainWriters.clear();\x0d\n    } else {\x0d\n      state.awaitDrainWriters = null;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (state.length === 0) {\x0d\n    // If we have nothing in the buffer\x2C then we want to know\x0d\n    // as soon as we *do* get something into the buffer.\x0d\n    if (!state.ended)\x0d\n      state.needReadable = true;\x0d\n\x0d\n    // If we tried to read() past the EOF\x2C then emit end on the next tick.\x0d\n    if (nOrig !== n && state.ended)\x0d\n      endReadable(this);\x0d\n  }\x0d\n\x0d\n  if (ret !== null && !state.errorEmitted && !state.closeEmitted) {\x0d\n    state.dataEmitted = true;\x0d\n    this.emit('data'\x2C ret);\x0d\n  }\x0d\n\x0d\n  return ret;\x0d\n};\x0d\n\x0d\nfunction onEofChunk(stream\x2C state) {\x0d\n  debug('onEofChunk');\x0d\n  if (state.ended) return;\x0d\n  if (state.decoder) {\x0d\n    const chunk = state.decoder.end();\x0d\n    if (chunk && chunk.length) {\x0d\n      state.buffer.push(chunk);\x0d\n      state.length += state.objectMode ? 1 : chunk.length;\x0d\n    }\x0d\n  }\x0d\n  state.ended = true;\x0d\n\x0d\n  if (state.sync) {\x0d\n    // If we are sync\x2C wait until next tick to emit the data.\x0d\n    // Otherwise we risk emitting data in the flow()\x0d\n    // the readable code triggers during a read() call.\x0d\n    emitReadable(stream);\x0d\n  } else {\x0d\n    // Emit 'readable' now to make sure it gets picked up.\x0d\n    state.needReadable = false;\x0d\n    state.emittedReadable = true;\x0d\n    // We have to emit readable now that we are EOF. Modules\x0d\n    // in the ecosystem (e.g. dicer) rely on this event being sync.\x0d\n    emitReadable_(stream);\x0d\n  }\x0d\n}\x0d\n\x0d\n// Don't emit readable right away in sync mode\x2C because this can trigger\x0d\n// another read() call => stack overflow.  This way\x2C it might trigger\x0d\n// a nextTick recursion warning\x2C but that's not so bad.\x0d\nfunction emitReadable(stream) {\x0d\n  const state = stream._readableState;\x0d\n  debug('emitReadable'\x2C state.needReadable\x2C state.emittedReadable);\x0d\n  state.needReadable = false;\x0d\n  if (!state.emittedReadable) {\x0d\n    debug('emitReadable'\x2C state.flowing);\x0d\n    state.emittedReadable = true;\x0d\n    process.nextTick(emitReadable_\x2C stream);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction emitReadable_(stream) {\x0d\n  const state = stream._readableState;\x0d\n  debug('emitReadable_'\x2C state.destroyed\x2C state.length\x2C state.ended);\x0d\n  if (!state.destroyed && !state.errored && (state.length || state.ended)) {\x0d\n    stream.emit('readable');\x0d\n    state.emittedReadable = false;\x0d\n  }\x0d\n\x0d\n  // The stream needs another readable event if:\x0d\n  // 1. It is not flowing\x2C as the flow mechanism will take\x0d\n  //    care of it.\x0d\n  // 2. It is not ended.\x0d\n  // 3. It is below the highWaterMark\x2C so we can schedule\x0d\n  //    another readable later.\x0d\n  state.needReadable =\x0d\n    !state.flowing &&\x0d\n    !state.ended &&\x0d\n    state.length <= state.highWaterMark;\x0d\n  flow(stream);\x0d\n}\x0d\n\x0d\n\x0d\n// At this point\x2C the user has presumably seen the 'readable' event\x2C\x0d\n// and called read() to consume some data.  that may have triggered\x0d\n// in turn another _read(n) call\x2C in which case reading = true if\x0d\n// it's in progress.\x0d\n// However\x2C if we're not ended\x2C or reading\x2C and the length < hwm\x2C\x0d\n// then go ahead and try to read some more preemptively.\x0d\nfunction maybeReadMore(stream\x2C state) {\x0d\n  if (!state.readingMore && state.constructed) {\x0d\n    state.readingMore = true;\x0d\n    process.nextTick(maybeReadMore_\x2C stream\x2C state);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction maybeReadMore_(stream\x2C state) {\x0d\n  // Attempt to read more data if we should.\x0d\n  //\x0d\n  // The conditions for reading more data are (one of):\x0d\n  // - Not enough data buffered (state.length < state.highWaterMark). The loop\x0d\n  //   is responsible for filling the buffer with enough data if such data\x0d\n  //   is available. If highWaterMark is 0 and we are not in the flowing mode\x0d\n  //   we should _not_ attempt to buffer any extra data. We'll get more data\x0d\n  //   when the stream consumer calls read() instead.\x0d\n  // - No data in the buffer\x2C and the stream is in flowing mode. In this mode\x0d\n  //   the loop below is responsible for ensuring read() is called. Failing to\x0d\n  //   call read here would abort the flow and there's no other mechanism for\x0d\n  //   continuing the flow if the stream consumer has just subscribed to the\x0d\n  //   'data' event.\x0d\n  //\x0d\n  // In addition to the above conditions to keep reading data\x2C the following\x0d\n  // conditions prevent the data from being read:\x0d\n  // - The stream has ended (state.ended).\x0d\n  // - There is already a pending 'read' operation (state.reading). This is a\x0d\n  //   case where the stream has called the implementation defined _read()\x0d\n  //   method\x2C but they are processing the call asynchronously and have _not_\x0d\n  //   called push() with new data. In this case we skip performing more\x0d\n  //   read()s. The execution ends in this method again after the _read() ends\x0d\n  //   up calling push() with more data.\x0d\n  while (!state.reading && !state.ended &&\x0d\n         (state.length < state.highWaterMark ||\x0d\n          (state.flowing && state.length === 0))) {\x0d\n    const len = state.length;\x0d\n    debug('maybeReadMore read 0');\x0d\n    stream.read(0);\x0d\n    if (len === state.length)\x0d\n      // Didn't get any data\x2C stop spinning.\x0d\n      break;\x0d\n  }\x0d\n  state.readingMore = false;\x0d\n}\x0d\n\x0d\n// Abstract method.  to be overridden in specific implementation classes.\x0d\n// call cb(er\x2C data) where data is <= n in length.\x0d\n// for virtual (non-string\x2C non-buffer) streams\x2C "length" is somewhat\x0d\n// arbitrary\x2C and perhaps not very meaningful.\x0d\nReadable.prototype._read = function(n) {\x0d\n  throw new ERR_METHOD_NOT_IMPLEMENTED('_read()');\x0d\n};\x0d\n\x0d\nReadable.prototype.pipe = function(dest\x2C pipeOpts) {\x0d\n  const src = this;\x0d\n  const state = this._readableState;\x0d\n\x0d\n  if (state.pipes.length === 1) {\x0d\n    if (!state.multiAwaitDrain) {\x0d\n      state.multiAwaitDrain = true;\x0d\n      state.awaitDrainWriters = new SafeSet(\x0d\n        state.awaitDrainWriters ? [state.awaitDrainWriters] : []\x0d\n      );\x0d\n    }\x0d\n  }\x0d\n\x0d\n  state.pipes.push(dest);\x0d\n  debug('pipe count=%d opts=%j'\x2C state.pipes.length\x2C pipeOpts);\x0d\n\x0d\n  const doEnd = (!pipeOpts || pipeOpts.end !== false) &&\x0d\n              dest !== process.stdout &&\x0d\n              dest !== process.stderr;\x0d\n\x0d\n  const endFn = doEnd ? onend : unpipe;\x0d\n  if (state.endEmitted)\x0d\n    process.nextTick(endFn);\x0d\n  else\x0d\n    src.once('end'\x2C endFn);\x0d\n\x0d\n  dest.on('unpipe'\x2C onunpipe);\x0d\n  function onunpipe(readable\x2C unpipeInfo) {\x0d\n    debug('onunpipe');\x0d\n    if (readable === src) {\x0d\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\x0d\n        unpipeInfo.hasUnpiped = true;\x0d\n        cleanup();\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  function onend() {\x0d\n    debug('onend');\x0d\n    dest.end();\x0d\n  }\x0d\n\x0d\n  let ondrain;\x0d\n\x0d\n  let cleanedUp = false;\x0d\n  function cleanup() {\x0d\n    debug('cleanup');\x0d\n    // Cleanup event handlers once the pipe is broken.\x0d\n    dest.removeListener('close'\x2C onclose);\x0d\n    dest.removeListener('finish'\x2C onfinish);\x0d\n    if (ondrain) {\x0d\n      dest.removeListener('drain'\x2C ondrain);\x0d\n    }\x0d\n    dest.removeListener('error'\x2C onerror);\x0d\n    dest.removeListener('unpipe'\x2C onunpipe);\x0d\n    src.removeListener('end'\x2C onend);\x0d\n    src.removeListener('end'\x2C unpipe);\x0d\n    src.removeListener('data'\x2C ondata);\x0d\n\x0d\n    cleanedUp = true;\x0d\n\x0d\n    // If the reader is waiting for a drain event from this\x0d\n    // specific writer\x2C then it would cause it to never start\x0d\n    // flowing again.\x0d\n    // So\x2C if this is awaiting a drain\x2C then we just call it now.\x0d\n    // If we don't know\x2C then assume that we are waiting for one.\x0d\n    if (ondrain && state.awaitDrainWriters &&\x0d\n        (!dest._writableState || dest._writableState.needDrain))\x0d\n      ondrain();\x0d\n  }\x0d\n\x0d\n  function pause() {\x0d\n    // If the user unpiped during `dest.write()`\x2C it is possible\x0d\n    // to get stuck in a permanently paused state if that write\x0d\n    // also returned false.\x0d\n    // => Check whether `dest` is still a piping destination.\x0d\n    if (!cleanedUp) {\x0d\n      if (state.pipes.length === 1 && state.pipes[0] === dest) {\x0d\n        debug('false write response\x2C pause'\x2C 0);\x0d\n        state.awaitDrainWriters = dest;\x0d\n        state.multiAwaitDrain = false;\x0d\n      } else if (state.pipes.length > 1 && state.pipes.includes(dest)) {\x0d\n        debug('false write response\x2C pause'\x2C state.awaitDrainWriters.size);\x0d\n        state.awaitDrainWriters.add(dest);\x0d\n      }\x0d\n      src.pause();\x0d\n    }\x0d\n    if (!ondrain) {\x0d\n      // When the dest drains\x2C it reduces the awaitDrain counter\x0d\n      // on the source.  This would be more elegant with a .once()\x0d\n      // handler in flow()\x2C but adding and removing repeatedly is\x0d\n      // too slow.\x0d\n      ondrain = pipeOnDrain(src\x2C dest);\x0d\n      dest.on('drain'\x2C ondrain);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  src.on('data'\x2C ondata);\x0d\n  function ondata(chunk) {\x0d\n    debug('ondata');\x0d\n    const ret = dest.write(chunk);\x0d\n    debug('dest.write'\x2C ret);\x0d\n    if (ret === false) {\x0d\n      pause();\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // If the dest has an error\x2C then stop piping into it.\x0d\n  // However\x2C don't suppress the throwing behavior for this.\x0d\n  function onerror(er) {\x0d\n    debug('onerror'\x2C er);\x0d\n    unpipe();\x0d\n    dest.removeListener('error'\x2C onerror);\x0d\n    if (EE.listenerCount(dest\x2C 'error') === 0) {\x0d\n      const s = dest._writableState || dest._readableState;\x0d\n      if (s && !s.errorEmitted) {\x0d\n        // User incorrectly emitted 'error' directly on the stream.\x0d\n        errorOrDestroy(dest\x2C er);\x0d\n      } else {\x0d\n        dest.emit('error'\x2C er);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // Make sure our error handler is attached before userland ones.\x0d\n  prependListener(dest\x2C 'error'\x2C onerror);\x0d\n\x0d\n  // Both close and finish should trigger unpipe\x2C but only once.\x0d\n  function onclose() {\x0d\n    dest.removeListener('finish'\x2C onfinish);\x0d\n    unpipe();\x0d\n  }\x0d\n  dest.once('close'\x2C onclose);\x0d\n  function onfinish() {\x0d\n    debug('onfinish');\x0d\n    dest.removeListener('close'\x2C onclose);\x0d\n    unpipe();\x0d\n  }\x0d\n  dest.once('finish'\x2C onfinish);\x0d\n\x0d\n  function unpipe() {\x0d\n    debug('unpipe');\x0d\n    src.unpipe(dest);\x0d\n  }\x0d\n\x0d\n  // Tell the dest that it's being piped to.\x0d\n  dest.emit('pipe'\x2C src);\x0d\n\x0d\n  // Start the flow if it hasn't been started already.\x0d\n\x0d\n  if (dest.writableNeedDrain === true) {\x0d\n    if (state.flowing) {\x0d\n      pause();\x0d\n    }\x0d\n  } else if (!state.flowing) {\x0d\n    debug('pipe resume');\x0d\n    src.resume();\x0d\n  }\x0d\n\x0d\n  return dest;\x0d\n};\x0d\n\x0d\nfunction pipeOnDrain(src\x2C dest) {\x0d\n  return function pipeOnDrainFunctionResult() {\x0d\n    const state = src._readableState;\x0d\n\x0d\n    // `ondrain` will call directly\x2C\x0d\n    // `this` maybe not a reference to dest\x2C\x0d\n    // so we use the real dest here.\x0d\n    if (state.awaitDrainWriters === dest) {\x0d\n      debug('pipeOnDrain'\x2C 1);\x0d\n      state.awaitDrainWriters = null;\x0d\n    } else if (state.multiAwaitDrain) {\x0d\n      debug('pipeOnDrain'\x2C state.awaitDrainWriters.size);\x0d\n      state.awaitDrainWriters.delete(dest);\x0d\n    }\x0d\n\x0d\n    if ((!state.awaitDrainWriters || state.awaitDrainWriters.size === 0) &&\x0d\n      EE.listenerCount(src\x2C 'data')) {\x0d\n      state.flowing = true;\x0d\n      flow(src);\x0d\n    }\x0d\n  };\x0d\n}\x0d\n\x0d\n\x0d\nReadable.prototype.unpipe = function(dest) {\x0d\n  const state = this._readableState;\x0d\n  const unpipeInfo = { hasUnpiped: false };\x0d\n\x0d\n  // If we're not piping anywhere\x2C then do nothing.\x0d\n  if (state.pipes.length === 0)\x0d\n    return this;\x0d\n\x0d\n  if (!dest) {\x0d\n    // remove all.\x0d\n    const dests = state.pipes;\x0d\n    state.pipes = [];\x0d\n    this.pause();\x0d\n\x0d\n    for (let i = 0; i < dests.length; i++)\x0d\n      dests[i].emit('unpipe'\x2C this\x2C { hasUnpiped: false });\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  // Try to find the right one.\x0d\n  const index = ArrayPrototypeIndexOf(state.pipes\x2C dest);\x0d\n  if (index === -1)\x0d\n    return this;\x0d\n\x0d\n  state.pipes.splice(index\x2C 1);\x0d\n  if (state.pipes.length === 0)\x0d\n    this.pause();\x0d\n\x0d\n  dest.emit('unpipe'\x2C this\x2C unpipeInfo);\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\n// Set up data events if they are asked for\x0d\n// Ensure readable listeners eventually get something.\x0d\nReadable.prototype.on = function(ev\x2C fn) {\x0d\n  const res = Stream.prototype.on.call(this\x2C ev\x2C fn);\x0d\n  const state = this._readableState;\x0d\n\x0d\n  if (ev === 'data') {\x0d\n    // Update readableListening so that resume() may be a no-op\x0d\n    // a few lines down. This is needed to support once('readable').\x0d\n    state.readableListening = this.listenerCount('readable') > 0;\x0d\n\x0d\n    // Try start flowing on next tick if stream isn't explicitly paused.\x0d\n    if (state.flowing !== false)\x0d\n      this.resume();\x0d\n  } else if (ev === 'readable') {\x0d\n    if (!state.endEmitted && !state.readableListening) {\x0d\n      state.readableListening = state.needReadable = true;\x0d\n      state.flowing = false;\x0d\n      state.emittedReadable = false;\x0d\n      debug('on readable'\x2C state.length\x2C state.reading);\x0d\n      if (state.length) {\x0d\n        emitReadable(this);\x0d\n      } else if (!state.reading) {\x0d\n        process.nextTick(nReadingNextTick\x2C this);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return res;\x0d\n};\x0d\nReadable.prototype.addListener = Readable.prototype.on;\x0d\n\x0d\nReadable.prototype.removeListener = function(ev\x2C fn) {\x0d\n  const res = Stream.prototype.removeListener.call(this\x2C\x0d\n                                                   ev\x2C fn);\x0d\n\x0d\n  if (ev === 'readable') {\x0d\n    // We need to check if there is someone still listening to\x0d\n    // readable and reset the state. However this needs to happen\x0d\n    // after readable has been emitted but before I/O (nextTick) to\x0d\n    // support once('readable'\x2C fn) cycles. This means that calling\x0d\n    // resume within the same tick will have no\x0d\n    // effect.\x0d\n    process.nextTick(updateReadableListening\x2C this);\x0d\n  }\x0d\n\x0d\n  return res;\x0d\n};\x0d\nReadable.prototype.off = Readable.prototype.removeListener;\x0d\n\x0d\nReadable.prototype.removeAllListeners = function(ev) {\x0d\n  const res = Stream.prototype.removeAllListeners.apply(this\x2C\x0d\n                                                        arguments);\x0d\n\x0d\n  if (ev === 'readable' || ev === undefined) {\x0d\n    // We need to check if there is someone still listening to\x0d\n    // readable and reset the state. However this needs to happen\x0d\n    // after readable has been emitted but before I/O (nextTick) to\x0d\n    // support once('readable'\x2C fn) cycles. This means that calling\x0d\n    // resume within the same tick will have no\x0d\n    // effect.\x0d\n    process.nextTick(updateReadableListening\x2C this);\x0d\n  }\x0d\n\x0d\n  return res;\x0d\n};\x0d\n\x0d\nfunction updateReadableListening(self) {\x0d\n  const state = self._readableState;\x0d\n  state.readableListening = self.listenerCount('readable') > 0;\x0d\n\x0d\n  if (state.resumeScheduled && state[kPaused] === false) {\x0d\n    // Flowing needs to be set to true now\x2C otherwise\x0d\n    // the upcoming resume will not flow.\x0d\n    state.flowing = true;\x0d\n\x0d\n    // Crude way to check if we should resume.\x0d\n  } else if (self.listenerCount('data') > 0) {\x0d\n    self.resume();\x0d\n  } else if (!state.readableListening) {\x0d\n    state.flowing = null;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction nReadingNextTick(self) {\x0d\n  debug('readable nexttick read 0');\x0d\n  self.read(0);\x0d\n}\x0d\n\x0d\n// pause() and resume() are remnants of the legacy readable stream API\x0d\n// If the user uses them\x2C then switch into old mode.\x0d\nReadable.prototype.resume = function() {\x0d\n  const state = this._readableState;\x0d\n  if (!state.flowing) {\x0d\n    debug('resume');\x0d\n    // We flow only if there is no one listening\x0d\n    // for readable\x2C but we still have to call\x0d\n    // resume().\x0d\n    state.flowing = !state.readableListening;\x0d\n    resume(this\x2C state);\x0d\n  }\x0d\n  state[kPaused] = false;\x0d\n  return this;\x0d\n};\x0d\n\x0d\nfunction resume(stream\x2C state) {\x0d\n  if (!state.resumeScheduled) {\x0d\n    state.resumeScheduled = true;\x0d\n    process.nextTick(resume_\x2C stream\x2C state);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction resume_(stream\x2C state) {\x0d\n  debug('resume'\x2C state.reading);\x0d\n  if (!state.reading) {\x0d\n    stream.read(0);\x0d\n  }\x0d\n\x0d\n  state.resumeScheduled = false;\x0d\n  stream.emit('resume');\x0d\n  flow(stream);\x0d\n  if (state.flowing && !state.reading)\x0d\n    stream.read(0);\x0d\n}\x0d\n\x0d\nReadable.prototype.pause = function() {\x0d\n  debug('call pause flowing=%j'\x2C this._readableState.flowing);\x0d\n  if (this._readableState.flowing !== false) {\x0d\n    debug('pause');\x0d\n    this._readableState.flowing = false;\x0d\n    this.emit('pause');\x0d\n  }\x0d\n  this._readableState[kPaused] = true;\x0d\n  return this;\x0d\n};\x0d\n\x0d\nfunction flow(stream) {\x0d\n  const state = stream._readableState;\x0d\n  debug('flow'\x2C state.flowing);\x0d\n  while (state.flowing && stream.read() !== null);\x0d\n}\x0d\n\x0d\n// Wrap an old-style stream as the async data source.\x0d\n// This is *not* part of the readable stream interface.\x0d\n// It is an ugly unfortunate mess of history.\x0d\nReadable.prototype.wrap = function(stream) {\x0d\n  let paused = false;\x0d\n\x0d\n  // TODO (ronag): Should this.destroy(err) emit\x0d\n  // 'error' on the wrapped stream? Would require\x0d\n  // a static factory method\x2C e.g. Readable.wrap(stream).\x0d\n\x0d\n  stream.on('data'\x2C (chunk) => {\x0d\n    if (!this.push(chunk) && stream.pause) {\x0d\n      paused = true;\x0d\n      stream.pause();\x0d\n    }\x0d\n  });\x0d\n\x0d\n  stream.on('end'\x2C () => {\x0d\n    this.push(null);\x0d\n  });\x0d\n\x0d\n  stream.on('error'\x2C (err) => {\x0d\n    errorOrDestroy(this\x2C err);\x0d\n  });\x0d\n\x0d\n  stream.on('close'\x2C () => {\x0d\n    this.destroy();\x0d\n  });\x0d\n\x0d\n  stream.on('destroy'\x2C () => {\x0d\n    this.destroy();\x0d\n  });\x0d\n\x0d\n  this._read = () => {\x0d\n    if (paused && stream.resume) {\x0d\n      paused = false;\x0d\n      stream.resume();\x0d\n    }\x0d\n  };\x0d\n\x0d\n  // Proxy all the other methods. Important when wrapping filters and duplexes.\x0d\n  const streamKeys = ObjectKeys(stream);\x0d\n  for (let j = 1; j < streamKeys.length; j++) {\x0d\n    const i = streamKeys[j];\x0d\n    if (this[i] === undefined && typeof stream[i] === 'function') {\x0d\n      this[i] = stream[i].bind(stream);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\nReadable.prototype[SymbolAsyncIterator] = function() {\x0d\n  return streamToAsyncIterator(this);\x0d\n};\x0d\n\x0d\nReadable.prototype.iterator = function(options) {\x0d\n  if (options !== undefined) {\x0d\n    validateObject(options\x2C 'options');\x0d\n  }\x0d\n  return streamToAsyncIterator(this\x2C options);\x0d\n};\x0d\n\x0d\nfunction streamToAsyncIterator(stream\x2C options) {\x0d\n  if (typeof stream.read !== 'function') {\x0d\n    stream = Readable.wrap(stream\x2C { objectMode: true });\x0d\n  }\x0d\n\x0d\n  const iter = createAsyncIterator(stream\x2C options);\x0d\n  iter.stream = stream;\x0d\n  return iter;\x0d\n}\x0d\n\x0d\nasync function* createAsyncIterator(stream\x2C options) {\x0d\n  let callback = nop;\x0d\n\x0d\n  function next(resolve) {\x0d\n    if (this === stream) {\x0d\n      callback();\x0d\n      callback = nop;\x0d\n    } else {\x0d\n      callback = resolve;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  stream.on('readable'\x2C next);\x0d\n\x0d\n  let error;\x0d\n  eos(stream\x2C { writable: false }\x2C (err) => {\x0d\n    error = err ? aggregateTwoErrors(error\x2C err) : null;\x0d\n    callback();\x0d\n    callback = nop;\x0d\n  });\x0d\n\x0d\n  try {\x0d\n    while (true) {\x0d\n      const chunk = stream.destroyed ? null : stream.read();\x0d\n      if (chunk !== null) {\x0d\n        yield chunk;\x0d\n      } else if (error) {\x0d\n        throw error;\x0d\n      } else if (error === null) {\x0d\n        return;\x0d\n      } else {\x0d\n        await new Promise(next);\x0d\n      }\x0d\n    }\x0d\n  } catch (err) {\x0d\n    error = aggregateTwoErrors(error\x2C err);\x0d\n    throw error;\x0d\n  } finally {\x0d\n    if (\x0d\n      (error || options?.destroyOnReturn !== false) &&\x0d\n      (error === undefined || stream._readableState.autoDestroy)\x0d\n    ) {\x0d\n      destroyImpl.destroyer(stream\x2C null);\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\n// Making it explicit these properties are not enumerable\x0d\n// because otherwise some prototype manipulation in\x0d\n// userland will fail.\x0d\nObjectDefineProperties(Readable.prototype\x2C {\x0d\n  readable: {\x0d\n    get() {\x0d\n      const r = this._readableState;\x0d\n      // r.readable === false means that this is part of a Duplex stream\x0d\n      // where the readable side was disabled upon construction.\x0d\n      // Compat. The user might manually disable readable side through\x0d\n      // deprecated setter.\x0d\n      return !!r && r.readable !== false && !r.destroyed && !r.errorEmitted &&\x0d\n        !r.endEmitted;\x0d\n    }\x2C\x0d\n    set(val) {\x0d\n      // Backwards compat.\x0d\n      if (this._readableState) {\x0d\n        this._readableState.readable = !!val;\x0d\n      }\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  readableDidRead: {\x0d\n    enumerable: false\x2C\x0d\n    get: function() {\x0d\n      return this._readableState.dataEmitted;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  readableAborted: {\x0d\n    enumerable: false\x2C\x0d\n    get: function() {\x0d\n      return !!(\x0d\n        this._readableState.readable !== false &&\x0d\n        (this._readableState.destroyed || this._readableState.errored) &&\x0d\n        !this._readableState.endEmitted\x0d\n      );\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  readableHighWaterMark: {\x0d\n    enumerable: false\x2C\x0d\n    get: function() {\x0d\n      return this._readableState.highWaterMark;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  readableBuffer: {\x0d\n    enumerable: false\x2C\x0d\n    get: function() {\x0d\n      return this._readableState && this._readableState.buffer;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  readableFlowing: {\x0d\n    enumerable: false\x2C\x0d\n    get: function() {\x0d\n      return this._readableState.flowing;\x0d\n    }\x2C\x0d\n    set: function(state) {\x0d\n      if (this._readableState) {\x0d\n        this._readableState.flowing = state;\x0d\n      }\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  readableLength: {\x0d\n    enumerable: false\x2C\x0d\n    get() {\x0d\n      return this._readableState.length;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  readableObjectMode: {\x0d\n    enumerable: false\x2C\x0d\n    get() {\x0d\n      return this._readableState ? this._readableState.objectMode : false;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  readableEncoding: {\x0d\n    enumerable: false\x2C\x0d\n    get() {\x0d\n      return this._readableState ? this._readableState.encoding : null;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  destroyed: {\x0d\n    enumerable: false\x2C\x0d\n    get() {\x0d\n      if (this._readableState === undefined) {\x0d\n        return false;\x0d\n      }\x0d\n      return this._readableState.destroyed;\x0d\n    }\x2C\x0d\n    set(value) {\x0d\n      // We ignore the value if the stream\x0d\n      // has not been initialized yet.\x0d\n      if (!this._readableState) {\x0d\n        return;\x0d\n      }\x0d\n\x0d\n      // Backward compatibility\x2C the user is explicitly\x0d\n      // managing destroyed.\x0d\n      this._readableState.destroyed = value;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  readableEnded: {\x0d\n    enumerable: false\x2C\x0d\n    get() {\x0d\n      return this._readableState ? this._readableState.endEmitted : false;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n});\x0d\n\x0d\nObjectDefineProperties(ReadableState.prototype\x2C {\x0d\n  // Legacy getter for `pipesCount`.\x0d\n  pipesCount: {\x0d\n    get() {\x0d\n      return this.pipes.length;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  // Legacy property for `paused`.\x0d\n  paused: {\x0d\n    get() {\x0d\n      return this[kPaused] !== false;\x0d\n    }\x2C\x0d\n    set(value) {\x0d\n      this[kPaused] = !!value;\x0d\n    }\x0d\n  }\x0d\n});\x0d\n\x0d\n// Exposed for testing purposes only.\x0d\nReadable._fromList = fromList;\x0d\n\x0d\n// Pluck off n bytes from an array of buffers.\x0d\n// Length is the combined lengths of all the buffers in the list.\x0d\n// This function is designed to be inlinable\x2C so please take care when making\x0d\n// changes to the function body.\x0d\nfunction fromList(n\x2C state) {\x0d\n  // nothing buffered.\x0d\n  if (state.length === 0)\x0d\n    return null;\x0d\n\x0d\n  let ret;\x0d\n  if (state.objectMode)\x0d\n    ret = state.buffer.shift();\x0d\n  else if (!n || n >= state.length) {\x0d\n    // Read it all\x2C truncate the list.\x0d\n    if (state.decoder)\x0d\n      ret = state.buffer.join('');\x0d\n    else if (state.buffer.length === 1)\x0d\n      ret = state.buffer.first();\x0d\n    else\x0d\n      ret = state.buffer.concat(state.length);\x0d\n    state.buffer.clear();\x0d\n  } else {\x0d\n    // read part of list.\x0d\n    ret = state.buffer.consume(n\x2C state.decoder);\x0d\n  }\x0d\n\x0d\n  return ret;\x0d\n}\x0d\n\x0d\nfunction endReadable(stream) {\x0d\n  const state = stream._readableState;\x0d\n\x0d\n  debug('endReadable'\x2C state.endEmitted);\x0d\n  if (!state.endEmitted) {\x0d\n    state.ended = true;\x0d\n    process.nextTick(endReadableNT\x2C state\x2C stream);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction endReadableNT(state\x2C stream) {\x0d\n  debug('endReadableNT'\x2C state.endEmitted\x2C state.length);\x0d\n\x0d\n  // Check that we didn't get one last unshift.\x0d\n  if (!state.errored && !state.closeEmitted &&\x0d\n      !state.endEmitted && state.length === 0) {\x0d\n    state.endEmitted = true;\x0d\n    stream.emit('end');\x0d\n\x0d\n    if (stream.writable && stream.allowHalfOpen === false) {\x0d\n      process.nextTick(endWritableNT\x2C stream);\x0d\n    } else if (state.autoDestroy) {\x0d\n      // In case of duplex streams we need a way to detect\x0d\n      // if the writable side is ready for autoDestroy as well.\x0d\n      const wState = stream._writableState;\x0d\n      const autoDestroy = !wState || (\x0d\n        wState.autoDestroy &&\x0d\n        // We don't expect the writable to ever 'finish'\x0d\n        // if writable is explicitly set to false.\x0d\n        (wState.finished || wState.writable === false)\x0d\n      );\x0d\n\x0d\n      if (autoDestroy) {\x0d\n        stream.destroy();\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction endWritableNT(stream) {\x0d\n  const writable = stream.writable && !stream.writableEnded &&\x0d\n    !stream.destroyed;\x0d\n  if (writable) {\x0d\n    stream.end();\x0d\n  }\x0d\n}\x0d\n\x0d\nReadable.from = function(iterable\x2C opts) {\x0d\n  return from(Readable\x2C iterable\x2C opts);\x0d\n};\x0d\n\x0d\nlet webStreamsAdapters;\x0d\n\x0d\n// Lazy to avoid circular references\x0d\nfunction lazyWebStreams() {\x0d\n  if (webStreamsAdapters === undefined)\x0d\n    webStreamsAdapters = require('internal/webstreams/adapters');\x0d\n  return webStreamsAdapters;\x0d\n}\x0d\n\x0d\nReadable.fromWeb = function(readableStream\x2C options) {\x0d\n  return lazyWebStreams().newStreamReadableFromReadableStream(\x0d\n    readableStream\x2C\x0d\n    options);\x0d\n};\x0d\n\x0d\nReadable.toWeb = function(streamReadable) {\x0d\n  return lazyWebStreams().newReadableStreamFromStreamReadable(streamReadable);\x0d\n};\x0d\n\x0d\nReadable.wrap = function(src\x2C options) {\x0d\n  return new Readable({\x0d\n    objectMode: src.readableObjectMode ?? src.objectMode ?? true\x2C\x0d\n    ...options\x2C\x0d\n    destroy(err\x2C callback) {\x0d\n      destroyImpl.destroyer(src\x2C err);\x0d\n      callback(err);\x0d\n    }\x0d\n  }).wrap(src);\x0d\n};\x0d\n
code-source-info,0x30632492efe,57,6538,7440,C0O6538C9O6553C16O6564C21O6591C28O6598C33O6620C34O6779C41O6795C44O6802C48O6784C52O6815C71O6837C76O6835C80O6886C84O6925C92O6953C95O6974C99O6964C103O7006C111O7037C114O7061C118O7051C122O7096C130O7129C133O7155C137O7145C141O7185C149O7196C151O7213C158O7236C166O7213C171O7261C178O7268C186O7268C192O7294C199O7306C212O7306C219O7439,,
tick,0x7ff99731faad,267301,0,0x0,3,0x7ff7e78ebf00,0x30632488047,0x1c1d96d3791,0x1c1d96cf653,0x1c1d96ceb76,0x109c10f963f,0x109c10f920a,0x109c10f83db,0x109c10f8185,0x1abee806768,0x1abee8012dd
code-creation,LazyCompile,10,267325,0x30632495d56,18,Stream node:internal/streams/legacy:10:16,0x13c5c2cee80,~
script-source,58,node:internal/streams/legacy,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayIsArray\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst EE = require('events');\x0d\n\x0d\nfunction Stream(opts) {\x0d\n  EE.call(this\x2C opts);\x0d\n}\x0d\nObjectSetPrototypeOf(Stream.prototype\x2C EE.prototype);\x0d\nObjectSetPrototypeOf(Stream\x2C EE);\x0d\n\x0d\nStream.prototype.pipe = function(dest\x2C options) {\x0d\n  const source = this;\x0d\n\x0d\n  function ondata(chunk) {\x0d\n    if (dest.writable && dest.write(chunk) === false && source.pause) {\x0d\n      source.pause();\x0d\n    }\x0d\n  }\x0d\n\x0d\n  source.on('data'\x2C ondata);\x0d\n\x0d\n  function ondrain() {\x0d\n    if (source.readable && source.resume) {\x0d\n      source.resume();\x0d\n    }\x0d\n  }\x0d\n\x0d\n  dest.on('drain'\x2C ondrain);\x0d\n\x0d\n  // If the 'end' option is not supplied\x2C dest.end() will be called when\x0d\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\x0d\n  if (!dest._isStdio && (!options || options.end !== false)) {\x0d\n    source.on('end'\x2C onend);\x0d\n    source.on('close'\x2C onclose);\x0d\n  }\x0d\n\x0d\n  let didOnEnd = false;\x0d\n  function onend() {\x0d\n    if (didOnEnd) return;\x0d\n    didOnEnd = true;\x0d\n\x0d\n    dest.end();\x0d\n  }\x0d\n\x0d\n\x0d\n  function onclose() {\x0d\n    if (didOnEnd) return;\x0d\n    didOnEnd = true;\x0d\n\x0d\n    if (typeof dest.destroy === 'function') dest.destroy();\x0d\n  }\x0d\n\x0d\n  // Don't leave dangling pipes when there are errors.\x0d\n  function onerror(er) {\x0d\n    cleanup();\x0d\n    if (EE.listenerCount(this\x2C 'error') === 0) {\x0d\n      this.emit('error'\x2C er);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  prependListener(source\x2C 'error'\x2C onerror);\x0d\n  prependListener(dest\x2C 'error'\x2C onerror);\x0d\n\x0d\n  // Remove all the event listeners that were added.\x0d\n  function cleanup() {\x0d\n    source.removeListener('data'\x2C ondata);\x0d\n    dest.removeListener('drain'\x2C ondrain);\x0d\n\x0d\n    source.removeListener('end'\x2C onend);\x0d\n    source.removeListener('close'\x2C onclose);\x0d\n\x0d\n    source.removeListener('error'\x2C onerror);\x0d\n    dest.removeListener('error'\x2C onerror);\x0d\n\x0d\n    source.removeListener('end'\x2C cleanup);\x0d\n    source.removeListener('close'\x2C cleanup);\x0d\n\x0d\n    dest.removeListener('close'\x2C cleanup);\x0d\n  }\x0d\n\x0d\n  source.on('end'\x2C cleanup);\x0d\n  source.on('close'\x2C cleanup);\x0d\n\x0d\n  dest.on('close'\x2C cleanup);\x0d\n  dest.emit('pipe'\x2C source);\x0d\n\x0d\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\x0d\n  return dest;\x0d\n};\x0d\n\x0d\nfunction prependListener(emitter\x2C event\x2C fn) {\x0d\n  // Sadly this is not cacheable as some libraries bundle their own\x0d\n  // event emitter implementation with them.\x0d\n  if (typeof emitter.prependListener === 'function')\x0d\n    return emitter.prependListener(event\x2C fn);\x0d\n\x0d\n  // This is a hack to make sure that our error handler is attached before any\x0d\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\x0d\n  // to continue to work with older versions of Node.js that do not include\x0d\n  // the prependListener() method. The goal is to eventually remove this hack.\x0d\n  if (!emitter._events || !emitter._events[event])\x0d\n    emitter.on(event\x2C fn);\x0d\n  else if (ArrayIsArray(emitter._events[event]))\x0d\n    emitter._events[event].unshift(fn);\x0d\n  else\x0d\n    emitter._events[event] = [fn\x2C emitter._events[event]];\x0d\n}\x0d\n\x0d\nmodule.exports = { Stream\x2C prependListener };\x0d\n
code-source-info,0x30632495d56,58,136,171,C0O148C5O151C10O151C17O170,,
code-creation,LazyCompile,10,267643,0x306324965ae,354,ReadableState node:internal/streams/readable:83:23,0x13c5c2cc470,~
code-source-info,0x306324965ae,57,2708,6515,C0O3052C6O3092C8O3121C11O3128C15O3110C20O3265C25O3286C27O3305C33O3281C37O3323C41O3365C52O3389C54O3408C60O3358C64O3578C69O3599C73O3614C88O3614C97O3688C102O3688C106O3597C110O3896C112O3914C115O3910C120O3908C124O3931C125O3943C129O3951C131O3962C135O3971C136O3984C140O3995C141O4006C145O4018C146O4034C150O4046C151O4059C155O4259C156O4276C160O4562C161O4572C165O4697C166O4715C170O4727C171O4748C175O4760C176O4783C180O4795C181O4816C185O4828C187O4833C191O4842C195O4931C196O4949C200O5023C202O5041C208O5060C214O5070C218O5038C222O5160C224O5180C230O5199C236O5211C240O5177C244O5256C245O5271C249O5530C250O5543C254O5616C255O5628C259O5736C260O5754C264O5966C269O5990C271O6009C279O5987C283O6146C284O6169C288O6180C289O6201C293O6266C294O6283C298O6297C299O6314C303O6328C304O6341C308O6352C309O6366C313O6377C317O6400C323O6417C325O6436C328O6458C335O6432C340O6430C344O6498C348O6488C353O6514,,
code-creation,LazyCompile,10,267799,0x306324969be,98,getHighWaterMark node:internal/streams/state:19:26,0x13c5c2d1960,~
script-source,61,node:internal/streams/state,'use strict';\x0d\n\x0d\nconst {\x0d\n  MathFloor\x2C\x0d\n  NumberIsInteger\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { ERR_INVALID_ARG_VALUE } = require('internal/errors').codes;\x0d\n\x0d\nfunction highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey) {\x0d\n  return options.highWaterMark != null ? options.highWaterMark :\x0d\n    isDuplex ? options[duplexKey] : null;\x0d\n}\x0d\n\x0d\nfunction getDefaultHighWaterMark(objectMode) {\x0d\n  return objectMode ? 16 : 16 * 1024;\x0d\n}\x0d\n\x0d\nfunction getHighWaterMark(state\x2C options\x2C duplexKey\x2C isDuplex) {\x0d\n  const hwm = highWaterMarkFrom(options\x2C isDuplex\x2C duplexKey);\x0d\n  if (hwm != null) {\x0d\n    if (!NumberIsInteger(hwm) || hwm < 0) {\x0d\n      const name = isDuplex ? `options.${duplexKey}` : 'options.highWaterMark';\x0d\n      throw new ERR_INVALID_ARG_VALUE(name\x2C hwm);\x0d\n    }\x0d\n    return MathFloor(hwm);\x0d\n  }\x0d\n\x0d\n  // Default value\x0d\n  return getDefaultHighWaterMark(state.objectMode);\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  getHighWaterMark\x2C\x0d\n  getDefaultHighWaterMark\x0d\n};\x0d\n
code-source-info,0x306324969be,61,442,862,C0O497C12O497C18O549C21O573C26O578C33O606C38O633C47O655C56O701C69O707C74O701C75O757C80O764C84O779C85O810C88O847C93O817C97O859,,
code-creation,LazyCompile,10,267906,0x30632496c56,26,highWaterMarkFrom node:internal/streams/state:10:27,0x13c5c2d1800,~
code-source-info,0x30632496c56,61,177,321,C0O228C7O260C15O281C19O299C25O318,,
code-creation,LazyCompile,10,267946,0x30632496d2e,13,getDefaultHighWaterMark node:internal/streams/state:15:33,0x13c5c2d1910,~
code-source-info,0x30632496d2e,61,357,413,C0O375C12O410,,
code-creation,LazyCompile,10,267997,0x30632496e0e,17,BufferList node:internal/streams/buffer_list:14:14,0x13c5c2d0cb8,~
script-source,60,node:internal/streams/buffer_list,'use strict';\x0d\n\x0d\nconst {\x0d\n  StringPrototypeSlice\x2C\x0d\n  SymbolIterator\x2C\x0d\n  TypedArrayPrototypeSet\x2C\x0d\n  Uint8Array\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { Buffer } = require('buffer');\x0d\nconst { inspect } = require('internal/util/inspect');\x0d\n\x0d\nmodule.exports = class BufferList {\x0d\n  constructor() {\x0d\n    this.head = null;\x0d\n    this.tail = null;\x0d\n    this.length = 0;\x0d\n  }\x0d\n\x0d\n  push(v) {\x0d\n    const entry = { data: v\x2C next: null };\x0d\n    if (this.length > 0)\x0d\n      this.tail.next = entry;\x0d\n    else\x0d\n      this.head = entry;\x0d\n    this.tail = entry;\x0d\n    ++this.length;\x0d\n  }\x0d\n\x0d\n  unshift(v) {\x0d\n    const entry = { data: v\x2C next: this.head };\x0d\n    if (this.length === 0)\x0d\n      this.tail = entry;\x0d\n    this.head = entry;\x0d\n    ++this.length;\x0d\n  }\x0d\n\x0d\n  shift() {\x0d\n    if (this.length === 0)\x0d\n      return;\x0d\n    const ret = this.head.data;\x0d\n    if (this.length === 1)\x0d\n      this.head = this.tail = null;\x0d\n    else\x0d\n      this.head = this.head.next;\x0d\n    --this.length;\x0d\n    return ret;\x0d\n  }\x0d\n\x0d\n  clear() {\x0d\n    this.head = this.tail = null;\x0d\n    this.length = 0;\x0d\n  }\x0d\n\x0d\n  join(s) {\x0d\n    if (this.length === 0)\x0d\n      return '';\x0d\n    let p = this.head;\x0d\n    let ret = '' + p.data;\x0d\n    while (p = p.next)\x0d\n      ret += s + p.data;\x0d\n    return ret;\x0d\n  }\x0d\n\x0d\n  concat(n) {\x0d\n    if (this.length === 0)\x0d\n      return Buffer.alloc(0);\x0d\n    const ret = Buffer.allocUnsafe(n >>> 0);\x0d\n    let p = this.head;\x0d\n    let i = 0;\x0d\n    while (p) {\x0d\n      TypedArrayPrototypeSet(ret\x2C p.data\x2C i);\x0d\n      i += p.data.length;\x0d\n      p = p.next;\x0d\n    }\x0d\n    return ret;\x0d\n  }\x0d\n\x0d\n  // Consumes a specified amount of bytes or characters from the buffered data.\x0d\n  consume(n\x2C hasStrings) {\x0d\n    const data = this.head.data;\x0d\n    if (n < data.length) {\x0d\n      // `slice` is the same for buffers and strings.\x0d\n      const slice = data.slice(0\x2C n);\x0d\n      this.head.data = data.slice(n);\x0d\n      return slice;\x0d\n    }\x0d\n    if (n === data.length) {\x0d\n      // First chunk is a perfect match.\x0d\n      return this.shift();\x0d\n    }\x0d\n    // Result spans more than one buffer.\x0d\n    return hasStrings ? this._getString(n) : this._getBuffer(n);\x0d\n  }\x0d\n\x0d\n  first() {\x0d\n    return this.head.data;\x0d\n  }\x0d\n\x0d\n  *[SymbolIterator]() {\x0d\n    for (let p = this.head; p; p = p.next) {\x0d\n      yield p.data;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // Consumes a specified amount of characters from the buffered data.\x0d\n  _getString(n) {\x0d\n    let ret = '';\x0d\n    let p = this.head;\x0d\n    let c = 0;\x0d\n    do {\x0d\n      const str = p.data;\x0d\n      if (n > str.length) {\x0d\n        ret += str;\x0d\n        n -= str.length;\x0d\n      } else {\x0d\n        if (n === str.length) {\x0d\n          ret += str;\x0d\n          ++c;\x0d\n          if (p.next)\x0d\n            this.head = p.next;\x0d\n          else\x0d\n            this.head = this.tail = null;\x0d\n        } else {\x0d\n          ret += StringPrototypeSlice(str\x2C 0\x2C n);\x0d\n          this.head = p;\x0d\n          p.data = StringPrototypeSlice(str\x2C n);\x0d\n        }\x0d\n        break;\x0d\n      }\x0d\n      ++c;\x0d\n    } while (p = p.next);\x0d\n    this.length -= c;\x0d\n    return ret;\x0d\n  }\x0d\n\x0d\n  // Consumes a specified amount of bytes from the buffered data.\x0d\n  _getBuffer(n) {\x0d\n    const ret = Buffer.allocUnsafe(n);\x0d\n    const retLen = n;\x0d\n    let p = this.head;\x0d\n    let c = 0;\x0d\n    do {\x0d\n      const buf = p.data;\x0d\n      if (n > buf.length) {\x0d\n        TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\x0d\n        n -= buf.length;\x0d\n      } else {\x0d\n        if (n === buf.length) {\x0d\n          TypedArrayPrototypeSet(ret\x2C buf\x2C retLen - n);\x0d\n          ++c;\x0d\n          if (p.next)\x0d\n            this.head = p.next;\x0d\n          else\x0d\n            this.head = this.tail = null;\x0d\n        } else {\x0d\n          TypedArrayPrototypeSet(ret\x2C\x0d\n                                 new Uint8Array(buf.buffer\x2C buf.byteOffset\x2C n)\x2C\x0d\n                                 retLen - n);\x0d\n          this.head = p;\x0d\n          p.data = buf.slice(n);\x0d\n        }\x0d\n        break;\x0d\n      }\x0d\n      ++c;\x0d\n    } while (p = p.next);\x0d\n    this.length -= c;\x0d\n    return ret;\x0d\n  }\x0d\n\x0d\n  // Make sure the linked list only shows the minimal necessary information.\x0d\n  [inspect.custom](_\x2C options) {\x0d\n    return inspect(this\x2C {\x0d\n      ...options\x2C\x0d\n      // Only inspect one level.\x0d\n      depth: 0\x2C\x0d\n      // It should not recurse.\x0d\n      customInspect: false\x0d\n    });\x0d\n  }\x0d\n};\x0d\n
code-source-info,0x30632496e0e,60,278,355,C0O288C1O298C5O311C6O321C10O334C11O346C16O354,,
code-creation,LazyCompile,10,268335,0x3063249753e,98,construct node:internal/streams/destroy:232:19,0x394c9e37268,~
script-source,55,node:internal/streams/destroy,'use strict';\x0d\n\x0d\nconst {\x0d\n  aggregateTwoErrors\x2C\x0d\n  codes: {\x0d\n    ERR_MULTIPLE_CALLBACK\x2C\x0d\n  }\x2C\x0d\n  AbortError\x2C\x0d\n} = require('internal/errors');\x0d\nconst {\x0d\n  Symbol\x2C\x0d\n} = primordials;\x0d\nconst {\x0d\n  kDestroyed\x2C\x0d\n  isDestroyed\x2C\x0d\n  isFinished\x2C\x0d\n  isServerRequest\x0d\n} = require('internal/streams/utils');\x0d\n\x0d\nconst kDestroy = Symbol('kDestroy');\x0d\nconst kConstruct = Symbol('kConstruct');\x0d\n\x0d\nfunction checkError(err\x2C w\x2C r) {\x0d\n  if (err) {\x0d\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\x0d\n    err.stack; // eslint-disable-line no-unused-expressions\x0d\n\x0d\n    if (w && !w.errored) {\x0d\n      w.errored = err;\x0d\n    }\x0d\n    if (r && !r.errored) {\x0d\n      r.errored = err;\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\n// Backwards compat. cb() is undocumented and unused in core but\x0d\n// unfortunately might be used by modules.\x0d\nfunction destroy(err\x2C cb) {\x0d\n  const r = this._readableState;\x0d\n  const w = this._writableState;\x0d\n  // With duplex streams we use the writable side for state.\x0d\n  const s = w || r;\x0d\n\x0d\n  if ((w && w.destroyed) || (r && r.destroyed)) {\x0d\n    if (typeof cb === 'function') {\x0d\n      cb();\x0d\n    }\x0d\n\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n\x0d\n  // We set destroyed to true before firing error callbacks in order\x0d\n  // to make it re-entrance safe in case destroy() is called within callbacks\x0d\n  checkError(err\x2C w\x2C r);\x0d\n\x0d\n  if (w) {\x0d\n    w.destroyed = true;\x0d\n  }\x0d\n  if (r) {\x0d\n    r.destroyed = true;\x0d\n  }\x0d\n\x0d\n  // If still constructing then defer calling _destroy.\x0d\n  if (!s.constructed) {\x0d\n    this.once(kDestroy\x2C function(er) {\x0d\n      _destroy(this\x2C aggregateTwoErrors(er\x2C err)\x2C cb);\x0d\n    });\x0d\n  } else {\x0d\n    _destroy(this\x2C err\x2C cb);\x0d\n  }\x0d\n\x0d\n  return this;\x0d\n}\x0d\n\x0d\nfunction _destroy(self\x2C err\x2C cb) {\x0d\n  let called = false;\x0d\n\x0d\n  function onDestroy(err) {\x0d\n    if (called) {\x0d\n      return;\x0d\n    }\x0d\n    called = true;\x0d\n\x0d\n    const r = self._readableState;\x0d\n    const w = self._writableState;\x0d\n\x0d\n    checkError(err\x2C w\x2C r);\x0d\n\x0d\n    if (w) {\x0d\n      w.closed = true;\x0d\n    }\x0d\n    if (r) {\x0d\n      r.closed = true;\x0d\n    }\x0d\n\x0d\n    if (typeof cb === 'function') {\x0d\n      cb(err);\x0d\n    }\x0d\n\x0d\n    if (err) {\x0d\n      process.nextTick(emitErrorCloseNT\x2C self\x2C err);\x0d\n    } else {\x0d\n      process.nextTick(emitCloseNT\x2C self);\x0d\n    }\x0d\n  }\x0d\n  try {\x0d\n    const result = self._destroy(err || null\x2C onDestroy);\x0d\n    if (result != null) {\x0d\n      const then = result.then;\x0d\n      if (typeof then === 'function') {\x0d\n        then.call(\x0d\n          result\x2C\x0d\n          function() {\x0d\n            process.nextTick(onDestroy\x2C null);\x0d\n          }\x2C\x0d\n          function(err) {\x0d\n            process.nextTick(onDestroy\x2C err);\x0d\n          });\x0d\n      }\x0d\n    }\x0d\n  } catch (err) {\x0d\n    onDestroy(err);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction emitErrorCloseNT(self\x2C err) {\x0d\n  emitErrorNT(self\x2C err);\x0d\n  emitCloseNT(self);\x0d\n}\x0d\n\x0d\nfunction emitCloseNT(self) {\x0d\n  const r = self._readableState;\x0d\n  const w = self._writableState;\x0d\n\x0d\n  if (w) {\x0d\n    w.closeEmitted = true;\x0d\n  }\x0d\n  if (r) {\x0d\n    r.closeEmitted = true;\x0d\n  }\x0d\n\x0d\n  if ((w && w.emitClose) || (r && r.emitClose)) {\x0d\n    self.emit('close');\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction emitErrorNT(self\x2C err) {\x0d\n  const r = self._readableState;\x0d\n  const w = self._writableState;\x0d\n\x0d\n  if ((w && w.errorEmitted) || (r && r.errorEmitted)) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (w) {\x0d\n    w.errorEmitted = true;\x0d\n  }\x0d\n  if (r) {\x0d\n    r.errorEmitted = true;\x0d\n  }\x0d\n\x0d\n  self.emit('error'\x2C err);\x0d\n}\x0d\n\x0d\nfunction undestroy() {\x0d\n  const r = this._readableState;\x0d\n  const w = this._writableState;\x0d\n\x0d\n  if (r) {\x0d\n    r.constructed = true;\x0d\n    r.closed = false;\x0d\n    r.closeEmitted = false;\x0d\n    r.destroyed = false;\x0d\n    r.errored = null;\x0d\n    r.errorEmitted = false;\x0d\n    r.reading = false;\x0d\n    r.ended = r.readable === false;\x0d\n    r.endEmitted = r.readable === false;\x0d\n  }\x0d\n\x0d\n  if (w) {\x0d\n    w.constructed = true;\x0d\n    w.destroyed = false;\x0d\n    w.closed = false;\x0d\n    w.closeEmitted = false;\x0d\n    w.errored = null;\x0d\n    w.errorEmitted = false;\x0d\n    w.finalCalled = false;\x0d\n    w.prefinished = false;\x0d\n    w.ended = w.writable === false;\x0d\n    w.ending = w.writable === false;\x0d\n    w.finished = w.writable === false;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction errorOrDestroy(stream\x2C err\x2C sync) {\x0d\n  // We have tests that rely on errors being emitted\x0d\n  // in the same tick\x2C so changing this is semver major.\x0d\n  // For now when you opt-in to autoDestroy we allow\x0d\n  // the error to be emitted nextTick. In a future\x0d\n  // semver major update we should change the default to this.\x0d\n\x0d\n  const r = stream._readableState;\x0d\n  const w = stream._writableState;\x0d\n\x0d\n  if ((w && w.destroyed) || (r && r.destroyed)) {\x0d\n    return this;\x0d\n  }\x0d\n\x0d\n  if ((r && r.autoDestroy) || (w && w.autoDestroy))\x0d\n    stream.destroy(err);\x0d\n  else if (err) {\x0d\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\x0d\n    err.stack; // eslint-disable-line no-unused-expressions\x0d\n\x0d\n    if (w && !w.errored) {\x0d\n      w.errored = err;\x0d\n    }\x0d\n    if (r && !r.errored) {\x0d\n      r.errored = err;\x0d\n    }\x0d\n    if (sync) {\x0d\n      process.nextTick(emitErrorNT\x2C stream\x2C err);\x0d\n    } else {\x0d\n      emitErrorNT(stream\x2C err);\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction construct(stream\x2C cb) {\x0d\n  if (typeof stream._construct !== 'function') {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  const r = stream._readableState;\x0d\n  const w = stream._writableState;\x0d\n\x0d\n  if (r) {\x0d\n    r.constructed = false;\x0d\n  }\x0d\n  if (w) {\x0d\n    w.constructed = false;\x0d\n  }\x0d\n\x0d\n  stream.once(kConstruct\x2C cb);\x0d\n\x0d\n  if (stream.listenerCount(kConstruct) > 1) {\x0d\n    // Duplex\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  process.nextTick(constructNT\x2C stream);\x0d\n}\x0d\n\x0d\nfunction constructNT(stream) {\x0d\n  let called = false;\x0d\n\x0d\n  function onConstruct(err) {\x0d\n    if (called) {\x0d\n      errorOrDestroy(stream\x2C err ?? new ERR_MULTIPLE_CALLBACK());\x0d\n      return;\x0d\n    }\x0d\n    called = true;\x0d\n\x0d\n    const r = stream._readableState;\x0d\n    const w = stream._writableState;\x0d\n    const s = w || r;\x0d\n\x0d\n    if (r) {\x0d\n      r.constructed = true;\x0d\n    }\x0d\n    if (w) {\x0d\n      w.constructed = true;\x0d\n    }\x0d\n\x0d\n    if (s.destroyed) {\x0d\n      stream.emit(kDestroy\x2C err);\x0d\n    } else if (err) {\x0d\n      errorOrDestroy(stream\x2C err\x2C true);\x0d\n    } else {\x0d\n      process.nextTick(emitConstructNT\x2C stream);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  try {\x0d\n    const result = stream._construct(onConstruct);\x0d\n    if (result != null) {\x0d\n      const then = result.then;\x0d\n      if (typeof then === 'function') {\x0d\n        then.call(\x0d\n          result\x2C\x0d\n          function() {\x0d\n            if (!called) {\x0d\n              process.nextTick(onConstruct\x2C null);\x0d\n            }\x0d\n          }\x2C\x0d\n          function(err) {\x0d\n            if (!called) {\x0d\n              process.nextTick(onConstruct\x2C err);\x0d\n            }\x0d\n          });\x0d\n      }\x0d\n    }\x0d\n  } catch (err) {\x0d\n    onConstruct(err);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction emitConstructNT(stream) {\x0d\n  stream.emit(kConstruct);\x0d\n}\x0d\n\x0d\nfunction isRequest(stream) {\x0d\n  return stream && stream.setHeader && typeof stream.abort === 'function';\x0d\n}\x0d\n\x0d\nfunction emitCloseLegacy(stream) {\x0d\n  stream.emit('close');\x0d\n}\x0d\n\x0d\nfunction emitErrorCloseLegacy(stream\x2C err) {\x0d\n  stream.emit('error'\x2C err);\x0d\n  process.nextTick(emitCloseLegacy\x2C stream);\x0d\n}\x0d\n\x0d\n// Normalize destroy for legacy.\x0d\nfunction destroyer(stream\x2C err) {\x0d\n  if (!stream || isDestroyed(stream)) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  if (!err && !isFinished(stream)) {\x0d\n    err = new AbortError();\x0d\n  }\x0d\n\x0d\n  // TODO: Remove isRequest branches.\x0d\n  if (isServerRequest(stream)) {\x0d\n    stream.socket = null;\x0d\n    stream.destroy(err);\x0d\n  } else if (isRequest(stream)) {\x0d\n    stream.abort();\x0d\n  } else if (isRequest(stream.req)) {\x0d\n    stream.req.abort();\x0d\n  } else if (typeof stream.destroy === 'function') {\x0d\n    stream.destroy(err);\x0d\n  } else if (typeof stream.close === 'function') {\x0d\n    // TODO: Don't lose err?\x0d\n    stream.close();\x0d\n  } else if (err) {\x0d\n    process.nextTick(emitErrorCloseLegacy\x2C stream);\x0d\n  } else {\x0d\n    process.nextTick(emitCloseLegacy\x2C stream);\x0d\n  }\x0d\n\x0d\n  if (!stream.destroyed) {\x0d\n    stream[kDestroyed] = true;\x0d\n  }\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  construct\x2C\x0d\n  destroyer\x2C\x0d\n  destroy\x2C\x0d\n  undestroy\x2C\x0d\n  errorOrDestroy\x0d\n};\x0d\n
code-source-info,0x3063249753e,55,5054,5465,C0O5090C8O5124C9O5131C10O5159C15O5195C20O5216C24O5230C25O5244C29O5261C33O5275C34O5289C38O5315C45O5320C48O5315C54O5353C61O5367C64O5353C72O5379C77O5406C78O5413C79O5424C82O5432C90O5432C97O5464,,
code-creation,LazyCompile,10,268880,0x3063249835e,266,Writable node:internal/streams/writable:219:18,0x13c5c2db4a0,~
script-source,64,node:internal/streams/writable,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n// A bit simpler than readable streams.\x0d\n// Implement an async ._write(chunk\x2C encoding\x2C cb)\x2C and it'll handle all\x0d\n// the drain event emission and buffering.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  Error\x2C\x0d\n  FunctionPrototypeSymbolHasInstance\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  StringPrototypeToLowerCase\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolHasInstance\x2C\x0d\n} = primordials;\x0d\n\x0d\nmodule.exports = Writable;\x0d\nWritable.WritableState = WritableState;\x0d\n\x0d\nconst EE = require('events');\x0d\nconst Stream = require('internal/streams/legacy').Stream;\x0d\nconst { Buffer } = require('buffer');\x0d\nconst destroyImpl = require('internal/streams/destroy');\x0d\n\x0d\nconst {\x0d\n  addAbortSignal\x2C\x0d\n} = require('internal/streams/add-abort-signal');\x0d\n\x0d\nconst {\x0d\n  getHighWaterMark\x2C\x0d\n  getDefaultHighWaterMark\x0d\n} = require('internal/streams/state');\x0d\nconst {\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n  ERR_METHOD_NOT_IMPLEMENTED\x2C\x0d\n  ERR_MULTIPLE_CALLBACK\x2C\x0d\n  ERR_STREAM_CANNOT_PIPE\x2C\x0d\n  ERR_STREAM_DESTROYED\x2C\x0d\n  ERR_STREAM_ALREADY_FINISHED\x2C\x0d\n  ERR_STREAM_NULL_VALUES\x2C\x0d\n  ERR_STREAM_WRITE_AFTER_END\x2C\x0d\n  ERR_UNKNOWN_ENCODING\x0d\n} = require('internal/errors').codes;\x0d\n\x0d\nconst { errorOrDestroy } = destroyImpl;\x0d\n\x0d\nObjectSetPrototypeOf(Writable.prototype\x2C Stream.prototype);\x0d\nObjectSetPrototypeOf(Writable\x2C Stream);\x0d\n\x0d\nfunction nop() {}\x0d\n\x0d\nconst kOnFinished = Symbol('kOnFinished');\x0d\n\x0d\nfunction WritableState(options\x2C stream\x2C isDuplex) {\x0d\n  // Duplex streams are both readable and writable\x2C but share\x0d\n  // the same options object.\x0d\n  // However\x2C some cases require setting options to different\x0d\n  // values for the readable and the writable sides of the duplex stream\x2C\x0d\n  // e.g. options.readableObjectMode vs. options.writableObjectMode\x2C etc.\x0d\n  if (typeof isDuplex !== 'boolean')\x0d\n    isDuplex = stream instanceof Stream.Duplex;\x0d\n\x0d\n  // Object stream flag to indicate whether or not this stream\x0d\n  // contains buffers or objects.\x0d\n  this.objectMode = !!(options && options.objectMode);\x0d\n\x0d\n  if (isDuplex)\x0d\n    this.objectMode = this.objectMode ||\x0d\n      !!(options && options.writableObjectMode);\x0d\n\x0d\n  // The point at which write() starts returning false\x0d\n  // Note: 0 is a valid value\x2C means that we always return false if\x0d\n  // the entire buffer is not flushed immediately on write().\x0d\n  this.highWaterMark = options ?\x0d\n    getHighWaterMark(this\x2C options\x2C 'writableHighWaterMark'\x2C isDuplex) :\x0d\n    getDefaultHighWaterMark(false);\x0d\n\x0d\n  // if _final has been called.\x0d\n  this.finalCalled = false;\x0d\n\x0d\n  // drain event flag.\x0d\n  this.needDrain = false;\x0d\n  // At the start of calling end()\x0d\n  this.ending = false;\x0d\n  // When end() has been called\x2C and returned.\x0d\n  this.ended = false;\x0d\n  // When 'finish' is emitted.\x0d\n  this.finished = false;\x0d\n\x0d\n  // Has it been destroyed\x0d\n  this.destroyed = false;\x0d\n\x0d\n  // Should we decode strings into buffers before passing to _write?\x0d\n  // this is here so that some node-core streams can optimize string\x0d\n  // handling at a lower level.\x0d\n  const noDecode = !!(options && options.decodeStrings === false);\x0d\n  this.decodeStrings = !noDecode;\x0d\n\x0d\n  // Crypto is kind of old and crusty.  Historically\x2C its default string\x0d\n  // encoding is 'binary' so we have to make this configurable.\x0d\n  // Everything else in the universe uses 'utf8'\x2C though.\x0d\n  this.defaultEncoding = (options && options.defaultEncoding) || 'utf8';\x0d\n\x0d\n  // Not an actual buffer we keep track of\x2C but a measurement\x0d\n  // of how much we're waiting to get pushed to some underlying\x0d\n  // socket or file.\x0d\n  this.length = 0;\x0d\n\x0d\n  // A flag to see when we're in the middle of a write.\x0d\n  this.writing = false;\x0d\n\x0d\n  // When true all writes will be buffered until .uncork() call.\x0d\n  this.corked = 0;\x0d\n\x0d\n  // A flag to be able to tell if the onwrite cb is called immediately\x2C\x0d\n  // or on a later tick.  We set this to true at first\x2C because any\x0d\n  // actions that shouldn't happen until "later" should generally also\x0d\n  // not happen before the first write call.\x0d\n  this.sync = true;\x0d\n\x0d\n  // A flag to know if we're processing previously buffered items\x2C which\x0d\n  // may call the _write() callback in the same tick\x2C so that we don't\x0d\n  // end up in an overlapped onwrite situation.\x0d\n  this.bufferProcessing = false;\x0d\n\x0d\n  // The callback that's passed to _write(chunk\x2C cb).\x0d\n  this.onwrite = onwrite.bind(undefined\x2C stream);\x0d\n\x0d\n  // The callback that the user supplies to write(chunk\x2C encoding\x2C cb).\x0d\n  this.writecb = null;\x0d\n\x0d\n  // The amount that is being written when _write is called.\x0d\n  this.writelen = 0;\x0d\n\x0d\n  // Storage for data passed to the afterWrite() callback in case of\x0d\n  // synchronous _write() completion.\x0d\n  this.afterWriteTickInfo = null;\x0d\n\x0d\n  resetBuffer(this);\x0d\n\x0d\n  // Number of pending user-supplied write callbacks\x0d\n  // this must be 0 before 'finish' can be emitted.\x0d\n  this.pendingcb = 0;\x0d\n\x0d\n  // Stream is still being constructed and cannot be\x0d\n  // destroyed until construction finished or failed.\x0d\n  // Async construction is opt in\x2C therefore we start as\x0d\n  // constructed.\x0d\n  this.constructed = true;\x0d\n\x0d\n  // Emit prefinish if the only thing we're waiting for is _write cbs\x0d\n  // This is relevant for synchronous Transform streams.\x0d\n  this.prefinished = false;\x0d\n\x0d\n  // True if the error was already emitted and should not be thrown again.\x0d\n  this.errorEmitted = false;\x0d\n\x0d\n  // Should close be emitted on destroy. Defaults to true.\x0d\n  this.emitClose = !options || options.emitClose !== false;\x0d\n\x0d\n  // Should .destroy() be called after 'finish' (and potentially 'end').\x0d\n  this.autoDestroy = !options || options.autoDestroy !== false;\x0d\n\x0d\n  // Indicates whether the stream has errored. When true all write() calls\x0d\n  // should return false. This is needed since when autoDestroy\x0d\n  // is disabled we need a way to tell whether the stream has failed.\x0d\n  this.errored = null;\x0d\n\x0d\n  // Indicates whether the stream has finished destroying.\x0d\n  this.closed = false;\x0d\n\x0d\n  // True if close has been emitted or would have been emitted\x0d\n  // depending on emitClose.\x0d\n  this.closeEmitted = false;\x0d\n\x0d\n  this[kOnFinished] = [];\x0d\n}\x0d\n\x0d\nfunction resetBuffer(state) {\x0d\n  state.buffered = [];\x0d\n  state.bufferedIndex = 0;\x0d\n  state.allBuffers = true;\x0d\n  state.allNoop = true;\x0d\n}\x0d\n\x0d\nWritableState.prototype.getBuffer = function getBuffer() {\x0d\n  return ArrayPrototypeSlice(this.buffered\x2C this.bufferedIndex);\x0d\n};\x0d\n\x0d\nObjectDefineProperty(WritableState.prototype\x2C 'bufferedRequestCount'\x2C {\x0d\n  get() {\x0d\n    return this.buffered.length - this.bufferedIndex;\x0d\n  }\x0d\n});\x0d\n\x0d\nfunction Writable(options) {\x0d\n  // Writable ctor is applied to Duplexes\x2C too.\x0d\n  // `realHasInstance` is necessary because using plain `instanceof`\x0d\n  // would return false\x2C as no `_writableState` property is attached.\x0d\n\x0d\n  // Trying to use the custom `instanceof` for Writable here will also break the\x0d\n  // Node.js LazyTransform implementation\x2C which has a non-trivial getter for\x0d\n  // `_writableState` that would lead to infinite recursion.\x0d\n\x0d\n  // Checking for a Stream.Duplex instance is faster here instead of inside\x0d\n  // the WritableState constructor\x2C at least with V8 6.5.\x0d\n  const isDuplex = (this instanceof Stream.Duplex);\x0d\n\x0d\n  if (!isDuplex && !FunctionPrototypeSymbolHasInstance(Writable\x2C this))\x0d\n    return new Writable(options);\x0d\n\x0d\n  this._writableState = new WritableState(options\x2C this\x2C isDuplex);\x0d\n\x0d\n  if (options) {\x0d\n    if (typeof options.write === 'function')\x0d\n      this._write = options.write;\x0d\n\x0d\n    if (typeof options.writev === 'function')\x0d\n      this._writev = options.writev;\x0d\n\x0d\n    if (typeof options.destroy === 'function')\x0d\n      this._destroy = options.destroy;\x0d\n\x0d\n    if (typeof options.final === 'function')\x0d\n      this._final = options.final;\x0d\n\x0d\n    if (typeof options.construct === 'function')\x0d\n      this._construct = options.construct;\x0d\n\x0d\n    if (options.signal)\x0d\n      addAbortSignal(options.signal\x2C this);\x0d\n  }\x0d\n\x0d\n  Stream.call(this\x2C options);\x0d\n\x0d\n  destroyImpl.construct(this\x2C () => {\x0d\n    const state = this._writableState;\x0d\n\x0d\n    if (!state.writing) {\x0d\n      clearBuffer(this\x2C state);\x0d\n    }\x0d\n\x0d\n    finishMaybe(this\x2C state);\x0d\n  });\x0d\n}\x0d\n\x0d\nObjectDefineProperty(Writable\x2C SymbolHasInstance\x2C {\x0d\n  value: function(object) {\x0d\n    if (FunctionPrototypeSymbolHasInstance(this\x2C object)) return true;\x0d\n    if (this !== Writable) return false;\x0d\n\x0d\n    return object && object._writableState instanceof WritableState;\x0d\n  }\x2C\x0d\n});\x0d\n\x0d\n// Otherwise people can pipe Writable streams\x2C which is just wrong.\x0d\nWritable.prototype.pipe = function() {\x0d\n  errorOrDestroy(this\x2C new ERR_STREAM_CANNOT_PIPE());\x0d\n};\x0d\n\x0d\nfunction _write(stream\x2C chunk\x2C encoding\x2C cb) {\x0d\n  const state = stream._writableState;\x0d\n\x0d\n  if (typeof encoding === 'function') {\x0d\n    cb = encoding;\x0d\n    encoding = state.defaultEncoding;\x0d\n  } else {\x0d\n    if (!encoding)\x0d\n      encoding = state.defaultEncoding;\x0d\n    else if (encoding !== 'buffer' && !Buffer.isEncoding(encoding))\x0d\n      throw new ERR_UNKNOWN_ENCODING(encoding);\x0d\n    if (typeof cb !== 'function')\x0d\n      cb = nop;\x0d\n  }\x0d\n\x0d\n  if (chunk === null) {\x0d\n    throw new ERR_STREAM_NULL_VALUES();\x0d\n  } else if (!state.objectMode) {\x0d\n    if (typeof chunk === 'string') {\x0d\n      if (state.decodeStrings !== false) {\x0d\n        chunk = Buffer.from(chunk\x2C encoding);\x0d\n        encoding = 'buffer';\x0d\n      }\x0d\n    } else if (chunk instanceof Buffer) {\x0d\n      encoding = 'buffer';\x0d\n    } else if (Stream._isUint8Array(chunk)) {\x0d\n      chunk = Stream._uint8ArrayToBuffer(chunk);\x0d\n      encoding = 'buffer';\x0d\n    } else {\x0d\n      throw new ERR_INVALID_ARG_TYPE(\x0d\n        'chunk'\x2C ['string'\x2C 'Buffer'\x2C 'Uint8Array']\x2C chunk);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  let err;\x0d\n  if (state.ending) {\x0d\n    err = new ERR_STREAM_WRITE_AFTER_END();\x0d\n  } else if (state.destroyed) {\x0d\n    err = new ERR_STREAM_DESTROYED('write');\x0d\n  }\x0d\n\x0d\n  if (err) {\x0d\n    process.nextTick(cb\x2C err);\x0d\n    errorOrDestroy(stream\x2C err\x2C true);\x0d\n    return err;\x0d\n  }\x0d\n  state.pendingcb++;\x0d\n  return writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C cb);\x0d\n}\x0d\n\x0d\nWritable.prototype.write = function(chunk\x2C encoding\x2C cb) {\x0d\n  return _write(this\x2C chunk\x2C encoding\x2C cb) === true;\x0d\n};\x0d\n\x0d\nWritable.prototype.cork = function() {\x0d\n  this._writableState.corked++;\x0d\n};\x0d\n\x0d\nWritable.prototype.uncork = function() {\x0d\n  const state = this._writableState;\x0d\n\x0d\n  if (state.corked) {\x0d\n    state.corked--;\x0d\n\x0d\n    if (!state.writing)\x0d\n      clearBuffer(this\x2C state);\x0d\n  }\x0d\n};\x0d\n\x0d\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\x0d\n  // node::ParseEncoding() requires lower case.\x0d\n  if (typeof encoding === 'string')\x0d\n    encoding = StringPrototypeToLowerCase(encoding);\x0d\n  if (!Buffer.isEncoding(encoding))\x0d\n    throw new ERR_UNKNOWN_ENCODING(encoding);\x0d\n  this._writableState.defaultEncoding = encoding;\x0d\n  return this;\x0d\n};\x0d\n\x0d\n// If we're already writing something\x2C then just put this\x0d\n// in the queue\x2C and wait our turn.  Otherwise\x2C call _write\x0d\n// If we return false\x2C then we need a drain event\x2C so set that flag.\x0d\nfunction writeOrBuffer(stream\x2C state\x2C chunk\x2C encoding\x2C callback) {\x0d\n  const len = state.objectMode ? 1 : chunk.length;\x0d\n\x0d\n  state.length += len;\x0d\n\x0d\n  // stream._write resets state.length\x0d\n  const ret = state.length < state.highWaterMark;\x0d\n  // We must ensure that previous needDrain will not be reset to false.\x0d\n  if (!ret)\x0d\n    state.needDrain = true;\x0d\n\x0d\n  if (state.writing || state.corked || state.errored || !state.constructed) {\x0d\n    state.buffered.push({ chunk\x2C encoding\x2C callback });\x0d\n    if (state.allBuffers && encoding !== 'buffer') {\x0d\n      state.allBuffers = false;\x0d\n    }\x0d\n    if (state.allNoop && callback !== nop) {\x0d\n      state.allNoop = false;\x0d\n    }\x0d\n  } else {\x0d\n    state.writelen = len;\x0d\n    state.writecb = callback;\x0d\n    state.writing = true;\x0d\n    state.sync = true;\x0d\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\x0d\n    state.sync = false;\x0d\n  }\x0d\n\x0d\n  // Return false if errored or destroyed in order to break\x0d\n  // any synchronous while(stream.write(data)) loops.\x0d\n  return ret && !state.errored && !state.destroyed;\x0d\n}\x0d\n\x0d\nfunction doWrite(stream\x2C state\x2C writev\x2C len\x2C chunk\x2C encoding\x2C cb) {\x0d\n  state.writelen = len;\x0d\n  state.writecb = cb;\x0d\n  state.writing = true;\x0d\n  state.sync = true;\x0d\n  if (state.destroyed)\x0d\n    state.onwrite(new ERR_STREAM_DESTROYED('write'));\x0d\n  else if (writev)\x0d\n    stream._writev(chunk\x2C state.onwrite);\x0d\n  else\x0d\n    stream._write(chunk\x2C encoding\x2C state.onwrite);\x0d\n  state.sync = false;\x0d\n}\x0d\n\x0d\nfunction onwriteError(stream\x2C state\x2C er\x2C cb) {\x0d\n  --state.pendingcb;\x0d\n\x0d\n  cb(er);\x0d\n  // Ensure callbacks are invoked even when autoDestroy is\x0d\n  // not enabled. Passing `er` here doesn't make sense since\x0d\n  // it's related to one specific write\x2C not to the buffered\x0d\n  // writes.\x0d\n  errorBuffer(state);\x0d\n  // This can emit error\x2C but error must always follow cb.\x0d\n  errorOrDestroy(stream\x2C er);\x0d\n}\x0d\n\x0d\nfunction onwrite(stream\x2C er) {\x0d\n  const state = stream._writableState;\x0d\n  const sync = state.sync;\x0d\n  const cb = state.writecb;\x0d\n\x0d\n  if (typeof cb !== 'function') {\x0d\n    errorOrDestroy(stream\x2C new ERR_MULTIPLE_CALLBACK());\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  state.writing = false;\x0d\n  state.writecb = null;\x0d\n  state.length -= state.writelen;\x0d\n  state.writelen = 0;\x0d\n\x0d\n  if (er) {\x0d\n    // Avoid V8 leak\x2C https://github.com/nodejs/node/pull/34103#issuecomment-652002364\x0d\n    er.stack; // eslint-disable-line no-unused-expressions\x0d\n\x0d\n    if (!state.errored) {\x0d\n      state.errored = er;\x0d\n    }\x0d\n\x0d\n    // In case of duplex streams we need to notify the readable side of the\x0d\n    // error.\x0d\n    if (stream._readableState && !stream._readableState.errored) {\x0d\n      stream._readableState.errored = er;\x0d\n    }\x0d\n\x0d\n    if (sync) {\x0d\n      process.nextTick(onwriteError\x2C stream\x2C state\x2C er\x2C cb);\x0d\n    } else {\x0d\n      onwriteError(stream\x2C state\x2C er\x2C cb);\x0d\n    }\x0d\n  } else {\x0d\n    if (state.buffered.length > state.bufferedIndex) {\x0d\n      clearBuffer(stream\x2C state);\x0d\n    }\x0d\n\x0d\n    if (sync) {\x0d\n      // It is a common case that the callback passed to .write() is always\x0d\n      // the same. In that case\x2C we do not schedule a new nextTick()\x2C but\x0d\n      // rather just increase a counter\x2C to improve performance and avoid\x0d\n      // memory allocations.\x0d\n      if (state.afterWriteTickInfo !== null &&\x0d\n          state.afterWriteTickInfo.cb === cb) {\x0d\n        state.afterWriteTickInfo.count++;\x0d\n      } else {\x0d\n        state.afterWriteTickInfo = { count: 1\x2C cb\x2C stream\x2C state };\x0d\n        process.nextTick(afterWriteTick\x2C state.afterWriteTickInfo);\x0d\n      }\x0d\n    } else {\x0d\n      afterWrite(stream\x2C state\x2C 1\x2C cb);\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction afterWriteTick({ stream\x2C state\x2C count\x2C cb }) {\x0d\n  state.afterWriteTickInfo = null;\x0d\n  return afterWrite(stream\x2C state\x2C count\x2C cb);\x0d\n}\x0d\n\x0d\nfunction afterWrite(stream\x2C state\x2C count\x2C cb) {\x0d\n  const needDrain = !state.ending && !stream.destroyed && state.length === 0 &&\x0d\n    state.needDrain;\x0d\n  if (needDrain) {\x0d\n    state.needDrain = false;\x0d\n    stream.emit('drain');\x0d\n  }\x0d\n\x0d\n  while (count-- > 0) {\x0d\n    state.pendingcb--;\x0d\n    cb();\x0d\n  }\x0d\n\x0d\n  if (state.destroyed) {\x0d\n    errorBuffer(state);\x0d\n  }\x0d\n\x0d\n  finishMaybe(stream\x2C state);\x0d\n}\x0d\n\x0d\n// If there's something in the buffer waiting\x2C then invoke callbacks.\x0d\nfunction errorBuffer(state) {\x0d\n  if (state.writing) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  for (let n = state.bufferedIndex; n < state.buffered.length; ++n) {\x0d\n    const { chunk\x2C callback } = state.buffered[n];\x0d\n    const len = state.objectMode ? 1 : chunk.length;\x0d\n    state.length -= len;\x0d\n    callback(state.errored ?? new ERR_STREAM_DESTROYED('write'));\x0d\n  }\x0d\n\x0d\n  const onfinishCallbacks = state[kOnFinished].splice(0);\x0d\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\x0d\n    onfinishCallbacks[i](state.errored ?? new ERR_STREAM_DESTROYED('end'));\x0d\n  }\x0d\n\x0d\n  resetBuffer(state);\x0d\n}\x0d\n\x0d\n// If there's something in the buffer waiting\x2C then process it.\x0d\nfunction clearBuffer(stream\x2C state) {\x0d\n  if (state.corked ||\x0d\n      state.bufferProcessing ||\x0d\n      state.destroyed ||\x0d\n      !state.constructed) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  const { buffered\x2C bufferedIndex\x2C objectMode } = state;\x0d\n  const bufferedLength = buffered.length - bufferedIndex;\x0d\n\x0d\n  if (!bufferedLength) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  let i = bufferedIndex;\x0d\n\x0d\n  state.bufferProcessing = true;\x0d\n  if (bufferedLength > 1 && stream._writev) {\x0d\n    state.pendingcb -= bufferedLength - 1;\x0d\n\x0d\n    const callback = state.allNoop ? nop : (err) => {\x0d\n      for (let n = i; n < buffered.length; ++n) {\x0d\n        buffered[n].callback(err);\x0d\n      }\x0d\n    };\x0d\n    // Make a copy of `buffered` if it's going to be used by `callback` above\x2C\x0d\n    // since `doWrite` will mutate the array.\x0d\n    const chunks = state.allNoop && i === 0 ?\x0d\n      buffered : ArrayPrototypeSlice(buffered\x2C i);\x0d\n    chunks.allBuffers = state.allBuffers;\x0d\n\x0d\n    doWrite(stream\x2C state\x2C true\x2C state.length\x2C chunks\x2C ''\x2C callback);\x0d\n\x0d\n    resetBuffer(state);\x0d\n  } else {\x0d\n    do {\x0d\n      const { chunk\x2C encoding\x2C callback } = buffered[i];\x0d\n      buffered[i++] = null;\x0d\n      const len = objectMode ? 1 : chunk.length;\x0d\n      doWrite(stream\x2C state\x2C false\x2C len\x2C chunk\x2C encoding\x2C callback);\x0d\n    } while (i < buffered.length && !state.writing);\x0d\n\x0d\n    if (i === buffered.length) {\x0d\n      resetBuffer(state);\x0d\n    } else if (i > 256) {\x0d\n      buffered.splice(0\x2C i);\x0d\n      state.bufferedIndex = 0;\x0d\n    } else {\x0d\n      state.bufferedIndex = i;\x0d\n    }\x0d\n  }\x0d\n  state.bufferProcessing = false;\x0d\n}\x0d\n\x0d\nWritable.prototype._write = function(chunk\x2C encoding\x2C cb) {\x0d\n  if (this._writev) {\x0d\n    this._writev([{ chunk\x2C encoding }]\x2C cb);\x0d\n  } else {\x0d\n    throw new ERR_METHOD_NOT_IMPLEMENTED('_write()');\x0d\n  }\x0d\n};\x0d\n\x0d\nWritable.prototype._writev = null;\x0d\n\x0d\nWritable.prototype.end = function(chunk\x2C encoding\x2C cb) {\x0d\n  const state = this._writableState;\x0d\n\x0d\n  if (typeof chunk === 'function') {\x0d\n    cb = chunk;\x0d\n    chunk = null;\x0d\n    encoding = null;\x0d\n  } else if (typeof encoding === 'function') {\x0d\n    cb = encoding;\x0d\n    encoding = null;\x0d\n  }\x0d\n\x0d\n  let err;\x0d\n\x0d\n  if (chunk !== null && chunk !== undefined) {\x0d\n    const ret = _write(this\x2C chunk\x2C encoding);\x0d\n    if (ret instanceof Error) {\x0d\n      err = ret;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // .end() fully uncorks.\x0d\n  if (state.corked) {\x0d\n    state.corked = 1;\x0d\n    this.uncork();\x0d\n  }\x0d\n\x0d\n  if (err) {\x0d\n    // Do nothing...\x0d\n  } else if (!state.errored && !state.ending) {\x0d\n    // This is forgiving in terms of unnecessary calls to end() and can hide\x0d\n    // logic errors. However\x2C usually such errors are harmless and causing a\x0d\n    // hard error can be disproportionately destructive. It is not always\x0d\n    // trivial for the user to determine whether end() needs to be called\x0d\n    // or not.\x0d\n\x0d\n    state.ending = true;\x0d\n    finishMaybe(this\x2C state\x2C true);\x0d\n    state.ended = true;\x0d\n  } else if (state.finished) {\x0d\n    err = new ERR_STREAM_ALREADY_FINISHED('end');\x0d\n  } else if (state.destroyed) {\x0d\n    err = new ERR_STREAM_DESTROYED('end');\x0d\n  }\x0d\n\x0d\n  if (typeof cb === 'function') {\x0d\n    if (err || state.finished) {\x0d\n      process.nextTick(cb\x2C err);\x0d\n    } else {\x0d\n      state[kOnFinished].push(cb);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return this;\x0d\n};\x0d\n\x0d\nfunction needFinish(state) {\x0d\n  return (state.ending &&\x0d\n          state.constructed &&\x0d\n          state.length === 0 &&\x0d\n          !state.errored &&\x0d\n          state.buffered.length === 0 &&\x0d\n          !state.finished &&\x0d\n          !state.writing &&\x0d\n          !state.errorEmitted &&\x0d\n          !state.closeEmitted);\x0d\n}\x0d\n\x0d\nfunction callFinal(stream\x2C state) {\x0d\n  let called = false;\x0d\n\x0d\n  function onFinish(err) {\x0d\n    if (called) {\x0d\n      errorOrDestroy(stream\x2C err ?? ERR_MULTIPLE_CALLBACK());\x0d\n      return;\x0d\n    }\x0d\n    called = true;\x0d\n\x0d\n    state.pendingcb--;\x0d\n    if (err) {\x0d\n      const onfinishCallbacks = state[kOnFinished].splice(0);\x0d\n      for (let i = 0; i < onfinishCallbacks.length; i++) {\x0d\n        onfinishCallbacks[i](err);\x0d\n      }\x0d\n      errorOrDestroy(stream\x2C err\x2C state.sync);\x0d\n    } else if (needFinish(state)) {\x0d\n      state.prefinished = true;\x0d\n      stream.emit('prefinish');\x0d\n      // Backwards compat. Don't check state.sync here.\x0d\n      // Some streams assume 'finish' will be emitted\x0d\n      // asynchronously relative to _final callback.\x0d\n      state.pendingcb++;\x0d\n      process.nextTick(finish\x2C stream\x2C state);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  state.sync = true;\x0d\n  state.pendingcb++;\x0d\n\x0d\n  try {\x0d\n    const result = stream._final(onFinish);\x0d\n    if (result != null) {\x0d\n      const then = result.then;\x0d\n      if (typeof then === 'function') {\x0d\n        then.call(\x0d\n          result\x2C\x0d\n          function() {\x0d\n            if (!called) {\x0d\n              process.nextTick(onFinish\x2C null);\x0d\n            }\x0d\n          }\x2C\x0d\n          function(err) {\x0d\n            if (!called) {\x0d\n              process.nextTick(onFinish\x2C err);\x0d\n            }\x0d\n          });\x0d\n      }\x0d\n    }\x0d\n  } catch (err) {\x0d\n    onFinish(err);\x0d\n  }\x0d\n\x0d\n  state.sync = false;\x0d\n}\x0d\n\x0d\nfunction prefinish(stream\x2C state) {\x0d\n  if (!state.prefinished && !state.finalCalled) {\x0d\n    if (typeof stream._final === 'function' && !state.destroyed) {\x0d\n      state.finalCalled = true;\x0d\n      callFinal(stream\x2C state);\x0d\n    } else {\x0d\n      state.prefinished = true;\x0d\n      stream.emit('prefinish');\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction finishMaybe(stream\x2C state\x2C sync) {\x0d\n  if (needFinish(state)) {\x0d\n    prefinish(stream\x2C state);\x0d\n    if (state.pendingcb === 0 && needFinish(state)) {\x0d\n      state.pendingcb++;\x0d\n      if (sync) {\x0d\n        process.nextTick(finish\x2C stream\x2C state);\x0d\n      } else {\x0d\n        finish(stream\x2C state);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction finish(stream\x2C state) {\x0d\n  state.pendingcb--;\x0d\n  state.finished = true;\x0d\n\x0d\n  const onfinishCallbacks = state[kOnFinished].splice(0);\x0d\n  for (let i = 0; i < onfinishCallbacks.length; i++) {\x0d\n    onfinishCallbacks[i]();\x0d\n  }\x0d\n\x0d\n  stream.emit('finish');\x0d\n\x0d\n  if (state.autoDestroy) {\x0d\n    // In case of duplex streams we need a way to detect\x0d\n    // if the readable side is ready for autoDestroy as well.\x0d\n    const rState = stream._readableState;\x0d\n    const autoDestroy = !rState || (\x0d\n      rState.autoDestroy &&\x0d\n      // We don't expect the readable to ever 'end'\x0d\n      // if readable is explicitly set to false.\x0d\n      (rState.endEmitted || rState.readable === false)\x0d\n    );\x0d\n    if (autoDestroy) {\x0d\n      stream.destroy();\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(Writable.prototype\x2C {\x0d\n\x0d\n  destroyed: {\x0d\n    get() {\x0d\n      return this._writableState ? this._writableState.destroyed : false;\x0d\n    }\x2C\x0d\n    set(value) {\x0d\n      // Backward compatibility\x2C the user is explicitly managing destroyed.\x0d\n      if (this._writableState) {\x0d\n        this._writableState.destroyed = value;\x0d\n      }\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  writable: {\x0d\n    get() {\x0d\n      const w = this._writableState;\x0d\n      // w.writable === false means that this is part of a Duplex stream\x0d\n      // where the writable side was disabled upon construction.\x0d\n      // Compat. The user might manually disable writable side through\x0d\n      // deprecated setter.\x0d\n      return !!w && w.writable !== false && !w.destroyed && !w.errored &&\x0d\n        !w.ending && !w.ended;\x0d\n    }\x2C\x0d\n    set(val) {\x0d\n      // Backwards compatible.\x0d\n      if (this._writableState) {\x0d\n        this._writableState.writable = !!val;\x0d\n      }\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  writableFinished: {\x0d\n    get() {\x0d\n      return this._writableState ? this._writableState.finished : false;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  writableObjectMode: {\x0d\n    get() {\x0d\n      return this._writableState ? this._writableState.objectMode : false;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  writableBuffer: {\x0d\n    get() {\x0d\n      return this._writableState && this._writableState.getBuffer();\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  writableEnded: {\x0d\n    get() {\x0d\n      return this._writableState ? this._writableState.ending : false;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  writableNeedDrain: {\x0d\n    get() {\x0d\n      const wState = this._writableState;\x0d\n      if (!wState) return false;\x0d\n      return !wState.destroyed && !wState.ending && wState.needDrain;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  writableHighWaterMark: {\x0d\n    get() {\x0d\n      return this._writableState && this._writableState.highWaterMark;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  writableCorked: {\x0d\n    get() {\x0d\n      return this._writableState ? this._writableState.corked : 0;\x0d\n    }\x0d\n  }\x2C\x0d\n\x0d\n  writableLength: {\x0d\n    get() {\x0d\n      return this._writableState && this._writableState.length;\x0d\n    }\x0d\n  }\x0d\n});\x0d\n\x0d\nconst destroy = destroyImpl.destroy;\x0d\nWritable.prototype.destroy = function(err\x2C cb) {\x0d\n  const state = this._writableState;\x0d\n\x0d\n  // Invoke pending callbacks.\x0d\n  if (!state.destroyed &&\x0d\n    (state.bufferedIndex < state.buffered.length ||\x0d\n      state[kOnFinished].length)) {\x0d\n    process.nextTick(errorBuffer\x2C state);\x0d\n  }\x0d\n\x0d\n  destroy.call(this\x2C err\x2C cb);\x0d\n  return this;\x0d\n};\x0d\n\x0d\nWritable.prototype._undestroy = destroyImpl.undestroy;\x0d\nWritable.prototype._destroy = function(err\x2C cb) {\x0d\n  cb(err);\x0d\n};\x0d\n\x0d\nWritable.prototype[EE.captureRejectionSymbol] = function(err) {\x0d\n  this.destroy(err);\x0d\n};\x0d\n\x0d\nlet webStreamsAdapters;\x0d\n\x0d\n// Lazy to avoid circular references\x0d\nfunction lazyWebStreams() {\x0d\n  if (webStreamsAdapters === undefined)\x0d\n    webStreamsAdapters = require('internal/webstreams/adapters');\x0d\n  return webStreamsAdapters;\x0d\n}\x0d\n\x0d\nWritable.fromWeb = function(writableStream\x2C options) {\x0d\n  return lazyWebStreams().newStreamWritableFromWritableStream(\x0d\n    writableStream\x2C\x0d\n    options);\x0d\n};\x0d\n\x0d\nWritable.toWeb = function(streamWritable) {\x0d\n  return lazyWebStreams().newWritableStreamFromStreamWritable(streamWritable);\x0d\n};\x0d\n
code-source-info,0x3063249835e,64,7617,9177,C0O7617C9O8202C16O8219C19O8226C23O8208C27O8240C33O8258C44O8258C51O8315C58O8322C63O8344C64O8350C83O8372C88O8370C92O8421C96O8460C104O8489C107O8511C111O8501C115O8544C123O8574C126O8597C130O8587C134O8631C142O8662C145O8686C149O8676C153O8721C161O8750C164O8772C168O8762C172O8805C180O8838C183O8864C187O8854C191O8894C197O8909C204O8932C212O8909C217O8957C224O8964C232O8964C238O8990C245O9002C258O9002C265O9176,,
code-creation,LazyCompile,10,270254,0x3063249a456,341,WritableState node:internal/streams/writable:77:23,0x13c5c2db340,~
code-source-info,0x3063249a456,64,2548,7172,C0O2888C6O2928C8O2957C11O2964C15O2946C20O3076C25O3097C27O3116C33O3092C37O3134C41O3176C52O3200C54O3219C60O3169C64O3433C69O3454C73O3469C88O3469C97O3543C102O3543C106O3452C110O3613C111O3630C115O3668C116O3683C120O3731C121O3743C125O3803C126O3814C130O3858C131O3872C135O3914C136O3929C140O4133C144O4155C150O4169C156O4184C158O4206C159O4203C163O4419C168O4443C170O4462C178O4440C182O4645C183O4657C187O4724C188O4737C192O4817C193O4829C197O5099C198O5109C202O5317C203O5339C207O5408C210O5431C217O5431C223O5421C227O5534C228O5547C232O5622C233O5636C237O5755C238O5779C242O5792C245O5792C249O5923C250O5938C254O6134C255O6151C259O6293C260O6310C264O6400C265O6418C269O6492C271O6510C277O6529C283O6539C287O6507C291O6629C293O6649C299O6668C305O6680C309O6646C313O6908C314O6921C318O6994C319O7006C323O7114C324O7132C328O7146C330O7151C335O7164C340O7171,,
code-creation,LazyCompile,10,270401,0x3063249a866,23,resetBuffer node:internal/streams/writable:202:21,0x13c5c2db390,~
code-source-info,0x3063249a866,64,7196,7313,C0O7209C2O7224C6O7233C7O7253C11O7261C12O7278C16O7289C17O7303C22O7312,,
code-creation,LazyCompile,10,270491,0x3063249a9c6,131,createHandle node:net:137:22,0x1c1d96e8178,~
code-source-info,0x3063249a9c6,131,3733,4109,C0O3754C13O3754C18O3798C23O3798C28O3822C30O3831C35O3850C42O3874C46O3886C49O3900C57O3909C60O3923C67O3857C72O3937C73O3948C75O3957C80O3975C87O3998C91O4010C94O4023C102O4032C105O4045C112O3982C117O4059C118O4070C125O4076C130O4070,,
code-creation,LazyCompile,10,270566,0x3063249ab66,14,set node:net:1703:6,0x1c1d96ea1b8,~
code-source-info,0x3063249ab66,131,47195,47228,C0O47201C2O47213C7O47222C13O47226,,
code-creation,LazyCompile,10,270607,0x3063249ac56,8,get node:net:1702:6,0x1c1d96ea168,~
code-source-info,0x3063249ac56,131,47159,47187,C0O47164C2O47176C4O47175C7O47185,,
code-creation,LazyCompile,10,270699,0x3063249ae06,196,Readable.on node:internal/streams/readable:898:33,0x13c5c2ccda0,~
code-source-info,0x3063249ae06,57,29223,30149,C0O29249C5O29256C10O29266C15O29269C29O29269C35O29311C40O29332C42O29339C47O29524C55O29524C62O29550C65O29517C69O29646C75O29654C80O29677C85O29677C91O29697C93O29704C98O29738C104O29759C110O29787C112O29832C118O29811C122O29847C123O29861C127O29877C128O29899C132O29915C140O29942C145O29956C150O29915C155O29983C161O30002C164O30002C170O30047C176O30067C179O30075C187O30075C193O30135C195O30146,,
code-creation,LazyCompile,10,270805,0x3063249b07e,135,initSocketHandle node:net:254:26,0x1c1d96e8358,~
code-source-info,0x3063249b07e,131,6574,7174,C0O6591C5O6591C9O6608C10O6623C14O6712C20O6733C27O6741C32O6755C36O6773C43O6790C45O6788C49O6809C51O6814C57O6852C62O6833C66O6831C70O6883C72O6888C74O6887C78O6903C80O6940C82O6945C84O6944C88O6965C90O7007C94O7026C99O7031C105O7065C106O7072C107O7082C109O7087C114O7096C118O7128C123O7136C128O7136C134O7173,,
code-creation,LazyCompile,10,270896,0x3063249b2be,160,undestroy node:internal/streams/destroy:167:19,0x394c9e371a8,~
code-source-info,0x3063249b2be,55,3352,4053,C0O3375C5O3409C10O3430C14O3444C15O3458C19O3471C20O3480C24O3494C25O3509C29O3523C30O3535C34O3549C35O3559C39O3572C40O3587C44O3601C45O3611C49O3637C55O3646C58O3633C62O3679C68O3688C71O3675C75O3709C79O3723C80O3737C84O3750C85O3762C89O3776C90O3785C94O3799C95O3814C99O3828C100O3838C104O3851C105O3866C109O3880C110O3894C114O3908C115O3922C119O3948C125O3957C128O3944C132O3986C138O3995C141O3982C145O4026C151O4035C154O4022C159O4052,,
code-creation,LazyCompile,10,271002,0x3063249b576,32,getNewAsyncId node:net:156:23,0x1c1d96e81c8,~
code-source-info,0x3063249b576,131,4137,4256,C0O4151C4O4184C14O4218C17O4218C22O4240C27O4240C31O4253,,
code-creation,LazyCompile,10,271059,0x3063249b676,5,get node:internal/bootstrap/pre_execution:305:8,0x1abee821128,~
code-source-info,0x3063249b676,96,10116,10151,C0O10128C4O10144,,
code-creation,LazyCompile,10,271105,0x3063249b74e,5,get C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\redir-stdout.js:19:10,0x30632487d90,~
code-source-info,0x3063249b74e,141,392,404,C0O398C4O404,,
code-creation,Function,11,271758,0x29be72cb000,72,isUint32 node:internal/validators:40:18,0x147335fcd68,^
code-source-info,0x29be72cb000,15,835,882,,,
code-creation,Function,11,271793,0x29be72cb100,220, node:vm:313:27,0x1c1d96d5110,^
code-source-info,0x29be72cb100,89,10064,10115,,,
code-creation,Function,11,271816,0x29be72cb280,44,noop node:internal/util/debuglog:47:14,0x25ca27217d8,^
code-source-info,0x29be72cb280,22,1465,1473,,,
code-creation,Function,11,271847,0x29be72cb340,1036,debuglog node:internal/util/debuglog:71:18,0x25ca2721878,^
code-source-info,0x29be72cb340,22,2302,3390,,,
code-creation,Function,11,271872,0x29be72cb800,256,canBeRequiredByUsers node:internal/bootstrap/loaders:240:30,0x147335cfc00,^
code-source-info,0x29be72cb800,9,7593,7692,,,
code-creation,Function,11,271895,0x29be72cb980,72,isInt32 node:internal/validators:36:17,0x147335fc858,^
code-source-info,0x29be72cb980,15,769,814,,,
code-creation,Function,11,271928,0x29be72cba80,1200,readPackageScope node:internal/modules/cjs/loader:321:26,0x1abee823fc0,^
code-source-info,0x29be72cba80,103,9239,9772,,,
code-creation,Eval,10,271997,0x3063249beb6,5, C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\soft-exit.js:1:1,0x3063249bd70,~
script-source,147,C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\soft-exit.js,'use strict'\n\nprocess.on('SIGINT'\x2C process.exit)\nprocess.on('SIGTERM'\x2C process.exit)\n
code-source-info,0x3063249beb6,147,0,85,C0O0C4O85,,
code-creation,Function,10,272039,0x3063249bf56,56, C:\\Users\\ojedaweb\\AppData\\Roaming\\npm\\node_modules\\0x\\lib\\preload\\soft-exit.js:1:1,0x3063249be30,~
code-source-info,0x3063249bf56,147,0,85,C0O14C4O22C12O35C16O43C21O22C27O49C31O57C39O71C43O79C48O57C55O84,,
new,MemoryChunk,0x3037540000,262144
code-creation,LazyCompile,10,272197,0x3063249c5b6,50,initializeFrozenIntrinsics node:internal/bootstrap/pre_execution:457:36,0x1abee803858,~
code-source-info,0x3063249c5b6,96,15199,15427,C0O15207C8O15211C14O15257C17O15265C28O15265C34O15379C40O15379C45O15416C49O15426,,
code-creation,LazyCompile,10,272272,0x3063249c6de,80,executeUserEntryPoint node:internal/modules/run_main:70:31,0x109c10f7530,~
code-source-info,0x3063249c6de,125,2231,2545,C7O2247C14O2251C22O2282C25O2282C30O2329C33O2329C38O2366C40O2391C45O2402C50O2391C56O2506C61O2513C73O2513C79O2544,,
code-creation,LazyCompile,10,272333,0x3063249cb0e,68,resolveMainPath node:internal/modules/run_main:15:25,0x109c10f73f0,~
code-source-info,0x3063249cb0e,125,412,839,C0O588C5O595C12O605C15O610C20O610C30O595C36O641C38O661C39O668C40O703C48O703C53O750C55O782C60O793C65O820C67O836,,
code-creation,Function,11,272754,0x29be72cbfc0,8000,realpathSync node:fs:2410:22,0x1d498299340,^
code-source-info,0x29be72cbfc0,81,66533,70573,,,
code-creation,LazyCompile,10,272855,0x3063249d596,109,shouldUseESMLoader node:internal/modules/run_main:30:28,0x109c10f7440,~
code-source-info,0x3063249d596,125,870,1445,C0O905C8O905C13O949C15O970C16O982C17O1027C25O1027C30O1085C32O1117C37O1134C38O1146C39O1196C45O1212C51O1212C58O1260C59O1272C60O1276C66O1293C72O1293C79O1341C80O1354C81O1370C86O1370C91O1401C93O1419C98O1424C105O1429C108O1442,,
code-creation,LazyCompile,10,272955,0x3063249d80e,70,runMainESM node:internal/modules/run_main:47:20,0x109c10f7490,~
code-source-info,0x3063249d80e,125,1468,1817,C0O1468C12O1504C20O1504C25O1492C30O1573C38O1573C43O1555C49O1603C54O1621C59O1621C64O1603C69O1816,,
code-creation,LazyCompile,10,273040,0x3063249da4e,222,loadESM node:internal/process/esm_loader:85:41,0x1abee82a610,~
code-source-info,0x3063249da4e,105,2652,2979,C10O2652C21O2679C24O2685C35O2679C58O2710C60O2725C63O2716C75O2710C113O2761C120O2765C125O2813C130O2821C138O2821C143O2850C154O2857C155O2870C163O2870C168O2895C178O2896C197O2978,,
code-creation,LazyCompile,10,273134,0x3063249e06e,284,initializeLoader node:internal/process/esm_loader:50:32,0x1abee82a4e0,~
code-source-info,0x3063249e06e,105,1490,2608,C10O1490C18O1525C24O1525C29O1506C34O1690C37O1690C42O1755C48O1763C59O1770C60O1812C66O1812C71O1784C76O1841C79O1841C83O1900C88O1919C91O1933C96O1933C103O1939C110O1923C111O1964C114O2229C119O2229C125O2371C132O2404C135O2404C140O2422C147O2434C152O2434C163O2377C176O2347C202O2563C207O2579C212O2579C225O2563C259O2607,,
code-creation,LazyCompile,10,273226,0x3063249e35e,175,handleMainPromise node:internal/modules/run_main:58:33,0x109c10f74e0,~
code-source-info,0x3063249e35e,125,1853,2010,C10O1853C18O1868C21O1876C31O1887C34O1876C43O1921C53O1928C90O1963C93O1971C103O1983C106O1971C150O2009,,
code-creation,LazyCompile,10,273296,0x3063249e51e,77, node:internal/modules/run_main:51:29,0x3063249d748,~
code-source-info,0x3063249e51e,125,1629,1811,C0O1664C7O1669C15O1669C24O1699C30O1699C35O1722C44O1762C55O1786C60O1786C71O1768C76O1806,,
code-creation,LazyCompile,10,273393,0x3063249e79e,283,pathToFileURL node:internal/url:1517:23,0x14121bf9728,~
code-source-info,0x3063249e79e,39,43777,45041,C0O43808C10O43808C16O43831C24O43848C30O43848C37O43963C45O43963C51O44016C58O44023C63O44038C79O44044C84O44038C85O44187C87O44192C91O44215C97O44222C102O44238C118O44244C123O44238C124O44365C127O44383C131O44381C135O44413C140O44455C145O44474C151O44474C160O44455C166O44431C170O44429C176O44544C181O44549C186O44549C192O44664C197O44761C201O44768C205O44664C211O44779C213O44801C215O44797C222O44834C228O44864C230O44860C235O44916C239O44923C242O44906C248O44932C251O44937C255O44928C260O44949C269O44971C272O44989C276O44987C280O45024C282O45038,,
code-creation,LazyCompile,10,273500,0x3063249ea6e,117,URL node:internal/url:634:14,0x14121bf8540,~
code-source-info,0x3063249ea6e,39,18190,18547,C13O18258C17O18287C19O18306C23O18339C30O18354C40O18368C42O18367C46O18390C50O18395C57O18410C60O18406C65O18404C69O18429C85O18482C93O18482C110O18429C116O18546,,
code-creation,LazyCompile,10,273560,0x3063249ec3e,51,URLContext node:internal/url:160:14,0x14121bf7c90,~
code-source-info,0x3063249ec3e,39,3859,4081,C0O3869C1O3880C5O3890C7O3902C11O3914C13O3928C17O3939C19O3953C23O3964C24O3974C28O3987C29O3997C33O4010C35O4020C39O4031C40O4042C44O4055C45O4069C50O4080,,
code-creation,LazyCompile,10,273664,0x3063249ee86,190,onParseComplete node:internal/url:542:25,0x14121bf8220,~
code-source-info,0x3063249ee86,39,15195,15881,C0O15311C2O15316C4O15315C8O15329C10O15339C14O15351C16O15362C20O15377C22O15401C24O15399C29O15425C43O15390C47O15451C49O15475C51O15473C56O15499C70O15464C74O15525C76O15534C80O15545C82O15565C84O15563C89O15585C101O15593C103O15554C107O15607C109O15617C113O15629C115O15642C119O15657C121O15666C125O15677C127O15687C129O15686C134O15741C136O15746C141O15766C144O15762C149O15760C153O15790C155O15795C157O15794C163O15809C168O15818C172O15834C177O15856C179O15855C183O15834C189O15880,,
code-creation,LazyCompile,10,273865,0x3063249f306,934,URLSearchParams node:internal/url:182:14,0x14121bf7d30,~
code-source-info,0x3063249f306,39,4506,7433,C10O4532C16O4582C18O4587C24O4601C30O4619C42O4703C44O4708C46O4707C50O4732C52O4752C54O4751C57O4743C62O4953C64O4958C66O4957C71O4982C73O4987C77O5015C83O5015C87O5001C93O5038C101O5094C107O5141C119O5147C124O5141C125O5346C128O5378C156O5370C187O5370C190O5397C208O5520C210O5519C217O5567C233O5573C238O5567C239O5678C243O5715C271O5704C302O5704C305O5734C313O5768C317O5768C323O5734C331O5693C407O5802C413O5802C418O5359C492O5866C494O5871C500O5885C504O5919C532O5911C563O5911C566O5948C574O5955C579O5977C595O5983C600O5977C601O6066C609O6090C611O6089C617O6109C624O6118C629O6066C634O5900C707O6283C709O6296C711O6301C717O6315C721O6343C727O6343C732O6387C734O6399C738O6392C743O6437C745O6441C749O6470C755O6470C761O6525C763O6556C769O6600C775O6600C780O6650C788O6666C793O6650C798O6822C800O6833C805O6876C807O6881C809O6880C816O6902C823O6914C829O6965C831O6985C837O7009C839O7008C850O6985C855O7154C858O6983C862O6408C867O6374C872O7248C878O7255C883O7281C884O7289C891O7293C896O7314C906O7314C912O7331C916O7331C921O7407C923O7412C928O7421C933O7432,,
code-creation,LazyCompile,10,274021,0x3063249f92e,35,initSearchParams node:internal/url:1078:26,0x14121bf9288,~
code-source-info,0x3063249f92e,39,30302,30423,C0O30319C4O30337C6O30341C11O30355C15O30366C16O30373C17O30382C19O30386C25O30402C29O30400C34O30422,,
code-creation,LazyCompile,10,274108,0x3063249fade,199,encodePathChars node:internal/url:1502:25,0x14121bf96d8,~
code-source-info,0x3063249fade,39,43046,43751,C0O43062C8O43066C15O43111C22O43155C31O43122C38O43237C46O43255C52O43255C59O43301C66O43345C75O43312C82O43372C90O43376C97O43422C104O43466C113O43433C120O43491C128O43495C135O43541C142O43585C151O43552C158O43617C166O43621C173O43667C180O43711C189O43678C196O43732C198O43748,,
code-creation,LazyCompile,10,274193,0x3063249fd1e,99,set pathname node:internal/url:932:15,0x14121bf8e78,~
code-source-info,0x3063249fd1e,39,26263,26541,C0O26277C5O26282C11O26306C23O26312C28O26306C29O26381C34O26404C38O26413C40O26412C45O26435C46O26442C47O26448C58O26460C67O26483C69O26482C78O26524C83O26524C92O26448C98O26540,,
code-creation,LazyCompile,10,274249,0x3063249fe86,22,isURLThis node:internal/url:629:19,0x14121bf84f0,~
code-source-info,0x3063249fe86,39,18069,18160,C0O18081C3O18094C9O18116C14O18133C16O18132C20O18142C21O18157,,
code-creation,LazyCompile,10,274293,0x3063249ff96,31, node:internal/url:650:21,0x14121bf8618,~
code-source-info,0x3063249ff96,39,18660,18737,C0O18670C4O18683C6O18682C10O18692C19O18700C21O18698C26O18726C30O18732,,
code-creation,LazyCompile,10,274368,0x306324a00c6,108,onParsePathComplete node:internal/url:601:29,0x14121bf8400,~
code-source-info,0x306324a00c6,39,17213,17695,C0O17333C2O17338C4O17337C8O17351C10O17364C12O17362C17O17384C22O17398C24O17407C28O17420C35O17433C40O17430C46O17470C48O17479C52O17490C59O17504C61O17503C66O17500C70O17586C72O17599C74O17597C79O17619C84O17633C86O17642C90O17655C97O17668C102O17665C107O17694,,
code-creation,LazyCompile,10,274436,0x306324a0276,47,get href node:internal/url:750:11,0x14121bf87a8,~
code-source-info,0x306324a0276,39,21492,21601,C0O21502C5O21507C11O21531C23O21537C28O21531C29O21571C33O21583C35O21582C41O21591C46O21596,,
code-creation,LazyCompile,10,274542,0x306324a055e,393, node:internal/url:696:12,0x14121bf8708,~
code-source-info,0x306324a055e,39,20006,21301,C0O20023C4O20043C14O20043C19O20086C30O20194C37O20227C41O20232C43O20231C47O20314C52O20335C58O20359C67O20404C74O20413C79O20453C86O20462C91O20489C99O20498C103O20514C105O20540C109O20580C120O20599C124O20628C127O20643C142O20664C151O20707C165O20746C170O20726C176O20758C184O20779C190O20803C193O20818C208O20838C212O20847C214O20846C219O20882C225O20886C237O20920C243O20941C248O20946C255O20953C260O20964C266O20968C272O20972C277O20991C286O21028C291O21033C297O21052C304O21065C307O21088C315O21065C320O21063C330O21133C336O21147C342O21170C345O21185C360O21211C366O21227C372O21253C375O21268C390O21285C392O21296,,
code-creation,LazyCompile,10,274652,0x306324a08f6,99, node:internal/validators:154:3,0x147335fd0c8,~
code-source-info,0x306324a08f6,15,4537,5108,C0O4596C4O4637C9O4673C14O4712C21O4748C26O4785C33O4821C38O4836C46O4884C50O4898C53O4898C67O4975C75O5042C91O5048C96O5042C98O5107,,
code-creation,LazyCompile,10,274765,0x306324a0d1e,308,import node:internal/modules/esm/loader:324:15,0x1abee82bc00,~
code-source-info,0x306324a0d1e,106,9901,10471,C10O9901C18O9965C25O9965C30O9996C32O10009C41O10023C50O10068C55O10094C64O10094C70O10132C81O10327C90O10147C98O10137C100O10137C116O10175C123O10198C137O10175C143O10241C154O10242C160O10276C170O10277C175O10168C186O10119C201O10355C212O10376C217O10372C223O10361C235O10355C261O10409C270O10462C283O10466,,
code-creation,LazyCompile,10,274873,0x306324a1086,251,getModuleJob node:internal/modules/esm/loader:242:21,0x1abee82bbb0,~
code-source-info,0x306324a1086,106,6920,7769,C10O6920C18O6972C20O7005C22O7014C26O7023C33O7030C38O7197C49O7248C54O7248C59O7235C65O7341C82O7341C95O7330C118O7307C123O7315C128O7422C133O7432C138O7458C143O7432C150O7533C154O7578C159O7588C166O7614C176O7588C181O7636C185O7668C187O7679C208O7695C214O7753C226O7764,,
code-creation,LazyCompile,10,274999,0x306324a14d6,411,resolve node:internal/modules/esm/loader:509:16,0x1abee82bd40,~
code-source-info,0x306324a14d6,106,15399,16818,C10O15399C32O15466C37O15466C75O15508C79O15540C91O15611C94O15611C100O15643C120O15649C125O15643C126O15773C133O15824C135O15829C140O15839C144O15868C146O15873C150O15884C157O15891C168O15936C174O15946C178O15998C185O16035C191O16056C197O16083C207O15981C220O15975C246O16143C252O16188C270O16194C275O16188C276O16323C281O16331C286O16358C297O16438C318O16444C323O16438C324O16587C330O16625C351O16631C356O16625C357O16770C364O16786C370O16801C386O16813,,
code-creation,LazyCompile,10,275244,0x306324a19e6,577,defaultResolve node:internal/modules/esm/resolve:1000:24,0x1abee833c08,~
code-source-info,0x306324a19e6,110,33576,36108,C7O33576C16O33635C21O33646C26O33673C32O33690C38O33696C47O33733C53O33740C59O33749C65O33749C71O33786C73O33818C78O33827C83O33878C85O33901C91O33897C98O33878C104O33944C106O33957C107O33973C112O33994C116O34025C120O34078C125O34093C133O34107C139O34114C140O34131C144O34155C146O34168C152O34256C158O34279C165O34256C180O34164C187O34155C191O34352C195O34380C197O34399C207O34436C213O34436C227O34411C233O34445C238O34865C244O34886C250O34892C255O34886C256O34936C260O34949C265O34986C270O35005C285O35088C289O35097C295O35120C299O35011C309O35009C320O35268C324O35278C332O35283C341O35328C349O35333C354O35376C366O35380C373O35440C381O35452C386O35508C392O35508C398O35556C400O35660C412O35687C422O35660C428O35723C434O35749C446O35768C454O35793C458O35793C466O35820C473O35827C480O35845C489O35865C497O35865C502O35852C505O35780C509O35907C525O35929C532O35921C536O35958C538O35958C539O35981C543O35981C547O36022C555O36044C562O36064C566O36064C576O36105,,
code-creation,LazyCompile,10,275424,0x306324a409e,64,getConditionsSet node:internal/modules/esm/resolve:141:26,0x1abee8332f8,~
code-source-info,0x306324a409e,110,4467,4803,C0O4485C6O4532C8O4528C13O4559C18O4564C24O4599C40O4605C45O4599C46O4730C53O4737C58O4761C59O4770C63O4800,,
code-creation,LazyCompile,10,275498,0x306324a4206,135,moduleResolve node:internal/modules/esm/resolve:926:23,0x1abee833b18,~
code-source-info,0x306324a4206,110,31031,31693,C0O31190C2O31203C5O31207C11O31266C24O31277C32O31313C33O31326C39O31330C44O31346C56O31357C67O31439C74O31450C83O31448C84O31492C96O31503C102O31576C109O31585C114O31605C116O31621C117O31630C129O31637C134O31690,,
code-creation,LazyCompile,10,275557,0x306324a439e,31,shouldBeTreatedAsRelativeOrAbsolutePath node:internal/modules/esm/resolve:913:49,0x1abee833ac8,~
code-source-info,0x306324a439e,110,30668,30807,C0O30685C2O30699C7O30707C8O30720C9O30724C10O30737C16O30741C21O30750C22O30762C23O30766C26O30773C30O30804,,
code-creation,LazyCompile,10,275611,0x306324a44b6,81,isRelativeSpecifier node:internal/modules/esm/resolve:903:29,0x1abee833a78,~
code-source-info,0x306324a44b6,110,30365,30616,C0O30382C1O30395C7O30399C12O30429C19O30436C26O30454C32O30458C37O30467C38O30479C39O30485C41O30498C47O30502C52O30534C59O30541C66O30559C72O30563C77O30572C78O30584C79O30600C80O30613,,
code-creation,LazyCompile,10,275681,0x306324a4646,44,get protocol node:internal/url:791:15,0x14121bf88e8,~
code-source-info,0x306324a4646,39,22572,22684,C0O22582C5O22587C11O22611C23O22617C28O22611C29O22651C33O22663C35O22662C39O22672C43O22679,,
code-creation,LazyCompile,10,275796,0x306324a488e,444,finalizeResolution node:internal/modules/esm/resolve:367:28,0x1abee833578,~
code-source-info,0x306324a488e,110,11690,13267,C0O11730C7O11754C10O11780C15O11734C22O11796C27O11852C37O11920C40O11920C47O11802C52O11796C53O11960C58O11960C63O11988C71O11992C78O12046C83O12076C86O12076C91O12126C93O12150C95O12162C96O12168C104O12173C111O12218C116O12251C121O12258C131O12247C137O12225C142O12280C144O12304C146O12316C149O12338C152O12345C160O12389C161O12402C166O12450C173O12460C176O12460C186O12408C191O12402C192O12516C199O12528C205O12528C214O12570C220O12570C230O12516C235O12623C240O12623C246O12657C253O12694C256O12694C266O12657C272O12721C274O12731C277O12731C281O12729C285O12754C287O12754C288O12786C293O12786C299O12803C306O12842C308O12859C315O12869C319O12877C322O12877C332O12809C337O12803C338O12919C342O12962C347O12975C354O12991C357O13002C365O13021C372O12962C378O13057C383O13065C388O13089C395O13131C400O13161C403O13131C419O13128C423O13109C429O13185C431O13201C435O13216C437O13230C441O13248C443O13264,,
code-creation,LazyCompile,10,275929,0x306324a4c86,107,get pathname node:internal/url:921:15,0x14121bf8e08,~
code-source-info,0x306324a4c86,39,25976,26245,C0O25986C5O25991C11O26015C23O26021C28O26015C29O26067C33O26072C35O26071C39O26087C43O26096C45O26095C50O26129C56O26133C59O26137C60O26151C65O26156C71O26163C76O26177C78O26187C79O26193C86O26204C89O26227C97O26204C106O26240,,
code-creation,LazyCompile,10,276049,0x306324a4f06,106,fileURLToPath node:internal/url:1475:23,0x14121bf9688,~
code-source-info,0x306324a4f06,39,41910,42243,C0O41922C6O41957C13O41964C22O41987C25O41992C31O42018C49O42024C54O42018C55O42095C62O42104C67O42122C77O42128C82O42122C83O42167C92O42186C101O42214C105O42240,,
code-creation,LazyCompile,10,276138,0x306324a5146,179,get origin node:internal/url:766:13,0x14121bf8878,~
code-source-info,0x306324a5146,39,21905,22554,C0O21915C5O21920C11O21944C23O21950C28O21944C29O22058C33O22063C35O22062C39O22090C88O22138C93O22143C99O22150C107O22187C112O22207C118O22211C124O22195C130O22217C134O22224C139O22322C145O22343C146O22455C151O22487C156O22499C161O22509C166O22462C171O22515C172O22528C178O22549,,
code-creation,LazyCompile,10,276250,0x306324a5486,261,getPathFromURLWin32 node:internal/url:1422:29,0x14121bf95e8,~
code-source-info,0x306324a5486,39,39962,41360,C0O39994C5O40026C10O40052C12O40068C16O40057C21O40088C23O40100C29O40104C34O40145C41O40159C45O40145C50O40164C54O40179C56O40195C59O40192C65O40200C72O40217C79O40263C82O40260C88O40268C95O40285C100O40317C110O40323C115O40317C116O40077C121O40039C124O40467C131O40475C137O40467C144O40504C149O40515C154O40548C156O40561C161O40957C167O40971C178O40999C182O41010C183O41107C191O41107C196O41122C200O41145C202O41153C206O41161C208O41174C210O41172C217O41203C219O41201C226O41250C231O41267C241O41273C246O41267C247O41348C255O41348C260O41357,,
code-creation,LazyCompile,10,276340,0x306324a573e,48,get hostname node:internal/url:879:15,0x14121bf8c58,~
code-source-info,0x306324a573e,39,24876,24992,C0O24886C5O24891C11O24915C23O24921C28O24915C29O24955C33O24967C35O24966C39O24976C47O24987,,
code-creation,LazyCompile,10,276427,0x306324a5ade,30,tryStatSync node:internal/modules/esm/resolve:160:3,0x1abee833c58,~
code-source-info,0x306324a5ade,110,5017,5083,C0O5072C5O5036C10O5027C21O5076C24O5072C29O5083,,
code-creation,LazyCompile,10,276498,0x306324a5e26,123,statSync node:fs:1530:18,0x1d498298438,~
code-source-info,0x306324a5e26,81,40498,40912,C7O40498C16O40561C21O40568C26O40607C33O40609C40O40634C45O40642C52O40647C55O40658C60O40658C66O40720C76O40642C82O40760C88O40775C96O40788C102O40817C103O40834C104O40843C109O40843C113O40875C118O40882C122O40909,,
code-creation,LazyCompile,10,276643,0x306324a6036,64,hasNoEntryError node:fs:1467:25,0x1d498298308,~
code-source-info,0x306324a6036,81,38872,39074,C0O38891C6O38919C11O38935C16O38919C21O38948C27O38962C36O38966C39O38979C40O38998C46O39023C51O39029C58O39034C61O39047C62O39058C63O39071,,
code-creation,LazyCompile,10,276737,0x306324a616e,576,getStatsFromBinding node:internal/fs/utils:530:29,0x1d4982a22f0,~
code-source-info,0x306324a616e,82,14524,15597,C13O14549C18O14553C24O14585C31O14624C34O14621C43O14643C46O14640C55O14662C58O14659C67O14688C70O14685C79O14707C82O14704C91O14726C94O14723C103O14752C106O14749C115O14771C118O14768C127O14790C130O14787C139O14816C142O14813C154O14864C157O14860C167O14884C170O14880C174O14834C189O14933C192O14929C202O14953C205O14949C210O14903C225O15002C228O14998C239O15022C242O15018C247O14972C263O15071C266O15067C277O15091C280O15087C285O15041C294O14592C299O15109C300O15118C307O15149C310O15146C319O15168C322O15165C331O15187C334O15184C343O15211C346O15208C355O15230C358O15227C367O15249C370O15246C379O15273C382O15270C391O15292C394O15289C403O15311C406O15308C415O15335C418O15332C430O15375C433O15371C443O15395C446O15391C450O15351C465O15436C468O15432C478O15456C481O15452C486O15412C501O15497C504O15493C515O15517C518O15513C523O15473C539O15558C542O15554C553O15578C556O15574C561O15534C570O15125C575O15594,,
code-creation,LazyCompile,10,276854,0x306324a659e,16,isBigUint64Array node:internal/util/types:53:26,0x25ca2707398,~
code-source-info,0x306324a659e,17,1423,1514,C0O1436C5O1443C12O1490C15O1511,,
code-creation,LazyCompile,10,276899,0x306324a66be,19,msFromTimeSpec node:internal/fs/utils:446:24,0x1d4982a2018,~
code-source-info,0x306324a66be,82,11451,11512,C0O11468C2O11481C4O11479C10O11500C12O11498C15O11491C18O11509,,
code-creation,LazyCompile,10,276960,0x306324a68fe,116,Stats node:internal/fs/utils:495:15,0x1d4982a2210,~
code-source-info,0x306324a68fe,82,13243,13784,C0O13383C41O13383C46O13513C48O13526C52O13540C54O13553C58O13567C60O13580C64O13594C66O13611C70O13629C73O13642C77O13640C81O13666C84O13679C88O13677C92O13703C95O13716C99O13714C103O13740C106O13757C110O13755C115O13783,,
code-creation,LazyCompile,10,277022,0x306324a6ad6,62,StatsBase node:internal/fs/utils:400:19,0x1d4982a1be8,~
code-source-info,0x306324a6ad6,82,10312,10613,C0O10400C2O10409C6O10419C8O10429C12O10440C14O10451C18O10463C20O10472C24O10482C26O10491C30O10501C32O10511C36O10522C38O10535C42O10549C44O10558C48O10568C50O10578C54O10589C56O10601C61O10612,,
code-creation,LazyCompile,10,277098,0x306324a6cce,29,dateFromMs node:internal/fs/utils:460:20,0x1d4982a20b8,~
code-source-info,0x306324a6cce,82,11977,12024,C0O11987C7O12003C10O12003C17O12014C23O11994C28O12021,,
code-creation,LazyCompile,10,277150,0x306324a6dd6,16,StatsBase.isDirectory node:internal/fs/utils:414:43,0x1d4982a1c38,~
code-source-info,0x306324a6dd6,82,10659,10710,C0O10679C7O10698C10O10679C15O10707,,
code-creation,LazyCompile,10,277198,0x306324a6eee,54,Stats._checkModeProperty node:internal/fs/utils:517:46,0x1d4982a2260,~
code-source-info,0x306324a6eee,82,14142,14370,C0O14158C8O14189C10O14185C17O14213C19O14209C26O14242C28O14238C33O14260C34O14273C35O14339C42O14346C44O14344C50O14354C53O14367,,
code-creation,LazyCompile,10,277247,0x306324a7026,16,StatsBase.isFile node:internal/fs/utils:418:38,0x1d4982a1cc8,~
code-source-info,0x306324a7026,82,10752,10803,C0O10772C7O10791C10O10772C15O10800,,
code-creation,LazyCompile,10,277523,0x306324a7286,66,get search node:internal/url:943:13,0x14121bf8ee8,~
code-source-info,0x306324a7286,39,26557,26757,C0O26567C5O26572C11O26596C23O26602C28O26596C29O26654C33O26659C35O26658C39O26644C44O26674C48O26702C53O26717C55O26727C56O26733C61O26744C65O26752,,
code-creation,LazyCompile,10,277587,0x306324a73fe,66,get hash node:internal/url:979:11,0x14121bf9038,~
code-source-info,0x306324a73fe,39,27526,27738,C0O27536C5O27541C11O27565C23O27571C28O27565C29O27626C33O27631C35O27630C39O27613C44O27646C48O27680C53O27695C55O27705C56O27711C61O27722C65O27733,,
code-creation,LazyCompile,10,277701,0x306324a75be,210,set search node:internal/url:952:13,0x14121bf8f58,~
code-source-info,0x306324a75be,39,26773,27365,C0O26789C5O26794C11O26818C23O26824C28O26818C29O26870C33O26875C35O26874C39O26890C46O26899C52O26925C54O26936C59O26953C60O26963C64O26978C73O26992C75O26991C80O26988C86O27034C87O27044C93O27048C98O27057C108O27066C115O27106C117O27116C121O27129C130O27142C135O27139C139O27170C143O27193C154O27207C163O27241C171O27241C183O27193C188O27315C197O27337C199O27336C203O27315C209O27364,,
code-creation,LazyCompile,10,277783,0x306324a77de,41,toUSVString node:internal/util:59:21,0x25ca2704d20,~
code-source-info,0x306324a77de,16,1409,1709,C0O1432C4O1586C11O1606C14O1586C20O1636C22O1653C24O1664C25O1668C30O1699C35O1675C40O1706,,
code-creation,LazyCompile,10,277874,0x306324a7966,173,set hash node:internal/url:988:11,0x14121bf90a0,~
code-source-info,0x306324a7966,39,27752,28268,C0O27766C5O27771C11O27795C23O27801C28O27795C29O27847C33O27852C35O27851C39O27902C44O27925C46O27945C47O27958C51O27973C60O27987C62O27986C67O27983C71O28018C72O28025C73O28038C74O28046C80O28050C85O28059C95O28066C102O28102C104O28115C108O28126C117O28139C122O28136C126O28168C137O28180C146O28213C154O28213C166O28168C172O28267,,
code-creation,LazyCompile,10,277952,0x306324a7b5e,51,throwIfUnsupportedURLProtocol node:internal/modules/esm/resolve:993:39,0x1abee833bb8,~
code-source-info,0x306324a7b5e,110,33384,33549,C0O33403C7O33412C12O33431C19O33440C24O33466C31O33475C36O33495C43O33501C48O33495C50O33548,,
code-creation,LazyCompile,10,278016,0x306324a7f96,47,toString node:internal/url:744:11,0x14121bf8758,~
code-source-info,0x306324a7f96,39,21369,21478,C0O21379C5O21384C11O21408C23O21414C28O21408C29O21448C33O21460C35O21459C41O21468C46O21473,,
code-creation,LazyCompile,10,278088,0x306324a8126,59,defaultGetFormatWithoutErrors node:internal/modules/esm/get_format:92:39,0x1abee8375a0,~
code-source-info,0x306324a8126,111,2872,3074,C0O2907C7O2907C13O2924C20O2959C23O2984C28O2929C35O3000C36O3012C37O3016C42O3047C46O3039C52O3056C58O3071,,
code-creation,LazyCompile,10,278180,0x306324a8636,119,getFileProtocolModuleFormat node:internal/modules/esm/get_format:75:37,0x1abee837550,~
code-source-info,0x306324a8636,111,2291,2830,C0O2328C5O2340C10O2328C15O2354C17O2362C22O2380C27O2387C34O2407C45O2444C46O2470C53O2488C57O2498C59O2510C61O2524C62O2528C69O2564C74O2663C78O2688C79O2705C80O2711C87O2753C90O2753C100O2717C105O2711C106O2782C109O2789C118O2827,,
code-creation,LazyCompile,10,278295,0x306324a8856,275,extname node:path:836:10,0x394c9e0d838,~
code-source-info,0x306324a8856,41,26915,29043,C0O26929C8O26929C13O26976C15O26999C18O27024C20O27042C23O27070C25O27219C27O27415C34O27422C41O27439C47O27439C55O27478C57O27474C67O27521C72O27521C78O27501C84O27567C88O27622C92O27629C96O27636C98O27636C103O27673C108O27673C114O27716C117O27720C123O27890C127O27922C129O27936C133O27952C135O27979C137O28005C139O28013C144O28131C146O28162C148O28170C152O28191C154O28204C156O28200C161O28301C163O28314C168O28333C175O28361C177O28377C182O28395C187O28426C189O28439C194O28602C197O27648C202O27604C205O28643C207O28656C214O28679C220O28776C227O28875C234O28911C237O28903C244O28951C247O28937C252O28966C254O28976C255O28989C269O28996C274O29038,,
code-creation,LazyCompile,10,278397,0x306324a8ae6,13,getPackageType node:internal/modules/esm/resolve:789:24,0x1abee833938,~
code-source-info,0x306324a8ae6,110,26561,26654,C0O26594C3O26594C8O26646C12O26651,,
code-creation,LazyCompile,10,278469,0x306324a8d3e,173,getPackageScopeConfig node:internal/modules/esm/resolve:224:31,0x1abee833398,~
code-source-info,0x306324a8d3e,110,6721,7820,C0O6758C13O6758C19O6857C24O6872C32O6876C39O6954C41O6988C46O7005C49O7005C54O6988C60O7114C66O7122C68O7143C69O7178C72O7199C85O7216C91O7425C96O7457C100O7434C105O7467C107O6798C110O7506C115O7506C120O7562C127O7580C132O7628C137O7650C142O7694C147O7719C154O7739C159O7756C164O7756C170O7796C172O7817,,
code-creation,LazyCompile,10,278647,0x306324a91de,331,getPackageConfig node:internal/modules/esm/resolve:168:26,0x1abee833348,~
code-source-info,0x306324a91de,110,5250,6613,C0O5296C5O5313C10O5313C16O5327C18O5362C20O5378C21O5402C26O5420C31O5420C37O5430C42O5442C44O5497C51O5517C56O5558C61O5582C66O5630C71O5657C78O5681C83O5698C88O5698C94O5729C96O5750C97O5765C102O5792C107O5806C115O5804C125O5851C137O5910C144O5921C163O5948C168O5962C174O5948C178O5946C185O5995C192O5857C197O5851C198O6027C203O6036C208O6042C213O6048C218O6081C223O6109C233O6162C235O6186C241O6216C243O6237C249O6267C251O6342C253O6351C260O6372C265O6388C268O6430C275O6448C281O6478C287O6489C293O6500C299O6511C305O6525C312O6543C317O6560C322O6560C328O6589C330O6610,,
code-creation,LazyCompile,10,278796,0x306324a94d6,78,get node:internal/modules/esm/module_map:18:6,0x1abee82df78,~
code-source-info,0x306324a94d6,107,604,748,C11O617C18O645C28O645C33O678C43O678C48O713C50O726C61O726C71O736C77O743,,
code-creation,LazyCompile,10,278877,0x306324a96ce,111,#createModuleJob node:internal/modules/esm/loader:278:19,0x1abee82ba20,~
code-source-info,0x306324a96ce,106,8436,9240,C0O8436C17O8509C22O8909C31O8952C37O8952C42O9011C70O9011C76O9164C79O9169C84O9179C92O9205C103O9179C108O9224C110O9235,,
code-creation,LazyCompile,10,278990,0x306324a99f6,196,ModuleJob node:internal/modules/esm/module_job:56:14,0x1abee82eec0,~
code-source-info,0x306324a99f6,108,1367,3214,C0O1367C27O1400C32O1400C50O1478C55O1490C59O1505C64O1527C68O1552C73O1564C77O1579C82O1595C86O1616C90O1628C94O1766C101O1787C104O1816C113O1825C122O1830C135O1787C140O1785C144O1937C149O2890C152O2904C155O2902C159O3014C169O3041C178O3049C181O3014C186O3179C190O3197C195O3213,,
code-creation,LazyCompile,10,279096,0x306324aa456,187,moduleProvider node:internal/modules/esm/loader:279:28,0x306324a95f8,~
code-source-info,0x306324aa456,106,8509,8881,C10O8509C18O8581C21O8592C26O8607C33O8614C39O8622C43O8592C57O8581C80O8557C85O8570C90O8671C97O8683C102O8683C108O8710C110O8738C119O8744C124O8738C125O8806C147O8813C162O8874,,
code-creation,LazyCompile,10,279219,0x306324aa866,410,load node:internal/modules/esm/loader:353:13,0x1abee82bc50,~
code-source-info,0x306324aa866,106,10849,12157,C10O10849C60O10898C62O10903C67O10911C71O10938C73O10943C77O10952C84O10959C95O11002C101O11010C105O11035C114O11041C127O11035C153O11085C159O11126C177O11132C182O11126C183O11261C188O11276C193O11308C198O11353C210O11353C216O11462C228O11525C235O11575C255O11468C260O11462C261O11611C267O11652C288O11658C293O11652C294O11803C309O11878C312O11878C322O11914C325O11914C331O11947C350O11953C355O11947C356O12106C363O12122C369O12137C385O12152,,
code-creation,LazyCompile,10,279329,0x306324aac5e,201,defaultLoad node:internal/modules/esm/load:13:27,0x1abee838e68,~
code-source-info,0x306324aac5e,113,380,847,C10O380C18O411C23O424C28O459C33O494C38O521C43O530C48O563C62O563C67O619C69O636C76O665C81O692C85O717C90O744C95O776C102O783C106O759C119O753C147O804C154O818C160O831C176O844,,
code-creation,LazyCompile,10,279412,0x306324aafc6,150,validateAssertions node:internal/modules/esm/assert:55:28,0x1abee830fa8,~
code-source-info,0x306324aafc6,109,1835,2993,C12O1897C17O1897C26O1940C33O1953C37O1968C38O1999C48O2155C55O2505C66O2130C67O2142C68O2320C76O2325C83O2393C84O2405C85O2422C88O2469C93O2429C98O2475C99O2581C100O2593C101O2745C109O2750C116O2862C129O2868C134O2862C135O2939C138O2979C143O2939C149O2992,,
code-creation,LazyCompile,10,279531,0x306324ab306,338,defaultGetSource node:internal/modules/esm/get_source:25:32,0x1abee839570,~
code-source-info,0x306324ab306,114,686,1346,C10O686C31O694C70O747C77O747C83O768C85O790C92O799C97O819C102O834C114O828C144O878C151O887C156O921C163O941C166O966C171O921C177O982C179O1003C186O1009C191O1003C192O1058C199O1069C206O1090C211O1106C218O1111C221O1111C228O1137C237O1106C246O1183C258O1189C263O1183C264O1243C271O1253C280O1272C285O1279C290O1288C295O1288C301O1329C313O1343,,
code-creation,LazyCompile,10,279689,0x306324ab7ce,194,readFile node:internal/fs/promises:838:24,0x1abee83bab8,~
code-source-info,0x306324ab7ce,115,24307,24639,C10O24307C18O24328C23O24349C28O24338C35O24398C44O24416C46O24436C48O24425C53O24453C56O24460C71O24490C72O24496C75O24517C80O24496C84O24542C98O24548C111O24542C137O24576C143O24597C149O24629C154O24583C169O24636,,
code-creation,LazyCompile,10,279756,0x306324ad5ae,56,checkAborted node:internal/fs/promises:371:22,0x1abee83ade8,~
code-source-info,0x306324ad5ae,115,8868,8970,C0O8882C7O8892C16O8908C23O8929C35O8955C48O8914C53O8908C55O8969,,
code-creation,LazyCompile,10,279818,0x306324ad776,182,open node:internal/fs/promises:501:20,0x1abee83afc8,~
code-source-info,0x306324ad776,115,13187,13500,C10O13187C18O13212C23O13219C29O13266C34O13266C39O13291C55O13298C62O13337C69O13371C72O13379C79O13394C82O13405C87O13405C95O13482C104O13379C117O13365C142O13344C157O13497,,
code-creation,LazyCompile,10,280549,0x306324adafe,263,link node:internal/modules/esm/module_job:69:18,0x306324a9878,~
code-source-info,0x306324adafe,108,1937,2831,C4O1937C26O1958C36O1983C48O1972C73O1970C77O2005C89O2017C98O2035C100O2024C104O2005C108O2357C110O2357C112O2385C117O2390C122O2397C132O2397C138O2670C140O2707C151O2728C156O2724C162O2713C174O2707C199O2767C210O2789C218O2785C224O2774C238O2824,,
code-creation,LazyCompile,10,280632,0x306324add86,19,primordials.PromisePrototypeCatch node:internal/per_context/primordials:397:37,0x147335ca4d0,~
code-source-info,0x306324add86,6,11842,11930,C0O11874C13O11874C18O11930,,
code-creation,LazyCompile,10,280714,0x306324adf5e,216,set node:internal/modules/esm/module_map:23:6,0x1abee82dfc8,~
code-source-info,0x306324adf5e,107,755,1288,C11O768C21O801C31O801C36O834C46O834C51O869C55O888C57O877C62O898C73O955C91O961C96O955C97O1024C109O1041C124O1066C126O1062C137O1106C148O1024C152O1165C154O1171C165O1171C178O1183C183O1183C188O1208C190O1231C194O1243C196O1256C210O1256C215O1283,,
code-creation,LazyCompile,10,280789,0x306324ae166,10, node:internal/modules/esm/module_map:9:63,0x1abee82ded8,~
code-source-info,0x306324ae166,107,271,298,C0O284C2O290C9O297,,
code-creation,LazyCompile,10,280830,0x306324ae22e,10, node:internal/modules/esm/loader:333:15,0x306324a0b88,~
code-source-info,0x306324ae22e,106,10247,10265,C0O10260C5O10260C9O10265,,
code-creation,LazyCompile,10,280925,0x306324ae65e,433,run node:internal/modules/esm/module_job:190:12,0x1abee82efb0,~
code-source-info,0x306324ae65e,108,7065,8269,C10O7065C18O7086C23O7086C35O7075C58O7122C61O7153C66O7189C71O7196C76O7196C90O7178C128O7256C133O7261C143O7268C152O7303C158O7341C163O7303C169O7362C182O7372C186O7409C196O7441C204O7413C211O7476C224O7486C228O7576C235O7607C240O7614C248O7576C259O7646C267O7696C272O7703C277O7646C292O7724C297O7779C302O7807C307O7814C312O7780C318O7847C325O7852C330O7879C344O8028C358O7970C364O8051C370O8131C376O7889C380O8212C382O8212C383O8233C388O8255C408O8264,,
code-creation,LazyCompile,10,281013,0x306324ae98e,24,instantiate node:internal/modules/esm/module_job:101:14,0x1abee82ef10,~
code-source-info,0x306324ae98e,108,3231,3370,C0O3250C6O3312C11O3312C15O3305C19O3352C23O3365,,
code-creation,LazyCompile,10,281178,0x306324af006,935,_instantiate node:internal/modules/esm/module_job:108:21,0x1abee82ef60,~
code-source-info,0x306324af006,108,3394,7050,C4O3394C29O3424C37O3424C42O3424C44O3477C48O3477C50O3789C54O3795C67O3789C97O3847C105O3875C111O3898C118O3913C126O3950C136O3950C142O3978C147O4026C153O4033C159O4051C165O4009C172O4090C178O4097C184O4097C203O4147C215O4147C219O4492C227O4497C236O4534C244O4560C254O4534C261O4672C273O4695C283O4672C289O4740C298O4785C313O4740C319O4884C331O4919C343O4884C350O4856C358O4875C366O5047C372O5054C378O5054C393O5036C418O5019C423O5130C428O5440C434O5447C440O5447C454O5429C479O5405C490O5499C492O5510C497O5563C499O5573C503O5898C511O5919C517O5898C523O5988C529O6024C533O6047C546O6024C552O6099C562O6128C581O6188C592O6168C599O6250C606O6328C617O6446C632O6483C640O6535C659O6407C662O6109C666O6606C678O6629C688O6606C694O6654C706O6686C714O6666C718O6708C726O6718C734O6718C739O6716C743O6781C745O6781C746O6832C778O6815C809O6815C812O6993C816O7022C818O7020C822O6804C906O7049,,
code-creation,LazyCompile,10,281321,0x306324af67e,179,addJobsToDependencyGraph node:internal/modules/esm/module_job:110:38,0x306324aed48,~
code-source-info,0x306324af67e,108,3477,3782,C10O3477C18O3507C23O3523C28O3523C35O3550C46O3557C47O3574C52O3586C57O3586C62O3648C74O3632C100O3663C111O3685C118O3713C123O3747C126O3713C134O3681C140O3670C154O3775,,
code-creation,LazyCompile,10,281415,0x306324af866,112,FileHandle node:internal/fs/promises:128:14,0x1abee83bb08,~
code-source-info,0x306324af866,115,3244,3417,C3O3264C11O3264C40O3278C45O3283C50O3292C54O3311C59O3316C67O3323C69O3347C77O3321C81O3363C86O3368C91O3375C95O3385C100O3390C104O3405C111O3416,,
code-creation,LazyCompile,10,281475,0x306324af9e6,63,MixedEventEmitter node:internal/event_target:968:16,0x109c10e9508,~
code-source-info,0x306324af9e6,44,26839,26973,C0O26839C8O26858C15O26865C21O26901C25O26910C29O26901C41O26924C48O26946C54O26924C62O26972,,
code-creation,LazyCompile,10,281647,0x306324afcce,601,readFileHandle node:internal/fs/promises:411:30,0x1abee83ae88,~
code-source-info,0x306324afcce,115,10181,12012,C10O10181C18O10223C25O10230C33O10245C37O10245C41O10291C47O10305C53O10322C64O10333C68O10305C82O10291C110O10353C114O10353C118O10384C120O10393C122O10408C129O10424C131O10422C138O10436C140O10432C145O10452C147O10469C153O10501C155O10521C157O10532C159O10530C164O10551C172O10557C177O10551C178O10611C180O10637C182O10658C183O10663C187O10689C190O10715C199O10736C203O10743C209O10743C215O10779C219O10779C223O10810C225O10827C227O10844C229O10857C233O10878C239O10894C247O10910C251O10894C257O10948C259O10967C266O11027C269O11055C272O11082C280O11104C287O11117C291O11091C297O11173C303O11188C309O11204C321O11279C334O11188C348O11174C379O11305C381O11318C388O11334C389O11356C396O11375C400O11390C405O11414C410O11449C412O11463C414O11459C418O11520C424O11551C433O11551C440O11579C446O11579C451O11640C455O10769C458O11662C460O11673C461O11682C466O11694C468O11713C477O11748C486O11748C495O11803C503O11810C509O11825C516O11831C520O11838C526O11838C533O11955C539O11973C545O11990C551O11973C568O12002C572O12009,,
code-creation,LazyCompile,10,281835,0x306324b0116,8,get fd node:internal/fs/promises:141:9,0x1abee83bbc0,~
code-source-info,0x306324b0116,115,3494,3526,C0O3504C2O3516C4O3515C7O3521,,
code-creation,LazyCompile,10,281905,0x306324b031e,83,handleFdClose node:internal/fs/promises:338:29,0x1abee83ad48,~
code-source-info,0x306324b031e,115,8009,8361,C0O8009C23O8041C30O8075C43O8048C58O8358,,
code-creation,LazyCompile,10,281965,0x306324b04ae,19,allocUnsafeSlow node:buffer:382:50,0x25ca2736bf8,~
code-source-info,0x306324b04ae,24,11572,11640,C0O11584C5O11584C9O11605C14O11612C18O11637,,
code-creation,LazyCompile,10,282015,0x306324b05d6,71,createUnsafeBuffer node:internal/buffer:1059:28,0x14121bcbd18,~
code-source-info,0x306324b05d6,25,31379,31495,C0O31391C8O31403C15O31422C22O31429C39O31471C48O31483C70O31494,,
tick,0x7ff7e82a888e,282273,0,0x0,2
code-creation,LazyCompile,10,282292,0x306324b076e,36, node:internal/fs/promises:341:5,0x306324b01f0,~
code-source-info,0x306324b076e,115,8095,8154,C0O8095C9O8107C21O8128C30O8107C35O8154,,
code-creation,LazyCompile,10,282385,0x306324b0a66,248,close node:internal/fs/promises:201:11,0x1abee83de40,~
code-source-info,0x306324b0a66,115,4680,5501,C0O4693C7O4702C9O4701C15O4707C20O4724C27O4731C30O4748C31O4763C38O4772C40O4771C45O4797C52O4809C54O4808C57O4824C58O4839C65O4844C73O4850C77O4859C84O4868C86O4867C91O4875C96O4891C103O4896C108O4901C112O4914C119O4919C126O4936C136O4979C138O4978C142O4988C147O4988C157O4936C162O4934C168O5080C175O5085C182O5102C189O5144C199O5140C210O5102C215O5100C219O5444C222O5449C230O5449C235O5469C242O5481C244O5480C247O5496,,
code-creation,LazyCompile,10,282506,0x306324b0e2e,33,primordials.SafePromisePrototypeFinally node:internal/per_context/primordials:409:43,0x147335ca588,~
code-source-info,0x306324b0e2e,6,12438,12718,C0O12438C13O12574C27O12574C32O12718,,
code-creation,LazyCompile,10,282567,0x306324b0fbe,46, node:internal/per_context/primordials:412:15,0x306324b0d80,~
code-source-info,0x306324b0fbe,6,12586,12713,C0O12703C14O12601C20O12676C28O12683C34O12702C39O12703C45O12713,,
code-creation,LazyCompile,10,282612,0x306324b1106,27,SafePromise node:internal/per_context/primordials:393:16,0x147335ca480,~
code-source-info,0x306324b1106,6,11762,11793,C3O11775C7O11781C11O11775C26O11792,,
code-creation,LazyCompile,10,282654,0x306324b11fe,22, node:internal/per_context/primordials:413:21,0x306324b0f08,~
code-source-info,0x306324b11fe,6,12617,12666,C0O12627C16O12627C21O12666,,
code-creation,LazyCompile,10,282711,0x306324b12ee,17, node:internal/fs/promises:215:9,0x306324b0850,~
code-source-info,0x306324b12ee,115,5006,5048,C0O5014C7O5019C11O5034C16O5047,,
code-creation,LazyCompile,10,282752,0x306324b13be,3, node:internal/fs/promises:341:51,0x306324b06c0,~
code-source-info,0x306324b13be,115,8141,8153,C0O8147C2O8153,,
code-creation,LazyCompile,10,282864,0x306324b172e,193,moduleStrategy node:internal/modules/esm/translators:110:56,0x109c10ec888,~
code-source-info,0x306324b172e,122,3150,3602,C0O3150C23O3177C36O3177C41O3222C46O3231C52O3253C59O3253C64O3290C76O3326C81O3290C85O3352C106O3352C112O3401C119O3412C124O3424C129O3428C134O3465C146O3550C150O3424C156O3585C168O3599,,
code-creation,LazyCompile,10,282941,0x306324b2476,83,assertBufferSource node:internal/modules/esm/translators:74:28,0x109c10ec658,~
code-source-info,0x306324b2476,122,2103,2510,C0O2138C10O2190C11O2197C12O2254C15O2254C19O2214C24O2233C29O2274C35O2301C41O2332C42O2339C43O2348C50O2401C77O2354C82O2348,,
code-creation,LazyCompile,10,282993,0x306324b25ce,31,lazyTypes node:internal/modules/esm/translators:22:19,0x109c10ec5b8,~
code-source-info,0x306324b25ce,122,417,514,C0O425C6O446C10O460C11O464C17O480C24O478C30O511,,
code-creation,LazyCompile,10,283050,0x306324b26e6,72,stringify node:internal/modules/esm/translators:90:19,0x109c10ec6a8,~
code-source-info,0x306324b26e6,122,2532,2737,C0O2544C6O2574C8O2586C9O2590C20O2590C25O2645C33O2678C36O2674C45O2694C50O2653C56O2706C61O2721C66O2721C71O2734,,
code-creation,LazyCompile,10,283191,0x306324b28d6,206,TextDecoder node:internal/encoding:379:16,0x14121bd3fa0,~
script-source,27,node:internal/encoding,'use strict';\x0d\n\x0d\n// An implementation of the WHATWG Encoding Standard\x0d\n// https://encoding.spec.whatwg.org\x0d\n\x0d\nconst {\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectGetOwnPropertyDescriptors\x2C\x0d\n  SafeMap\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolToStringTag\x2C\x0d\n  Uint32Array\x2C\x0d\n  Uint8Array\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  ERR_ENCODING_INVALID_ENCODED_DATA\x2C\x0d\n  ERR_ENCODING_NOT_SUPPORTED\x2C\x0d\n  ERR_INVALID_ARG_TYPE\x2C\x0d\n  ERR_INVALID_THIS\x2C\x0d\n  ERR_NO_ICU\x0d\n} = require('internal/errors').codes;\x0d\nconst kHandle = Symbol('handle');\x0d\nconst kFlags = Symbol('flags');\x0d\nconst kEncoding = Symbol('encoding');\x0d\nconst kDecoder = Symbol('decoder');\x0d\nconst kEncoder = Symbol('encoder');\x0d\n\x0d\nconst {\x0d\n  getConstructorOf\x2C\x0d\n  customInspectSymbol: inspect\x0d\n} = require('internal/util');\x0d\n\x0d\nconst {\x0d\n  isAnyArrayBuffer\x2C\x0d\n  isArrayBufferView\x2C\x0d\n  isUint8Array\x0d\n} = require('internal/util/types');\x0d\n\x0d\nconst {\x0d\n  validateString\x2C\x0d\n  validateObject\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nconst {\x0d\n  encodeInto\x2C\x0d\n  encodeUtf8String\x0d\n} = internalBinding('buffer');\x0d\n\x0d\nlet Buffer;\x0d\nfunction lazyBuffer() {\x0d\n  if (Buffer === undefined)\x0d\n    Buffer = require('buffer').Buffer;\x0d\n  return Buffer;\x0d\n}\x0d\n\x0d\nfunction validateEncoder(obj) {\x0d\n  if (obj == null || obj[kEncoder] !== true)\x0d\n    throw new ERR_INVALID_THIS('TextEncoder');\x0d\n}\x0d\n\x0d\nfunction validateDecoder(obj) {\x0d\n  if (obj == null || obj[kDecoder] !== true)\x0d\n    throw new ERR_INVALID_THIS('TextDecoder');\x0d\n}\x0d\n\x0d\nconst CONVERTER_FLAGS_FLUSH = 0x1;\x0d\nconst CONVERTER_FLAGS_FATAL = 0x2;\x0d\nconst CONVERTER_FLAGS_IGNORE_BOM = 0x4;\x0d\n\x0d\nconst empty = new Uint8Array(0);\x0d\n\x0d\nconst encodings = new SafeMap([\x0d\n  ['unicode-1-1-utf-8'\x2C 'utf-8']\x2C\x0d\n  ['utf8'\x2C 'utf-8']\x2C\x0d\n  ['utf-8'\x2C 'utf-8']\x2C\x0d\n  ['866'\x2C 'ibm866']\x2C\x0d\n  ['cp866'\x2C 'ibm866']\x2C\x0d\n  ['csibm866'\x2C 'ibm866']\x2C\x0d\n  ['ibm866'\x2C 'ibm866']\x2C\x0d\n  ['csisolatin2'\x2C 'iso-8859-2']\x2C\x0d\n  ['iso-8859-2'\x2C 'iso-8859-2']\x2C\x0d\n  ['iso-ir-101'\x2C 'iso-8859-2']\x2C\x0d\n  ['iso8859-2'\x2C 'iso-8859-2']\x2C\x0d\n  ['iso88592'\x2C 'iso-8859-2']\x2C\x0d\n  ['iso_8859-2'\x2C 'iso-8859-2']\x2C\x0d\n  ['iso_8859-2:1987'\x2C 'iso-8859-2']\x2C\x0d\n  ['l2'\x2C 'iso-8859-2']\x2C\x0d\n  ['latin2'\x2C 'iso-8859-2']\x2C\x0d\n  ['csisolatin3'\x2C 'iso-8859-3']\x2C\x0d\n  ['iso-8859-3'\x2C 'iso-8859-3']\x2C\x0d\n  ['iso-ir-109'\x2C 'iso-8859-3']\x2C\x0d\n  ['iso8859-3'\x2C 'iso-8859-3']\x2C\x0d\n  ['iso88593'\x2C 'iso-8859-3']\x2C\x0d\n  ['iso_8859-3'\x2C 'iso-8859-3']\x2C\x0d\n  ['iso_8859-3:1988'\x2C 'iso-8859-3']\x2C\x0d\n  ['l3'\x2C 'iso-8859-3']\x2C\x0d\n  ['latin3'\x2C 'iso-8859-3']\x2C\x0d\n  ['csisolatin4'\x2C 'iso-8859-4']\x2C\x0d\n  ['iso-8859-4'\x2C 'iso-8859-4']\x2C\x0d\n  ['iso-ir-110'\x2C 'iso-8859-4']\x2C\x0d\n  ['iso8859-4'\x2C 'iso-8859-4']\x2C\x0d\n  ['iso88594'\x2C 'iso-8859-4']\x2C\x0d\n  ['iso_8859-4'\x2C 'iso-8859-4']\x2C\x0d\n  ['iso_8859-4:1988'\x2C 'iso-8859-4']\x2C\x0d\n  ['l4'\x2C 'iso-8859-4']\x2C\x0d\n  ['latin4'\x2C 'iso-8859-4']\x2C\x0d\n  ['csisolatincyrillic'\x2C 'iso-8859-5']\x2C\x0d\n  ['cyrillic'\x2C 'iso-8859-5']\x2C\x0d\n  ['iso-8859-5'\x2C 'iso-8859-5']\x2C\x0d\n  ['iso-ir-144'\x2C 'iso-8859-5']\x2C\x0d\n  ['iso8859-5'\x2C 'iso-8859-5']\x2C\x0d\n  ['iso88595'\x2C 'iso-8859-5']\x2C\x0d\n  ['iso_8859-5'\x2C 'iso-8859-5']\x2C\x0d\n  ['iso_8859-5:1988'\x2C 'iso-8859-5']\x2C\x0d\n  ['arabic'\x2C 'iso-8859-6']\x2C\x0d\n  ['asmo-708'\x2C 'iso-8859-6']\x2C\x0d\n  ['csiso88596e'\x2C 'iso-8859-6']\x2C\x0d\n  ['csiso88596i'\x2C 'iso-8859-6']\x2C\x0d\n  ['csisolatinarabic'\x2C 'iso-8859-6']\x2C\x0d\n  ['ecma-114'\x2C 'iso-8859-6']\x2C\x0d\n  ['iso-8859-6'\x2C 'iso-8859-6']\x2C\x0d\n  ['iso-8859-6-e'\x2C 'iso-8859-6']\x2C\x0d\n  ['iso-8859-6-i'\x2C 'iso-8859-6']\x2C\x0d\n  ['iso-ir-127'\x2C 'iso-8859-6']\x2C\x0d\n  ['iso8859-6'\x2C 'iso-8859-6']\x2C\x0d\n  ['iso88596'\x2C 'iso-8859-6']\x2C\x0d\n  ['iso_8859-6'\x2C 'iso-8859-6']\x2C\x0d\n  ['iso_8859-6:1987'\x2C 'iso-8859-6']\x2C\x0d\n  ['csisolatingreek'\x2C 'iso-8859-7']\x2C\x0d\n  ['ecma-118'\x2C 'iso-8859-7']\x2C\x0d\n  ['elot_928'\x2C 'iso-8859-7']\x2C\x0d\n  ['greek'\x2C 'iso-8859-7']\x2C\x0d\n  ['greek8'\x2C 'iso-8859-7']\x2C\x0d\n  ['iso-8859-7'\x2C 'iso-8859-7']\x2C\x0d\n  ['iso-ir-126'\x2C 'iso-8859-7']\x2C\x0d\n  ['iso8859-7'\x2C 'iso-8859-7']\x2C\x0d\n  ['iso88597'\x2C 'iso-8859-7']\x2C\x0d\n  ['iso_8859-7'\x2C 'iso-8859-7']\x2C\x0d\n  ['iso_8859-7:1987'\x2C 'iso-8859-7']\x2C\x0d\n  ['sun_eu_greek'\x2C 'iso-8859-7']\x2C\x0d\n  ['csiso88598e'\x2C 'iso-8859-8']\x2C\x0d\n  ['csisolatinhebrew'\x2C 'iso-8859-8']\x2C\x0d\n  ['hebrew'\x2C 'iso-8859-8']\x2C\x0d\n  ['iso-8859-8'\x2C 'iso-8859-8']\x2C\x0d\n  ['iso-8859-8-e'\x2C 'iso-8859-8']\x2C\x0d\n  ['iso-ir-138'\x2C 'iso-8859-8']\x2C\x0d\n  ['iso8859-8'\x2C 'iso-8859-8']\x2C\x0d\n  ['iso88598'\x2C 'iso-8859-8']\x2C\x0d\n  ['iso_8859-8'\x2C 'iso-8859-8']\x2C\x0d\n  ['iso_8859-8:1988'\x2C 'iso-8859-8']\x2C\x0d\n  ['visual'\x2C 'iso-8859-8']\x2C\x0d\n  ['csiso88598i'\x2C 'iso-8859-8-i']\x2C\x0d\n  ['iso-8859-8-i'\x2C 'iso-8859-8-i']\x2C\x0d\n  ['logical'\x2C 'iso-8859-8-i']\x2C\x0d\n  ['csisolatin6'\x2C 'iso-8859-10']\x2C\x0d\n  ['iso-8859-10'\x2C 'iso-8859-10']\x2C\x0d\n  ['iso-ir-157'\x2C 'iso-8859-10']\x2C\x0d\n  ['iso8859-10'\x2C 'iso-8859-10']\x2C\x0d\n  ['iso885910'\x2C 'iso-8859-10']\x2C\x0d\n  ['l6'\x2C 'iso-8859-10']\x2C\x0d\n  ['latin6'\x2C 'iso-8859-10']\x2C\x0d\n  ['iso-8859-13'\x2C 'iso-8859-13']\x2C\x0d\n  ['iso8859-13'\x2C 'iso-8859-13']\x2C\x0d\n  ['iso885913'\x2C 'iso-8859-13']\x2C\x0d\n  ['iso-8859-14'\x2C 'iso-8859-14']\x2C\x0d\n  ['iso8859-14'\x2C 'iso-8859-14']\x2C\x0d\n  ['iso885914'\x2C 'iso-8859-14']\x2C\x0d\n  ['csisolatin9'\x2C 'iso-8859-15']\x2C\x0d\n  ['iso-8859-15'\x2C 'iso-8859-15']\x2C\x0d\n  ['iso8859-15'\x2C 'iso-8859-15']\x2C\x0d\n  ['iso885915'\x2C 'iso-8859-15']\x2C\x0d\n  ['iso_8859-15'\x2C 'iso-8859-15']\x2C\x0d\n  ['l9'\x2C 'iso-8859-15']\x2C\x0d\n  ['cskoi8r'\x2C 'koi8-r']\x2C\x0d\n  ['koi'\x2C 'koi8-r']\x2C\x0d\n  ['koi8'\x2C 'koi8-r']\x2C\x0d\n  ['koi8-r'\x2C 'koi8-r']\x2C\x0d\n  ['koi8_r'\x2C 'koi8-r']\x2C\x0d\n  ['koi8-ru'\x2C 'koi8-u']\x2C\x0d\n  ['koi8-u'\x2C 'koi8-u']\x2C\x0d\n  ['csmacintosh'\x2C 'macintosh']\x2C\x0d\n  ['mac'\x2C 'macintosh']\x2C\x0d\n  ['macintosh'\x2C 'macintosh']\x2C\x0d\n  ['x-mac-roman'\x2C 'macintosh']\x2C\x0d\n  ['dos-874'\x2C 'windows-874']\x2C\x0d\n  ['iso-8859-11'\x2C 'windows-874']\x2C\x0d\n  ['iso8859-11'\x2C 'windows-874']\x2C\x0d\n  ['iso885911'\x2C 'windows-874']\x2C\x0d\n  ['tis-620'\x2C 'windows-874']\x2C\x0d\n  ['windows-874'\x2C 'windows-874']\x2C\x0d\n  ['cp1250'\x2C 'windows-1250']\x2C\x0d\n  ['windows-1250'\x2C 'windows-1250']\x2C\x0d\n  ['x-cp1250'\x2C 'windows-1250']\x2C\x0d\n  ['cp1251'\x2C 'windows-1251']\x2C\x0d\n  ['windows-1251'\x2C 'windows-1251']\x2C\x0d\n  ['x-cp1251'\x2C 'windows-1251']\x2C\x0d\n  ['ansi_x3.4-1968'\x2C 'windows-1252']\x2C\x0d\n  ['ascii'\x2C 'windows-1252']\x2C\x0d\n  ['cp1252'\x2C 'windows-1252']\x2C\x0d\n  ['cp819'\x2C 'windows-1252']\x2C\x0d\n  ['csisolatin1'\x2C 'windows-1252']\x2C\x0d\n  ['ibm819'\x2C 'windows-1252']\x2C\x0d\n  ['iso-8859-1'\x2C 'windows-1252']\x2C\x0d\n  ['iso-ir-100'\x2C 'windows-1252']\x2C\x0d\n  ['iso8859-1'\x2C 'windows-1252']\x2C\x0d\n  ['iso88591'\x2C 'windows-1252']\x2C\x0d\n  ['iso_8859-1'\x2C 'windows-1252']\x2C\x0d\n  ['iso_8859-1:1987'\x2C 'windows-1252']\x2C\x0d\n  ['l1'\x2C 'windows-1252']\x2C\x0d\n  ['latin1'\x2C 'windows-1252']\x2C\x0d\n  ['us-ascii'\x2C 'windows-1252']\x2C\x0d\n  ['windows-1252'\x2C 'windows-1252']\x2C\x0d\n  ['x-cp1252'\x2C 'windows-1252']\x2C\x0d\n  ['cp1253'\x2C 'windows-1253']\x2C\x0d\n  ['windows-1253'\x2C 'windows-1253']\x2C\x0d\n  ['x-cp1253'\x2C 'windows-1253']\x2C\x0d\n  ['cp1254'\x2C 'windows-1254']\x2C\x0d\n  ['csisolatin5'\x2C 'windows-1254']\x2C\x0d\n  ['iso-8859-9'\x2C 'windows-1254']\x2C\x0d\n  ['iso-ir-148'\x2C 'windows-1254']\x2C\x0d\n  ['iso8859-9'\x2C 'windows-1254']\x2C\x0d\n  ['iso88599'\x2C 'windows-1254']\x2C\x0d\n  ['iso_8859-9'\x2C 'windows-1254']\x2C\x0d\n  ['iso_8859-9:1989'\x2C 'windows-1254']\x2C\x0d\n  ['l5'\x2C 'windows-1254']\x2C\x0d\n  ['latin5'\x2C 'windows-1254']\x2C\x0d\n  ['windows-1254'\x2C 'windows-1254']\x2C\x0d\n  ['x-cp1254'\x2C 'windows-1254']\x2C\x0d\n  ['cp1255'\x2C 'windows-1255']\x2C\x0d\n  ['windows-1255'\x2C 'windows-1255']\x2C\x0d\n  ['x-cp1255'\x2C 'windows-1255']\x2C\x0d\n  ['cp1256'\x2C 'windows-1256']\x2C\x0d\n  ['windows-1256'\x2C 'windows-1256']\x2C\x0d\n  ['x-cp1256'\x2C 'windows-1256']\x2C\x0d\n  ['cp1257'\x2C 'windows-1257']\x2C\x0d\n  ['windows-1257'\x2C 'windows-1257']\x2C\x0d\n  ['x-cp1257'\x2C 'windows-1257']\x2C\x0d\n  ['cp1258'\x2C 'windows-1258']\x2C\x0d\n  ['windows-1258'\x2C 'windows-1258']\x2C\x0d\n  ['x-cp1258'\x2C 'windows-1258']\x2C\x0d\n  ['x-mac-cyrillic'\x2C 'x-mac-cyrillic']\x2C\x0d\n  ['x-mac-ukrainian'\x2C 'x-mac-cyrillic']\x2C\x0d\n  ['chinese'\x2C 'gbk']\x2C\x0d\n  ['csgb2312'\x2C 'gbk']\x2C\x0d\n  ['csiso58gb231280'\x2C 'gbk']\x2C\x0d\n  ['gb2312'\x2C 'gbk']\x2C\x0d\n  ['gb_2312'\x2C 'gbk']\x2C\x0d\n  ['gb_2312-80'\x2C 'gbk']\x2C\x0d\n  ['gbk'\x2C 'gbk']\x2C\x0d\n  ['iso-ir-58'\x2C 'gbk']\x2C\x0d\n  ['x-gbk'\x2C 'gbk']\x2C\x0d\n  ['gb18030'\x2C 'gb18030']\x2C\x0d\n  ['big5'\x2C 'big5']\x2C\x0d\n  ['big5-hkscs'\x2C 'big5']\x2C\x0d\n  ['cn-big5'\x2C 'big5']\x2C\x0d\n  ['csbig5'\x2C 'big5']\x2C\x0d\n  ['x-x-big5'\x2C 'big5']\x2C\x0d\n  ['cseucpkdfmtjapanese'\x2C 'euc-jp']\x2C\x0d\n  ['euc-jp'\x2C 'euc-jp']\x2C\x0d\n  ['x-euc-jp'\x2C 'euc-jp']\x2C\x0d\n  ['csiso2022jp'\x2C 'iso-2022-jp']\x2C\x0d\n  ['iso-2022-jp'\x2C 'iso-2022-jp']\x2C\x0d\n  ['csshiftjis'\x2C 'shift_jis']\x2C\x0d\n  ['ms932'\x2C 'shift_jis']\x2C\x0d\n  ['ms_kanji'\x2C 'shift_jis']\x2C\x0d\n  ['shift-jis'\x2C 'shift_jis']\x2C\x0d\n  ['shift_jis'\x2C 'shift_jis']\x2C\x0d\n  ['sjis'\x2C 'shift_jis']\x2C\x0d\n  ['windows-31j'\x2C 'shift_jis']\x2C\x0d\n  ['x-sjis'\x2C 'shift_jis']\x2C\x0d\n  ['cseuckr'\x2C 'euc-kr']\x2C\x0d\n  ['csksc56011987'\x2C 'euc-kr']\x2C\x0d\n  ['euc-kr'\x2C 'euc-kr']\x2C\x0d\n  ['iso-ir-149'\x2C 'euc-kr']\x2C\x0d\n  ['korean'\x2C 'euc-kr']\x2C\x0d\n  ['ks_c_5601-1987'\x2C 'euc-kr']\x2C\x0d\n  ['ks_c_5601-1989'\x2C 'euc-kr']\x2C\x0d\n  ['ksc5601'\x2C 'euc-kr']\x2C\x0d\n  ['ksc_5601'\x2C 'euc-kr']\x2C\x0d\n  ['windows-949'\x2C 'euc-kr']\x2C\x0d\n  ['utf-16be'\x2C 'utf-16be']\x2C\x0d\n  ['utf-16le'\x2C 'utf-16le']\x2C\x0d\n  ['utf-16'\x2C 'utf-16le']\x2C\x0d\n]);\x0d\n\x0d\n// Unfortunately\x2C String.prototype.trim also removes non-ascii whitespace\x2C\x0d\n// so we have to do this manually\x0d\nfunction trimAsciiWhitespace(label) {\x0d\n  let s = 0;\x0d\n  let e = label.length;\x0d\n  while (s < e && (\x0d\n    label[s] === '\\u0009' ||\x0d\n    label[s] === '\\u000a' ||\x0d\n    label[s] === '\\u000c' ||\x0d\n    label[s] === '\\u000d' ||\x0d\n    label[s] === '\\u0020')) {\x0d\n    s++;\x0d\n  }\x0d\n  while (e > s && (\x0d\n    label[e - 1] === '\\u0009' ||\x0d\n    label[e - 1] === '\\u000a' ||\x0d\n    label[e - 1] === '\\u000c' ||\x0d\n    label[e - 1] === '\\u000d' ||\x0d\n    label[e - 1] === '\\u0020')) {\x0d\n    e--;\x0d\n  }\x0d\n  return StringPrototypeSlice(label\x2C s\x2C e);\x0d\n}\x0d\n\x0d\nfunction getEncodingFromLabel(label) {\x0d\n  const enc = encodings.get(label);\x0d\n  if (enc !== undefined) return enc;\x0d\n  return encodings.get(trimAsciiWhitespace(label.toLowerCase()));\x0d\n}\x0d\n\x0d\nconst encodeIntoResults = new Uint32Array(2);\x0d\n\x0d\nclass TextEncoder {\x0d\n  constructor() {\x0d\n    this[kEncoder] = true;\x0d\n  }\x0d\n\x0d\n  get encoding() {\x0d\n    validateEncoder(this);\x0d\n    return 'utf-8';\x0d\n  }\x0d\n\x0d\n  encode(input = '') {\x0d\n    validateEncoder(this);\x0d\n    return encodeUtf8String(`${input}`);\x0d\n  }\x0d\n\x0d\n  encodeInto(src\x2C dest) {\x0d\n    validateEncoder(this);\x0d\n    validateString(src\x2C 'src');\x0d\n    if (!dest || !isUint8Array(dest))\x0d\n      throw new ERR_INVALID_ARG_TYPE('dest'\x2C 'Uint8Array'\x2C dest);\x0d\n    encodeInto(src\x2C dest\x2C encodeIntoResults);\x0d\n    return { read: encodeIntoResults[0]\x2C written: encodeIntoResults[1] };\x0d\n  }\x0d\n\x0d\n  [inspect](depth\x2C opts) {\x0d\n    validateEncoder(this);\x0d\n    if (typeof depth === 'number' && depth < 0)\x0d\n      return this;\x0d\n    const ctor = getConstructorOf(this);\x0d\n    const obj = ObjectCreate({\x0d\n      constructor: ctor === null ? TextEncoder : ctor\x0d\n    });\x0d\n    obj.encoding = this.encoding;\x0d\n    // Lazy to avoid circular dependency\x0d\n    return require('internal/util/inspect').inspect(obj\x2C opts);\x0d\n  }\x0d\n}\x0d\n\x0d\nObjectDefineProperties(\x0d\n  TextEncoder.prototype\x2C {\x0d\n    'encode': { enumerable: true }\x2C\x0d\n    'encodeInto': { enumerable: true }\x2C\x0d\n    'encoding': { enumerable: true }\x2C\x0d\n    [SymbolToStringTag]: { configurable: true\x2C value: 'TextEncoder' }\x2C\x0d\n  });\x0d\n\x0d\nconst TextDecoder =\x0d\n  internalBinding('config').hasIntl ?\x0d\n    makeTextDecoderICU() :\x0d\n    makeTextDecoderJS();\x0d\n\x0d\nfunction makeTextDecoderICU() {\x0d\n  const {\x0d\n    decode: _decode\x2C\x0d\n    getConverter\x2C\x0d\n  } = internalBinding('icu');\x0d\n\x0d\n  class TextDecoder {\x0d\n    constructor(encoding = 'utf-8'\x2C options = {}) {\x0d\n      encoding = `${encoding}`;\x0d\n      validateObject(options\x2C 'options'\x2C {\x0d\n        nullable: true\x2C\x0d\n        allowArray: true\x2C\x0d\n        allowFunction: true\x2C\x0d\n      });\x0d\n\x0d\n      const enc = getEncodingFromLabel(encoding);\x0d\n      if (enc === undefined)\x0d\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\x0d\n\x0d\n      let flags = 0;\x0d\n      if (options !== null) {\x0d\n        flags |= options.fatal ? CONVERTER_FLAGS_FATAL : 0;\x0d\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\x0d\n      }\x0d\n\x0d\n      const handle = getConverter(enc\x2C flags);\x0d\n      if (handle === undefined)\x0d\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\x0d\n\x0d\n      this[kDecoder] = true;\x0d\n      this[kHandle] = handle;\x0d\n      this[kFlags] = flags;\x0d\n      this[kEncoding] = enc;\x0d\n    }\x0d\n\x0d\n\x0d\n    decode(input = empty\x2C options = {}) {\x0d\n      validateDecoder(this);\x0d\n      if (isAnyArrayBuffer(input)) {\x0d\n        input = lazyBuffer().from(input);\x0d\n      } else if (!isArrayBufferView(input)) {\x0d\n        throw new ERR_INVALID_ARG_TYPE('input'\x2C\x0d\n                                       ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\x0d\n                                       input);\x0d\n      }\x0d\n      validateObject(options\x2C 'options'\x2C {\x0d\n        nullable: true\x2C\x0d\n        allowArray: true\x2C\x0d\n        allowFunction: true\x2C\x0d\n      });\x0d\n\x0d\n      let flags = 0;\x0d\n      if (options !== null)\x0d\n        flags |= options.stream ? 0 : CONVERTER_FLAGS_FLUSH;\x0d\n\x0d\n      const ret = _decode(this[kHandle]\x2C input\x2C flags);\x0d\n      if (typeof ret === 'number') {\x0d\n        throw new ERR_ENCODING_INVALID_ENCODED_DATA(this.encoding\x2C ret);\x0d\n      }\x0d\n      return ret.toString('ucs2');\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return TextDecoder;\x0d\n}\x0d\n\x0d\nfunction makeTextDecoderJS() {\x0d\n  let StringDecoder;\x0d\n  function lazyStringDecoder() {\x0d\n    if (StringDecoder === undefined)\x0d\n      ({ StringDecoder } = require('string_decoder'));\x0d\n    return StringDecoder;\x0d\n  }\x0d\n\x0d\n  const kBOMSeen = Symbol('BOM seen');\x0d\n\x0d\n  function hasConverter(encoding) {\x0d\n    return encoding === 'utf-8' || encoding === 'utf-16le';\x0d\n  }\x0d\n\x0d\n  class TextDecoder {\x0d\n    constructor(encoding = 'utf-8'\x2C options = {}) {\x0d\n      encoding = `${encoding}`;\x0d\n      validateObject(options\x2C 'options'\x2C {\x0d\n        nullable: true\x2C\x0d\n        allowArray: true\x2C\x0d\n        allowFunction: true\x2C\x0d\n      });\x0d\n\x0d\n      const enc = getEncodingFromLabel(encoding);\x0d\n      if (enc === undefined || !hasConverter(enc))\x0d\n        throw new ERR_ENCODING_NOT_SUPPORTED(encoding);\x0d\n\x0d\n      let flags = 0;\x0d\n      if (options !== null) {\x0d\n        if (options.fatal) {\x0d\n          throw new ERR_NO_ICU('"fatal" option');\x0d\n        }\x0d\n        flags |= options.ignoreBOM ? CONVERTER_FLAGS_IGNORE_BOM : 0;\x0d\n      }\x0d\n\x0d\n      this[kDecoder] = true;\x0d\n      // StringDecoder will normalize WHATWG encoding to Node.js encoding.\x0d\n      this[kHandle] = new (lazyStringDecoder())(enc);\x0d\n      this[kFlags] = flags;\x0d\n      this[kEncoding] = enc;\x0d\n      this[kBOMSeen] = false;\x0d\n    }\x0d\n\x0d\n    decode(input = empty\x2C options = {}) {\x0d\n      validateDecoder(this);\x0d\n      if (isAnyArrayBuffer(input)) {\x0d\n        input = lazyBuffer().from(input);\x0d\n      } else if (isArrayBufferView(input)) {\x0d\n        input = lazyBuffer().from(input.buffer\x2C input.byteOffset\x2C\x0d\n                                  input.byteLength);\x0d\n      } else {\x0d\n        throw new ERR_INVALID_ARG_TYPE('input'\x2C\x0d\n                                       ['ArrayBuffer'\x2C 'ArrayBufferView']\x2C\x0d\n                                       input);\x0d\n      }\x0d\n      validateObject(options\x2C 'options'\x2C {\x0d\n        nullable: true\x2C\x0d\n        allowArray: true\x2C\x0d\n        allowFunction: true\x2C\x0d\n      });\x0d\n\x0d\n      if (this[kFlags] & CONVERTER_FLAGS_FLUSH) {\x0d\n        this[kBOMSeen] = false;\x0d\n      }\x0d\n\x0d\n      if (options !== null && options.stream) {\x0d\n        this[kFlags] &= ~CONVERTER_FLAGS_FLUSH;\x0d\n      } else {\x0d\n        this[kFlags] |= CONVERTER_FLAGS_FLUSH;\x0d\n      }\x0d\n\x0d\n      let result = this[kFlags] & CONVERTER_FLAGS_FLUSH ?\x0d\n        this[kHandle].end(input) :\x0d\n        this[kHandle].write(input);\x0d\n\x0d\n      if (result.length > 0 &&\x0d\n          !this[kBOMSeen] &&\x0d\n          !(this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM)) {\x0d\n        // If the very first result in the stream is a BOM\x2C and we are not\x0d\n        // explicitly told to ignore it\x2C then we discard it.\x0d\n        if (result[0] === '\\ufeff') {\x0d\n          result = StringPrototypeSlice(result\x2C 1);\x0d\n        }\x0d\n        this[kBOMSeen] = true;\x0d\n      }\x0d\n\x0d\n      return result;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return TextDecoder;\x0d\n}\x0d\n\x0d\n// Mix in some shared properties.\x0d\nObjectDefineProperties(\x0d\n  TextDecoder.prototype\x2C\x0d\n  ObjectGetOwnPropertyDescriptors({\x0d\n    get encoding() {\x0d\n      validateDecoder(this);\x0d\n      return this[kEncoding];\x0d\n    }\x2C\x0d\n\x0d\n    get fatal() {\x0d\n      validateDecoder(this);\x0d\n      return (this[kFlags] & CONVERTER_FLAGS_FATAL) === CONVERTER_FLAGS_FATAL;\x0d\n    }\x2C\x0d\n\x0d\n    get ignoreBOM() {\x0d\n      validateDecoder(this);\x0d\n      return (this[kFlags] & CONVERTER_FLAGS_IGNORE_BOM) ===\x0d\n              CONVERTER_FLAGS_IGNORE_BOM;\x0d\n    }\x2C\x0d\n\x0d\n    [inspect](depth\x2C opts) {\x0d\n      validateDecoder(this);\x0d\n      if (typeof depth === 'number' && depth < 0)\x0d\n        return this;\x0d\n      const constructor = getConstructorOf(this) || TextDecoder;\x0d\n      const obj = ObjectCreate({ constructor });\x0d\n      obj.encoding = this.encoding;\x0d\n      obj.fatal = this.fatal;\x0d\n      obj.ignoreBOM = this.ignoreBOM;\x0d\n      if (opts.showHidden) {\x0d\n        obj[kFlags] = this[kFlags];\x0d\n        obj[kHandle] = this[kHandle];\x0d\n      }\x0d\n      // Lazy to avoid circular dependency\x0d\n      const { inspect } = require('internal/util/inspect');\x0d\n      return `${constructor.name} ${inspect(obj)}`;\x0d\n    }\x0d\n  })\x0d\n);\x0d\n\x0d\nObjectDefineProperties(TextDecoder.prototype\x2C {\x0d\n  decode: { enumerable: true }\x2C\x0d\n  [inspect]: { enumerable: false }\x2C\x0d\n  [SymbolToStringTag]: {\x0d\n    configurable: true\x2C\x0d\n    value: 'TextDecoder'\x0d\n  }\x0d\n});\x0d\n\x0d\nmodule.exports = {\x0d\n  getEncodingFromLabel\x2C\x0d\n  TextDecoder\x2C\x0d\n  TextEncoder\x0d\n};\x0d\n
code-source-info,0x306324b28d6,27,10677,11487,C15O10677C21O10721C25O10754C35O10769C43O10754C48O10905C53O10905C58O10944C60O10976C69O10982C74O10976C75O11045C77O11055C81O11105C94O11113C103O11166C116O11178C125O11243C130O11243C136O11276C138O11311C147O11317C152O11311C153O11368C157O11373C161O11383C165O11398C169O11403C174O11412C178O11429C182O11434C187O11442C191O11458C195O11463C200O11474C205O11486,,
code-creation,LazyCompile,10,284113,0x306324b3d56,55,getEncodingFromLabel node:internal/encoding:313:30,0x14121bd3cd8,~
code-source-info,0x306324b3d56,27,8957,9111,C0O8982C5O8992C10O8992C16O9007C18O9030C20O9041C21O9045C26O9062C34O9092C39O9092C44O9066C49O9062C54O9108,,
code-creation,LazyCompile,10,284243,0x306324b4066,227,decode node:internal/encoding:408:11,0x14121bd40c0,~
code-source-info,0x306324b4066,27,11503,12349,C8O11512C25O11542C30O11542C34O11572C41O11576C47O11612C52O11620C56O11632C61O11633C69O11660C76O11665C82O11702C102O11708C107O11702C108O11882C118O11897C126O11882C131O12033C133O12043C137O12091C153O12104C159O12148C168O12161C170O12160C180O12148C186O12193C190O12233C197O12282C207O12239C212O12233C213O12325C221O12325C226O12342,,
code-creation,LazyCompile,10,284315,0x306324b428e,37,validateDecoder node:internal/encoding:64:25,0x14121bd3c38,~
code-source-info,0x306324b428e,27,1332,1436,C0O1343C7O1366C9O1365C14O1376C19O1391C29O1397C34O1391C36O1435,,
code-creation,LazyCompile,10,284380,0x306324b43de,12,slice node:buffer:602:12,0x25ca2737518,~
code-source-info,0x306324b43de,24,17572,17618,C0O17597C5O17597C11O17618,,
code-creation,LazyCompile,10,284434,0x306324b44c6,10, node:internal/modules/esm/translators:42:63,0x109c10ec838,~
code-source-info,0x306324b44c6,122,1058,1085,C0O1071C2O1077C9O1084,,
code-creation,Script,10,284521,0x306324b4a26,93, file:///D:/Escritorio/desafio-14-Loggers-gzip-analisis-performance/serverAutocannon.js:1:1,0x306324b4720,~
script-source,148,file:///D:/Escritorio/desafio-14-Loggers-gzip-analisis-performance/serverAutocannon.js,import autocannon from 'autocannon'\x0d\nimport { PassThroug } from 'stream'\x0d\n\x0d\nfunction run(url) {\x0d\n  const buf = [];\x0d\n  const outputStream = new PassThroug();\x0d\n\x0d\n  const inst = autocannon({\x0d\n    url\x2C\x0d\n    connections: 100\x2C\x0d\n    duration: 20\x2C\x0d\n  });\x0d\n\x0d\n  autocannon.track(inst\x2C { outputStream });\x0d\n\x0d\n  outputStream.on("data"\x2C (data) => buf.push(data));\x0d\n  inst.on("done"\x2C function () {\x0d\n    process.stdout.write(Buffer.concat(buf));\x0d\n  });\x0d\n}\x0d\n\x0d\nconsole.log('Running all benchmarks in parallel ....')\x0d\n\x0d\nrun('http://localhost:8082/info-debug')\x0d\nrun('http://localhost:8082/info-nodebug')\x0d\nrun('http://localhost:8082/api/randoms-debug/?cant=50');\x0d\nrun('http://localhost:8082/api/randoms-nodebug/?cant=50');
code-source-info,0x306324b4a26,148,0,701,C10O0C22O0C42O0C46O443C50O451C58O451C63O501C66O501C70O542C73O542C77O585C80O585C84O643C87O643C92O701,,
code-creation,LazyCompile,10,284669,0x306324b4d86,144, node:internal/modules/esm/module_job:78:41,0x306324ad9e8,~
code-source-info,0x306324b4d86,108,2402,2658,C10O2402C18O2465C23O2470C28O2477C37O2501C46O2477C52O2528C61O2547C64O2528C69O2597C79O2597C105O2635C119O2649,,
code-creation,Function,11,284749,0x29be72cdf80,356,URLContext node:internal/url:160:14,0x14121bf7c90,^
code-source-info,0x29be72cdf80,39,3859,4081,,,
code-creation,Function,11,284779,0x29be72ce180,336,isURLThis node:internal/url:629:19,0x14121bf84f0,^
code-source-info,0x29be72ce180,39,18069,18160,,,
code-creation,Function,11,284826,0x29be72ce380,1976,getPathFromURLWin32 node:internal/url:1422:29,0x14121bf95e8,^
code-source-info,0x29be72ce380,39,39962,41360,,,
code-creation,Function,11,284853,0x29be72cebc0,168,isUint8Array node:internal/util/types:13:22,0x25ca2706f30,^
code-source-info,0x29be72cebc0,17,269,356,,,
code-creation,Function,11,284877,0x29be72ced00,204,isURLInstance node:internal/url:1554:23,0x14121bf9798,^
code-source-info,0x29be72ced00,39,45067,45166,,,
code-creation,Function,11,284901,0x29be72cee80,292, node:internal/url:650:21,0x14121bf8618,^
code-source-info,0x29be72cee80,39,18660,18737,,,
code-creation,LazyCompile,10,284954,0x306324b5256,13,onParseError node:internal/url:561:22,0x14121bf8270,~
code-source-info,0x306324b5256,39,15906,15962,C0O15926C7O15932C12O15926,,
code-creation,LazyCompile,10,285133,0x306324b5516,187,NodeError node:internal/errors:342:28,0x147335e5b48,~
script-source,11,node:internal/errors,/* eslint node-core/documented-errors: "error" */\x0d\n/* eslint node-core/alphabetize-errors: "error" */\x0d\n/* eslint node-core/prefer-util-format-errors: "error" */\x0d\n\x0d\n'use strict';\x0d\n\x0d\n// The whole point behind this internal module is to allow Node.js to no\x0d\n// longer be forced to treat every error message change as a semver-major\x0d\n// change. The NodeError classes here all expose a `code` property whose\x0d\n// value statically and permanently identifies the error. While the error\x0d\n// message may change\x2C the code should not.\x0d\n\x0d\nconst {\x0d\n  AggregateError\x2C\x0d\n  ArrayFrom\x2C\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeFilter\x2C\x0d\n  ArrayPrototypeIncludes\x2C\x0d\n  ArrayPrototypeIndexOf\x2C\x0d\n  ArrayPrototypeJoin\x2C\x0d\n  ArrayPrototypeMap\x2C\x0d\n  ArrayPrototypePop\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  ArrayPrototypeSplice\x2C\x0d\n  ArrayPrototypeUnshift\x2C\x0d\n  Error\x2C\x0d\n  ErrorCaptureStackTrace\x2C\x0d\n  ErrorPrototypeToString\x2C\x0d\n  JSONStringify\x2C\x0d\n  MapPrototypeGet\x2C\x0d\n  MathAbs\x2C\x0d\n  MathMax\x2C\x0d\n  Number\x2C\x0d\n  NumberIsInteger\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  ObjectIsExtensible\x2C\x0d\n  ObjectGetOwnPropertyDescriptor\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  RangeError\x2C\x0d\n  ReflectApply\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  SafeArrayIterator\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeWeakMap\x2C\x0d\n  String\x2C\x0d\n  StringPrototypeEndsWith\x2C\x0d\n  StringPrototypeIncludes\x2C\x0d\n  StringPrototypeMatch\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n  StringPrototypeStartsWith\x2C\x0d\n  StringPrototypeToLowerCase\x2C\x0d\n  Symbol\x2C\x0d\n  SymbolFor\x2C\x0d\n  SyntaxError\x2C\x0d\n  TypeError\x2C\x0d\n  URIError\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst kIsNodeError = Symbol('kIsNodeError');\x0d\n\x0d\nconst isWindows = process.platform === 'win32';\x0d\n\x0d\nconst messages = new SafeMap();\x0d\nconst codes = {};\x0d\n\x0d\nconst classRegExp = /^([A-Z][a-z0-9]*)+$/;\x0d\n// Sorted by a rough estimate on most frequently used entries.\x0d\nconst kTypes = [\x0d\n  'string'\x2C\x0d\n  'function'\x2C\x0d\n  'number'\x2C\x0d\n  'object'\x2C\x0d\n  // Accept 'Function' and 'Object' as alternative to the lower cased version.\x0d\n  'Function'\x2C\x0d\n  'Object'\x2C\x0d\n  'boolean'\x2C\x0d\n  'bigint'\x2C\x0d\n  'symbol'\x2C\x0d\n];\x0d\n\x0d\nconst MainContextError = Error;\x0d\nconst overrideStackTrace = new SafeWeakMap();\x0d\nconst kNoOverride = Symbol('kNoOverride');\x0d\nlet userStackTraceLimit;\x0d\nconst nodeInternalPrefix = '__node_internal_';\x0d\nconst prepareStackTrace = (globalThis\x2C error\x2C trace) => {\x0d\n  // API for node internals to override error stack formatting\x0d\n  // without interfering with userland code.\x0d\n  if (overrideStackTrace.has(error)) {\x0d\n    const f = overrideStackTrace.get(error);\x0d\n    overrideStackTrace.delete(error);\x0d\n    return f(error\x2C trace);\x0d\n  }\x0d\n\x0d\n  const firstFrame = trace[0]?.getFunctionName();\x0d\n  if (firstFrame && StringPrototypeStartsWith(firstFrame\x2C nodeInternalPrefix)) {\x0d\n    for (let l = trace.length - 1; l >= 0; l--) {\x0d\n      const fn = trace[l]?.getFunctionName();\x0d\n      if (fn && StringPrototypeStartsWith(fn\x2C nodeInternalPrefix)) {\x0d\n        ArrayPrototypeSplice(trace\x2C 0\x2C l + 1);\x0d\n        break;\x0d\n      }\x0d\n    }\x0d\n    // `userStackTraceLimit` is the user value for `Error.stackTraceLimit`\x2C\x0d\n    // it is updated at every new exception in `captureLargerStackTrace`.\x0d\n    if (trace.length > userStackTraceLimit)\x0d\n      ArrayPrototypeSplice(trace\x2C userStackTraceLimit);\x0d\n  }\x0d\n\x0d\n  const globalOverride =\x0d\n    maybeOverridePrepareStackTrace(globalThis\x2C error\x2C trace);\x0d\n  if (globalOverride !== kNoOverride) return globalOverride;\x0d\n\x0d\n  // Normal error formatting:\x0d\n  //\x0d\n  // Error: Message\x0d\n  //     at function (file)\x0d\n  //     at file\x0d\n  let errorString;\x0d\n  if (kIsNodeError in error) {\x0d\n    errorString = `${error.name} [${error.code}]: ${error.message}`;\x0d\n  } else {\x0d\n    errorString = ErrorPrototypeToString(error);\x0d\n  }\x0d\n  if (trace.length === 0) {\x0d\n    return errorString;\x0d\n  }\x0d\n  return `${errorString}\\n    at ${ArrayPrototypeJoin(trace\x2C '\\n    at ')}`;\x0d\n};\x0d\n\x0d\nconst maybeOverridePrepareStackTrace = (globalThis\x2C error\x2C trace) => {\x0d\n  // Polyfill of V8's Error.prepareStackTrace API.\x0d\n  // https://crbug.com/v8/7848\x0d\n  // `globalThis` is the global that contains the constructor which\x0d\n  // created `error`.\x0d\n  if (typeof globalThis.Error?.prepareStackTrace === 'function') {\x0d\n    return globalThis.Error.prepareStackTrace(error\x2C trace);\x0d\n  }\x0d\n  // We still have legacy usage that depends on the main context's `Error`\x0d\n  // being used\x2C even when the error is from a different context.\x0d\n  // TODO(devsnek): evaluate if this can be eventually deprecated/removed.\x0d\n  if (typeof MainContextError.prepareStackTrace === 'function') {\x0d\n    return MainContextError.prepareStackTrace(error\x2C trace);\x0d\n  }\x0d\n\x0d\n  return kNoOverride;\x0d\n};\x0d\n\x0d\nconst aggregateTwoErrors = hideStackFrames((innerError\x2C outerError) => {\x0d\n  if (innerError && outerError && innerError !== outerError) {\x0d\n    if (ArrayIsArray(outerError.errors)) {\x0d\n      // If `outerError` is already an `AggregateError`.\x0d\n      ArrayPrototypePush(outerError.errors\x2C innerError);\x0d\n      return outerError;\x0d\n    }\x0d\n    // eslint-disable-next-line no-restricted-syntax\x0d\n    const err = new AggregateError(new SafeArrayIterator([\x0d\n      outerError\x2C\x0d\n      innerError\x2C\x0d\n    ])\x2C outerError.message);\x0d\n    err.code = outerError.code;\x0d\n    return err;\x0d\n  }\x0d\n  return innerError || outerError;\x0d\n});\x0d\n\x0d\n// Lazily loaded\x0d\nlet util;\x0d\nlet assert;\x0d\n\x0d\nlet internalUtil = null;\x0d\nfunction lazyInternalUtil() {\x0d\n  if (!internalUtil) {\x0d\n    internalUtil = require('internal/util');\x0d\n  }\x0d\n  return internalUtil;\x0d\n}\x0d\n\x0d\nlet internalUtilInspect = null;\x0d\nfunction lazyInternalUtilInspect() {\x0d\n  if (!internalUtilInspect) {\x0d\n    internalUtilInspect = require('internal/util/inspect');\x0d\n  }\x0d\n  return internalUtilInspect;\x0d\n}\x0d\n\x0d\nlet buffer;\x0d\nfunction lazyBuffer() {\x0d\n  if (buffer === undefined)\x0d\n    buffer = require('buffer').Buffer;\x0d\n  return buffer;\x0d\n}\x0d\n\x0d\nfunction isErrorStackTraceLimitWritable() {\x0d\n  const desc = ObjectGetOwnPropertyDescriptor(Error\x2C 'stackTraceLimit');\x0d\n  if (desc === undefined) {\x0d\n    return ObjectIsExtensible(Error);\x0d\n  }\x0d\n\x0d\n  return ObjectPrototypeHasOwnProperty(desc\x2C 'writable') ?\x0d\n    desc.writable :\x0d\n    desc.set !== undefined;\x0d\n}\x0d\n\x0d\n// A specialized Error that includes an additional info property with\x0d\n// additional information about the error condition.\x0d\n// It has the properties present in a UVException but with a custom error\x0d\n// message followed by the uv error code and uv error message.\x0d\n// It also has its own error code with the original uv error context put into\x0d\n// `err.info`.\x0d\n// The context passed into this error must have .code\x2C .syscall and .message\x2C\x0d\n// and may have .path and .dest.\x0d\nclass SystemError extends Error {\x0d\n  constructor(key\x2C context) {\x0d\n    const limit = Error.stackTraceLimit;\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\x0d\n    super();\x0d\n    // Reset the limit and setting the name property.\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\x0d\n    const prefix = getMessage(key\x2C []\x2C this);\x0d\n    let message = `${prefix}: ${context.syscall} returned ` +\x0d\n                  `${context.code} (${context.message})`;\x0d\n\x0d\n    if (context.path !== undefined)\x0d\n      message += ` ${context.path}`;\x0d\n    if (context.dest !== undefined)\x0d\n      message += ` => ${context.dest}`;\x0d\n\x0d\n    captureLargerStackTrace(this);\x0d\n\x0d\n    this.code = key;\x0d\n\x0d\n    ObjectDefineProperties(this\x2C {\x0d\n      [kIsNodeError]: {\x0d\n        value: true\x2C\x0d\n        enumerable: false\x2C\x0d\n        writable: false\x2C\x0d\n        configurable: true\x2C\x0d\n      }\x2C\x0d\n      name: {\x0d\n        value: 'SystemError'\x2C\x0d\n        enumerable: false\x2C\x0d\n        writable: true\x2C\x0d\n        configurable: true\x2C\x0d\n      }\x2C\x0d\n      message: {\x0d\n        value: message\x2C\x0d\n        enumerable: false\x2C\x0d\n        writable: true\x2C\x0d\n        configurable: true\x2C\x0d\n      }\x2C\x0d\n      info: {\x0d\n        value: context\x2C\x0d\n        enumerable: true\x2C\x0d\n        configurable: true\x2C\x0d\n        writable: false\x2C\x0d\n      }\x2C\x0d\n      errno: {\x0d\n        get() {\x0d\n          return context.errno;\x0d\n        }\x2C\x0d\n        set: (value) => {\x0d\n          context.errno = value;\x0d\n        }\x2C\x0d\n        enumerable: true\x2C\x0d\n        configurable: true\x2C\x0d\n      }\x2C\x0d\n      syscall: {\x0d\n        get() {\x0d\n          return context.syscall;\x0d\n        }\x2C\x0d\n        set: (value) => {\x0d\n          context.syscall = value;\x0d\n        }\x2C\x0d\n        enumerable: true\x2C\x0d\n        configurable: true\x2C\x0d\n      }\x2C\x0d\n    });\x0d\n\x0d\n    if (context.path !== undefined) {\x0d\n      // TODO(BridgeAR): Investigate why and when the `.toString()` was\x0d\n      // introduced. The `path` and `dest` properties in the context seem to\x0d\n      // always be of type string. We should probably just remove the\x0d\n      // `.toString()` and `Buffer.from()` operations and set the value on the\x0d\n      // context as the user did.\x0d\n      ObjectDefineProperty(this\x2C 'path'\x2C {\x0d\n        get() {\x0d\n          return context.path != null ?\x0d\n            context.path.toString() : context.path;\x0d\n        }\x2C\x0d\n        set: (value) => {\x0d\n          context.path = value ?\x0d\n            lazyBuffer().from(value.toString()) : undefined;\x0d\n        }\x2C\x0d\n        enumerable: true\x2C\x0d\n        configurable: true\x0d\n      });\x0d\n    }\x0d\n\x0d\n    if (context.dest !== undefined) {\x0d\n      ObjectDefineProperty(this\x2C 'dest'\x2C {\x0d\n        get() {\x0d\n          return context.dest != null ?\x0d\n            context.dest.toString() : context.dest;\x0d\n        }\x2C\x0d\n        set: (value) => {\x0d\n          context.dest = value ?\x0d\n            lazyBuffer().from(value.toString()) : undefined;\x0d\n        }\x2C\x0d\n        enumerable: true\x2C\x0d\n        configurable: true\x0d\n      });\x0d\n    }\x0d\n  }\x0d\n\x0d\n  toString() {\x0d\n    return `${this.name} [${this.code}]: ${this.message}`;\x0d\n  }\x0d\n\x0d\n  [SymbolFor('nodejs.util.inspect.custom')](recurseTimes\x2C ctx) {\x0d\n    return lazyInternalUtilInspect().inspect(this\x2C {\x0d\n      ...ctx\x2C\x0d\n      getters: true\x2C\x0d\n      customInspect: false\x0d\n    });\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction makeSystemErrorWithCode(key) {\x0d\n  return class NodeError extends SystemError {\x0d\n    constructor(ctx) {\x0d\n      super(key\x2C ctx);\x0d\n    }\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction makeNodeErrorWithCode(Base\x2C key) {\x0d\n  return function NodeError(...args) {\x0d\n    const limit = Error.stackTraceLimit;\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\x0d\n    const error = new Base();\x0d\n    // Reset the limit and setting the name property.\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = limit;\x0d\n    const message = getMessage(key\x2C args\x2C error);\x0d\n    ObjectDefineProperties(error\x2C {\x0d\n      [kIsNodeError]: {\x0d\n        value: true\x2C\x0d\n        enumerable: false\x2C\x0d\n        writable: false\x2C\x0d\n        configurable: true\x2C\x0d\n      }\x2C\x0d\n      message: {\x0d\n        value: message\x2C\x0d\n        enumerable: false\x2C\x0d\n        writable: true\x2C\x0d\n        configurable: true\x2C\x0d\n      }\x2C\x0d\n      toString: {\x0d\n        value() {\x0d\n          return `${this.name} [${key}]: ${this.message}`;\x0d\n        }\x2C\x0d\n        enumerable: false\x2C\x0d\n        writable: true\x2C\x0d\n        configurable: true\x2C\x0d\n      }\x2C\x0d\n    });\x0d\n    captureLargerStackTrace(error);\x0d\n    error.code = key;\x0d\n    return error;\x0d\n  };\x0d\n}\x0d\n\x0d\n/**\x0d\n * This function removes unnecessary frames from Node.js core errors.\x0d\n * @template {(...args: any[]) => any} T\x0d\n * @type {(fn: T) => T}\x0d\n */\x0d\nfunction hideStackFrames(fn) {\x0d\n  // We rename the functions that will be hidden to cut off the stacktrace\x0d\n  // at the outermost one\x0d\n  const hidden = nodeInternalPrefix + fn.name;\x0d\n  ObjectDefineProperty(fn\x2C 'name'\x2C { value: hidden });\x0d\n  return fn;\x0d\n}\x0d\n\x0d\n// Utility function for registering the error codes. Only used here. Exported\x0d\n// *only* to allow for testing.\x0d\nfunction E(sym\x2C val\x2C def\x2C ...otherClasses) {\x0d\n  // Special case for SystemError that formats the error message differently\x0d\n  // The SystemErrors only have SystemError as their base classes.\x0d\n  messages.set(sym\x2C val);\x0d\n  if (def === SystemError) {\x0d\n    def = makeSystemErrorWithCode(sym);\x0d\n  } else {\x0d\n    def = makeNodeErrorWithCode(def\x2C sym);\x0d\n  }\x0d\n\x0d\n  if (otherClasses.length !== 0) {\x0d\n    otherClasses.forEach((clazz) => {\x0d\n      def[clazz.name] = makeNodeErrorWithCode(clazz\x2C sym);\x0d\n    });\x0d\n  }\x0d\n  codes[sym] = def;\x0d\n}\x0d\n\x0d\nfunction getMessage(key\x2C args\x2C self) {\x0d\n  const msg = messages.get(key);\x0d\n\x0d\n  if (assert === undefined) assert = require('internal/assert');\x0d\n\x0d\n  if (typeof msg === 'function') {\x0d\n    assert(\x0d\n      msg.length <= args.length\x2C // Default options do not count.\x0d\n      `Code: ${key}; The provided arguments length (${args.length}) does not ` +\x0d\n        `match the required ones (${msg.length}).`\x0d\n    );\x0d\n    return ReflectApply(msg\x2C self\x2C args);\x0d\n  }\x0d\n\x0d\n  const expectedLength =\x0d\n    (StringPrototypeMatch(msg\x2C /%[dfijoOs]/g) || []).length;\x0d\n  assert(\x0d\n    expectedLength === args.length\x2C\x0d\n    `Code: ${key}; The provided arguments length (${args.length}) does not ` +\x0d\n      `match the required ones (${expectedLength}).`\x0d\n  );\x0d\n  if (args.length === 0)\x0d\n    return msg;\x0d\n\x0d\n  ArrayPrototypeUnshift(args\x2C msg);\x0d\n  return ReflectApply(lazyInternalUtilInspect().format\x2C null\x2C args);\x0d\n}\x0d\n\x0d\nlet uvBinding;\x0d\n\x0d\nfunction lazyUv() {\x0d\n  if (!uvBinding) {\x0d\n    uvBinding = internalBinding('uv');\x0d\n  }\x0d\n  return uvBinding;\x0d\n}\x0d\n\x0d\nconst uvUnmappedError = ['UNKNOWN'\x2C 'unknown error'];\x0d\n\x0d\nfunction uvErrmapGet(name) {\x0d\n  uvBinding = lazyUv();\x0d\n  if (!uvBinding.errmap) {\x0d\n    uvBinding.errmap = uvBinding.getErrorMap();\x0d\n  }\x0d\n  return MapPrototypeGet(uvBinding.errmap\x2C name);\x0d\n}\x0d\n\x0d\nconst captureLargerStackTrace = hideStackFrames(\x0d\n  function captureLargerStackTrace(err) {\x0d\n    const stackTraceLimitIsWritable = isErrorStackTraceLimitWritable();\x0d\n    if (stackTraceLimitIsWritable) {\x0d\n      userStackTraceLimit = Error.stackTraceLimit;\x0d\n      Error.stackTraceLimit = Infinity;\x0d\n    }\x0d\n    ErrorCaptureStackTrace(err);\x0d\n    // Reset the limit\x0d\n    if (stackTraceLimitIsWritable) Error.stackTraceLimit = userStackTraceLimit;\x0d\n\x0d\n    return err;\x0d\n  });\x0d\n\x0d\n/**\x0d\n * This creates an error compatible with errors produced in the C++\x0d\n * function UVException using a context object with data assembled in C++.\x0d\n * The goal is to migrate them to ERR_* errors later when compatibility is\x0d\n * not a concern.\x0d\n *\x0d\n * @param {object} ctx\x0d\n * @returns {Error}\x0d\n */\x0d\nconst uvException = hideStackFrames(function uvException(ctx) {\x0d\n  const { 0: code\x2C 1: uvmsg } = uvErrmapGet(ctx.errno) || uvUnmappedError;\x0d\n  let message = `${code}: ${ctx.message || uvmsg}\x2C ${ctx.syscall}`;\x0d\n\x0d\n  let path;\x0d\n  let dest;\x0d\n  if (ctx.path) {\x0d\n    path = ctx.path.toString();\x0d\n    message += ` '${path}'`;\x0d\n  }\x0d\n  if (ctx.dest) {\x0d\n    dest = ctx.dest.toString();\x0d\n    message += ` -> '${dest}'`;\x0d\n  }\x0d\n\x0d\n  // Reducing the limit improves the performance significantly. We do not lose\x0d\n  // the stack frames due to the `captureStackTrace()` function that is called\x0d\n  // later.\x0d\n  const tmpLimit = Error.stackTraceLimit;\x0d\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\x0d\n  // Pass the message to the constructor instead of setting it on the object\x0d\n  // to make sure it is the same as the one created in C++\x0d\n  // eslint-disable-next-line no-restricted-syntax\x0d\n  const err = new Error(message);\x0d\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\x0d\n\x0d\n  for (const prop of ObjectKeys(ctx)) {\x0d\n    if (prop === 'message' || prop === 'path' || prop === 'dest') {\x0d\n      continue;\x0d\n    }\x0d\n    err[prop] = ctx[prop];\x0d\n  }\x0d\n\x0d\n  err.code = code;\x0d\n  if (path) {\x0d\n    err.path = path;\x0d\n  }\x0d\n  if (dest) {\x0d\n    err.dest = dest;\x0d\n  }\x0d\n\x0d\n  return captureLargerStackTrace(err);\x0d\n});\x0d\n\x0d\n/**\x0d\n * This creates an error compatible with errors produced in the C++\x0d\n * This function should replace the deprecated\x0d\n * `exceptionWithHostPort()` function.\x0d\n *\x0d\n * @param {number} err - A libuv error number\x0d\n * @param {string} syscall\x0d\n * @param {string} address\x0d\n * @param {number} [port]\x0d\n * @returns {Error}\x0d\n */\x0d\nconst uvExceptionWithHostPort = hideStackFrames(\x0d\n  function uvExceptionWithHostPort(err\x2C syscall\x2C address\x2C port) {\x0d\n    const { 0: code\x2C 1: uvmsg } = uvErrmapGet(err) || uvUnmappedError;\x0d\n    const message = `${syscall} ${code}: ${uvmsg}`;\x0d\n    let details = '';\x0d\n\x0d\n    if (port && port > 0) {\x0d\n      details = ` ${address}:${port}`;\x0d\n    } else if (address) {\x0d\n      details = ` ${address}`;\x0d\n    }\x0d\n\x0d\n    // Reducing the limit improves the performance significantly. We do not\x0d\n    // lose the stack frames due to the `captureStackTrace()` function that\x0d\n    // is called later.\x0d\n    const tmpLimit = Error.stackTraceLimit;\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\x0d\n    // eslint-disable-next-line no-restricted-syntax\x0d\n    const ex = new Error(`${message}${details}`);\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\x0d\n    ex.code = code;\x0d\n    ex.errno = err;\x0d\n    ex.syscall = syscall;\x0d\n    ex.address = address;\x0d\n    if (port) {\x0d\n      ex.port = port;\x0d\n    }\x0d\n\x0d\n    return captureLargerStackTrace(ex);\x0d\n  });\x0d\n\x0d\n/**\x0d\n * This used to be util._errnoException().\x0d\n *\x0d\n * @param {number} err - A libuv error number\x0d\n * @param {string} syscall\x0d\n * @param {string} [original]\x0d\n * @returns {Error}\x0d\n */\x0d\nconst errnoException = hideStackFrames(\x0d\n  function errnoException(err\x2C syscall\x2C original) {\x0d\n    // TODO(joyeecheung): We have to use the type-checked\x0d\n    // getSystemErrorName(err) to guard against invalid arguments from users.\x0d\n    // This can be replaced with [ code ] = errmap.get(err) when this method\x0d\n    // is no longer exposed to user land.\x0d\n    if (util === undefined) util = require('util');\x0d\n    const code = util.getSystemErrorName(err);\x0d\n    const message = original ?\x0d\n      `${syscall} ${code} ${original}` : `${syscall} ${code}`;\x0d\n\x0d\n    const tmpLimit = Error.stackTraceLimit;\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\x0d\n    // eslint-disable-next-line no-restricted-syntax\x0d\n    const ex = new Error(message);\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\x0d\n    ex.errno = err;\x0d\n    ex.code = code;\x0d\n    ex.syscall = syscall;\x0d\n\x0d\n    return captureLargerStackTrace(ex);\x0d\n  });\x0d\n\x0d\n/**\x0d\n * Deprecated\x2C new function is `uvExceptionWithHostPort()`\x0d\n * New function added the error description directly\x0d\n * from C++. this method for backwards compatibility\x0d\n * @param {number} err - A libuv error number\x0d\n * @param {string} syscall\x0d\n * @param {string} address\x0d\n * @param {number} [port]\x0d\n * @param {string} [additional]\x0d\n * @returns {Error}\x0d\n */\x0d\nconst exceptionWithHostPort = hideStackFrames(\x0d\n  function exceptionWithHostPort(err\x2C syscall\x2C address\x2C port\x2C additional) {\x0d\n    // TODO(joyeecheung): We have to use the type-checked\x0d\n    // getSystemErrorName(err) to guard against invalid arguments from users.\x0d\n    // This can be replaced with [ code ] = errmap.get(err) when this method\x0d\n    // is no longer exposed to user land.\x0d\n    if (util === undefined) util = require('util');\x0d\n    const code = util.getSystemErrorName(err);\x0d\n    let details = '';\x0d\n    if (port && port > 0) {\x0d\n      details = ` ${address}:${port}`;\x0d\n    } else if (address) {\x0d\n      details = ` ${address}`;\x0d\n    }\x0d\n    if (additional) {\x0d\n      details += ` - Local (${additional})`;\x0d\n    }\x0d\n\x0d\n    // Reducing the limit improves the performance significantly. We do not\x0d\n    // lose the stack frames due to the `captureStackTrace()` function that\x0d\n    // is called later.\x0d\n    const tmpLimit = Error.stackTraceLimit;\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\x0d\n    // eslint-disable-next-line no-restricted-syntax\x0d\n    const ex = new Error(`${syscall} ${code}${details}`);\x0d\n    if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\x0d\n    ex.errno = err;\x0d\n    ex.code = code;\x0d\n    ex.syscall = syscall;\x0d\n    ex.address = address;\x0d\n    if (port) {\x0d\n      ex.port = port;\x0d\n    }\x0d\n\x0d\n    return captureLargerStackTrace(ex);\x0d\n  });\x0d\n\x0d\n/**\x0d\n * @param {number|string} code - A libuv error number or a c-ares error code\x0d\n * @param {string} syscall\x0d\n * @param {string} [hostname]\x0d\n * @returns {Error}\x0d\n */\x0d\nconst dnsException = hideStackFrames(function(code\x2C syscall\x2C hostname) {\x0d\n  let errno;\x0d\n  // If `code` is of type number\x2C it is a libuv error number\x2C else it is a\x0d\n  // c-ares error code.\x0d\n  // TODO(joyeecheung): translate c-ares error codes into numeric ones and\x0d\n  // make them available in a property that's not error.errno (since they\x0d\n  // can be in conflict with libuv error codes). Also make sure\x0d\n  // util.getSystemErrorName() can understand them when an being informed that\x0d\n  // the number is a c-ares error code.\x0d\n  if (typeof code === 'number') {\x0d\n    errno = code;\x0d\n    // ENOTFOUND is not a proper POSIX error\x2C but this error has been in place\x0d\n    // long enough that it's not practical to remove it.\x0d\n    if (code === lazyUv().UV_EAI_NODATA || code === lazyUv().UV_EAI_NONAME) {\x0d\n      code = 'ENOTFOUND'; // Fabricated error name.\x0d\n    } else {\x0d\n      code = lazyInternalUtil().getSystemErrorName(code);\x0d\n    }\x0d\n  }\x0d\n  const message = `${syscall} ${code}${hostname ? ` ${hostname}` : ''}`;\x0d\n  // Reducing the limit improves the performance significantly. We do not lose\x0d\n  // the stack frames due to the `captureStackTrace()` function that is called\x0d\n  // later.\x0d\n  const tmpLimit = Error.stackTraceLimit;\x0d\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = 0;\x0d\n  // eslint-disable-next-line no-restricted-syntax\x0d\n  const ex = new Error(message);\x0d\n  if (isErrorStackTraceLimitWritable()) Error.stackTraceLimit = tmpLimit;\x0d\n  ex.errno = errno;\x0d\n  ex.code = code;\x0d\n  ex.syscall = syscall;\x0d\n  if (hostname) {\x0d\n    ex.hostname = hostname;\x0d\n  }\x0d\n\x0d\n  return captureLargerStackTrace(ex);\x0d\n});\x0d\n\x0d\nfunction connResetException(msg) {\x0d\n  // eslint-disable-next-line no-restricted-syntax\x0d\n  const ex = new Error(msg);\x0d\n  ex.code = 'ECONNRESET';\x0d\n  return ex;\x0d\n}\x0d\n\x0d\nlet maxStack_ErrorName;\x0d\nlet maxStack_ErrorMessage;\x0d\n/**\x0d\n * Returns true if `err.name` and `err.message` are equal to engine-specific\x0d\n * values indicating max call stack size has been exceeded.\x0d\n * "Maximum call stack size exceeded" in V8.\x0d\n *\x0d\n * @param {Error} err\x0d\n * @returns {boolean}\x0d\n */\x0d\nfunction isStackOverflowError(err) {\x0d\n  if (maxStack_ErrorMessage === undefined) {\x0d\n    try {\x0d\n      function overflowStack() { overflowStack(); }\x0d\n      overflowStack();\x0d\n    } catch (err) {\x0d\n      maxStack_ErrorMessage = err.message;\x0d\n      maxStack_ErrorName = err.name;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return err && err.name === maxStack_ErrorName &&\x0d\n         err.message === maxStack_ErrorMessage;\x0d\n}\x0d\n\x0d\n// Only use this for integers! Decimal numbers do not work with this function.\x0d\nfunction addNumericalSeparator(val) {\x0d\n  let res = '';\x0d\n  let i = val.length;\x0d\n  const start = val[0] === '-' ? 1 : 0;\x0d\n  for (; i >= start + 4; i -= 3) {\x0d\n    res = `_${StringPrototypeSlice(val\x2C i - 3\x2C i)}${res}`;\x0d\n  }\x0d\n  return `${StringPrototypeSlice(val\x2C 0\x2C i)}${res}`;\x0d\n}\x0d\n\x0d\n// Used to enhance the stack that will be picked up by the inspector\x0d\nconst kEnhanceStackBeforeInspector = Symbol('kEnhanceStackBeforeInspector');\x0d\n\x0d\n// These are supposed to be called only on fatal exceptions before\x0d\n// the process exits.\x0d\nconst fatalExceptionStackEnhancers = {\x0d\n  beforeInspector(error) {\x0d\n    if (typeof error[kEnhanceStackBeforeInspector] !== 'function') {\x0d\n      return error.stack;\x0d\n    }\x0d\n\x0d\n    try {\x0d\n      // Set the error.stack here so it gets picked up by the\x0d\n      // inspector.\x0d\n      error.stack = error[kEnhanceStackBeforeInspector]();\x0d\n    } catch {\x0d\n      // We are just enhancing the error. If it fails\x2C ignore it.\x0d\n    }\x0d\n    return error.stack;\x0d\n  }\x2C\x0d\n  afterInspector(error) {\x0d\n    const originalStack = error.stack;\x0d\n    let useColors = true;\x0d\n    // Some consoles do not convert ANSI escape sequences to colors\x2C\x0d\n    // rather display them directly to the stdout. On those consoles\x2C\x0d\n    // libuv emulates colors by intercepting stdout stream and calling\x0d\n    // corresponding Windows API functions for setting console colors.\x0d\n    // However\x2C fatal error are handled differently and we cannot easily\x0d\n    // highlight them. On Windows\x2C detecting whether a console supports\x0d\n    // ANSI escape sequences is not reliable.\x0d\n    if (process.platform === 'win32') {\x0d\n      const info = internalBinding('os').getOSInformation();\x0d\n      const ver = ArrayPrototypeMap(StringPrototypeSplit(info[2]\x2C '.')\x2C\x0d\n                                    Number);\x0d\n      if (ver[0] !== 10 || ver[2] < 14393) {\x0d\n        useColors = false;\x0d\n      }\x0d\n    }\x0d\n    const {\x0d\n      inspect\x2C\x0d\n      inspectDefaultOptions: {\x0d\n        colors: defaultColors\x0d\n      }\x0d\n    } = lazyInternalUtilInspect();\x0d\n    const colors = useColors &&\x0d\n                   ((internalBinding('util').guessHandleType(2) === 'TTY' &&\x0d\n                   require('internal/tty').hasColors()) ||\x0d\n                   defaultColors);\x0d\n    try {\x0d\n      return inspect(error\x2C {\x0d\n        colors\x2C\x0d\n        customInspect: false\x2C\x0d\n        depth: MathMax(inspect.defaultOptions.depth\x2C 5)\x0d\n      });\x0d\n    } catch {\x0d\n      return originalStack;\x0d\n    }\x0d\n  }\x0d\n};\x0d\n\x0d\n// Ensures the printed error line is from user code.\x0d\nlet _kArrowMessagePrivateSymbol\x2C _setHiddenValue;\x0d\nfunction setArrowMessage(err\x2C arrowMessage) {\x0d\n  if (!_kArrowMessagePrivateSymbol) {\x0d\n    ({\x0d\n      arrow_message_private_symbol: _kArrowMessagePrivateSymbol\x2C\x0d\n      setHiddenValue: _setHiddenValue\x2C\x0d\n    } = internalBinding('util'));\x0d\n  }\x0d\n  _setHiddenValue(err\x2C _kArrowMessagePrivateSymbol\x2C arrowMessage);\x0d\n}\x0d\n\x0d\n// Hide stack lines before the first user code line.\x0d\nfunction hideInternalStackFrames(error) {\x0d\n  overrideStackTrace.set(error\x2C (error\x2C stackFrames) => {\x0d\n    let frames = stackFrames;\x0d\n    if (typeof stackFrames === 'object') {\x0d\n      frames = ArrayPrototypeFilter(\x0d\n        stackFrames\x2C\x0d\n        (frm) => !StringPrototypeStartsWith(frm.getFileName() || ''\x2C\x0d\n                                            'node:internal')\x0d\n      );\x0d\n    }\x0d\n    ArrayPrototypeUnshift(frames\x2C error);\x0d\n    return ArrayPrototypeJoin(frames\x2C '\\n    at ');\x0d\n  });\x0d\n}\x0d\n\x0d\n// Node uses an AbortError that isn't exactly the same as the DOMException\x0d\n// to make usage of the error in userland and readable-stream easier.\x0d\n// It is a regular error with `.code` and `.name`.\x0d\nclass AbortError extends Error {\x0d\n  constructor(message = 'The operation was aborted'\x2C options = undefined) {\x0d\n    if (options !== undefined && typeof options !== 'object') {\x0d\n      throw new codes.ERR_INVALID_ARG_TYPE('options'\x2C 'Object'\x2C options);\x0d\n    }\x0d\n    super(message\x2C options);\x0d\n    this.code = 'ABORT_ERR';\x0d\n    this.name = 'AbortError';\x0d\n  }\x0d\n}\x0d\nmodule.exports = {\x0d\n  aggregateTwoErrors\x2C\x0d\n  codes\x2C\x0d\n  dnsException\x2C\x0d\n  errnoException\x2C\x0d\n  exceptionWithHostPort\x2C\x0d\n  getMessage\x2C\x0d\n  hideStackFrames\x2C\x0d\n  hideInternalStackFrames\x2C\x0d\n  isErrorStackTraceLimitWritable\x2C\x0d\n  isStackOverflowError\x2C\x0d\n  setArrowMessage\x2C\x0d\n  connResetException\x2C\x0d\n  uvErrmapGet\x2C\x0d\n  uvException\x2C\x0d\n  uvExceptionWithHostPort\x2C\x0d\n  SystemError\x2C\x0d\n  AbortError\x2C\x0d\n  // This is exported only to facilitate testing.\x0d\n  E\x2C\x0d\n  kNoOverride\x2C\x0d\n  prepareStackTrace\x2C\x0d\n  maybeOverridePrepareStackTrace\x2C\x0d\n  overrideStackTrace\x2C\x0d\n  kEnhanceStackBeforeInspector\x2C\x0d\n  fatalExceptionStackEnhancers\x2C\x0d\n  kIsNodeError\x2C\x0d\n  captureLargerStackTrace\x2C\x0d\n};\x0d\n\x0d\n// To declare an error message\x2C use the E(sym\x2C val\x2C def) function above. The sym\x0d\n// must be an upper case string. The val can be either a function or a string.\x0d\n// The def must be an error class.\x0d\n// The return value of the function must be a string.\x0d\n// Examples:\x0d\n// E('EXAMPLE_KEY1'\x2C 'This is the error value'\x2C Error);\x0d\n// E('EXAMPLE_KEY2'\x2C (a\x2C b) => return `${a} ${b}`\x2C RangeError);\x0d\n//\x0d\n// Once an error code has been assigned\x2C the code itself MUST NOT change and\x0d\n// any given error code must never be reused to identify a different error.\x0d\n//\x0d\n// Any error code added here should also be added to the documentation\x0d\n//\x0d\n// Note: Please try to keep these in alphabetical order\x0d\n//\x0d\n// Note: Node.js specific errors must begin with the prefix ERR_\x0d\n\x0d\nE('ERR_AMBIGUOUS_ARGUMENT'\x2C 'The "%s" argument is ambiguous. %s'\x2C TypeError);\x0d\nE('ERR_ARG_NOT_ITERABLE'\x2C '%s must be iterable'\x2C TypeError);\x0d\nE('ERR_ASSERTION'\x2C '%s'\x2C Error);\x0d\nE('ERR_ASYNC_CALLBACK'\x2C '%s must be a function'\x2C TypeError);\x0d\nE('ERR_ASYNC_TYPE'\x2C 'Invalid name for async "type": %s'\x2C TypeError);\x0d\nE('ERR_BROTLI_INVALID_PARAM'\x2C '%s is not a valid Brotli parameter'\x2C RangeError);\x0d\nE('ERR_BUFFER_OUT_OF_BOUNDS'\x2C\x0d\n  // Using a default argument here is important so the argument is not counted\x0d\n  // towards `Function#length`.\x0d\n  (name = undefined) => {\x0d\n    if (name) {\x0d\n      return `"${name}" is outside of buffer bounds`;\x0d\n    }\x0d\n    return 'Attempt to access memory outside buffer bounds';\x0d\n  }\x2C RangeError);\x0d\nE('ERR_BUFFER_TOO_LARGE'\x2C\x0d\n  'Cannot create a Buffer larger than %s bytes'\x2C\x0d\n  RangeError);\x0d\nE('ERR_CANNOT_WATCH_SIGINT'\x2C 'Cannot watch for SIGINT signals'\x2C Error);\x0d\nE('ERR_CHILD_CLOSED_BEFORE_REPLY'\x2C\x0d\n  'Child closed before reply received'\x2C Error);\x0d\nE('ERR_CHILD_PROCESS_IPC_REQUIRED'\x2C\x0d\n  "Forked processes must have an IPC channel\x2C missing value 'ipc' in %s"\x2C\x0d\n  Error);\x0d\nE('ERR_CHILD_PROCESS_STDIO_MAXBUFFER'\x2C '%s maxBuffer length exceeded'\x2C\x0d\n  RangeError);\x0d\nE('ERR_CONSOLE_WRITABLE_STREAM'\x2C\x0d\n  'Console expects a writable stream instance for %s'\x2C TypeError);\x0d\nE('ERR_CONTEXT_NOT_INITIALIZED'\x2C 'context used is not initialized'\x2C Error);\x0d\nE('ERR_CRYPTO_CUSTOM_ENGINE_NOT_SUPPORTED'\x2C\x0d\n  'Custom engines not supported by this OpenSSL'\x2C Error);\x0d\nE('ERR_CRYPTO_ECDH_INVALID_FORMAT'\x2C 'Invalid ECDH format: %s'\x2C TypeError);\x0d\nE('ERR_CRYPTO_ECDH_INVALID_PUBLIC_KEY'\x2C\x0d\n  'Public key is not valid for specified curve'\x2C Error);\x0d\nE('ERR_CRYPTO_ENGINE_UNKNOWN'\x2C 'Engine "%s" was not found'\x2C Error);\x0d\nE('ERR_CRYPTO_FIPS_FORCED'\x2C\x0d\n  'Cannot set FIPS mode\x2C it was forced with --force-fips at startup.'\x2C Error);\x0d\nE('ERR_CRYPTO_FIPS_UNAVAILABLE'\x2C 'Cannot set FIPS mode in a non-FIPS build.'\x2C\x0d\n  Error);\x0d\nE('ERR_CRYPTO_HASH_FINALIZED'\x2C 'Digest already called'\x2C Error);\x0d\nE('ERR_CRYPTO_HASH_UPDATE_FAILED'\x2C 'Hash update failed'\x2C Error);\x0d\nE('ERR_CRYPTO_INCOMPATIBLE_KEY'\x2C 'Incompatible %s: %s'\x2C Error);\x0d\nE('ERR_CRYPTO_INCOMPATIBLE_KEY_OPTIONS'\x2C 'The selected key encoding %s %s.'\x2C\x0d\n  Error);\x0d\nE('ERR_CRYPTO_INVALID_DIGEST'\x2C 'Invalid digest: %s'\x2C TypeError);\x0d\nE('ERR_CRYPTO_INVALID_JWK'\x2C 'Invalid JWK data'\x2C TypeError);\x0d\nE('ERR_CRYPTO_INVALID_KEY_OBJECT_TYPE'\x2C\x0d\n  'Invalid key object type %s\x2C expected %s.'\x2C TypeError);\x0d\nE('ERR_CRYPTO_INVALID_STATE'\x2C 'Invalid state for operation %s'\x2C Error);\x0d\nE('ERR_CRYPTO_PBKDF2_ERROR'\x2C 'PBKDF2 error'\x2C Error);\x0d\nE('ERR_CRYPTO_SCRYPT_INVALID_PARAMETER'\x2C 'Invalid scrypt parameter'\x2C Error);\x0d\nE('ERR_CRYPTO_SCRYPT_NOT_SUPPORTED'\x2C 'Scrypt algorithm not supported'\x2C Error);\x0d\n// Switch to TypeError. The current implementation does not seem right.\x0d\nE('ERR_CRYPTO_SIGN_KEY_REQUIRED'\x2C 'No key provided to sign'\x2C Error);\x0d\nE('ERR_DEBUGGER_ERROR'\x2C '%s'\x2C Error);\x0d\nE('ERR_DEBUGGER_STARTUP_ERROR'\x2C '%s'\x2C Error);\x0d\nE('ERR_DIR_CLOSED'\x2C 'Directory handle was closed'\x2C Error);\x0d\nE('ERR_DIR_CONCURRENT_OPERATION'\x2C\x0d\n  'Cannot do synchronous work on directory handle with concurrent ' +\x0d\n  'asynchronous operations'\x2C Error);\x0d\nE('ERR_DNS_SET_SERVERS_FAILED'\x2C 'c-ares failed to set servers: "%s" [%s]'\x2C\x0d\n  Error);\x0d\nE('ERR_DOMAIN_CALLBACK_NOT_AVAILABLE'\x2C\x0d\n  'A callback was registered through ' +\x0d\n     'process.setUncaughtExceptionCaptureCallback()\x2C which is mutually ' +\x0d\n     'exclusive with using the `domain` module'\x2C\x0d\n  Error);\x0d\nE('ERR_DOMAIN_CANNOT_SET_UNCAUGHT_EXCEPTION_CAPTURE'\x2C\x0d\n  'The `domain` module is in use\x2C which is mutually exclusive with calling ' +\x0d\n     'process.setUncaughtExceptionCaptureCallback()'\x2C\x0d\n  Error);\x0d\nE('ERR_ENCODING_INVALID_ENCODED_DATA'\x2C function(encoding\x2C ret) {\x0d\n  this.errno = ret;\x0d\n  return `The encoded data was not valid for encoding ${encoding}`;\x0d\n}\x2C TypeError);\x0d\nE('ERR_ENCODING_NOT_SUPPORTED'\x2C 'The "%s" encoding is not supported'\x2C\x0d\n  RangeError);\x0d\nE('ERR_EVAL_ESM_CANNOT_PRINT'\x2C '--print cannot be used with ESM input'\x2C Error);\x0d\nE('ERR_EVENT_RECURSION'\x2C 'The event "%s" is already being dispatched'\x2C Error);\x0d\nE('ERR_FALSY_VALUE_REJECTION'\x2C function(reason) {\x0d\n  this.reason = reason;\x0d\n  return 'Promise was rejected with falsy value';\x0d\n}\x2C Error);\x0d\nE('ERR_FEATURE_UNAVAILABLE_ON_PLATFORM'\x2C\x0d\n  'The feature %s is unavailable on the current platform' +\x0d\n  '\x2C which is being used to run Node.js'\x2C\x0d\n  TypeError);\x0d\nE('ERR_FS_CP_DIR_TO_NON_DIR'\x2C\x0d\n  'Cannot overwrite directory with non-directory'\x2C SystemError);\x0d\nE('ERR_FS_CP_EEXIST'\x2C 'Target already exists'\x2C SystemError);\x0d\nE('ERR_FS_CP_EINVAL'\x2C 'Invalid src or dest'\x2C SystemError);\x0d\nE('ERR_FS_CP_FIFO_PIPE'\x2C 'Cannot copy a FIFO pipe'\x2C SystemError);\x0d\nE('ERR_FS_CP_NON_DIR_TO_DIR'\x2C\x0d\n  'Cannot overwrite non-directory with directory'\x2C SystemError);\x0d\nE('ERR_FS_CP_SOCKET'\x2C 'Cannot copy a socket file'\x2C SystemError);\x0d\nE('ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY'\x2C\x0d\n  'Cannot overwrite symlink in subdirectory of self'\x2C SystemError);\x0d\nE('ERR_FS_CP_UNKNOWN'\x2C 'Cannot copy an unknown file type'\x2C SystemError);\x0d\nE('ERR_FS_EISDIR'\x2C 'Path is a directory'\x2C SystemError);\x0d\nE('ERR_FS_FILE_TOO_LARGE'\x2C 'File size (%s) is greater than 2 GB'\x2C RangeError);\x0d\nE('ERR_FS_INVALID_SYMLINK_TYPE'\x2C\x0d\n  'Symlink type must be one of "dir"\x2C "file"\x2C or "junction". Received "%s"'\x2C\x0d\n  Error); // Switch to TypeError. The current implementation does not seem right\x0d\nE('ERR_HTTP2_ALTSVC_INVALID_ORIGIN'\x2C\x0d\n  'HTTP/2 ALTSVC frames require a valid origin'\x2C TypeError);\x0d\nE('ERR_HTTP2_ALTSVC_LENGTH'\x2C\x0d\n  'HTTP/2 ALTSVC frames are limited to 16382 bytes'\x2C TypeError);\x0d\nE('ERR_HTTP2_CONNECT_AUTHORITY'\x2C\x0d\n  ':authority header is required for CONNECT requests'\x2C Error);\x0d\nE('ERR_HTTP2_CONNECT_PATH'\x2C\x0d\n  'The :path header is forbidden for CONNECT requests'\x2C Error);\x0d\nE('ERR_HTTP2_CONNECT_SCHEME'\x2C\x0d\n  'The :scheme header is forbidden for CONNECT requests'\x2C Error);\x0d\nE('ERR_HTTP2_GOAWAY_SESSION'\x2C\x0d\n  'New streams cannot be created after receiving a GOAWAY'\x2C Error);\x0d\nE('ERR_HTTP2_HEADERS_AFTER_RESPOND'\x2C\x0d\n  'Cannot specify additional headers after response initiated'\x2C Error);\x0d\nE('ERR_HTTP2_HEADERS_SENT'\x2C 'Response has already been initiated.'\x2C Error);\x0d\nE('ERR_HTTP2_HEADER_SINGLE_VALUE'\x2C\x0d\n  'Header field "%s" must only have a single value'\x2C TypeError);\x0d\nE('ERR_HTTP2_INFO_STATUS_NOT_ALLOWED'\x2C\x0d\n  'Informational status codes cannot be used'\x2C RangeError);\x0d\nE('ERR_HTTP2_INVALID_CONNECTION_HEADERS'\x2C\x0d\n  'HTTP/1 Connection specific headers are forbidden: "%s"'\x2C TypeError);\x0d\nE('ERR_HTTP2_INVALID_HEADER_VALUE'\x2C\x0d\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\x0d\nE('ERR_HTTP2_INVALID_INFO_STATUS'\x2C\x0d\n  'Invalid informational status code: %s'\x2C RangeError);\x0d\nE('ERR_HTTP2_INVALID_ORIGIN'\x2C\x0d\n  'HTTP/2 ORIGIN frames require a valid origin'\x2C TypeError);\x0d\nE('ERR_HTTP2_INVALID_PACKED_SETTINGS_LENGTH'\x2C\x0d\n  'Packed settings length must be a multiple of six'\x2C RangeError);\x0d\nE('ERR_HTTP2_INVALID_PSEUDOHEADER'\x2C\x0d\n  '"%s" is an invalid pseudoheader or is used incorrectly'\x2C TypeError);\x0d\nE('ERR_HTTP2_INVALID_SESSION'\x2C 'The session has been destroyed'\x2C Error);\x0d\nE('ERR_HTTP2_INVALID_SETTING_VALUE'\x2C\x0d\n  // Using default arguments here is important so the arguments are not counted\x0d\n  // towards `Function#length`.\x0d\n  function(name\x2C actual\x2C min = undefined\x2C max = undefined) {\x0d\n    this.actual = actual;\x0d\n    if (min !== undefined) {\x0d\n      this.min = min;\x0d\n      this.max = max;\x0d\n    }\x0d\n    return `Invalid value for setting "${name}": ${actual}`;\x0d\n  }\x2C TypeError\x2C RangeError);\x0d\nE('ERR_HTTP2_INVALID_STREAM'\x2C 'The stream has been destroyed'\x2C Error);\x0d\nE('ERR_HTTP2_MAX_PENDING_SETTINGS_ACK'\x2C\x0d\n  'Maximum number of pending settings acknowledgements'\x2C Error);\x0d\nE('ERR_HTTP2_NESTED_PUSH'\x2C\x0d\n  'A push stream cannot initiate another push stream.'\x2C Error);\x0d\nE('ERR_HTTP2_NO_MEM'\x2C 'Out of memory'\x2C Error);\x0d\nE('ERR_HTTP2_NO_SOCKET_MANIPULATION'\x2C\x0d\n  'HTTP/2 sockets should not be directly manipulated (e.g. read and written)'\x2C\x0d\n  Error);\x0d\nE('ERR_HTTP2_ORIGIN_LENGTH'\x2C\x0d\n  'HTTP/2 ORIGIN frames are limited to 16382 bytes'\x2C TypeError);\x0d\nE('ERR_HTTP2_OUT_OF_STREAMS'\x2C\x0d\n  'No stream ID is available because maximum stream ID has been reached'\x2C\x0d\n  Error);\x0d\nE('ERR_HTTP2_PAYLOAD_FORBIDDEN'\x2C\x0d\n  'Responses with %s status must not have a payload'\x2C Error);\x0d\nE('ERR_HTTP2_PING_CANCEL'\x2C 'HTTP2 ping cancelled'\x2C Error);\x0d\nE('ERR_HTTP2_PING_LENGTH'\x2C 'HTTP2 ping payload must be 8 bytes'\x2C RangeError);\x0d\nE('ERR_HTTP2_PSEUDOHEADER_NOT_ALLOWED'\x2C\x0d\n  'Cannot set HTTP/2 pseudo-headers'\x2C TypeError);\x0d\nE('ERR_HTTP2_PUSH_DISABLED'\x2C 'HTTP/2 client has disabled push streams'\x2C Error);\x0d\nE('ERR_HTTP2_SEND_FILE'\x2C 'Directories cannot be sent'\x2C Error);\x0d\nE('ERR_HTTP2_SEND_FILE_NOSEEK'\x2C\x0d\n  'Offset or length can only be specified for regular files'\x2C Error);\x0d\nE('ERR_HTTP2_SESSION_ERROR'\x2C 'Session closed with error code %s'\x2C Error);\x0d\nE('ERR_HTTP2_SETTINGS_CANCEL'\x2C 'HTTP2 session settings canceled'\x2C Error);\x0d\nE('ERR_HTTP2_SOCKET_BOUND'\x2C\x0d\n  'The socket is already bound to an Http2Session'\x2C Error);\x0d\nE('ERR_HTTP2_SOCKET_UNBOUND'\x2C\x0d\n  'The socket has been disconnected from the Http2Session'\x2C Error);\x0d\nE('ERR_HTTP2_STATUS_101'\x2C\x0d\n  'HTTP status code 101 (Switching Protocols) is forbidden in HTTP/2'\x2C Error);\x0d\nE('ERR_HTTP2_STATUS_INVALID'\x2C 'Invalid status code: %s'\x2C RangeError);\x0d\nE('ERR_HTTP2_STREAM_CANCEL'\x2C function(error) {\x0d\n  let msg = 'The pending stream has been canceled';\x0d\n  if (error) {\x0d\n    this.cause = error;\x0d\n    if (typeof error.message === 'string')\x0d\n      msg += ` (caused by: ${error.message})`;\x0d\n  }\x0d\n  return msg;\x0d\n}\x2C Error);\x0d\nE('ERR_HTTP2_STREAM_ERROR'\x2C 'Stream closed with error code %s'\x2C Error);\x0d\nE('ERR_HTTP2_STREAM_SELF_DEPENDENCY'\x2C\x0d\n  'A stream cannot depend on itself'\x2C Error);\x0d\nE('ERR_HTTP2_TOO_MANY_INVALID_FRAMES'\x2C 'Too many invalid HTTP/2 frames'\x2C Error);\x0d\nE('ERR_HTTP2_TRAILERS_ALREADY_SENT'\x2C\x0d\n  'Trailing headers have already been sent'\x2C Error);\x0d\nE('ERR_HTTP2_TRAILERS_NOT_READY'\x2C\x0d\n  'Trailing headers cannot be sent until after the wantTrailers event is ' +\x0d\n  'emitted'\x2C Error);\x0d\nE('ERR_HTTP2_UNSUPPORTED_PROTOCOL'\x2C 'protocol "%s" is unsupported.'\x2C Error);\x0d\nE('ERR_HTTP_HEADERS_SENT'\x2C\x0d\n  'Cannot %s headers after they are sent to the client'\x2C Error);\x0d\nE('ERR_HTTP_INVALID_HEADER_VALUE'\x2C\x0d\n  'Invalid value "%s" for header "%s"'\x2C TypeError);\x0d\nE('ERR_HTTP_INVALID_STATUS_CODE'\x2C 'Invalid status code: %s'\x2C RangeError);\x0d\nE('ERR_HTTP_REQUEST_TIMEOUT'\x2C 'Request timeout'\x2C Error);\x0d\nE('ERR_HTTP_SOCKET_ENCODING'\x2C\x0d\n  'Changing the socket encoding is not allowed per RFC7230 Section 3.'\x2C Error);\x0d\nE('ERR_HTTP_TRAILER_INVALID'\x2C\x0d\n  'Trailers are invalid with this transfer encoding'\x2C Error);\x0d\nE('ERR_ILLEGAL_CONSTRUCTOR'\x2C 'Illegal constructor'\x2C TypeError);\x0d\nE('ERR_IMPORT_ASSERTION_TYPE_FAILED'\x2C\x0d\n  'Module "%s" is not of type "%s"'\x2C TypeError);\x0d\nE('ERR_IMPORT_ASSERTION_TYPE_MISSING'\x2C\x0d\n  'Module "%s" needs an import assertion of type "%s"'\x2C TypeError);\x0d\nE('ERR_IMPORT_ASSERTION_TYPE_UNSUPPORTED'\x2C\x0d\n  'Import assertion type "%s" is unsupported'\x2C TypeError);\x0d\nE('ERR_INCOMPATIBLE_OPTION_PAIR'\x2C\x0d\n  'Option "%s" cannot be used in combination with option "%s"'\x2C TypeError);\x0d\nE('ERR_INPUT_TYPE_NOT_ALLOWED'\x2C '--input-type can only be used with string ' +\x0d\n  'input via --eval\x2C --print\x2C or STDIN'\x2C Error);\x0d\nE('ERR_INSPECTOR_ALREADY_ACTIVATED'\x2C\x0d\n  'Inspector is already activated. Close it with inspector.close() ' +\x0d\n  'before activating it again.'\x2C\x0d\n  Error);\x0d\nE('ERR_INSPECTOR_ALREADY_CONNECTED'\x2C '%s is already connected'\x2C Error);\x0d\nE('ERR_INSPECTOR_CLOSED'\x2C 'Session was closed'\x2C Error);\x0d\nE('ERR_INSPECTOR_COMMAND'\x2C 'Inspector error %d: %s'\x2C Error);\x0d\nE('ERR_INSPECTOR_NOT_ACTIVE'\x2C 'Inspector is not active'\x2C Error);\x0d\nE('ERR_INSPECTOR_NOT_AVAILABLE'\x2C 'Inspector is not available'\x2C Error);\x0d\nE('ERR_INSPECTOR_NOT_CONNECTED'\x2C 'Session is not connected'\x2C Error);\x0d\nE('ERR_INSPECTOR_NOT_WORKER'\x2C 'Current thread is not a worker'\x2C Error);\x0d\nE('ERR_INTERNAL_ASSERTION'\x2C (message) => {\x0d\n  const suffix = 'This is caused by either a bug in Node.js ' +\x0d\n    'or incorrect usage of Node.js internals.\\n' +\x0d\n    'Please open an issue with this stack trace at ' +\x0d\n    'https://github.com/nodejs/node/issues\\n';\x0d\n  return message === undefined ? suffix : `${message}\\n${suffix}`;\x0d\n}\x2C Error);\x0d\nE('ERR_INVALID_ADDRESS_FAMILY'\x2C function(addressType\x2C host\x2C port) {\x0d\n  this.host = host;\x0d\n  this.port = port;\x0d\n  return `Invalid address family: ${addressType} ${host}:${port}`;\x0d\n}\x2C RangeError);\x0d\nE('ERR_INVALID_ARG_TYPE'\x2C\x0d\n  (name\x2C expected\x2C actual) => {\x0d\n    assert(typeof name === 'string'\x2C "'name' must be a string");\x0d\n    if (!ArrayIsArray(expected)) {\x0d\n      expected = [expected];\x0d\n    }\x0d\n\x0d\n    let msg = 'The ';\x0d\n    if (StringPrototypeEndsWith(name\x2C ' argument')) {\x0d\n      // For cases like 'first argument'\x0d\n      msg += `${name} `;\x0d\n    } else {\x0d\n      const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\x0d\n      msg += `"${name}" ${type} `;\x0d\n    }\x0d\n    msg += 'must be ';\x0d\n\x0d\n    const types = [];\x0d\n    const instances = [];\x0d\n    const other = [];\x0d\n\x0d\n    for (const value of expected) {\x0d\n      assert(typeof value === 'string'\x2C\x0d\n             'All expected entries have to be of type string');\x0d\n      if (ArrayPrototypeIncludes(kTypes\x2C value)) {\x0d\n        ArrayPrototypePush(types\x2C StringPrototypeToLowerCase(value));\x0d\n      } else if (RegExpPrototypeTest(classRegExp\x2C value)) {\x0d\n        ArrayPrototypePush(instances\x2C value);\x0d\n      } else {\x0d\n        assert(value !== 'object'\x2C\x0d\n               'The value "object" should be written as "Object"');\x0d\n        ArrayPrototypePush(other\x2C value);\x0d\n      }\x0d\n    }\x0d\n\x0d\n    // Special handle `object` in case other instances are allowed to outline\x0d\n    // the differences between each other.\x0d\n    if (instances.length > 0) {\x0d\n      const pos = ArrayPrototypeIndexOf(types\x2C 'object');\x0d\n      if (pos !== -1) {\x0d\n        ArrayPrototypeSplice(types\x2C pos\x2C 1);\x0d\n        ArrayPrototypePush(instances\x2C 'Object');\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (types.length > 0) {\x0d\n      if (types.length > 2) {\x0d\n        const last = ArrayPrototypePop(types);\x0d\n        msg += `one of type ${ArrayPrototypeJoin(types\x2C '\x2C ')}\x2C or ${last}`;\x0d\n      } else if (types.length === 2) {\x0d\n        msg += `one of type ${types[0]} or ${types[1]}`;\x0d\n      } else {\x0d\n        msg += `of type ${types[0]}`;\x0d\n      }\x0d\n      if (instances.length > 0 || other.length > 0)\x0d\n        msg += ' or ';\x0d\n    }\x0d\n\x0d\n    if (instances.length > 0) {\x0d\n      if (instances.length > 2) {\x0d\n        const last = ArrayPrototypePop(instances);\x0d\n        msg +=\x0d\n          `an instance of ${ArrayPrototypeJoin(instances\x2C '\x2C ')}\x2C or ${last}`;\x0d\n      } else {\x0d\n        msg += `an instance of ${instances[0]}`;\x0d\n        if (instances.length === 2) {\x0d\n          msg += ` or ${instances[1]}`;\x0d\n        }\x0d\n      }\x0d\n      if (other.length > 0)\x0d\n        msg += ' or ';\x0d\n    }\x0d\n\x0d\n    if (other.length > 0) {\x0d\n      if (other.length > 2) {\x0d\n        const last = ArrayPrototypePop(other);\x0d\n        msg += `one of ${ArrayPrototypeJoin(other\x2C '\x2C ')}\x2C or ${last}`;\x0d\n      } else if (other.length === 2) {\x0d\n        msg += `one of ${other[0]} or ${other[1]}`;\x0d\n      } else {\x0d\n        if (StringPrototypeToLowerCase(other[0]) !== other[0])\x0d\n          msg += 'an ';\x0d\n        msg += `${other[0]}`;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (actual == null) {\x0d\n      msg += `. Received ${actual}`;\x0d\n    } else if (typeof actual === 'function' && actual.name) {\x0d\n      msg += `. Received function ${actual.name}`;\x0d\n    } else if (typeof actual === 'object') {\x0d\n      if (actual.constructor && actual.constructor.name) {\x0d\n        msg += `. Received an instance of ${actual.constructor.name}`;\x0d\n      } else {\x0d\n        const inspected = lazyInternalUtilInspect()\x0d\n          .inspect(actual\x2C { depth: -1 });\x0d\n        msg += `. Received ${inspected}`;\x0d\n      }\x0d\n    } else {\x0d\n      let inspected = lazyInternalUtilInspect()\x0d\n        .inspect(actual\x2C { colors: false });\x0d\n      if (inspected.length > 25)\x0d\n        inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 25)}...`;\x0d\n      msg += `. Received type ${typeof actual} (${inspected})`;\x0d\n    }\x0d\n    return msg;\x0d\n  }\x2C TypeError);\x0d\nE('ERR_INVALID_ARG_VALUE'\x2C (name\x2C value\x2C reason = 'is invalid') => {\x0d\n  let inspected = lazyInternalUtilInspect().inspect(value);\x0d\n  if (inspected.length > 128) {\x0d\n    inspected = `${StringPrototypeSlice(inspected\x2C 0\x2C 128)}...`;\x0d\n  }\x0d\n  const type = StringPrototypeIncludes(name\x2C '.') ? 'property' : 'argument';\x0d\n  return `The ${type} '${name}' ${reason}. Received ${inspected}`;\x0d\n}\x2C TypeError\x2C RangeError);\x0d\nE('ERR_INVALID_ASYNC_ID'\x2C 'Invalid %s value: %s'\x2C RangeError);\x0d\nE('ERR_INVALID_BUFFER_SIZE'\x2C\x0d\n  'Buffer size must be a multiple of %s'\x2C RangeError);\x0d\nE('ERR_INVALID_CALLBACK'\x2C\x0d\n  'Callback must be a function. Received %O'\x2C TypeError);\x0d\nE('ERR_INVALID_CHAR'\x2C\x0d\n  // Using a default argument here is important so the argument is not counted\x0d\n  // towards `Function#length`.\x0d\n  (name\x2C field = undefined) => {\x0d\n    let msg = `Invalid character in ${name}`;\x0d\n    if (field !== undefined) {\x0d\n      msg += ` ["${field}"]`;\x0d\n    }\x0d\n    return msg;\x0d\n  }\x2C TypeError);\x0d\nE('ERR_INVALID_CURSOR_POS'\x2C\x0d\n  'Cannot set cursor row without setting its column'\x2C TypeError);\x0d\nE('ERR_INVALID_FD'\x2C\x0d\n  '"fd" must be a positive integer: %s'\x2C RangeError);\x0d\nE('ERR_INVALID_FD_TYPE'\x2C 'Unsupported fd type: %s'\x2C TypeError);\x0d\nE('ERR_INVALID_FILE_URL_HOST'\x2C\x0d\n  'File URL host must be "localhost" or empty on %s'\x2C TypeError);\x0d\nE('ERR_INVALID_FILE_URL_PATH'\x2C 'File URL path %s'\x2C TypeError);\x0d\nE('ERR_INVALID_HANDLE_TYPE'\x2C 'This handle type cannot be sent'\x2C TypeError);\x0d\nE('ERR_INVALID_HTTP_TOKEN'\x2C '%s must be a valid HTTP token ["%s"]'\x2C TypeError);\x0d\nE('ERR_INVALID_IP_ADDRESS'\x2C 'Invalid IP address: %s'\x2C TypeError);\x0d\nE('ERR_INVALID_MODULE_SPECIFIER'\x2C (request\x2C reason\x2C base = undefined) => {\x0d\n  return `Invalid module "${request}" ${reason}${base ?\x0d\n    ` imported from ${base}` : ''}`;\x0d\n}\x2C TypeError);\x0d\nE('ERR_INVALID_PACKAGE_CONFIG'\x2C (path\x2C base\x2C message) => {\x0d\n  return `Invalid package config ${path}${base ? ` while importing ${base}` :\x0d\n    ''}${message ? `. ${message}` : ''}`;\x0d\n}\x2C Error);\x0d\nE('ERR_INVALID_PACKAGE_TARGET'\x2C\x0d\n  (pkgPath\x2C key\x2C target\x2C isImport = false\x2C base = undefined) => {\x0d\n    const relError = typeof target === 'string' && !isImport &&\x0d\n      target.length && !StringPrototypeStartsWith(target\x2C './');\x0d\n    if (key === '.') {\x0d\n      assert(isImport === false);\x0d\n      return `Invalid "exports" main target ${JSONStringify(target)} defined ` +\x0d\n        `in the package config ${pkgPath}package.json${base ?\x0d\n          ` imported from ${base}` : ''}${relError ?\x0d\n          '; targets must start with "./"' : ''}`;\x0d\n    }\x0d\n    return `Invalid "${isImport ? 'imports' : 'exports'}" target ${\x0d\n      JSONStringify(target)} defined for '${key}' in the package config ${\x0d\n      pkgPath}package.json${base ? ` imported from ${base}` : ''}${relError ?\x0d\n      '; targets must start with "./"' : ''}`;\x0d\n  }\x2C Error);\x0d\nE('ERR_INVALID_PROTOCOL'\x2C\x0d\n  'Protocol "%s" not supported. Expected "%s"'\x2C\x0d\n  TypeError);\x0d\nE('ERR_INVALID_REPL_EVAL_CONFIG'\x2C\x0d\n  'Cannot specify both "breakEvalOnSigint" and "eval" for REPL'\x2C TypeError);\x0d\nE('ERR_INVALID_REPL_INPUT'\x2C '%s'\x2C TypeError);\x0d\nE('ERR_INVALID_RETURN_PROPERTY'\x2C (input\x2C name\x2C prop\x2C value) => {\x0d\n  return `Expected a valid ${input} to be returned for the "${prop}" from the` +\x0d\n         ` "${name}" function but got ${value}.`;\x0d\n}\x2C TypeError);\x0d\nE('ERR_INVALID_RETURN_PROPERTY_VALUE'\x2C (input\x2C name\x2C prop\x2C value) => {\x0d\n  let type;\x0d\n  if (value && value.constructor && value.constructor.name) {\x0d\n    type = `instance of ${value.constructor.name}`;\x0d\n  } else {\x0d\n    type = `type ${typeof value}`;\x0d\n  }\x0d\n  return `Expected ${input} to be returned for the "${prop}" from the` +\x0d\n         ` "${name}" function but got ${type}.`;\x0d\n}\x2C TypeError);\x0d\nE('ERR_INVALID_RETURN_VALUE'\x2C (input\x2C name\x2C value) => {\x0d\n  let type;\x0d\n  if (value && value.constructor && value.constructor.name) {\x0d\n    type = `instance of ${value.constructor.name}`;\x0d\n  } else {\x0d\n    type = `type ${typeof value}`;\x0d\n  }\x0d\n  return `Expected ${input} to be returned from the "${name}"` +\x0d\n         ` function but got ${type}.`;\x0d\n}\x2C TypeError\x2C RangeError);\x0d\nE('ERR_INVALID_STATE'\x2C 'Invalid state: %s'\x2C Error\x2C TypeError\x2C RangeError);\x0d\nE('ERR_INVALID_SYNC_FORK_INPUT'\x2C\x0d\n  'Asynchronous forks do not support ' +\x0d\n    'Buffer\x2C TypedArray\x2C DataView or string input: %s'\x2C\x0d\n  TypeError);\x0d\nE('ERR_INVALID_THIS'\x2C 'Value of "this" must be of type %s'\x2C TypeError);\x0d\nE('ERR_INVALID_TUPLE'\x2C '%s must be an iterable %s tuple'\x2C TypeError);\x0d\nE('ERR_INVALID_URI'\x2C 'URI malformed'\x2C URIError);\x0d\nE('ERR_INVALID_URL'\x2C function(input) {\x0d\n  this.input = input;\x0d\n  // Don't include URL in message.\x0d\n  // (See https://github.com/nodejs/node/pull/38614)\x0d\n  return 'Invalid URL';\x0d\n}\x2C TypeError);\x0d\nE('ERR_INVALID_URL_SCHEME'\x2C\x0d\n  (expected) => {\x0d\n    if (typeof expected === 'string')\x0d\n      expected = [expected];\x0d\n    assert(expected.length <= 2);\x0d\n    const res = expected.length === 2 ?\x0d\n      `one of scheme ${expected[0]} or ${expected[1]}` :\x0d\n      `of scheme ${expected[0]}`;\x0d\n    return `The URL must be ${res}`;\x0d\n  }\x2C TypeError);\x0d\nE('ERR_IPC_CHANNEL_CLOSED'\x2C 'Channel closed'\x2C Error);\x0d\nE('ERR_IPC_DISCONNECTED'\x2C 'IPC channel is already disconnected'\x2C Error);\x0d\nE('ERR_IPC_ONE_PIPE'\x2C 'Child process can have only one IPC pipe'\x2C Error);\x0d\nE('ERR_IPC_SYNC_FORK'\x2C 'IPC cannot be used with synchronous forks'\x2C Error);\x0d\nE('ERR_MANIFEST_ASSERT_INTEGRITY'\x2C\x0d\n  (moduleURL\x2C realIntegrities) => {\x0d\n    let msg = `The content of "${\x0d\n      moduleURL\x0d\n    }" does not match the expected integrity.`;\x0d\n    if (realIntegrities.size) {\x0d\n      const sri = ArrayPrototypeJoin(\x0d\n        ArrayFrom(realIntegrities.entries()\x2C\x0d\n                  ({ 0: alg\x2C 1: dgs }) => `${alg}-${dgs}`)\x2C\x0d\n        ' '\x0d\n      );\x0d\n      msg += ` Integrities found are: ${sri}`;\x0d\n    } else {\x0d\n      msg += ' The resource was not found in the policy.';\x0d\n    }\x0d\n    return msg;\x0d\n  }\x2C Error);\x0d\nE('ERR_MANIFEST_DEPENDENCY_MISSING'\x2C\x0d\n  'Manifest resource %s does not list %s as a dependency specifier for ' +\x0d\n  'conditions: %s'\x2C\x0d\n  Error);\x0d\nE('ERR_MANIFEST_INTEGRITY_MISMATCH'\x2C\x0d\n  'Manifest resource %s has multiple entries but integrity lists do not match'\x2C\x0d\n  SyntaxError);\x0d\nE('ERR_MANIFEST_INVALID_RESOURCE_FIELD'\x2C\x0d\n  'Manifest resource %s has invalid property value for %s'\x2C\x0d\n  TypeError);\x0d\nE('ERR_MANIFEST_INVALID_SPECIFIER'\x2C\x0d\n  'Manifest resource %s has invalid dependency mapping %s'\x2C\x0d\n  TypeError);\x0d\nE('ERR_MANIFEST_TDZ'\x2C 'Manifest initialization has not yet run'\x2C Error);\x0d\nE('ERR_MANIFEST_UNKNOWN_ONERROR'\x2C\x0d\n  'Manifest specified unknown error behavior "%s".'\x2C\x0d\n  SyntaxError);\x0d\nE('ERR_METHOD_NOT_IMPLEMENTED'\x2C 'The %s method is not implemented'\x2C Error);\x0d\nE('ERR_MISSING_ARGS'\x2C\x0d\n  (...args) => {\x0d\n    assert(args.length > 0\x2C 'At least one arg needs to be specified');\x0d\n    let msg = 'The ';\x0d\n    const len = args.length;\x0d\n    const wrap = (a) => `"${a}"`;\x0d\n    args = ArrayPrototypeMap(\x0d\n      args\x2C\x0d\n      (a) => (ArrayIsArray(a) ?\x0d\n        ArrayPrototypeJoin(ArrayPrototypeMap(a\x2C wrap)\x2C ' or ') :\x0d\n        wrap(a))\x0d\n    );\x0d\n    switch (len) {\x0d\n      case 1:\x0d\n        msg += `${args[0]} argument`;\x0d\n        break;\x0d\n      case 2:\x0d\n        msg += `${args[0]} and ${args[1]} arguments`;\x0d\n        break;\x0d\n      default:\x0d\n        msg += ArrayPrototypeJoin(ArrayPrototypeSlice(args\x2C 0\x2C len - 1)\x2C '\x2C ');\x0d\n        msg += `\x2C and ${args[len - 1]} arguments`;\x0d\n        break;\x0d\n    }\x0d\n    return `${msg} must be specified`;\x0d\n  }\x2C TypeError);\x0d\nE('ERR_MISSING_OPTION'\x2C '%s is required'\x2C TypeError);\x0d\nE('ERR_MODULE_NOT_FOUND'\x2C (path\x2C base\x2C type = 'package') => {\x0d\n  return `Cannot find ${type} '${path}' imported from ${base}`;\x0d\n}\x2C Error);\x0d\nE('ERR_MULTIPLE_CALLBACK'\x2C 'Callback called multiple times'\x2C Error);\x0d\nE('ERR_NAPI_CONS_FUNCTION'\x2C 'Constructor must be a function'\x2C TypeError);\x0d\nE('ERR_NAPI_INVALID_DATAVIEW_ARGS'\x2C\x0d\n  'byte_offset + byte_length should be less than or equal to the size in ' +\x0d\n    'bytes of the array passed in'\x2C\x0d\n  RangeError);\x0d\nE('ERR_NAPI_INVALID_TYPEDARRAY_ALIGNMENT'\x2C\x0d\n  'start offset of %s should be a multiple of %s'\x2C RangeError);\x0d\nE('ERR_NAPI_INVALID_TYPEDARRAY_LENGTH'\x2C\x0d\n  'Invalid typed array length'\x2C RangeError);\x0d\nE('ERR_NO_CRYPTO'\x2C\x0d\n  'Node.js is not compiled with OpenSSL crypto support'\x2C Error);\x0d\nE('ERR_NO_ICU'\x2C\x0d\n  '%s is not supported on Node.js compiled without ICU'\x2C TypeError);\x0d\nE('ERR_OPERATION_FAILED'\x2C 'Operation failed: %s'\x2C Error\x2C TypeError);\x0d\nE('ERR_OUT_OF_RANGE'\x2C\x0d\n  (str\x2C range\x2C input\x2C replaceDefaultBoolean = false) => {\x0d\n    assert(range\x2C 'Missing "range" argument');\x0d\n    let msg = replaceDefaultBoolean ? str :\x0d\n      `The value of "${str}" is out of range.`;\x0d\n    let received;\x0d\n    if (NumberIsInteger(input) && MathAbs(input) > 2 ** 32) {\x0d\n      received = addNumericalSeparator(String(input));\x0d\n    } else if (typeof input === 'bigint') {\x0d\n      received = String(input);\x0d\n      if (input > 2n ** 32n || input < -(2n ** 32n)) {\x0d\n        received = addNumericalSeparator(received);\x0d\n      }\x0d\n      received += 'n';\x0d\n    } else {\x0d\n      received = lazyInternalUtilInspect().inspect(input);\x0d\n    }\x0d\n    msg += ` It must be ${range}. Received ${received}`;\x0d\n    return msg;\x0d\n  }\x2C RangeError);\x0d\nE('ERR_PACKAGE_IMPORT_NOT_DEFINED'\x2C (specifier\x2C packagePath\x2C base) => {\x0d\n  return `Package import specifier "${specifier}" is not defined${packagePath ?\x0d\n    ` in package ${packagePath}package.json` : ''} imported from ${base}`;\x0d\n}\x2C TypeError);\x0d\nE('ERR_PACKAGE_PATH_NOT_EXPORTED'\x2C (pkgPath\x2C subpath\x2C base = undefined) => {\x0d\n  if (subpath === '.')\x0d\n    return `No "exports" main defined in ${pkgPath}package.json${base ?\x0d\n      ` imported from ${base}` : ''}`;\x0d\n  return `Package subpath '${subpath}' is not defined by "exports" in ${\x0d\n    pkgPath}package.json${base ? ` imported from ${base}` : ''}`;\x0d\n}\x2C Error);\x0d\nE('ERR_PERFORMANCE_INVALID_TIMESTAMP'\x2C\x0d\n  '%d is not a valid timestamp'\x2C TypeError);\x0d\nE('ERR_PERFORMANCE_MEASURE_INVALID_OPTIONS'\x2C '%s'\x2C TypeError);\x0d\nE('ERR_REQUIRE_ESM'\x2C\x0d\n  function(filename\x2C hasEsmSyntax\x2C parentPath = null\x2C packageJsonPath = null) {\x0d\n    hideInternalStackFrames(this);\x0d\n    let msg = `require() of ES Module ${filename}${parentPath ? ` from ${\x0d\n      parentPath}` : ''} not supported.`;\x0d\n    if (!packageJsonPath) {\x0d\n      if (StringPrototypeEndsWith(filename\x2C '.mjs'))\x0d\n        msg += `\\nInstead change the require of ${filename} to a dynamic ` +\x0d\n            'import() which is available in all CommonJS modules.';\x0d\n      return msg;\x0d\n    }\x0d\n    const path = require('path');\x0d\n    const basename = parentPath && path.basename(filename) ===\x0d\n      path.basename(parentPath) ? filename : path.basename(filename);\x0d\n    if (hasEsmSyntax) {\x0d\n      msg += `\\nInstead change the require of ${basename} in ${parentPath} to` +\x0d\n        ' a dynamic import() which is available in all CommonJS modules.';\x0d\n      return msg;\x0d\n    }\x0d\n    msg += `\\n${basename} is treated as an ES module file as it is a .js ` +\x0d\n      'file whose nearest parent package.json contains "type": "module" ' +\x0d\n      'which declares all .js files in that package scope as ES modules.' +\x0d\n      `\\nInstead rename ${basename} to end in .cjs\x2C change the requiring ` +\x0d\n      'code to use dynamic import() which is available in all CommonJS ' +\x0d\n      'modules\x2C or change "type": "module" to "type": "commonjs" in ' +\x0d\n      `${packageJsonPath} to treat all .js files as CommonJS (using .mjs for ` +\x0d\n      'all ES modules instead).\\n';\x0d\n    return msg;\x0d\n  }\x2C Error);\x0d\nE('ERR_SCRIPT_EXECUTION_INTERRUPTED'\x2C\x0d\n  'Script execution was interrupted by `SIGINT`'\x2C Error);\x0d\nE('ERR_SERVER_ALREADY_LISTEN'\x2C\x0d\n  'Listen method has been called more than once without closing.'\x2C Error);\x0d\nE('ERR_SERVER_NOT_RUNNING'\x2C 'Server is not running.'\x2C Error);\x0d\nE('ERR_SOCKET_ALREADY_BOUND'\x2C 'Socket is already bound'\x2C Error);\x0d\nE('ERR_SOCKET_BAD_BUFFER_SIZE'\x2C\x0d\n  'Buffer size must be a positive integer'\x2C TypeError);\x0d\nE('ERR_SOCKET_BAD_PORT'\x2C (name\x2C port\x2C allowZero = true) => {\x0d\n  assert(typeof allowZero === 'boolean'\x2C\x0d\n         "The 'allowZero' argument must be of type boolean.");\x0d\n  const operator = allowZero ? '>=' : '>';\x0d\n  return `${name} should be ${operator} 0 and < 65536. Received ${port}.`;\x0d\n}\x2C RangeError);\x0d\nE('ERR_SOCKET_BAD_TYPE'\x2C\x0d\n  'Bad socket type specified. Valid types are: udp4\x2C udp6'\x2C TypeError);\x0d\nE('ERR_SOCKET_BUFFER_SIZE'\x2C\x0d\n  'Could not get or set buffer size'\x2C\x0d\n  SystemError);\x0d\nE('ERR_SOCKET_CLOSED'\x2C 'Socket is closed'\x2C Error);\x0d\nE('ERR_SOCKET_DGRAM_IS_CONNECTED'\x2C 'Already connected'\x2C Error);\x0d\nE('ERR_SOCKET_DGRAM_NOT_CONNECTED'\x2C 'Not connected'\x2C Error);\x0d\nE('ERR_SOCKET_DGRAM_NOT_RUNNING'\x2C 'Not running'\x2C Error);\x0d\nE('ERR_SRI_PARSE'\x2C\x0d\n  'Subresource Integrity string %j had an unexpected %j at position %d'\x2C\x0d\n  SyntaxError);\x0d\nE('ERR_STREAM_ALREADY_FINISHED'\x2C\x0d\n  'Cannot call %s after a stream was finished'\x2C\x0d\n  Error);\x0d\nE('ERR_STREAM_CANNOT_PIPE'\x2C 'Cannot pipe\x2C not readable'\x2C Error);\x0d\nE('ERR_STREAM_DESTROYED'\x2C 'Cannot call %s after a stream was destroyed'\x2C Error);\x0d\nE('ERR_STREAM_NULL_VALUES'\x2C 'May not write null values to stream'\x2C TypeError);\x0d\nE('ERR_STREAM_PREMATURE_CLOSE'\x2C 'Premature close'\x2C Error);\x0d\nE('ERR_STREAM_PUSH_AFTER_EOF'\x2C 'stream.push() after EOF'\x2C Error);\x0d\nE('ERR_STREAM_UNSHIFT_AFTER_END_EVENT'\x2C\x0d\n  'stream.unshift() after end event'\x2C Error);\x0d\nE('ERR_STREAM_WRAP'\x2C 'Stream has StringDecoder set or is in objectMode'\x2C Error);\x0d\nE('ERR_STREAM_WRITE_AFTER_END'\x2C 'write after end'\x2C Error);\x0d\nE('ERR_SYNTHETIC'\x2C 'JavaScript Callstack'\x2C Error);\x0d\nE('ERR_SYSTEM_ERROR'\x2C 'A system error occurred'\x2C SystemError);\x0d\nE('ERR_TLS_CERT_ALTNAME_FORMAT'\x2C 'Invalid subject alternative name string'\x2C\x0d\n  SyntaxError);\x0d\nE('ERR_TLS_CERT_ALTNAME_INVALID'\x2C function(reason\x2C host\x2C cert) {\x0d\n  this.reason = reason;\x0d\n  this.host = host;\x0d\n  this.cert = cert;\x0d\n  return `Hostname/IP does not match certificate's altnames: ${reason}`;\x0d\n}\x2C Error);\x0d\nE('ERR_TLS_DH_PARAM_SIZE'\x2C 'DH parameter size %s is less than 2048'\x2C Error);\x0d\nE('ERR_TLS_HANDSHAKE_TIMEOUT'\x2C 'TLS handshake timeout'\x2C Error);\x0d\nE('ERR_TLS_INVALID_CONTEXT'\x2C '%s must be a SecureContext'\x2C TypeError);\x0d\nE('ERR_TLS_INVALID_PROTOCOL_VERSION'\x2C\x0d\n  '%j is not a valid %s TLS protocol version'\x2C TypeError);\x0d\nE('ERR_TLS_INVALID_STATE'\x2C 'TLS socket connection must be securely established'\x2C\x0d\n  Error);\x0d\nE('ERR_TLS_PROTOCOL_VERSION_CONFLICT'\x2C\x0d\n  'TLS protocol version %j conflicts with secureProtocol %j'\x2C TypeError);\x0d\nE('ERR_TLS_RENEGOTIATION_DISABLED'\x2C\x0d\n  'TLS session renegotiation disabled for this socket'\x2C Error);\x0d\n\x0d\n// This should probably be a `TypeError`.\x0d\nE('ERR_TLS_REQUIRED_SERVER_NAME'\x2C\x0d\n  '"servername" is required parameter for Server.addContext'\x2C Error);\x0d\nE('ERR_TLS_SESSION_ATTACK'\x2C 'TLS session renegotiation attack detected'\x2C Error);\x0d\nE('ERR_TLS_SNI_FROM_SERVER'\x2C\x0d\n  'Cannot issue SNI from a TLS server-side socket'\x2C Error);\x0d\nE('ERR_TRACE_EVENTS_CATEGORY_REQUIRED'\x2C\x0d\n  'At least one category is required'\x2C TypeError);\x0d\nE('ERR_TRACE_EVENTS_UNAVAILABLE'\x2C 'Trace events are unavailable'\x2C Error);\x0d\n\x0d\n// This should probably be a `RangeError`.\x0d\nE('ERR_TTY_INIT_FAILED'\x2C 'TTY initialization failed'\x2C SystemError);\x0d\nE('ERR_UNAVAILABLE_DURING_EXIT'\x2C 'Cannot call function in process exit ' +\x0d\n  'handler'\x2C Error);\x0d\nE('ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET'\x2C\x0d\n  '`process.setupUncaughtExceptionCapture()` was called while a capture ' +\x0d\n    'callback was already active'\x2C\x0d\n  Error);\x0d\nE('ERR_UNESCAPED_CHARACTERS'\x2C '%s contains unescaped characters'\x2C TypeError);\x0d\nE('ERR_UNHANDLED_ERROR'\x2C\x0d\n  // Using a default argument here is important so the argument is not counted\x0d\n  // towards `Function#length`.\x0d\n  (err = undefined) => {\x0d\n    const msg = 'Unhandled error.';\x0d\n    if (err === undefined) return msg;\x0d\n    return `${msg} (${err})`;\x0d\n  }\x2C Error);\x0d\nE('ERR_UNKNOWN_BUILTIN_MODULE'\x2C 'No such built-in module: %s'\x2C Error);\x0d\nE('ERR_UNKNOWN_CREDENTIAL'\x2C '%s identifier does not exist: %s'\x2C Error);\x0d\nE('ERR_UNKNOWN_ENCODING'\x2C 'Unknown encoding: %s'\x2C TypeError);\x0d\nE('ERR_UNKNOWN_FILE_EXTENSION'\x2C\x0d\n  'Unknown file extension "%s" for %s'\x2C\x0d\n  TypeError);\x0d\nE('ERR_UNKNOWN_MODULE_FORMAT'\x2C 'Unknown module format: %s'\x2C RangeError);\x0d\nE('ERR_UNKNOWN_SIGNAL'\x2C 'Unknown signal: %s'\x2C TypeError);\x0d\nE('ERR_UNSUPPORTED_DIR_IMPORT'\x2C "Directory import '%s' is not supported " +\x0d\n'resolving ES modules imported from %s'\x2C Error);\x0d\nE('ERR_UNSUPPORTED_ESM_URL_SCHEME'\x2C (url) => {\x0d\n  let msg = 'Only file and data URLs are supported by the default ESM loader';\x0d\n  if (isWindows && url.protocol.length === 2) {\x0d\n    msg +=\x0d\n      '. On Windows\x2C absolute paths must be valid file:// URLs';\x0d\n  }\x0d\n  msg += `. Received protocol '${url.protocol}'`;\x0d\n  return msg;\x0d\n}\x2C Error);\x0d\n\x0d\n// This should probably be a `TypeError`.\x0d\nE('ERR_VALID_PERFORMANCE_ENTRY_TYPE'\x2C\x0d\n  'At least one valid performance entry type is required'\x2C Error);\x0d\nE('ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING'\x2C\x0d\n  'A dynamic import callback was not specified.'\x2C TypeError);\x0d\nE('ERR_VM_MODULE_ALREADY_LINKED'\x2C 'Module has already been linked'\x2C Error);\x0d\nE('ERR_VM_MODULE_CANNOT_CREATE_CACHED_DATA'\x2C\x0d\n  'Cached data cannot be created for a module which has been evaluated'\x2C Error);\x0d\nE('ERR_VM_MODULE_DIFFERENT_CONTEXT'\x2C\x0d\n  'Linked modules must use the same context'\x2C Error);\x0d\nE('ERR_VM_MODULE_LINKING_ERRORED'\x2C\x0d\n  'Linking has already failed for the provided module'\x2C Error);\x0d\nE('ERR_VM_MODULE_NOT_MODULE'\x2C\x0d\n  'Provided module is not an instance of Module'\x2C Error);\x0d\nE('ERR_VM_MODULE_STATUS'\x2C 'Module status %s'\x2C Error);\x0d\nE('ERR_WASI_ALREADY_STARTED'\x2C 'WASI instance has already started'\x2C Error);\x0d\nE('ERR_WORKER_INIT_FAILED'\x2C 'Worker initialization failure: %s'\x2C Error);\x0d\nE('ERR_WORKER_INVALID_EXEC_ARGV'\x2C (errors\x2C msg = 'invalid execArgv flags') =>\x0d\n  `Initiated Worker with ${msg}: ${ArrayPrototypeJoin(errors\x2C '\x2C ')}`\x2C\x0d\n  Error);\x0d\nE('ERR_WORKER_NOT_RUNNING'\x2C 'Worker instance not running'\x2C Error);\x0d\nE('ERR_WORKER_OUT_OF_MEMORY'\x2C\x0d\n  'Worker terminated due to reaching memory limit: %s'\x2C Error);\x0d\nE('ERR_WORKER_PATH'\x2C (filename) =>\x0d\n  'The worker script or module filename must be an absolute path or a ' +\x0d\n  'relative path starting with \\'./\\' or \\'../\\'.' +\x0d\n  (StringPrototypeStartsWith(filename\x2C 'file://') ?\x0d\n    ' Wrap file:// URLs with `new URL`.' : ''\x0d\n  ) +\x0d\n  (StringPrototypeStartsWith(filename\x2C 'data:text/javascript') ?\x0d\n    ' Wrap data: URLs with `new URL`.' : ''\x0d\n  ) +\x0d\n  ` Received "${filename}"`\x2C\x0d\n  TypeError);\x0d\nE('ERR_WORKER_UNSERIALIZABLE_ERROR'\x2C\x0d\n  'Serializing an uncaught exception failed'\x2C Error);\x0d\nE('ERR_WORKER_UNSUPPORTED_OPERATION'\x2C\x0d\n  '%s is not supported in workers'\x2C TypeError);\x0d\nE('ERR_ZLIB_INITIALIZATION_FAILED'\x2C 'Initialization failed'\x2C Error);\x0d\n
code-source-info,0x306324b5516,11,9915,10856,C0O9915C3O9946C10O9952C15O9974C20O9978C25O10012C33O10034C37O10058C40O10058C46O10130C51O10134C56O10168C65O10190C69O10220C83O10220C89O10255C96O10278C105O10295C109O10310C121O10443C128O10461C142O10579C147O10590C162O10255C167O10778C174O10778C178O10815C180O10826C184O10838C186O10851,,
code-creation,LazyCompile,10,288021,0x306324b8a7e,64,isErrorStackTraceLimitWritable node:internal/errors:198:40,0x147335e57f8,~
code-source-info,0x306324b8a7e,11,5744,6010,C0O5765C7O5796C13O5765C19O5826C21O5857C28O5883C31O5864C35O5890C36O5901C44O5908C51O5968C57O5989C62O5993C63O6007,,
code-creation,LazyCompile,10,288126,0x306324b8d16,287,getMessage node:internal/errors:410:20,0x147335e5e00,~
code-source-info,0x306324b8d16,11,11929,12791,C0O11964C5O11973C10O11973C16O11988C22O12014C28O12023C35O12021C41O12056C47O12094C52O12113C57O12128C61O12120C70O12185C81O12229C99O12292C113O12249C117O12094C122O12316C136O12323C141O12353C142O12392C147O12414C152O12393C162O12441C167O12452C172O12489C176O12480C185O12511C196O12555C216O12612C226O12575C230O12452C235O12649C241O12656C246O12668C248O12679C249O12685C254O12685C259O12722C267O12742C271O12767C281O12729C286O12788,,
code-creation,LazyCompile,10,288230,0x306324b8fb6,9, node:internal/errors:1325:30,0x147335e69b0,~
code-source-info,0x306324b8fb6,11,48050,48200,C0O48063C2O48074C6O48176C8O48197,,
code-creation,LazyCompile,10,288305,0x306324b90f6,68,captureLargerStackTrace node:internal/errors:458:35,0x147335e5ef0,~
code-source-info,0x306324b90f6,11,13260,13641,C0O13307C3O13307C7O13346C9O13386C14O13414C21O13406C27O13438C32O13462C35O13460C39O13484C44O13484C48O13542C52O13573C59O13597C61O13595C65O13625C67O13636,,
code-creation,LazyCompile,10,288464,0x306324b935e,423,packageResolve node:internal/modules/esm/resolve:838:24,0x1abee8339d8,~
code-source-info,0x306324b935e,110,28099,30154,C0O28134C5O28151C10O28151C17O28189C27O28212C33O28196C38O28225C39O28286C42O28286C48O28239C53O28252C58O28268C63O28366C66O28366C71O28416C77O28454C82O28482C87O28454C92O28517C99O28522C104O28564C110O28603C116O28630C134O28637C139O28734C140O28778C150O28804C156O28818C165O28778C171O28869C176O28869C181O28907C183O28943C190O28955C195O29063C199O29070C206O28955C212O28943C217O29093C222O29093C228O29117C231O29152C238O29178C249O29254C255O29277C264O29169C270O29320C275O29338C280O29376C282O29445C294O29445C300O29520C306O29559C312O29586C330O29593C335O29690C336O29703C338O29722C343O29740C355O29747C360O29838C361O29853C374O29860C379O29900C380O29964C385O29984C389O29971C394O28920C397O30086C404O30130C407O30130C417O30092C422O30086,,
code-creation,LazyCompile,10,288613,0x306324b97c6,213,parsePackageName node:internal/modules/esm/resolve:799:26,0x1abee833988,~
code-source-info,0x306324b97c6,110,26848,27906,C0O26892C8O26892C14O26958C16O26982C18O26992C19O27005C25O27009C30O27025C32O27047C34O27066C39O27086C45O27093C50O27109C54O27156C64O27237C71O27173C77O27280C79O27295C90O27321C101O27321C107O27476C114O27500C117O27480C124O27553C126O27584C130O27614C140O27703C143O27703C153O27620C158O27614C159O27758C164O27780C175O27799C178O27799C183O27762C187O27854C194O27863C200O27876C206O27892C212O27903,,
code-creation,LazyCompile,10,289152,0x306324ba506,522,legacyMainResolve node:internal/modules/esm/resolve:275:27,0x1abee833438,~
code-source-info,0x306324ba506,110,8415,10267,C0O8462C2O8490C8O8594C13O8621C19O8644C33O8617C39O8598C45O8715C47O8728C48O8741C53O8768C59O8791C79O8764C85O8745C93O8874C98O8901C104O8924C124O8897C130O8878C138O9007C143O9034C149O9057C169O9030C175O9011C183O9140C188O9167C194O9190C214O9163C220O9144C228O9277C233O9304C239O9327C259O9300C265O9281C273O9416C278O9443C284O9466C304O9439C310O9420C318O9555C320O9579C324O9599C327O9703C341O9599C346O9717C348O9730C349O9767C354O9794C365O9790C371O9771C379O9852C384O9879C395O9875C401O9856C409O9926C414O9953C425O9949C431O9930C439O10000C441O10022C445O10040C448O10110C462O10040C467O10122C469O10135C470O10161C477O10198C482O10216C493O10212C499O10198C506O10243C509O10243C516O10167C521O10161,,
code-creation,LazyCompile,10,289306,0x306324ba8e6,36,fileExists node:internal/modules/esm/resolve:259:20,0x1abee8333e8,~
code-source-info,0x306324ba8e6,110,7906,7987,C0O7917C5O7933C10O7924C18O7964C23O7966C35O7984,,
code-creation,Function,11,289387,0x29be72cf040,180,toPathIfFileURL node:internal/url:1558:25,0x14121bf97e8,^
code-source-info,0x29be72cf040,39,45194,45319,,,
code-creation,Function,11,289428,0x29be72cf180,1516,onParseComplete node:internal/url:542:25,0x14121bf8220,^
code-source-info,0x29be72cf180,39,15195,15881,,,
code-creation,Function,11,289459,0x29be72cf800,876,URL node:internal/url:634:14,0x14121bf8540,^
code-source-info,0x29be72cf800,39,18190,18547,,,
code-creation,Function,11,289489,0x29be72cfc00,932, node:internal/validators:154:3,0x147335fd0c8,^
code-source-info,0x29be72cfc00,15,4537,5108,,,
code-creation,RegExp,3,289662,0x29be72d0040,1056,%2F|%5C
code-creation,Function,11,289718,0x29be72d0500,864,get pathname node:internal/url:921:15,0x14121bf8e08,^
code-source-info,0x29be72d0500,39,25976,26245,,,
code-creation,Function,11,289747,0x29be72d0900,224,msFromTimeSpec node:internal/fs/utils:446:24,0x1d4982a2018,^
code-source-info,0x29be72d0900,82,11451,11512,,,
code-creation,Function,11,289771,0x29be72d0a80,272,dateFromMs node:internal/fs/utils:460:20,0x1d4982a20b8,^
code-source-info,0x29be72d0a80,82,11977,12024,,,
code-creation,Function,11,289813,0x29be72d0c40,2628, node:internal/url:696:12,0x14121bf8708,^
code-source-info,0x29be72d0c40,39,20006,21301,,,
code-creation,RegExp,3,290261,0x29be72d1740,700,(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])
code-creation,Function,11,290371,0x29be72d1a80,2096,extname node:path:836:10,0x394c9e0d838,^
code-source-info,0x29be72d1a80,41,26915,29043,,,
code-creation,Function,11,290406,0x29be72d2340,596,handleErrorFromBinding node:internal/fs/utils:340:32,0x1d4982a1af8,^
code-source-info,0x29be72d2340,82,8269,8780,,,
code-creation,Function,11,290437,0x29be72d2640,352,initSearchParams node:internal/url:1078:26,0x14121bf9288,^
code-source-info,0x29be72d2640,39,30302,30423,,,
code-creation,Function,11,290462,0x29be72d2840,392,get protocol node:internal/url:791:15,0x14121bf88e8,^
code-source-info,0x29be72d2840,39,22572,22684,,,
code-creation,LazyCompile,10,290617,0x306324bbb06,3,node: node:internal/modules/esm/get_format:59:10,0x1abee837690,~
code-source-info,0x306324bbb06,111,1843,1867,C0O1848C2O1865,,
code-creation,LazyCompile,10,290747,0x306324bbdc6,357,commonjsStrategy node:internal/modules/esm/translators:146:60,0x109c10ec8d8,~
code-source-info,0x306324bbdc6,122,4519,5925,C4O4519C40O4607C52O4638C57O4607C61O4666C68O4684C77O4702C85O4698C91O4684C96O4666C98O4716C106O4736C120O4780C126O4747C131O4745C133O4805C141O4820C146O4826C157O4820C182O4877C190O4877C195O4853C201O4861C207O4941C210O4953C218O4953C227O4979C238O5009C241O5009C295O5028C307O5066C317O5035C332O5922,,
code-creation,LazyCompile,10,290870,0x306324bc206,151,initCJSParse node:internal/modules/esm/translators:58:28,0x109c10ec608,~
code-source-info,0x306324bc206,122,1661,1935,C10O1661C18O1669C26O1716C32O1727C37O1774C44O1725C52O1832C58O1832C63O1807C68O1814C73O1897C84O1891C107O1910C109O1919C126O1934,,
code-creation,Eval,10,291113,0x306324bc64e,5, node:internal/deps/cjs-module-lexer/dist/lexer:1:1,0x306324bc4a8,~
script-source,149,node:internal/deps/cjs-module-lexer/dist/lexer,"use strict";exports.parse=parse;exports.init=init;let A;const Q=1===new Uint8Array(new Uint16Array([1]).buffer)[0];function parse(g\x2CI="@"){if(!A)throw new Error("Not initialized");const D=g.length+1\x2CN=(A.__heap_base.value||A.__heap_base)+4*D-A.memory.buffer.byteLength;N>0&&A.memory.grow(Math.ceil(N/65536));const k=A.sa(D);if((Q?C:E)(g\x2Cnew Uint16Array(A.memory.buffer\x2Ck\x2CD))\x2C!A.parseCJS(k\x2Cg.length\x2C0\x2C0\x2C0))throw Object.assign(new Error(`Parse error ${I}${A.e()}:${g.slice(0\x2CA.e()).split("\\n").length}:${A.e()-g.lastIndexOf("\\n"\x2CA.e()-1)}`)\x2C{idx:A.e()});let w=new Set\x2Co=new Set\x2CJ=new Set;for(;A.rre();){const Q=B(g.slice(A.res()\x2CA.ree()));Q&&o.add(Q)}for(;A.ru();)J.add(B(g.slice(A.us()\x2CA.ue())));for(;A.re();){let Q=B(g.slice(A.es()\x2CA.ee()));void 0===Q||J.has(Q)||w.add(Q)}return{exports:[...w]\x2Creexports:[...o]}}function B(A){if('"'!==A[0]&&"'"!==A[0])return A;try{const Q=(0\x2Ceval)(A);for(let A=0;A<Q.length;A++){const B=64512&Q.charCodeAt(A);if(!(B<55296)){if(55296!==B)return;if(56320!=(64512&Q.charCodeAt(++A)))return}}return Q}catch{}}function E(A\x2CQ){const B=A.length;let E=0;for(;E<B;){const B=A.charCodeAt(E);Q[E++]=(255&B)<<8|B>>>8}}function C(A\x2CQ){const B=A.length;let E=0;for(;E<B;)Q[E]=A.charCodeAt(E++)}let g;function init(){return g||(g=(async()=>{const Q=await WebAssembly.compile((B="AGFzbQEAAAABrAERYAJ/fwBgAABgAX8Bf2AAAX9gBn9/f39/fwF/YAF/AGAXf39/f39/f39/f39/f39/f39/f39/f38Bf2AIf39/f39/f38Bf2AHf39/f39/fwF/YAN/f38Bf2AFf39/f38Bf2AOf39/f39/f39/f39/f38Bf2AKf39/f39/f39/fwF/YAt/f39/f39/f39/fwF/YAJ/fwF/YAR/f39/AX9gCX9/f39/f39/fwF/A0NCAgMDAwMDAwMDAwMAAAABBAICBQQFAQECAgICAQUBAQUBAQYHAQIIAwICAgkKAgELAgwNDgQPCA4HAgICAhACAgMJBAUBcAEFBQUDAQABBg8CfwFB0JgCC38AQdCYAgsHXA4GbWVtb3J5AgACc2EAAAFlAAECZXMAAgJlZQADA3JlcwAEA3JlZQAFAnVzAAYCdWUABwJyZQAIA3JyZQAJAnJ1AAoIcGFyc2VDSlMADwtfX2hlYXBfYmFzZQMBCQoBAEEBCwQLDA0OCtOhAUJ4AQF/QQAoApgfIgEgAEEBdGoiAEEAOwEAQQAgAEECaiIANgLkH0EAIAA2AugfQQBBADYCwB9BAEEANgLIH0EAQQA2AsQfQQBBADYCzB9BAEEANgLUH0EAQQA2AtAfQQBBADYC2B9BAEEANgLgH0EAQQA2AtwfIAELCABBACgC7B8LFQBBACgCxB8oAgBBACgCmB9rQQF1CxUAQQAoAsQfKAIEQQAoApgfa0EBdQsVAEEAKALQHygCAEEAKAKYH2tBAXULFQBBACgC0B8oAgRBACgCmB9rQQF1CxUAQQAoAtwfKAIAQQAoApgfa0EBdQsVAEEAKALcHygCBEEAKAKYH2tBAXULJQEBf0EAQQAoAsQfIgBBCGpBwB8gABsoAgAiADYCxB8gAEEARwslAQF/QQBBACgC0B8iAEEIakHMHyAAGygCACIANgLQHyAAQQBHCyUBAX9BAEEAKALcHyIAQQhqQdgfIAAbKAIAIgA2AtwfIABBAEcLSAEBf0EAKALIHyICQQhqQcAfIAIbQQAoAugfIgI2AgBBACACNgLIH0EAIAJBDGo2AugfIAJBADYCCCACIAE2AgQgAiAANgIAC0gBAX9BACgC1B8iAkEIakHMHyACG0EAKALoHyICNgIAQQAgAjYC1B9BACACQQxqNgLoHyACQQA2AgggAiABNgIEIAIgADYCAAtIAQF/QQAoAuAfIgJBCGpB2B8gAhtBACgC6B8iAjYCAEEAIAI2AuAfQQAgAkEMajYC6B8gAkEANgIIIAIgATYCBCACIAA2AgALEgBBAEEANgLMH0EAQQA2AtQfC6MPAEEAIAE2AoBAQQAgADYCmB8CQCACRQ0AQQAgAjYCnB8LAkAgA0UNAEEAIAM2AqAfCwJAIARFDQBBACAENgKkHwtBAEH//wM7AYhAQQBBoMAANgKgYEEAQbDgADYCsKABQQBBgCA2ArSgAUEAQQAoAqwfNgKMQEEAIABBfmoiAjYCvKABQQAgAiABQQF0aiIDNgLAoAFBAEEAOwGGQEEAQQA7AYRAQQBBADoAkEBBAEEANgLsH0EAQQA6APAfQQBBADoAuKABAkACQCAALwEAQSNHDQAgAC8BAkEhRw0AQQEhAiABQQJGDQFBACAAQQJqNgK8oAEgAEEEaiEAAkADQCAAIgJBfmogA08NASACQQJqIQAgAi8BAEF2aiIBQQNLDQAgAQ4EAQAAAQELC0EAIAI2ArygAQsDQEEAIAJBAmoiADYCvKABAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACIANPDQACQCAALwEAIgFBd2oiA0EXSw0AQQEgA3RBn4CABHENFwsCQAJAQQAvAYZAIgMNACABQaF/aiIEQQ5NDQMgAUFZaiIEQQhNDQQgAUGFf2oiBEECTQ0FIAFBIkYNCyABQc8ARg0BIAFB8gBHDRUCQEEAEBBFDQAgABARRQ0AIAIQEgtBAEEAKAK8oAE2AoxADBgLIAFBWWoiBEEITQ0FIAFBoH9qIgRBBU0NBiABQYV/aiIEQQJNDQcgAUEiRg0KIAFBzwBGDQAgAUHtAEcNFAwTCyACQQRqQeIAQeoAQeUAQeMAQfQAEBNFDRMgABARRQ0TIANFEBQMEwtBAC8BiEBB//8DRkEALwGGQEVxQQAtAPAfRXEPCyAEDg8SBRERDhEPERERExERERASCyAEDgkGDAgQEBAQEAUGCyAEDgMJDwcJCyAEDgkECgkODg4ODgMECyAEDgYBDQ0KDQsBCyAEDgMGDAMGC0EALwGIQEH+/wNGDQMMBAsCQAJAIAIvAQQiAkEqRg0AIAJBL0cNARAVDA8LEBYMDgsCQAJAAkACQEEAKAKMQCIALwEAIgIQF0UNACACQVVqIgNBA0sNAgJAAkACQCADDgQBBQIAAQsgAEF+ai8BAEFQakH//wNxQQpJDQMMBAsgAEF+ai8BAEErRg0CDAMLIABBfmovAQBBLUYNAQwCCwJAAkAgAkH9AEYNACACQS9GDQEgAkEpRw0CQQAoArCgASADQQJ0aigCABAYRQ0CDAMLQQAoArCgASADQQJ0aigCABAZDQIgA0HQoAFqLQAARQ0BDAILQQAtAJBADQELIAAQGiEDIAJFDQBBASECIANFDQELEBtBACECC0EAIAI6AJBADAoLIAEQHAwJC0EAIANBf2oiADsBhkACQCADQQAvAYhAIgJHDQBBAEEALwGEQEF/aiICOwGEQEEAQQAoAqBgIAJB//8DcUEBdGovAQA7AYhADAILIAJB//8DRg0IIABB//8DcSACTw0ICxAdQQAhAgwMCxAeDAYLIANB0KABakEALQC4oAE6AABBACADQQFqOwGGQEEAKAKwoAEgA0ECdGpBACgCjEA2AgBBAEEAOgC4oAEMBQtBACADQX9qOwGGQAwEC0EAIANBAWo7AYZAQQAoArCgASADQQJ0akEAKAKMQDYCAAwDCyAAEBFFDQIgAi8BBEHsAEcNAiACLwEGQeEARw0CIAIvAQhB8wBHDQIgAi8BCkHzAEcNAgJAAkAgAi8BDCIDQXdqIgJBF0sNAEEBIAJ0QZ+AgARxDQELIANBoAFHDQMLQQBBAToAuKABDAILIAJBBGpB+ABB8ABB7wBB8gBB9AAQE0UNASAAEBFFDQECQCACLwEOQfMARw0AQQAQHwwCCyADDQEQIAwBCyACQQRqQe8AQeQAQfUAQewAQeUAEBNFDQAgABARRQ0AECELQQBBACgCvKABNgKMQAwCCwJAAkAgAkEEaiIDQekAQe4AQfQAQeUAQfIAQe8AQfAAQdIAQeUAQfEAQfUAQekAQfIAQeUAQdcAQekAQewAQeQAQeMAQeEAQfIAQeQAECJFDQACQCAAEBENACACLwEAQS5HDQELQQAgAkEwajYCvKABIAIvATBBKEcNAUEAIAJBMmo2ArygAUEAQQE7AYZAQQAoArCgAUEAKAKMQDYCAEEAEBBFDQEgABARRQ0BIAIQEgwBCyADQd8AQeUAQfgAQfAAQe8AQfIAQfQAECNFDQACQCAAEBENACACLwEAQS5HDQELQQAgAkESajYCvKABAkAgAi8BEiIDQdMARw0AIAIvARRB9ABHDQEgAi8BFkHhAEcNASACLwEYQfIARw0BQQAgAkEaajYCvKABIAIvARohAwsgA0H//wNxQShHDQBBACgCsKABQQAoAoxANgIAQQBBATsBhkBBAEEAKAK8oAEiAkECajYCvKABIAIvAQJB8gBHDQBBAhAQGgtBAEEAKAK8oAE2AoxADAELAkAgAkEEakHtAEHwAEHvAEHyAEH0ABATRQ0AIAAQEUUNABAkQQAoArygASEAC0EAIAA2AoxAC0EAKALAoAEhA0EAKAK8oAEhAgwACwsgAgv3AQEEf0EAIQECQEEAKAK8oAEiAkECakHlAEHxAEH1AEHpAEHyAEHlABAmRQ0AQQAhAUEAIAJBDmo2ArygAQJAECdBKEcNAEEAQQAoArygAUECajYCvKABECchA0EAKAK8oAEhBAJAIANBJ0YNACADQSJHDQELIAMQHEEAQQAoArygAUECaiIDNgK8oAEQJ0EpRw0AAkAgAEF/aiIBQQFLDQACQAJAIAEOAgEAAQsgBCADQQAoAqAfEQAAQQEPCyAEIANBACgCoB8RAABBAQ8LQQAoArSgASAENgIAQQAoArSgASADNgIEQQEPC0EAIAI2ArygAQsgAQsdAAJAQQAoApgfIABHDQBBAQ8LIABBfmovAQAQJQv+AgEEf0EAKAKYHyEBAkADQCAAQX5qIQIgAC8BACIDQSBHDQEgACABSyEEIAIhACAEDQALCwJAIANBPUcNAAJAA0AgAkF+aiEAIAIvAQBBIEcNASACIAFLIQQgACECIAQNAAsLIABBAmohAiAAQQRqIQNBACEEAkADQCACECghACACIAFNDQEgAEUNASAAQdwARg0CIAAQKUUNASACQX5BfCAAQYCABEkbaiECIAAQKiEEDAALCyAEQQFxRQ0AIAIvAQBBIEcNAEEAKAK0oAEiBEEAKAKwH0YNACAEIAM2AgwgBCACQQJqNgIIIAJBfmohAEEgIQICQANAIABBAmogAU0NASACQf//A3FBIEcNASAALwEAIQIgAEF+aiEADAALCyACQf//A3FBjn9qIgJBAksNAAJAAkACQCACDgMAAwEACyAAQfYAQeEAECsNAQwCCyAAQewAQeUAECsNACAAQeMAQe8AQe4AQfMAECxFDQELQQAgBEEQajYCtKABCws/AQF/QQAhBgJAIAAvAQAgAUcNACAALwECIAJHDQAgAC8BBCADRw0AIAAvAQYgBEcNACAALwEIIAVGIQYLIAYLpCYBCH9BAEEAKAK8oAEiAUEMajYCvKABIAFBCmohAQJAECdBLkcNAEEAQQAoArygAUECajYCvKABAkACQBAnIgJB5ABHDQBBACgCvKABIgBBAmpB5QBB5gBB6QBB7gBB5QBB0ABB8gBB7wBB8ABB5QBB8gBB9ABB+QAQL0UNAkEAIABBHGo2ArygASAAQRpqIQEQJ0EoRw0CQQBBACgCvKABQQJqNgK8oAEQJxAwRQ0CECdBLEcNAkEAQQAoArygAUECajYCvKABAkAQJyIAQSdGDQAgAEEiRw0DC0EAKAK8oAEhAiAAEBxBAEEAKAK8oAFBAmoiADYCvKABECdBLEcNAUEAQQAoArygAUECajYCvKABECdB+wBHDQFBAEEAKAK8oAFBAmo2ArygAQJAECciA0HlAEcNAEEAKAK8oAEiA0ECakHuAEH1AEHtAEHlAEHyAEHhAEHiAEHsAEHlABAxRQ0CQQAgA0EUajYCvKABECdBOkcNAkEAQQAoArygAUECajYCvKABECdB9ABHDQJBACgCvKABIgMvAQJB8gBHDQIgAy8BBEH1AEcNAiADLwEGQeUARw0CQQAgA0EIajYCvKABECdBLEcNAkEAQQAoArygAUECajYCvKABECchAwsCQCADQecARg0AIANB9gBHDQJBACgCvKABIgMvAQJB4QBHDQIgAy8BBEHsAEcNAiADLwEGQfUARw0CIAMvAQhB5QBHDQJBACADQQpqNgK8oAEQJ0E6Rw0CIAIgAEEAKAKcHxEAAEEAIAE2ArygAQ8LQQAoArygASIDLwECQeUARw0BIAMvAQRB9ABHDQFBACADQQZqNgK8oAECQBAnIgNBOkcNAEEAQQAoArygAUECajYCvKABECdB5gBHDQJBACgCvKABIgNBAmpB9QBB7gBB4wBB9ABB6QBB7wBB7gAQI0UNAkEAIANBEGoiAzYCvKABAkAQJyIEQShGDQAgA0EAKAK8oAFGDQMgBBAtRQ0DCxAnIQMLIANBKEcNAUEAQQAoArygAUECajYCvKABECdBKUcNAUEAQQAoArygAUECajYCvKABECdB+wBHDQFBAEEAKAK8oAFBAmo2ArygARAnQfIARw0BQQAoArygASIDQQJqQeUAQfQAQfUAQfIAQe4AEBNFDQFBACADQQxqNgK8oAEQJxAtRQ0BAkACQAJAECciA0HbAEYNACADQS5HDQJBAEEAKAK8oAFBAmo2ArygARAnEC0NAQwEC0EAQQAoArygAUECajYCvKABAkAQJyIDQSdGDQAgA0EiRw0ECyADEBxBAEEAKAK8oAFBAmo2ArygARAnQd0ARw0DQQBBACgCvKABQQJqNgK8oAELECchAwsCQCADQTtHDQBBAEEAKAK8oAFBAmo2ArygARAnIQMLIANB/QBHDQFBAEEAKAK8oAFBAmo2ArygAQJAECciA0EsRw0AQQBBACgCvKABQQJqNgK8oAEQJyEDCyADQf0ARw0BQQBBACgCvKABQQJqNgK8oAEQJ0EpRw0BIAIgAEEAKAKcHxEAAA8LIAJB6wBHDQEgAEUNAUEAKAK8oAEiAC8BAkHlAEcNASAALwEEQfkARw0BIAAvAQZB8wBHDQEgAEEGaiEBQQAgAEEIajYCvKABECdBKEcNAUEAQQAoArygAUECajYCvKABECchAEEAKAK8oAEhAiAAEC1FDQFBACgCvKABIQAQJ0EpRw0BQQBBACgCvKABIgFBAmo2ArygARAnQS5HDQFBAEEAKAK8oAFBAmo2ArygARAnQeYARw0BQQAoArygASIDQQJqQe8AQfIAQcUAQeEAQeMAQegAECZFDQFBACADQQ5qNgK8oAEQJyEDQQAoArygASIEQX5qIQEgA0EoRw0BQQAgBEECajYCvKABECdB5gBHDQFBACgCvKABIgNBAmpB9QBB7gBB4wBB9ABB6QBB7wBB7gAQI0UNAUEAIANBEGo2ArygARAnQShHDQFBAEEAKAK8oAFBAmo2ArygARAnIQNBACgCvKABIQQgAxAtRQ0BQQAoArygASEDECdBKUcNAUEAQQAoArygAUECajYCvKABECdB+wBHDQFBAEEAKAK8oAFBAmo2ArygARAnQekARw0BQQAoArygASIFLwECQeYARw0BQQAgBUEEajYCvKABECdBKEcNAUEAQQAoArygAUECajYCvKABECcaQQAoArygASIFIAQgAyAEayIDEEENASAAIAJrIgZBAXUhB0EAIAUgA0EBdSIIQQF0ajYCvKABAkACQAJAECciAEEhRg0AIABBPUcNBEEAKAK8oAEiAC8BAkE9Rw0EIAAvAQRBPUcNBEEAIABBBmo2ArygAQJAECciAEEnRg0AIABBIkcNBQtBACgCvKABIgVBAmpB5ABB5QBB5gBB4QBB9QBB7ABB9AAQI0UNBEEAIAVBEGo2ArygARAnIABHDQRBAEEAKAK8oAFBAmo2ArygARAnQfwARw0EQQAoArygASIALwECQfwARw0EQQAgAEEEajYCvKABECcaQQAoArygASIAIAQgAxBBDQRBACAAIAhBAXRqNgK8oAEQJ0E9Rw0EQQAoArygASIALwECQT1HDQQgAC8BBEE9Rw0EQQAgAEEGajYCvKABAkAQJyIAQSdGDQAgAEEiRw0FC0EAKAK8oAEiBUECakHfAEHfAEHlAEHzAEHNAEHvAEHkAEH1AEHsAEHlABAyRQ0EQQAgBUEWajYCvKABECcgAEcNBEEAQQAoArygAUECajYCvKABECdBKUcNBEEAQQAoArygAUECajYCvKABECdB8gBHDQRBACgCvKABIgBBAmpB5QBB9ABB9QBB8gBB7gAQE0UNBEEAIABBDGo2ArygAQJAECdBO0cNAEEAQQAoArygAUECajYCvKABCxAnIgBB6QBHDQJB6QAhAEEAKAK8oAEiBS8BAkHmAEcNAkEAIAVBBGo2ArygARAnQShHDQRBAEEAKAK8oAFBAmoiADYCvKABAkAgBCAIEDNFDQAQJ0EpRw0FQQBBACgCvKABQQJqNgK8oAEQJ0HyAEcNBUEAKAK8oAEiAEECakHlAEH0AEH1AEHyAEHuABATRQ0FQQAgAEEMajYCvKABAkAQJ0E7Rw0AQQBBACgCvKABQQJqNgK8oAELECciAEHpAEcNA0HpACEAQQAoArygASIFLwECQeYARw0DQQAgBUEEajYCvKABECdBKEcNBUEAKAK8oAFBAmohAAtBACAANgK8oAEgACAEIAMQQQ0EQQAgACAIQQF0ajYCvKABECdB6QBHDQRBACgCvKABIgAvAQJB7gBHDQQgAC8BBEEgRw0EQQAgAEEGajYCvKABECcQMEUNBBAnQSZHDQRBACgCvKABIgAvAQJBJkcNBEEAIABBBGo2ArygARAnEDBFDQQQJ0HbAEcNBEEAQQAoArygAUECajYCvKABECcaQQAoArygASIAIAQgAxBBDQRBACAAIAhBAXRqNgK8oAEQJ0HdAEcNBEEAQQAoArygAUECajYCvKABECdBPUcNBEEAKAK8oAEiAC8BAkE9Rw0EIAAvAQRBPUcNBEEAIABBBmo2ArygARAnGkEAKAK8oAEiACACIAYQQQ0EQQAgACAHQQF0ajYCvKABECdB2wBHDQRBAEEAKAK8oAFBAmo2ArygARAnGkEAKAK8oAEiACAEIAMQQQ0EQQAgACAIQQF0ajYCvKABECdB3QBHDQRBAEEAKAK8oAFBAmo2ArygARAnQSlHDQRBAEEAKAK8oAFBAmo2ArygARAnQfIARw0EQQAoArygASIAQQJqQeUAQfQAQfUAQfIAQe4AEBNFDQRBACAAQQxqNgK8oAEQJ0E7Rw0BQQBBACgCvKABQQJqNgK8oAEMAQtBACgCvKABIgAvAQJBPUcNAyAALwEEQT1HDQNBACAAQQZqNgK8oAECQBAnIgBBJ0YNACAAQSJHDQQLQQAoArygASIFQQJqQeQAQeUAQeYAQeEAQfUAQewAQfQAECNFDQNBACAFQRBqNgK8oAEQJyAARw0DQQBBACgCvKABQQJqNgK8oAECQBAnIgBBJkcNAEEAKAK8oAEiAC8BAkEmRw0EQQAgAEEEajYCvKABECdBIUcNBEEAQQAoArygAUECajYCvKABAkACQBAnIgBBzwBHDQBBACgCvKABQQJqQeIAQeoAQeUAQeMAQfQAQS4QJkUNACAEIAgQM0UNBgwBCyAAEC1FDQAQJ0EuRw0FQQBBACgCvKABQQJqNgK8oAEQJ0HoAEcNBUEAKAK8oAEiAEECakHhAEHzAEHPAEH3AEHuAEHQAEHyAEHvAEHwAEHlAEHyAEH0AEH5ABAvRQ0FQQAgAEEcajYCvKABECdBKEcNBUEAQQAoArygAUECajYCvKABECcaQQAoArygASIAIAQgAxBBDQVBACAAIAhBAXRqNgK8oAEQJ0EpRw0FQQBBACgCvKABQQJqNgK8oAELECchAAsgAEEpRw0DQQBBACgCvKABQQJqNgK8oAELECchAAsCQAJAAkAgABAwRQ0AECdB2wBHDQRBAEEAKAK8oAFBAmo2ArygARAnGkEAKAK8oAEiACAEIAMQQQ0EQQAgACAIQQF0ajYCvKABECdB3QBHDQRBAEEAKAK8oAFBAmo2ArygARAnQT1HDQRBAEEAKAK8oAFBAmo2ArygARAnGkEAKAK8oAEiACACIAYQQQ0EQQAgACAHQQF0ajYCvKABECdB2wBHDQRBAEEAKAK8oAFBAmo2ArygARAnGkEAKAK8oAEiACAEIAMQQQ0EQQAgACAIQQF0ajYCvKABECdB3QBHDQRBAEEAKAK8oAFBAmo2ArygARAnIgBBO0cNAkEAQQAoArygAUECajYCvKABDAELIABBzwBHDQNBACgCvKABIgBBAmpB4gBB6gBB5QBB4wBB9AAQE0UNA0EAIABBDGo2ArygARAnQS5HDQNBAEEAKAK8oAFBAmo2ArygARAnQeQARw0DQQAoArygASIAQQJqQeUAQeYAQekAQe4AQeUAQdAAQfIAQe8AQfAAQeUAQfIAQfQAQfkAEC9FDQNBACAAQRxqNgK8oAEQJ0EoRw0DQQBBACgCvKABQQJqNgK8oAEQJxAwRQ0DECdBLEcNA0EAQQAoArygAUECajYCvKABECcaQQAoArygASIAIAQgAxBBDQNBACAAIAhBAXRqNgK8oAEQJ0EsRw0DQQBBACgCvKABQQJqNgK8oAEQJ0H7AEcNA0EAQQAoArygAUECajYCvKABECdB5QBHDQNBACgCvKABIgBBAmpB7gBB9QBB7QBB5QBB8gBB4QBB4gBB7ABB5QAQMUUNA0EAIABBFGo2ArygARAnQTpHDQNBAEEAKAK8oAFBAmo2ArygARAnIQVBACgCvKABIQACQCAFQfQARg0AIAAvAQJB8gBHDQQgAC8BBEH1AEcNBCAALwEGQeUARw0EC0EAIABBCGo2ArygARAnQSxHDQNBAEEAKAK8oAFBAmo2ArygARAnQecARw0DQQAoArygASIALwECQeUARw0DIAAvAQRB9ABHDQNBACAAQQZqNgK8oAECQBAnIgBBOkcNAEEAQQAoArygAUECajYCvKABECdB5gBHDQRBACgCvKABIgBBAmpB9QBB7gBB4wBB9ABB6QBB7wBB7gAQI0UNBEEAIABBEGoiADYCvKABAkAQJyIFQShGDQAgAEEAKAK8oAFGDQUgBRAtRQ0FCxAnIQALIABBKEcNA0EAQQAoArygAUECajYCvKABECdBKUcNA0EAQQAoArygAUECajYCvKABECdB+wBHDQNBAEEAKAK8oAFBAmo2ArygARAnQfIARw0DQQAoArygASIAQQJqQeUAQfQAQfUAQfIAQe4AEBNFDQNBACAAQQxqNgK8oAEQJxpBACgCvKABIgAgAiAGEEENA0EAIAAgB0EBdGo2ArygARAnQdsARw0DQQBBACgCvKABQQJqNgK8oAEQJxpBACgCvKABIgAgBCADEEENA0EAIAAgCEEBdGo2ArygARAnQd0ARw0DQQBBACgCvKABQQJqNgK8oAECQBAnIgBBO0cNAEEAQQAoArygAUECajYCvKABECchAAsgAEH9AEcNA0EAQQAoArygAUECajYCvKABAkAQJyIAQSxHDQBBAEEAKAK8oAFBAmo2ArygARAnIQALIABB/QBHDQNBAEEAKAK8oAFBAmo2ArygARAnQSlHDQNBAEEAKAK8oAFBAmo2ArygARAnIgBBO0cNAUEAQQAoArygAUECajYCvKABCxAnIQALIABB/QBHDQFBAEEAKAK8oAFBAmo2ArygARAnQSlHDQFBACgCtKABIQRBgCAhAANAAkACQCAEIABGDQAgByAAQQxqKAIAIABBCGooAgAiA2tBAXVHDQEgAiADIAYQQQ0BIAAoAgAgAEEEaigCAEEAKAKgHxEAAEEAIAE2ArygAQsPCyAAQRBqIQAMAAsLIAIgAEEAKAKkHxEAAAtBACABNgK8oAELUwEEf0EAKAK8oAFBAmohAEEAKALAoAEhAQJAA0AgACICQX5qIAFPDQEgAkECaiEAIAIvAQBBdmoiA0EDSw0AIAMOBAEAAAEBCwtBACACNgK8oAELfAECf0EAQQAoArygASIAQQJqNgK8oAEgAEEGaiEAQQAoAsCgASEBA0ACQAJAAkAgAEF8aiABTw0AIABBfmovAQBBKkcNAiAALwEAQS9HDQJBACAAQX5qNgK8oAEMAQsgAEF+aiEAC0EAIAA2ArygAQ8LIABBAmohAAwACwt1AQF/AkACQCAAQV9qIgFBBUsNAEEBIAF0QTFxDQELIABBRmpB//8DcUEGSQ0AIABBWGpB//8DcUEHSSAAQSlHcQ0AAkAgAEGlf2oiAUEDSw0AIAEOBAEAAAEBCyAAQf0ARyAAQYV/akH//wNxQQRJcQ8LQQELPQEBf0EBIQECQCAAQfcAQegAQekAQewAQeUAEDQNACAAQeYAQe8AQfIAEDUNACAAQekAQeYAECshAQsgAQutAQEDf0EBIQECQAJAAkACQAJAAkACQCAALwEAIgJBRWoiA0EDTQ0AIAJBm39qIgNBA00NASACQSlGDQMgAkH5AEcNAiAAQX5qQeYAQekAQe4AQeEAQewAQewAEDYPCyADDgQCAQEFAgsgAw4EAgAAAwILQQAhAQsgAQ8LIABBfmpB5QBB7ABB8wAQNQ8LIABBfmpB4wBB4QBB9ABB4wAQLA8LIABBfmovAQBBPUYL7QMBAn9BACEBAkAgAC8BAEGcf2oiAkETSw0AAkACQAJAAkACQAJAAkACQCACDhQAAQIICAgICAgIAwQICAUIBggIBwALIABBfmovAQBBl39qIgJBA0sNBwJAAkAgAg4EAAkJAQALIABBfGpB9gBB7wAQKw8LIABBfGpB+QBB6QBB5QAQNQ8LIABBfmovAQBBjX9qIgJBAUsNBgJAAkAgAg4CAAEACwJAIABBfGovAQAiAkHhAEYNACACQewARw0IIABBempB5QAQNw8LIABBempB4wAQNw8LIABBfGpB5ABB5QBB7ABB5QAQLA8LIABBfmovAQBB7wBHDQUgAEF8ai8BAEHlAEcNBQJAIABBemovAQAiAkHwAEYNACACQeMARw0GIABBeGpB6QBB7gBB8wBB9ABB4QBB7gAQNg8LIABBeGpB9ABB+QAQKw8LQQEhASAAQX5qIgBB6QAQNw0EIABB8gBB5QBB9ABB9QBB8gAQNA8LIABBfmpB5AAQNw8LIABBfmpB5ABB5QBB4gBB9QBB5wBB5wBB5QAQOA8LIABBfmpB4QBB9wBB4QBB6QAQLA8LAkAgAEF+ai8BACICQe8ARg0AIAJB5QBHDQEgAEF8akHuABA3DwsgAEF8akH0AEHoAEHyABA1IQELIAELhwEBA38DQEEAQQAoArygASIAQQJqIgE2ArygAQJAAkACQCAAQQAoAsCgAU8NACABLwEAIgFBpX9qIgJBAU0NAgJAIAFBdmoiAEEDTQ0AIAFBL0cNBAwCCyAADgQAAwMAAAsQHQsPCwJAAkAgAg4CAQABC0EAIABBBGo2ArygAQwBCxBAGgwACwuVAQEEf0EAKAK8oAEhAUEAKALAoAEhAgJAAkADQCABIgNBAmohASADIAJPDQEgAS8BACIEIABGDQICQCAEQdwARg0AIARBdmoiA0EDSw0BIAMOBAIBAQICCyADQQRqIQEgAy8BBEENRw0AIANBBmogASADLwEGQQpGGyEBDAALC0EAIAE2ArygARAdDwtBACABNgK8oAELOAEBf0EAQQE6APAfQQAoArygASEAQQBBACgCwKABQQJqNgK8oAFBACAAQQAoApgfa0EBdTYC7B8LzgEBBX9BACgCvKABIQBBACgCwKABIQEDQCAAIgJBAmohAAJAAkAgAiABTw0AIAAvAQAiA0Gkf2oiBEEETQ0BIANBJEcNAiACLwEEQfsARw0CQQBBAC8BhEAiAEEBajsBhEBBACgCoGAgAEEBdGpBAC8BiEA7AQBBACACQQRqNgK8oAFBAEEALwGGQEEBaiIAOwGIQEEAIAA7AYZADwtBACAANgK8oAEQHQ8LAkACQCAEDgUBAgICAAELQQAgADYCvKABDwsgAkEEaiEADAALC7YCAQJ/QQBBACgCvKABIgFBDmo2ArygAQJAAkACQBAnIgJB2wBGDQAgAkE9Rg0BIAJBLkcNAkEAQQAoArygAUECajYCvKABECchAkEAKAK8oAEhACACEC1FDQJBACgCvKABIQIQJ0E9Rw0CIAAgAkEAKAKcHxEAAA8LQQBBACgCvKABQQJqNgK8oAECQBAnIgJBJ0YNACACQSJHDQILQQAoArygASEAIAIQHEEAQQAoArygAUECaiICNgK8oAEQJ0HdAEcNAUEAQQAoArygAUECajYCvKABECdBPUcNASAAIAJBACgCnB8RAAAMAQsgAEUNAEEAKAKoHxEBAEEAQQAoArygAUECajYCvKABAkAQJyICQfIARg0AIAJB+wBHDQEQLg8LQQEQEBoLQQAgAUEMajYCvKABCzYBAn9BAEEAKAK8oAFBDGoiADYCvKABECchAQJAAkBBACgCvKABIABHDQAgARA/RQ0BCxAdCwtsAQF/QQBBACgCvKABIgBBDGo2ArygAQJAECdBLkcNAEEAQQAoArygAUECajYCvKABECdB5QBHDQBBACgCvKABQQJqQfgAQfAAQe8AQfIAQfQAQfMAECZFDQBBARAfDwtBACAAQQpqNgK8oAEL6QEBAX9BACEXAkAgAC8BACABRw0AIAAvAQIgAkcNACAALwEEIANHDQAgAC8BBiAERw0AIAAvAQggBUcNACAALwEKIAZHDQAgAC8BDCAHRw0AIAAvAQ4gCEcNACAALwEQIAlHDQAgAC8BEiAKRw0AIAAvARQgC0cNACAALwEWIAxHDQAgAC8BGCANRw0AIAAvARogDkcNACAALwEcIA9HDQAgAC8BHiAQRw0AIAAvASAgEUcNACAALwEiIBJHDQAgAC8BJCATRw0AIAAvASYgFEcNACAALwEoIBVHDQAgAC8BKiAWRiEXCyAXC1MBAX9BACEIAkAgAC8BACABRw0AIAAvAQIgAkcNACAALwEEIANHDQAgAC8BBiAERw0AIAAvAQggBUcNACAALwEKIAZHDQAgAC8BDCAHRiEICyAIC6QBAQR/QQBBACgCvKABIgBBDGoiATYCvKABAkACQAJAAkACQBAnIgJBWWoiA0EHTQ0AIAJBIkYNAiACQfsARg0CDAELAkAgAw4IAgABAgEBAQMCC0EAQQAvAYZAIgNBAWo7AYZAQQAoArCgASADQQJ0aiAANgIADwtBACgCvKABIAFGDQILQQAvAYZARQ0AQQBBACgCvKABQX5qNgK8oAEPCxAdCws0AQF/QQEhAQJAIABBd2pB//8DcUEFSQ0AIABBgAFyQaABRg0AIABBLkcgABA/cSEBCyABC0kBAX9BACEHAkAgAC8BACABRw0AIAAvAQIgAkcNACAALwEEIANHDQAgAC8BBiAERw0AIAAvAQggBUcNACAALwEKIAZGIQcLIAcLegEDf0EAKAK8oAEhAAJAA0ACQCAALwEAIgFBd2pBBUkNACABQSBGDQAgAUGgAUYNACABQS9HDQICQCAALwECIgBBKkYNACAAQS9HDQMQFQwBCxAWC0EAQQAoArygASICQQJqIgA2ArygASACQQAoAsCgAUkNAAsLIAELOQEBfwJAIAAvAQAiAUGA+ANxQYC4A0cNACAAQX5qLwEAQf8HcUEKdCABQf8HcXJBgIAEaiEBCyABC30BAX8CQCAAQS9LDQAgAEEkRg8LAkAgAEE6SQ0AQQAhAQJAIABBwQBJDQAgAEHbAEkNAQJAIABB4ABLDQAgAEHfAEYPCyAAQfsASQ0BAkAgAEH//wNLDQAgAEGqAUkNASAAEDkPC0EBIQEgABA6DQAgABA7IQELIAEPC0EBC2MBAX8CQCAAQcAASw0AIABBJEYPC0EBIQECQCAAQdsASQ0AAkAgAEHgAEsNACAAQd8ARg8LIABB+wBJDQACQCAAQf//A0sNAEEAIQEgAEGqAUkNASAAEDwPCyAAEDohAQsgAQtMAQN/QQAhAwJAIABBfmoiBEEAKAKYHyIFSQ0AIAQvAQAgAUcNACAALwEAIAJHDQACQCAEIAVHDQBBAQ8LIABBfGovAQAQJSEDCyADC2YBA39BACEFAkAgAEF6aiIGQQAoApgfIgdJDQAgBi8BACABRw0AIABBfGovAQAgAkcNACAAQX5qLwEAIANHDQAgAC8BACAERw0AAkAgBiAHRw0AQQEPCyAAQXhqLwEAECUhBQsgBQuFAQECfyAAED4iABAqIQECQAJAIABB3ABGDQBBACECIAFFDQELQQAoArygAUECQQQgAEGAgARJG2ohAAJAA0BBACAANgK8oAEgAC8BABA+IgFFDQECQCABEClFDQAgAEECQQQgAUGAgARJG2ohAAwBCwtBACECIAFB3ABGDQELQQEhAgsgAgvaAwEEf0EAKAK8oAEiAEF+aiEBA0BBACAAQQJqNgK8oAECQAJAAkAgAEEAKALAoAFPDQAQJyEAQQAoArygASECAkACQCAAEC1FDQBBACgCvKABIQMCQAJAECciAEE6Rw0AQQBBACgCvKABQQJqNgK8oAEQJxAtRQ0BQQAoArygAS8BACEACyACIANBACgCnB8RAAAMAgtBACABNgK8oAEPCwJAAkAgAEEiRg0AIABBLkYNASAAQSdHDQQLQQAoArygASECIAAQHEEAQQAoArygAUECaiIDNgK8oAEQJyIAQTpHDQFBAEEAKAK8oAFBAmo2ArygAQJAECcQLUUNAEEAKAK8oAEvAQAhACACIANBACgCnB8RAAAMAgtBACABNgK8oAEPC0EAKAK8oAEiAC8BAkEuRw0CIAAvAQRBLkcNAkEAIABBBmo2ArygAQJAAkACQCAALwEGIgBB8gBHDQBBARAQIQBBACgCvKABIQIgAA0BIAIvAQAhAAsgAEH//wNxEC0NAUEAIAE2ArygAQ8LQQAgAkECajYCvKABCxAnIQALIABB//8DcSIAQSxGDQIgAEH9AEYNAEEAIAE2ArygAQsPC0EAIAE2ArygAQ8LQQAoArygASEADAALC48BAQF/QQAhDgJAIAAvAQAgAUcNACAALwECIAJHDQAgAC8BBCADRw0AIAAvAQYgBEcNACAALwEIIAVHDQAgAC8BCiAGRw0AIAAvAQwgB0cNACAALwEOIAhHDQAgAC8BECAJRw0AIAAvARIgCkcNACAALwEUIAtHDQAgAC8BFiAMRw0AIAAvARggDUYhDgsgDguoAQECf0EAIQFBACgCvKABIQICQAJAIABB7QBHDQAgAkECakHvAEHkAEH1AEHsAEHlABATRQ0BQQAgAkEMajYCvKABAkAQJ0EuRg0AQQAhAQwCC0EAQQAoArygAUECajYCvKABECchAAsgAEHlAEcNAEEAKAK8oAEiAEEOaiACIABBAmpB+ABB8ABB7wBB8gBB9ABB8wAQJiIBGyECC0EAIAI2ArygASABC2cBAX9BACEKAkAgAC8BACABRw0AIAAvAQIgAkcNACAALwEEIANHDQAgAC8BBiAERw0AIAAvAQggBUcNACAALwEKIAZHDQAgAC8BDCAHRw0AIAAvAQ4gCEcNACAALwEQIAlGIQoLIAoLcQEBf0EAIQsCQCAALwEAIAFHDQAgAC8BAiACRw0AIAAvAQQgA0cNACAALwEGIARHDQAgAC8BCCAFRw0AIAAvAQogBkcNACAALwEMIAdHDQAgAC8BDiAIRw0AIAAvARAgCUcNACAALwESIApGIQsLIAsLgwQBAn9BACECAkAQJ0HPAEcNAEEAIQJBACgCvKABIgNBAmpB4gBB6gBB5QBB4wBB9AAQE0UNAEEAIQJBACADQQxqNgK8oAEQJ0EuRw0AQQBBACgCvKABQQJqNgK8oAECQBAnIgNB8ABHDQBBACECQQAoArygASIDQQJqQfIAQe8AQfQAQe8AQfQAQfkAQfAAQeUAED1FDQFBACECQQAgA0ESajYCvKABECdBLkcNAUEAQQAoArygAUECajYCvKABECchAwtBACECIANB6ABHDQBBACECQQAoArygASIDQQJqQeEAQfMAQc8AQfcAQe4AQdAAQfIAQe8AQfAAQeUAQfIAQfQAQfkAEC9FDQBBACECQQAgA0EcajYCvKABECdBLkcNAEEAIQJBAEEAKAK8oAFBAmo2ArygARAnQeMARw0AQQAhAkEAKAK8oAEiAy8BAkHhAEcNACADLwEEQewARw0AIAMvAQZB7ABHDQBBACECQQAgA0EIajYCvKABECdBKEcNAEEAIQJBAEEAKAK8oAFBAmo2ArygARAnEC1FDQAQJ0EsRw0AQQAhAkEAQQAoArygAUECajYCvKABECcaQQAoArygASIDIAAgAUEBdCIBEEENAEEAIQJBACADIAFqNgK8oAEQJ0EpRw0AQQBBACgCvKABQQJqNgK8oAFBASECCyACC0kBA39BACEGAkAgAEF4aiIHQQAoApgfIghJDQAgByABIAIgAyAEIAUQE0UNAAJAIAcgCEcNAEEBDwsgAEF2ai8BABAlIQYLIAYLWQEDf0EAIQQCQCAAQXxqIgVBACgCmB8iBkkNACAFLwEAIAFHDQAgAEF+ai8BACACRw0AIAAvAQAgA0cNAAJAIAUgBkcNAEEBDwsgAEF6ai8BABAlIQQLIAQLSwEDf0EAIQcCQCAAQXZqIghBACgCmB8iCUkNACAIIAEgAiADIAQgBSAGECZFDQACQCAIIAlHDQBBAQ8LIABBdGovAQAQJSEHCyAHCz0BAn9BACECAkBBACgCmB8iAyAASw0AIAAvAQAgAUcNAAJAIAMgAEcNAEEBDwsgAEF+ai8BABAlIQILIAILTQEDf0EAIQgCQCAAQXRqIglBACgCmB8iCkkNACAJIAEgAiADIAQgBSAGIAcQI0UNAAJAIAkgCkcNAEEBDwsgAEFyai8BABAlIQgLIAgL+RIBA38CQCAAEDwNACAAQfS/f2pBAkkNACAAQbcBRg0AIABBgHpqQfAASQ0AIABB/XZqQQVJDQAgAEGHB0YNACAAQe90akEtSQ0AAkAgAEHBdGoiAUEISw0AQQEgAXRB7QJxDQELIABB8HNqQQtJDQAgAEG1c2pBH0kNAAJAIABBqnJqIgFBEksNAEEBIAF0Qf/8GXENAQsgAEHwDEYNACAAQZZyakEESQ0AIABBwHBqQQpJDQAgAEHacGpBC0kNACAAQdBxakEbSQ0AIABBkQ5GDQAgAEGQcmpBCkkNACAAQcJtakESSQ0AIABBxm1qQQNJDQAgAEGdbmpBIUkNACAAQa1uakEPSQ0AIABBp29qQQNJDQAgAEHXb2pBBUkNACAAQdtvakEDSQ0AIABB5W9qQQlJDQAgAEHqb2pBBEkNACAAQf0PRg0AIABBlXBqQQlJDQACQCAAQa9taiIBQRJLDQBBASABdEH/gBhxDQELIABBmm1qQQpJDQACQAJAIABBxGxqIgFBJ00NACAAQf9sakEDSQ0CDAELIAEOKAEAAQEBAQEBAQAAAQEAAAEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAQEBCyAAQf4TRg0AIABBmmxqQQpJDQACQCAAQcRraiIBQRVLDQBBASABdEH9sI4BcQ0BCyAAQf9rakEDSQ0AIABB9RRGDQAgAEGaa2pBDEkNAAJAAkAgAEHEamoiAUEnTQ0AIABB/2pqQQNJDQIMAQsgAQ4oAQABAQEBAQEBAQABAQEAAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAABAQELIABBmmpqQQpJDQAgAEGGampBBkkNAAJAAkAgAEHEaWoiAUEnTQ0AIABB/2lqQQNJDQIMAQsgAQ4oAQABAQEBAQEBAAABAQAAAQEBAAAAAAAAAAABAQAAAAAAAAAAAAABAQELIABBmmlqQQpJDQACQCAAQcJoaiIBQRlLDQBBASABdEGf7oMQcQ0BCyAAQYIXRg0AIABBmmhqQQpJDQACQAJAIABBwmdqIgFBJU0NACAAQYBoakEFSQ0CDAELIAEOJgEBAQEBAQEAAQEBAAEBAQEAAAAAAAAAAQEAAAAAAAAAAAAAAAEBAQsgAEGaZ2pBCkkNAAJAAkAgAEHEZmoiAUEnTQ0AIABB/2ZqQQNJDQIMAQsgAQ4oAQABAQEBAQEBAAEBAQABAQEBAAAAAAAAAAEBAAAAAAAAAAAAAAABAQELIABBmmZqQQpJDQAgAEF8cSICQYAaRg0AAkAgAEHFZWoiAUEoSw0AIAEOKQEBAAEBAQEBAQEAAQEBAAEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAEBAQsgAEGaZWpBCkkNAAJAIABBtmRqIgFBDEsNAEEBIAF0QeEvcQ0BCyAAQf5kakECSQ0AIABBeHFB2BtGDQAgAEGaZGpBCkkNAAJAIABBz2NqIgFBHUsNAEEBIAF0QfmHgP4DcQ0BCyAAQY5kakECSQ0AIABBsR1GDQAgAEGwY2pBCkkNAAJAIABBzGJqIgFBCEsNACABQQZHDQELIABBuGJqQQZJDQAgAEHgYWpBCkkNACAAQQFyIgFBmR5GDQAgAEGwYmpBCkkNAAJAIABBy2FqIgNBCksNAEEBIAN0QZUMcQ0BCyAAQfNgakELSQ0AIAFBhx9GDQAgAEGPYWpBFEkNACAAQe5RakEDSQ0AIABBl1lqQQlJDQAgAEGjWWpBA0kNACAAQfFeakEPSQ0AIABB/l5qQQxJDQAgAEGPX2pBBEkNACAAQZlfakEHSQ0AIABBnl9qQQNJDQAgAEGiX2pBA0kNACAAQapfakEESQ0AIABBwF9qQQpJDQAgAEHVX2pBFEkNACAAQcYfRg0AIABB52BqQSRJDQAgAEHOUWpBA0kNACAAQa5RakECSQ0AIABBjlFqQQJJDQAgAEH1T2pBA0kNACAAQaBQakEKSQ0AIABB3S9GDQAgAEHMUGpBIEkNACAAQbBGakEDSQ0AIABBsEdqQQpJDQAgAEHAR2pBCkkNACAAQdxHakEUSQ0AIABBmkhqQQ5JDQAgAEHQSGpBCkkNACAAQd9IakENSQ0AIABBgElqQQNJDQAgAEGVSWpBCUkNACAAQbBJakEKSQ0AIABBzElqQRFJDQAgAEGASmpBBUkNACAAQdBKakEOSQ0AIABB8EpqQQpJDQAgAEGBS2pBC0kNACAAQaBLakEdSQ0AIABBq0tqQQpJDQAgAEHpS2pBBUkNACAAQbBMakELSQ0AIABBuk1qQQpJDQAgAEHQTWpBDEkNACAAQeBNakEMSQ0AIABBqTFGDQAgAEHwT2pBCkkNACAAQcBEakE6SQ0AIABBiUZqQQNJDQAgAEGORmpBA0kNACAAQe05Rg0AIABBrEZqQRVJDQAgAEGFRGpBBUkNAAJAIABBwb9/aiIBQRVLDQBBASABdEGDgIABcQ0BCyAAQZu+f2pBDEkNACAAQeHBAEYNACAAQbC+f2pBDUkNACAAQZGmf2pBA0kNACAAQf/aAEYNACAAQWBxQeDbAEYNACAAQdaff2pBBkkNACAAQeeef2pBAkkNACAAQYyzfWpBCkkNACAAQe/MAkYNACAAQeCzfWpBCkkNAAJAIABB9a99aiIBQRxLDQBBASABdEGBgID4AXENAQsgAEHisn1qQQJJDQAgAEGQsn1qQQJJDQACQAJAIABB/q99aiIBQQRNDQAgAEGAr31qQQJJDQIMAQsgAQ4FAQAAAAEBCyAAQc2sfWpBDkkNACACQYDTAkYNACAAQbmtfWpBDUkNACAAQdqtfWpBCEkNACAAQYGufWpBC0kNACAAQaCufWpBEkkNACAAQcyufWpBEkkNACAAQbCufWpBCkkNACAAQderfWpBDkkNACAAQeXTAkYNACAAQV9xQbCsfWpBCkkNAAJAIABBvat9aiIBQQpLDQBBASABdEGBDHENAQsgAEGwq31qQQpJDQACQCAAQZ2ofWoiAUEKSw0AIAFBCEcNAQsCQCAAQdCqfWoiAUERSw0AQQEgAXRBnYMLcQ0BCwJAIABBlap9aiIBQQtLDQBBASABdEGfGHENAQsgAEGFq31qQQNJDQAgAEFwcSIBQYD8A0YNACAAQZ72A0YNACAAQZCofWpBCkkNACAAQb/+A0YgAEHwgXxqQQpJIABBs4N8akEDSSAAQc2DfGpBAkkgAUGg/ANGcnJycg8LQQELXAEEf0GAgAQhAUGQCCECQX4hAwJAA0BBACEEIANBAmoiA0HnA0sNASACKAIAIAFqIgEgAEsNASACQQRqIQQgAkEIaiECIAQoAgAgAWoiASAASQ0AC0EBIQQLIAQLXAEEf0GAgAQhAUGwFyECQX4hAwJAA0BBACEEIANBAmoiA0H5AUsNASACKAIAIAFqIgEgAEsNASACQQRqIQQgAkEIaiECIAQoAgAgAWoiASAASQ0AC0EBIQQLIAQL7R8BBn9BASEBAkACQAJAIABB1n5qIgJBEEsNAEEBIAJ0QYGQBHENAQsgAEG6empBDEkNACAAQYh+akHKA0kNACAAQcB+akEXSQ0AIABBqH5qQR9JDQACQCAAQZB5aiICQRxLDQBBASACdEHf+YK6AXENAQsCQCAAQaB6aiICQQ5LDQBBASACdEGfoAFxDQELIABB9nZqQaYBSQ0AIABBiXhqQYsBSQ0AIABB8nhqQRRJDQAgAEHdeGpB0wBJDQAgAEGRdGpBBEkNACAAQbB0akEbSQ0AIABBoHVqQSlJDQAgAEHZCkYNACAAQc91akEmSQ0AAkACQAJAIABBj3NqQeMASQ0AIABBAXIiAkHvDEYNACAAQeBzakErSQ0AAkAgAEGrcmoiAUE8Tw0AQoGAjLCAnIGACCABrYhCAYNQRQ0BCyAAQe5xakEeSQ0AIABBtnBqQSFJDQAgAEGxD0YNACAAQbNxakHZAEkNAAJAIABBjHBqIgFBBksNAEEBIAF0QcMAcQ0BCyAAQYBwakEWSQ0AAkACQCAAQdxvaiIDQQRNDQAgAEGaEEYNAgwBC0EBIQEgAw4FBAAAAAQECyAAQfxtakE2SQ0AIABBym5qQQhJDQAgAEHgbmpBFUkNACAAQcBvakEZSQ0AIABBoG9qQQtJDQAgAEG9EkYNACAAQdASRg0AIABBqG1qQQpJDQAgAEGPbWpBEEkNAAJAIABB+2xqIgNBDE8NAEEBIQFB/xkgA0H//wNxdkEBcQ0ECyAAQe1sakEWSQ0AAkAgAEGEbGoiAUEUSw0AQQEgAXRBgfzhAHENAQsgAEHWbGpBB0kNAAJAIABBzmxqIgFBHEsNAEEBIAF0QfGRgIABcQ0BCwJAIABBpGxqIgFBFUsNAEEBIAF0QbuAwAFxDQELIABB7WtqQRZJDQACQCAAQdZraiIBQTVPDQBC/7aDgICA4AsgAa2IQgGDUEUNAQsgAEHtampBFkkNACAAQfFqakEDSQ0AIABBjmtqQQNJDQAgAEH7ampBCUkNAAJAAkACQCAAQdZqaiIDQSZNDQAgAEGHamoiAUEXSw0BQQEgAXRBgeC/BnFFDQEMAwtBASEBIAMOJwUFBQUFBQUBBQUBBQUFBQUBAQEFAQEBAQEBAQEBAQEBAQEBAQEBBQULIABBoGpqQQJJDQELIABB7WlqQRZJDQACQAJAAkAgAEGPaWoiA0EzTQ0AIABB1mlqIgFBE0sNAUEBIAF0Qf/2I3FFDQEMAwtBASEBIAMONAUBAQEBAQEBAQEBAQEBAQEBAQUBBQUFBQUFAQEBBQUFAQUFBQUBAQEFBQEFAQUFAQEBBQUFCyAAQaRpaiIBQQVLDQAgAUECRw0BCyAAQdhoakEDSQ0AIABB7mdqQRdJDQAgAEHyZ2pBA0kNACAAQftnakEISQ0AIABB0BdGDQAgAEHSaGpBDEkNACAAQb0YRg0AIABB1mdqQRBJDQACQCAAQahnaiIBQSlPDQBCh4aAgIAgIAGtiEIBg1BFDQELIABB1mZqQQpJDQAgAEHuZmpBF0kNACAAQftmakEISQ0AIABB8mZqQQNJDQACQCAAQftlaiIBQQtLDQAgAUEIRw0BCwJAIABBy2ZqIgFBCEsNAEEBIAF0QZ8CcQ0BCwJAIABBomZqIgFBFEsNAEEBIAF0QY2A4ABxDQELIABB7mVqQSlJDQAgAEG9GkYNACAAQc4aRg0AIABBzWRqQQlJDQAgAEHmZGpBGEkNACAAQftkakESSQ0AIABBhmVqQQZJDQAgAEGsZWpBA0kNACAAQaFlakEDSQ0AAkAgAEHDZGoiA0EKTw0AQQEhAUH5ByADQf//A3F2QQFxDQQLIAJBsxxGDQAgAEH/Y2pBMEkNACAAQcBjakEHSQ0AAkAgAEH/YmoiAUEMSw0AQQEgAXRByyVxDQELIABBfHEiA0GUHUYNACAAQediakEHSQ0AAkAgAEHfYmoiAUEmTw0AQtfsm4D5BSABrYhCAYNQRQ0BCyAAQYBgakErSQ0AIABB+GBqQQVJDQAgAEG3YWpBJEkNACAAQXhxIgRBwB5GDQAgAEGAHkYNACADQdwdRg0AAkAgAEHBX2oiAUEoTw0AQoGA+MPHGCABrYhCAYNQRQ0BCyAAQZJfakEDSQ0AIABB4F5qQSZJDQAgAEGOIUYNACAAQYtfakENSQ0AIABBxyFGDQAgAEHNIUYNACAAQbZbakEESQ0AIABBsF5qQStJDQAgAEGEXmpBzQJJDQACQCAAQbBbaiIFQQlPDQBBASEBQf8CIAVB//8DcXZBAXENBAsgAEHOWmpBBEkNACAAQfBaakEhSQ0AIABB9lpqQQRJDQAgAEGmW2pBBEkNACAAQaBbakEpSQ0AAkAgAEHIWmoiBUEJTw0AQQEhAUH/AiAFQf//A3F2QQFxDQQLIABBgFFqQTRJDQAgAEGSUWpBA0kNACAAQaBRakENSQ0AIABBwFFqQRJJDQAgAEHgUWpBEkkNACAAQfJRakEESQ0AIABBgFJqQQ1JDQAgAEGSUmpBC0kNACAAQeBSakHLAEkNACAAQf9SakEaSQ0AIABBkVNqQRFJDQAgAEH/V2pB7ARJDQAgAEGIWGpBBkkNACAAQeBYakHWAEkNACAAQXBxIgVBgCdGDQAgAEHoWWpBwwBJDQAgAEHuWWpBBEkNACAAQahaakE5SQ0AIABBvlpqQQRJDQAgAEG4WmpBD0kNACAAQdcvRg0AIABB3C9GDQAgAEHgT2pB2QBJDQAgAEGATGpBF0kNACAAQdBMakEaSQ0AIABBgE1qQSxJDQAgAEGQTWpBBUkNACAAQbBNakEeSQ0AIABBgE5qQR9JDQAgAEHQTmpBxgBJDQAgAEGqMUYNBCAAQYBPakEpSQ0EIABBu0lqQQdJDQQgAEH7SWpBL0kNBCAAQac1Rg0EIABB4EtqQTVJDQQgAEGXRmpBBEkNBCAAQcNGakEDSQ0EIABB8EZqQStJDQQgAEGAR2pBCUkNBCAAQaZHakEkSQ0EIABBs0dqQQNJDQQgAEGASGpBJEkNBCAAQcZIakEsSQ0EIAJBrzdGDQQgAEH9SGpBHkkNBCAAQZJGaiIGQQlJDQEMAgtBASEBDAILQQEhAUGPAyAGQf//A3F2QQFxDQELIARB0D5GDQEgAEG4QWpBBkkNASAAQeBBakEmSQ0BIABB6EFqQQZJDQEgAEGARmpBwAFJDQEgAEGARGpBlgJJDQECQCAAQadBaiIBQQRLDQBBASABdEEVcQ0CCyAAQaFBakEfSQ0BIABBgEFqQTVJDQECQCAAQcpAaiIEQQlPDQBBASEBQf8CIARB//8DcXZBAXENAQsgAEGOQGpBA0kNASAAQaBAakENSQ0BIABBqkBqQQZJDQEgA0HQP0YNASAAQb5AakEDSQ0BIABBukBqQQdJDQEgAEGKQGpBB0kNASAAQfHAAEYNASAAQf/AAEYNASAAQfC+f2pBDUkNASAAQYLCAEYNASAAQYfCAEYNASAAQZXCAEYNASAAQfa9f2pBCkkNAQJAIABB6L1/aiIEQRFPDQBBASEBQb+gBSAEdkEBcQ0BCyAAQda9f2pBEEkNASADQbzCAEYNAQJAIABBu71/aiIEQQpPDQBBASEBQZ8EIARB//8DcXZBAXENAQsgAEGgp39qQYUBSQ0BIABB0Kd/akEvSQ0BIABBoL1/akEpSQ0BIABBgKh/akEvSQ0BAkAgAEGVpn9qIgRBCU8NAEEBIQFBjwMgBEH//wNxdkEBcQ0BCyAAQYCmf2pBJkkNASAAQafaAEYNASAAQa3aAEYNASAAQYC2fWpBjQJJDQEgAEGwtn1qQS5JDQEgAEGAwH1qQY0JSQ0BIABBgOR+akHwowFJDQEgAEGAmH9qQbYzSQ0BIAVB8OMARg0BIABB4Jx/akEbSQ0BIABBz51/akHeAEkNASAAQfudf2pBK0kNASADQfzhAEYNASAAQd+ef2pB2gBJDQEgAEHlnn9qQQVJDQEgAEG/n39qQdYASQ0BIABByJ9/akEFSQ0BIABBz59/akEFSQ0BIABB359/akEJSQ0BIABB+59/akEDSQ0BIABBqKR/akEHSQ0BIABBsKR/akEHSQ0BIABBuKR/akEHSQ0BIABBwKR/akEHSQ0BIABByKR/akEHSQ0BIABB0KR/akEHSQ0BIABB2KR/akEHSQ0BIABB4KR/akEHSQ0BIABBgKV/akEXSQ0BIABB79oARg0BIABB0KV/akE4SQ0BIABB/q59akEySQ0BIABBwK99akE0SQ0BIABB9K99akEXSQ0BIABB+a99akEESQ0BIABB/a99akEDSQ0BIABBibB9akELSQ0BIABB9bB9akEvSQ0BIABB3rF9akHnAEkNASAAQemxfWpBCUkNASAAQeCyfWpB0ABJDQEgAEGBs31qQR9JDQEgAEHAs31qQS9JDQEgAkGrzAJGDQEgBUGQzAJGDQECQCAAQY6ufWoiAkENTw0AQQEhAUG/NCACQf//A3F2QQFxDQELIABBoK19akEdSQ0BIABB9q19akEcSQ0BIABB0K19akEXSQ0BIABBvKt9akEISQ0BIABBwKt9akEDSQ0BIABBgKx9akEpSQ0BIABBhqx9akEFSQ0BIABBmqx9akEKSQ0BIABBoKx9akEFSQ0BIABBz9MCRg0BIABB/Kx9akEvSQ0BIABBgqt9akEySQ0BIABB+tQCRg0BIABBoKt9akEXSQ0BAkAgAEHPqn1qIgJBEk8NAEEBIQFBsb4KIAJ2QQFxDQELIABBgIp8akEHSQ0BIABBkIt8akHqAEkNASAAQYCOfGpB7gJJDQEgAEG10HxqQTFJDQEgAEHQ0HxqQRdJDQEgAEGAqH1qQaTXAEkNASAAQZCpfWpB8wBJDQEgAEGkqX1qQQpJDQEgAEHQqX1qQStJDQEgAEHYqX1qQQdJDQEgAEHgqX1qQQdJDQEgAEHvqX1qQQZJDQEgAEF3cUH/qX1qQQZJDQEgAEGOqn1qQQNJDQEgAEGlqn1qQQNJDQEgAEGgqn1qQQtJDQECQCAAQe2JfGoiAkELTw0AQQEhAUGfCCACQf//A3F2QQFxDQELIABB4Yl8akEKSQ0BIABB1ol8akENSQ0BAkAgAEHIiXxqIgJBDU8NAEEBIQFB3zYgAkH//wNxdkEBcQ0BCyAAQa6AfGpBBkkNASAAQbaAfGpBBkkNASAAQb6AfGpBBkkNASAAQZqBfGpB2QBJDQEgAEG/gXxqQRpJDQEgAEHfgXxqQRpJDQEgAEGKg3xqQYcBSQ0BIABBkIN8akEFSQ0BIABBkIR8akEMSQ0BIABB7oR8akE2SQ0BIABBsIV8akHAAEkNASAAQbqJfGpB7ABJDQFBASEBIABBrYh8akHrAkkNACAAQaaAfGpBA0kPCyABDwtBAQtdAQF/QQAhCQJAIAAvAQAgAUcNACAALwECIAJHDQAgAC8BBCADRw0AIAAvAQYgBEcNACAALwEIIAVHDQAgAC8BCiAGRw0AIAAvAQwgB0cNACAALwEOIAhGIQkLIAkLNQACQCAAQYD4A3FBgLADRw0AIABBCnRBgPg/cUEAKAK8oAEvAQJB/wdxckGAgARqIQALIAALaAECf0EBIQECQAJAIABBX2oiAkEFSw0AQQEgAnRBMXENAQsgAEH4/wNxQShGDQAgAEFGakH//wNxQQZJDQACQCAAQaV/aiICQQNLDQAgAkEBRw0BCyAAQYV/akH//wNxQQRJIQELIAELjQEBBX9BACgCvKABIQBBACgCwKABIQEDfyAAQQJqIQICQAJAIAAgAU8NACACLwEAIgNBpH9qIgRBAU0NASACIQAgA0F2aiIDQQNLDQIgAiEAIAMOBAACAgAAC0EAIAI2ArygARAdQQAPCwJAAkAgBA4CAQABC0EAIAI2ArygAUHdAA8LIABBBGohAAwACwtJAQN/QQAhAwJAIAJFDQACQANAIAAtAAAiBCABLQAAIgVHDQEgAUEBaiEBIABBAWohACACQX9qIgINAAwCCwsgBCAFayEDCyADCwvCFwIAQYAIC5gXAAAAAAAAAAAAAAAAAAAAAAAAAAALAAAAAgAAABkAAAACAAAAEgAAAAIAAAABAAAAAgAAAA4AAAADAAAADQAAACMAAAB6AAAARgAAADQAAAAMAQAAHAAAAAQAAAAwAAAAMAAAAB8AAAAOAAAAHQAAAAYAAAAlAAAACwAAAB0AAAADAAAAIwAAAAUAAAAHAAAAAgAAAAQAAAArAAAAnQAAABMAAAAjAAAABQAAACMAAAAFAAAAJwAAAAkAAAAzAAAAnQAAADYBAAAKAAAAFQAAAAsAAAAHAAAAmQAAAAUAAAADAAAAAAAAAAIAAAArAAAAAgAAAAEAAAAEAAAAAAAAAAMAAAAWAAAACwAAABYAAAAKAAAAHgAAAEIAAAASAAAAAgAAAAEAAAALAAAAFQAAAAsAAAAZAAAARwAAADcAAAAHAAAAAQAAAEEAAAAAAAAAEAAAAAMAAAACAAAAAgAAAAIAAAAcAAAAKwAAABwAAAAEAAAAHAAAACQAAAAHAAAAAgAAABsAAAAcAAAANQAAAAsAAAAVAAAACwAAABIAAAAOAAAAEQAAAG8AAABIAAAAOAAAADIAAAAOAAAAMgAAAA4AAAAjAAAAXQEAACkAAAAHAAAAAQAAAE8AAAAcAAAACwAAAAAAAAAJAAAAFQAAAGsAAAAUAAAAHAAAABYAAAANAAAANAAAAEwAAAAsAAAAIQAAABgAAAAbAAAAIwAAAB4AAAAAAAAAAwAAAAAAAAAJAAAAIgAAAAQAAAAAAAAADQAAAC8AAAAPAAAAAwAAABYAAAAAAAAAAgAAAAAAAAAkAAAAEQAAAAIAAAAYAAAAVQAAAAYAAAACAAAAAAAAAAIAAAADAAAAAgAAAA4AAAACAAAACQAAAAgAAAAuAAAAJwAAAAcAAAADAAAAAQAAAAMAAAAVAAAAAgAAAAYAAAACAAAAAQAAAAIAAAAEAAAABAAAAAAAAAATAAAAAAAAAA0AAAAEAAAAnwAAADQAAAATAAAAAwAAABUAAAACAAAAHwAAAC8AAAAVAAAAAQAAAAIAAAAAAAAAuQAAAC4AAAAqAAAAAwAAACUAAAAvAAAAFQAAAAAAAAA8AAAAKgAAAA4AAAAAAAAASAAAABoAAADmAAAAKwAAAHUAAAA/AAAAIAAAAAcAAAADAAAAAAAAAAMAAAAHAAAAAgAAAAEAAAACAAAAFwAAABAAAAAAAAAAAgAAAAAAAABfAAAABwAAAAMAAAAmAAAAEQAAAAAAAAACAAAAAAAAAB0AAAAAAAAACwAAACcAAAAIAAAAAAAAABYAAAAAAAAADAAAAC0AAAAUAAAAAAAAACMAAAA4AAAACAEAAAgAAAACAAAAJAAAABIAAAAAAAAAMgAAAB0AAABxAAAABgAAAAIAAAABAAAAAgAAACUAAAAWAAAAAAAAABoAAAAFAAAAAgAAAAEAAAACAAAAHwAAAA8AAAAAAAAASAEAABIAAAC+AAAAAAAAAFAAAACZAwAAZwAAAG4AAAASAAAAwwAAAL0KAAAuBAAA0g8AAEYCAAC6IQAAOAIAAAgAAAAeAAAAcgAAAB0AAAATAAAALwAAABEAAAADAAAAIAAAABQAAAAGAAAAEgAAALECAAA/AAAAgQAAAEoAAAAGAAAAAAAAAEMAAAAMAAAAQQAAAAEAAAACAAAAAAAAAB0AAAD3FwAACQAAANUEAAArAAAACAAAAPgiAAAeAQAAMgAAAAIAAAASAAAAAwAAAAkAAACLAQAABQkAAGoAAAAGAAAADAAAAAQAAAAIAAAACAAAAAkAAABnFwAAVAAAAAIAAABGAAAAAgAAAAEAAAADAAAAAAAAAAMAAAABAAAAAwAAAAMAAAACAAAACwAAAAIAAAAAAAAAAgAAAAYAAAACAAAAQAAAAAIAAAADAAAAAwAAAAcAAAACAAAABgAAAAIAAAAbAAAAAgAAAAMAAAACAAAABAAAAAIAAAAAAAAABAAAAAYAAAACAAAAUwEAAAMAAAAYAAAAAgAAABgAAAACAAAAHgAAAAIAAAAYAAAAAgAAAB4AAAACAAAAGAAAAAIAAAAeAAAAAgAAABgAAAACAAAAHgAAAAIAAAAYAAAAAgAAAAcAAAA1CQAALAAAAAsAAAAGAAAAEQAAAAAAAAByAQAAKwAAABUFAADEAAAAPAAAAEMAAAAIAAAAAAAAALUEAAADAAAAAgAAABoAAAACAAAAAQAAAAIAAAAAAAAAAwAAAAAAAAACAAAACQAAAAIAAAADAAAAAgAAAAAAAAACAAAAAAAAAAcAAAAAAAAABQAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAgAAAAIAAAACAAAAAQAAAAIAAAAAAAAAAwAAAAAAAAACAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAACAAAAAAAAAAIAAAABAAAAAgAAAAAAAAADAAAAAwAAAAIAAAAGAAAAAgAAAAMAAAACAAAAAwAAAAIAAAAAAAAAAgAAAAkAAAACAAAAEAAAAAYAAAACAAAAAgAAAAQAAAACAAAAEAAAAEURAADdpgAAIwAAADQQAAAMAAAA3QAAAAMAAACBFgAADwAAADAdAAAgDAAAHQIAAOMFAABKEwAA/QEAAAAAAADjAAAAAAAAAJYAAAAEAAAAJgEAAAkAAABYBQAAAgAAAAIAAAABAAAABgAAAAMAAAApAAAAAgAAAAUAAAAAAAAApgAAAAEAAAA+AgAAAwAAAAkAAAAJAAAAcgEAAAEAAACaAAAACgAAALAAAAACAAAANgAAAA4AAAAgAAAACQAAABAAAAADAAAALgAAAAoAAAA2AAAACQAAAAcAAAACAAAAJQAAAA0AAAACAAAACQAAAAYAAAABAAAALQAAAAAAAAANAAAAAgAAADEAAAANAAAACQAAAAMAAAACAAAACwAAAFMAAAALAAAABwAAAAAAAAChAAAACwAAAAYAAAAJAAAABwAAAAMAAAA4AAAAAQAAAAIAAAAGAAAAAwAAAAEAAAADAAAAAgAAAAoAAAAAAAAACwAAAAEAAAADAAAABgAAAAQAAAAEAAAAwQAAABEAAAAKAAAACQAAAAUAAAAAAAAAUgAAABMAAAANAAAACQAAANYAAAAGAAAAAwAAAAgAAAAcAAAAAQAAAFMAAAAQAAAAEAAAAAkAAABSAAAADAAAAAkAAAAJAAAAVAAAAA4AAAAFAAAACQAAAPMAAAAOAAAApgAAAAkAAABHAAAABQAAAAIAAAABAAAAAwAAAAMAAAACAAAAAAAAAAIAAAABAAAADQAAAAkAAAB4AAAABgAAAAMAAAAGAAAABAAAAAAAAAAdAAAACQAAACkAAAAGAAAAAgAAAAMAAAAJAAAAAAAAAAoAAAAKAAAALwAAAA8AAACWAQAABwAAAAIAAAAHAAAAEQAAAAkAAAA5AAAAFQAAAAIAAAANAAAAewAAAAUAAAAEAAAAAAAAAAIAAAABAAAAAgAAAAYAAAACAAAAAAAAAAkAAAAJAAAAMQAAAAQAAAACAAAAAQAAAAIAAAAEAAAACQAAAAkAAABKAQAAAwAAAGpLAAAJAAAAhwAAAAQAAAA8AAAABgAAABoAAAAJAAAA9gMAAAAAAAACAAAANgAAAAgAAAADAAAAUgAAAAAAAAAMAAAAAQAAAKxMAAABAAAAxxQAAAQAAAAEAAAABQAAAAkAAAAHAAAAAwAAAAYAAAAfAAAAAwAAAJUAAAACAAAAigUAADEAAAABAgAANgAAAAUAAAAxAAAACQAAAAAAAAAPAAAAAAAAABcAAAAEAAAAAgAAAA4AAABRBQAABgAAAAIAAAAQAAAAAwAAAAYAAAACAAAAAQAAAAIAAAAEAAAABgEAAAYAAAAKAAAACQAAAKMBAAANAAAA1wUAAAYAAABuAAAABgAAAAYAAAAJAAAAlxIAAAkAAAAHBQwA7wAAAABBmB8LHFCMAAABAAAAAgAAAAMAAAAEAAAAAAQAAPAfAAA="\x2C"undefined"!=typeof window&&"function"==typeof atob?Uint8Array.from(atob(B)\x2CA=>A.charCodeAt(0)):Buffer.from(B\x2C"base64")));var B;const{exports:E}=await WebAssembly.instantiate(Q);A=E})())}
code-source-info,0x306324bc64e,149,0,33616,C0O0C4O33616,,
code-creation,Function,10,292314,0x306324bc8e6,108, node:internal/deps/cjs-module-lexer/dist/lexer:1:1,0x306324bc5c8,~
code-source-info,0x306324bc8e6,149,0,33616,C0O0C42O13C44O26C48O33C50O45C54O55C55O55C57O65C60O73C64O88C75O84C81O105C88O69C95O112C98O66C101O65C103O1219C104O1219C107O33615,,
new,MemoryChunk,0x29698280000,262144
code-creation,LazyCompile,10,292610,0x2969828900e,24,init node:internal/deps/cjs-module-lexer/dist/lexer:1:1235,0x306324bc7c0,~
code-source-info,0x2969828900e,149,1234,33616,C0O1237C11O33612C17O1249C23O33615,,
code-creation,LazyCompile,10,292638,0x2969828919e,227, node:internal/deps/cjs-module-lexer/dist/lexer:1:1252,0x29698288f80,~
code-source-info,0x2969828919e,149,1251,33611,C10O1251C18O1269C22O1287C30O1297C37O33440C44O33481C48O33492C57O33497C67O33492C75O33525C79O33532C87O33532C94O1287C107O1269C133O33574C137O33592C142O33592C155O33574C178O33571C183O33607C185O33608C202O33610,,
code-creation,LazyCompile,10,292698,0x2969828940e,5,get node:internal/bootstrap/pre_execution:317:8,0x1abee8211c8,~
code-source-info,0x2969828940e,96,10342,10376,C0O10354C4O10369,,
code-creation,LazyCompile,10,292743,0x296982894ce,14,byteLength node:buffer:640:17,0x25ca2737f78,~
code-source-info,0x296982894ce,24,19101,19152,C0O19113C3O19145C8O19113C13O19152,,
code-creation,LazyCompile,10,292795,0x296982895b6,76,base64ByteLength node:buffer:576:26,0x25ca27370e8,~
code-source-info,0x296982895b6,24,16722,16974,C0O16761C7O16802C11O16765C19O16807C24O16822C30O16834C32O16844C39O16851C44O16888C48O16851C56O16893C61O16908C67O16946C69O16960C72O16965C75O16971,,
code-creation,LazyCompile,10,292960,0x296982897fe,153,builtinStrategy node:internal/modules/esm/translators:248:58,0x109c10ec950,~
code-source-info,0x296982897fe,122,7623,7985,C6O7623C14O7634C24O7669C29O7634C33O7718C41O7718C47O7766C52O7766C58O7796C66O7801C75O7845C77O7860C84O7866C89O7860C90O7911C100O7942C105O7911C109O7967C114O7967C128O7982,,
code-creation,LazyCompile,10,293065,0x29698289b26,5,get node:stream:69:6,0x394c9e2b478,~
script-source,49,node:stream,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ReflectApply\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  promisify: { custom: customPromisify }\x2C\x0d\n} = require('internal/util');\x0d\n\x0d\nconst operators = require('internal/streams/operators');\x0d\nconst compose = require('internal/streams/compose');\x0d\nconst { pipeline } = require('internal/streams/pipeline');\x0d\nconst { destroyer } = require('internal/streams/destroy');\x0d\nconst eos = require('internal/streams/end-of-stream');\x0d\nconst internalBuffer = require('internal/buffer');\x0d\n\x0d\nconst promises = require('stream/promises');\x0d\nconst utils = require('internal/streams/utils');\x0d\n\x0d\nconst Stream = module.exports = require('internal/streams/legacy').Stream;\x0d\nStream.isDisturbed = utils.isDisturbed;\x0d\nStream.isErrored = utils.isErrored;\x0d\nStream.isReadable = utils.isReadable;\x0d\nStream.Readable = require('internal/streams/readable');\x0d\nfor (const key of ObjectKeys(operators)) {\x0d\n  const op = operators[key];\x0d\n  Stream.Readable.prototype[key] = function(...args) {\x0d\n    return Stream.Readable.from(ReflectApply(op\x2C this\x2C args));\x0d\n  };\x0d\n}\x0d\nStream.Writable = require('internal/streams/writable');\x0d\nStream.Duplex = require('internal/streams/duplex');\x0d\nStream.Transform = require('internal/streams/transform');\x0d\nStream.PassThrough = require('internal/streams/passthrough');\x0d\nStream.pipeline = pipeline;\x0d\nconst { addAbortSignal } = require('internal/streams/add-abort-signal');\x0d\nStream.addAbortSignal = addAbortSignal;\x0d\nStream.finished = eos;\x0d\nStream.destroy = destroyer;\x0d\nStream.compose = compose;\x0d\n\x0d\nObjectDefineProperty(Stream\x2C 'promises'\x2C {\x0d\n  configurable: true\x2C\x0d\n  enumerable: true\x2C\x0d\n  get() {\x0d\n    return promises;\x0d\n  }\x0d\n});\x0d\n\x0d\nObjectDefineProperty(pipeline\x2C customPromisify\x2C {\x0d\n  enumerable: true\x2C\x0d\n  get() {\x0d\n    return promises.pipeline;\x0d\n  }\x0d\n});\x0d\n\x0d\nObjectDefineProperty(eos\x2C customPromisify\x2C {\x0d\n  enumerable: true\x2C\x0d\n  get() {\x0d\n    return promises.finished;\x0d\n  }\x0d\n});\x0d\n\x0d\n// Backwards-compat with node 0.4.x\x0d\nStream.Stream = Stream;\x0d\n\x0d\nStream._isUint8Array = require('internal/util/types').isUint8Array;\x0d\nStream._uint8ArrayToBuffer = function _uint8ArrayToBuffer(chunk) {\x0d\n  return new internalBuffer.FastBuffer(chunk.buffer\x2C\x0d\n                                       chunk.byteOffset\x2C\x0d\n                                       chunk.byteLength);\x0d\n};\x0d\n
code-source-info,0x29698289b26,49,2787,2818,C0O2797C4O2813,,
tick,0x7ff997390934,298186,0,0x0,8
code-creation,Function,4,302513,0x299ca841a00,320,wasm-function[33],0x29be33d0f71,
code-creation,Function,4,302535,0x299ca841b40,768,wasm-function[49],0x29be33d0f81,
code-creation,Function,4,302545,0x299ca841e40,384,wasm-function[48],0x29be33d0f80,
code-creation,Function,4,302554,0x299ca841fc0,1024,wasm-function[47],0x29be33d0f7f,
code-creation,Function,4,302563,0x299ca8423c0,1344,wasm-function[46],0x29be33d0f7e,
code-creation,Function,4,302573,0x299ca842900,448,wasm-function[45],0x29be33d0f7d,
code-creation,Function,4,302582,0x299ca842ac0,576,wasm-function[44],0x29be33d0f7c,
code-creation,Function,4,302591,0x299ca842d00,384,wasm-function[43],0x29be33d0f7b,
code-creation,Function,4,302600,0x299ca842e80,256,wasm-function[42],0x29be33d0f7a,
code-creation,Function,4,302609,0x299ca842f80,320,wasm-function[41],0x29be33d0f79,
code-creation,Function,4,302619,0x299ca8430c0,256,wasm-function[40],0x29be33d0f78,
code-creation,Function,4,302628,0x299ca8431c0,448,wasm-function[39],0x29be33d0f77,
code-creation,Function,4,302637,0x299ca843380,512,wasm-function[38],0x29be33d0f76,
code-creation,Function,4,302647,0x299ca843580,192,wasm-function[37],0x29be33d0f75,
code-creation,Function,4,302656,0x299ca843640,512,wasm-function[36],0x29be33d0f74,
code-creation,Function,4,302666,0x299ca843840,576,wasm-function[35],0x29be33d0f73,
code-creation,Function,4,302675,0x299ca843a80,768,wasm-function[16],0x29be33d0f60,
code-creation,Function,4,302684,0x299ca843d80,192,wasm-function[32],0x29be33d0f70,
code-creation,Function,4,302694,0x299ca843e40,960,wasm-function[31],0x29be33d0f6f,
code-creation,Function,4,302703,0x299ca844200,640,wasm-function[30],0x29be33d0f6e,
code-creation,Function,4,302713,0x299ca844480,128,wasm-function[29],0x29be33d0f6d,
code-creation,Function,4,302722,0x299ca844500,512,wasm-function[28],0x29be33d0f6c,
code-creation,Function,4,302732,0x299ca844700,448,wasm-function[27],0x29be33d0f6b,
code-creation,Function,4,302741,0x299ca8448c0,1664,wasm-function[26],0x29be33d0f6a,
code-creation,Function,4,302751,0x299ca844f40,576,wasm-function[25],0x29be33d0f69,
code-creation,Function,4,302760,0x299ca845180,256,wasm-function[24],0x29be33d0f68,
code-creation,Function,4,302770,0x299ca845280,320,wasm-function[23],0x29be33d0f67,
code-creation,Function,4,302779,0x299ca8453c0,320,wasm-function[22],0x29be33d0f66,
code-creation,Function,4,302789,0x299ca845500,320,wasm-function[21],0x29be33d0f65,
code-creation,Function,4,302798,0x299ca845640,448,wasm-function[19],0x29be33d0f63,
code-creation,Function,4,302807,0x299ca845800,1216,wasm-function[18],0x29be33d0f62,
code-creation,Function,4,302817,0x299ca845cc0,192,wasm-function[17],0x29be33d0f61,
code-creation,Function,4,302826,0x299ca845d80,384,wasm-function[56],0x29be33d0f88,
code-creation,Function,4,302836,0x299ca845f00,192,wasm-function[8],0x29be33d0f58,
code-creation,Function,4,302845,0x299ca845fc0,832,wasm-function[50],0x29be33d0f82,
code-creation,Function,4,302854,0x299ca846300,384,wasm-function[65],0x29be33d0f91,
code-creation,Function,4,302864,0x299ca846480,448,wasm-function[64],0x29be33d0f90,
code-creation,Function,4,302873,0x299ca846640,256,wasm-function[63],0x29be33d0f8f,
code-creation,Function,4,302883,0x299ca846740,192,wasm-function[62],0x29be33d0f8e,
code-creation,Function,4,302892,0x299ca846800,704,wasm-function[61],0x29be33d0f8d,
code-creation,Function,4,302901,0x299ca846ac0,11328,wasm-function[60],0x29be33d0f8c,
code-creation,Function,4,302911,0x299ca849700,384,wasm-function[54],0x29be33d0f86,
code-creation,Function,4,302920,0x299ca849880,512,wasm-function[53],0x29be33d0f85,
code-creation,Function,4,302929,0x299ca849a80,320,wasm-function[52],0x29be33d0f84,
code-creation,Function,4,302939,0x299ca849bc0,1152,wasm-function[51],0x29be33d0f83,
code-creation,Function,4,302952,0x299ca84a040,320,wasm-function[12],0x29be33d0f5c,
code-creation,Function,4,302964,0x299ca84a180,128,wasm-function[14],0x29be33d0f5e,
code-creation,Function,4,302973,0x299ca84a200,320,wasm-function[13],0x29be33d0f5d,
code-creation,Function,4,302983,0x299ca84a340,1728,wasm-function[34],0x29be33d0f72,
code-creation,Function,4,302992,0x299ca84aa00,128,wasm-function[6],0x29be33d0f56,
code-creation,Function,4,303002,0x299ca84aa80,192,wasm-function[10],0x29be33d0f5a,
code-creation,Function,4,303011,0x299ca84ab40,320,wasm-function[11],0x29be33d0f5b,
code-creation,Function,4,303021,0x299ca84ac80,128,wasm-function[1],0x29be33d0f51,
code-creation,Function,4,303030,0x299ca84ad00,128,wasm-function[5],0x29be33d0f55,
code-creation,Function,4,303039,0x299ca84ad80,11200,wasm-function[20],0x29be33d0f64,
code-creation,Function,4,303049,0x299ca84d940,320,wasm-function[55],0x29be33d0f87,
code-creation,Function,4,303058,0x299ca84da80,384,wasm-function[59],0x29be33d0f8b,
code-creation,Function,4,303067,0x299ca84dc00,384,wasm-function[58],0x29be33d0f8a,
code-creation,Function,4,303077,0x299ca84dd80,9344,wasm-function[57],0x29be33d0f89,
code-creation,Function,4,303086,0x299ca850200,128,wasm-function[7],0x29be33d0f57,
code-creation,Function,4,303096,0x299ca850280,192,wasm-function[9],0x29be33d0f59,
code-creation,Function,4,303105,0x299ca850340,128,wasm-function[2],0x29be33d0f52,
code-creation,Function,4,303115,0x299ca8503c0,128,wasm-function[3],0x29be33d0f53,
code-creation,Function,4,303126,0x299ca850440,256,wasm-function[0],0x29be33d0f50,
code-creation,Function,4,303135,0x299ca850540,128,wasm-function[4],0x29be33d0f54,
code-creation,Function,4,303144,0x299ca8505c0,6080,wasm-function[15],0x29be33d0f5f,
code-creation,Function,4,303154,0x299ca851d80,256,wasm-function[33],0x29be33d0f71,*
code-creation,Function,4,303163,0x299ca851e80,448,wasm-function[49],0x29be33d0f81,*
code-creation,Function,4,303172,0x299ca852040,384,wasm-function[48],0x29be33d0f80,*
code-creation,Function,4,303182,0x299ca8521c0,576,wasm-function[47],0x29be33d0f7f,*
code-creation,Function,4,303191,0x299ca852400,1088,wasm-function[46],0x29be33d0f7e,*
code-creation,Function,4,303200,0x299ca852840,384,wasm-function[45],0x29be33d0f7d,*
code-creation,Function,4,303209,0x299ca8529c0,320,wasm-function[44],0x29be33d0f7c,*
code-creation,Function,4,303218,0x299ca852b00,256,wasm-function[43],0x29be33d0f7b,*
code-creation,Function,4,303227,0x299ca852c00,192,wasm-function[42],0x29be33d0f7a,*
code-creation,Function,4,303236,0x299ca852cc0,256,wasm-function[41],0x29be33d0f79,*
code-creation,Function,4,303245,0x299ca852dc0,192,wasm-function[40],0x29be33d0f78,*
code-creation,Function,4,303254,0x299ca852e80,384,wasm-function[39],0x29be33d0f77,*
code-creation,Function,4,303263,0x299ca853000,320,wasm-function[38],0x29be33d0f76,*
code-creation,Function,4,303272,0x299ca853140,192,wasm-function[37],0x29be33d0f75,*
code-creation,Function,4,303281,0x299ca853200,384,wasm-function[36],0x29be33d0f74,*
code-creation,Function,4,303290,0x299ca853380,320,wasm-function[35],0x29be33d0f73,*
code-creation,Function,4,303300,0x299ca8534c0,960,wasm-function[34],0x29be33d0f72,*
code-creation,Function,4,303309,0x299ca853880,640,wasm-function[16],0x29be33d0f60,*
code-creation,Function,4,303318,0x299ca853b00,192,wasm-function[24],0x29be33d0f68,*
code-creation,Function,4,303327,0x299ca853bc0,256,wasm-function[23],0x29be33d0f67,*
code-creation,Function,4,303336,0x299ca853cc0,384,wasm-function[22],0x29be33d0f66,*
code-creation,Function,4,303345,0x299ca853e40,320,wasm-function[21],0x29be33d0f65,*
code-creation,Function,4,303354,0x299ca853f80,256,wasm-function[19],0x29be33d0f63,*
code-creation,Function,4,303363,0x299ca854080,1216,wasm-function[18],0x29be33d0f62,*
code-creation,Function,4,303372,0x299ca854540,128,wasm-function[17],0x29be33d0f61,*
code-creation,Function,4,303381,0x299ca8545c0,192,wasm-function[12],0x29be33d0f5c,*
code-creation,Function,4,303390,0x299ca854680,64,wasm-function[14],0x29be33d0f5e,*
code-creation,Function,4,303400,0x299ca8546c0,192,wasm-function[13],0x29be33d0f5d,*
code-creation,Function,4,303410,0x299ca854780,320,wasm-function[58],0x29be33d0f8a,*
code-creation,Function,4,303420,0x299ca8548c0,320,wasm-function[65],0x29be33d0f91,*
code-creation,Function,4,303429,0x299ca854a00,448,wasm-function[64],0x29be33d0f90,*
code-creation,Function,4,303438,0x299ca854bc0,192,wasm-function[63],0x29be33d0f8f,*
code-creation,Function,4,303447,0x299ca854c80,128,wasm-function[62],0x29be33d0f8e,*
code-creation,Function,4,303457,0x299ca854d00,384,wasm-function[61],0x29be33d0f8d,*
code-creation,Function,4,303466,0x299ca854e80,5888,wasm-function[60],0x29be33d0f8c,*
code-creation,Function,4,303475,0x299ca856580,448,wasm-function[25],0x29be33d0f69,*
code-creation,Function,4,303484,0x299ca856740,192,wasm-function[32],0x29be33d0f70,*
code-creation,Function,4,303493,0x299ca856800,768,wasm-function[31],0x29be33d0f6f,*
code-creation,Function,4,303502,0x299ca856b00,512,wasm-function[30],0x29be33d0f6e,*
code-creation,Function,4,303511,0x299ca856d00,128,wasm-function[29],0x29be33d0f6d,*
code-creation,Function,4,303520,0x299ca856d80,512,wasm-function[28],0x29be33d0f6c,*
code-creation,Function,4,303529,0x299ca856f80,448,wasm-function[27],0x29be33d0f6b,*
code-creation,Function,4,303539,0x299ca857140,1216,wasm-function[26],0x29be33d0f6a,*
code-creation,Function,4,303548,0x299ca857600,128,wasm-function[2],0x29be33d0f52,*
code-creation,Function,4,303557,0x299ca857680,128,wasm-function[3],0x29be33d0f53,*
code-creation,Function,4,303566,0x299ca857700,128,wasm-function[9],0x29be33d0f59,*
code-creation,Function,4,303575,0x299ca857780,64,wasm-function[1],0x29be33d0f51,*
code-creation,Function,4,303584,0x299ca8577c0,448,wasm-function[50],0x29be33d0f82,*
code-creation,Function,4,303593,0x299ca857980,5056,wasm-function[57],0x29be33d0f89,*
code-creation,Function,4,303602,0x299ca858d40,256,wasm-function[56],0x29be33d0f88,*
code-creation,Function,4,303611,0x299ca858e40,192,wasm-function[55],0x29be33d0f87,*
code-creation,Function,4,303620,0x299ca858f00,256,wasm-function[54],0x29be33d0f86,*
code-creation,Function,4,303629,0x299ca859000,320,wasm-function[53],0x29be33d0f85,*
code-creation,Function,4,303638,0x299ca859140,256,wasm-function[52],0x29be33d0f84,*
code-creation,Function,4,303647,0x299ca859240,1024,wasm-function[51],0x29be33d0f83,*
code-creation,Function,4,303657,0x299ca859640,320,wasm-function[59],0x29be33d0f8b,*
code-creation,Function,4,303666,0x299ca859780,128,wasm-function[8],0x29be33d0f58,*
code-creation,Function,4,303675,0x299ca859800,4608,wasm-function[15],0x29be33d0f5f,*
code-creation,Function,4,303684,0x299ca85aa00,128,wasm-function[4],0x29be33d0f54,*
code-creation,Function,4,303693,0x299ca85aa80,128,wasm-function[7],0x29be33d0f57,*
code-creation,Function,4,303702,0x299ca85ab00,128,wasm-function[6],0x29be33d0f56,*
code-creation,Function,4,303711,0x299ca85ab80,128,wasm-function[5],0x29be33d0f55,*
code-creation,Function,4,303720,0x299ca85ac00,128,wasm-function[10],0x29be33d0f5a,*
code-creation,Function,4,303729,0x299ca85ac80,192,wasm-function[11],0x29be33d0f5b,*
code-creation,Function,4,303738,0x299ca85ad40,192,wasm-function[0],0x29be33d0f50,*
code-creation,Function,4,303748,0x299ca85ae00,10944,wasm-function[20],0x29be33d0f64,*
code-creation,LazyCompile,10,304005,0x2969828af3e,403,cjsPreparseModuleExports node:internal/modules/esm/translators:190:34,0x109c10ec7e8,~
code-source-info,0x2969828af3e,122,5964,7465,C0O5964C11O5993C18O6003C25O6009C28O5993C30O6024C34O6058C41O6072C49O6072C55O6090C57O6109C64O6118C68O6146C78O6160C79O6184C89O6184C94O6204C96O6224C105O6233C110O6231C112O6263C117O6279C121O6296C128O6311C131O6321C139O6345C144O6321C149O6309C153O6357C160O6367C167O6384C171O6408C176O6430C186O6439C195O6437C198O6494C200O6503C205O6528C214O6563C219O6554C224O6531C229O6540C238O6597C241O6616C244O6662C255O6678C260O6674C268O6662C273O6662C275O6740C282O6754C290O6758C297O6768C303O6776C309O6789C313O6754C319O6819C325O6834C330O6850C334O6867C341O6882C344O6892C352O6916C357O6892C362O6880C366O6931C373O6953C378O6931C383O7431C390O7440C396O7448C402O7462,,
code-creation,LazyCompile,10,304484,0x2969828b586,772,parse node:internal/deps/cjs-module-lexer/dist/lexer:1:131,0x306324bc680,~
code-source-info,0x2969828b586,149,130,813,C14O140C20O146C29O152C34O146C35O191C39O197C43O202C48O205C53O217C61O224C64O226C71O240C74O238C80O243C83O245C88O252C93O259C97O242C101O270C102O271C109O275C112O277C117O284C122O289C126O294C133O300C144O294C150O284C155O317C160O319C165O319C171O325C184O342C190O354C193O356C198O363C211O338C217O335C224O377C227O379C232O392C247O379C254O406C258O419C263O430C272O451C279O455C282O457C287O457C302O466C312O474C316O476C322O476C328O466C335O480C344O481C350O492C367O503C370O505C375O505C380O511C391O528C395O530C401O530C405O533C410O511C416O508C426O426C439O545C442O547C447O547C455O419C461O406C462O559C466O559C472O569C476O569C482O579C486O579C492O594C497O594C502O594C508O610C511O614C518O620C521O622C526O622C533O628C536O630C541O630C546O614C553O610C558O638C560O643C565O643C570O587C573O657C578O657C583O657C589O665C597O673C604O679C608O681C613O681C620O686C624O688C630O688C636O673C643O669C648O665C653O650C656O703C661O703C666O703C672O716C675O720C682O726C685O728C690O728C697O733C700O735C705O735C710O720C717O716C722O742C725O756C730O756C737O766C742O766C747O696C750O773C757O792C764O809C771O812,,
code-creation,LazyCompile,10,304684,0x2969828bae6,44,C node:internal/deps/cjs-module-lexer/dist/lexer:1:1152,0x306324bc770,~
code-source-info,0x2969828bae6,149,1151,1215,C0O1167C5O1180C7O1188C9O1188C14O1199C30O1199C35O1196C39O1182C43O1214,,
code-creation,LazyCompile,10,305193,0x2969828bcde,152,B node:internal/deps/cjs-module-lexer/dist/lexer:1:824,0x306324bc6d0,~
code-source-info,0x2969828bcde,149,823,1040,C0O827C4O837C7O833C16O849C19O845C24O853C26O862C30O874C34O882C39O896C41O902C45O899C50O930C55O930C60O927C71O944C77O950C82O959C91O967C96O972C97O979C98O979C105O998C115O998C120O995C130O987C135O1015C136O1021C137O910C142O886C145O1023C147O1031C151O1039,,
code-creation,Function,11,305348,0x29be72d2a80,40, node:internal/per_context/primordials:276:21,0x147335c9b48,^
code-source-info,0x29be72d2a80,6,8195,8226,,,
code-creation,Function,11,305388,0x29be72d2b40,404,get href node:internal/url:750:11,0x14121bf87a8,^
code-source-info,0x29be72d2b40,39,21492,21601,,,
code-creation,Function,11,305415,0x29be72d2d80,324, node:internal/fs/utils:680:42,0x1d4982a2520,^
code-source-info,0x29be72d2d80,82,19157,19296,,,
code-creation,Function,11,305443,0x29be72d2f80,344,C node:internal/deps/cjs-module-lexer/dist/lexer:1:1152,0x306324bc770,^
code-source-info,0x29be72d2f80,149,1151,1215,,,
code-creation,Function,11,305467,0x29be72d3180,116,SafeIterator node:internal/per_context/primordials:270:16,0x147335c99d8,^
code-source-info,0x29be72d3180,6,8054,8116,,,
code-creation,Function,11,305492,0x29be72d3280,264,SafeSet node:internal/per_context/primordials:364:16,0x147335ca1b8,^
code-source-info,0x29be72d3280,6,10890,10907,,,
code-creation,LazyCompile,10,305651,0x2969828c33e,90,decorateErrorStack node:internal/util:139:28,0x25ca2705860,~
code-source-info,0x2969828c33e,16,3751,4074,C0O3762C3O3768C9O3788C17O3805C22O3825C25O3805C32O3855C37O3870C38O3877C39O3897C46O3917C49O3897C55O3956C57O3998C61O3992C64O3984C68O4010C75O4030C83O4010C89O4073,,
code-creation,LazyCompile,10,305711,0x2969828c49e,19,isError node:internal/util:80:17,0x25ca2705648,~
code-source-info,0x2969828c49e,16,1925,2164,C0O2115C5O2122C13O2155C15O2144C18O2161,,
code-creation,LazyCompile,10,305826,0x2969828c6f6,343,prepareStackTrace node:internal/errors:90:27,0x147335e47e8,~
code-source-info,0x2969828c6f6,11,2252,3783,C0O2397C5O2420C10O2420C17O2449C22O2468C27O2468C33O2485C38O2504C43O2510C48O2531C53O2547C54O2577C55O2582C61O2585C66O2587C74O2609C78O2627C83O2665C86O2627C93O2712C97O2719C101O2726C102O2726C107O2757C109O2762C115O2765C120O2767C128O2793C132O2803C137O2833C140O2803C147O2865C156O2898C163O2865C168O2913C170O2733C175O2693C178O3103C185O3112C187O3110C192O3140C199O3168C202O3140C207O3228C221O3228C227O3289C229O3312C231O3308C236O3325C238O3347C239O3462C241O3478C248O3495C253O3535C265O3550C280O3566C291O3594C296O3608C301O3657C307O3664C312O3678C314O3697C315O3706C327O3739C333O3739C342O3780,,
code-creation,LazyCompile,10,305938,0x2969828c9ee,70,maybeOverridePrepareStackTrace node:internal/errors:135:40,0x147335e5668,~
code-source-info,0x2969828c9ee,11,3827,4550,C0O4060C7O4065C18O4126C23O4132C28O4132C34O4164C35O4392C40O4420C48O4461C53O4485C58O4485C64O4517C65O4528C69O4547,,
code-creation,LazyCompile,10,306244,0x2969828cbce,60,defaultGetFormat node:internal/modules/esm/get_format:99:26,0x1abee8375f0,~
code-source-info,0x2969828cbce,111,3103,3298,C0O3138C7O3138C13O3155C20O3192C23O3217C28O3162C37O3234C40O3258C44O3250C50O3267C59O3295,,
code-creation,LazyCompile,10,306337,0x2969828ccfe,12,hasUncaughtExceptionCaptureCallback node:internal/process/execution:118:45,0x13c5c2f1680,~
script-source,79,node:internal/process/execution,'use strict';\x0d\n\x0d\nconst {\x0d\n  globalThis\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst path = require('path');\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_TYPE\x2C\x0d\n    ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET\x2C\x0d\n    ERR_EVAL_ESM_CANNOT_PRINT\x2C\x0d\n  }\x2C\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  executionAsyncId\x2C\x0d\n  clearDefaultTriggerAsyncId\x2C\x0d\n  clearAsyncIdStack\x2C\x0d\n  hasAsyncIdStack\x2C\x0d\n  afterHooksExist\x2C\x0d\n  emitAfter\x0d\n} = require('internal/async_hooks');\x0d\n\x0d\n// shouldAbortOnUncaughtToggle is a typed array for faster\x0d\n// communication with JS.\x0d\nconst { shouldAbortOnUncaughtToggle } = internalBinding('util');\x0d\n\x0d\nfunction tryGetCwd() {\x0d\n  try {\x0d\n    return process.cwd();\x0d\n  } catch {\x0d\n    // getcwd(3) can fail if the current working directory has been deleted.\x0d\n    // Fall back to the directory name of the (absolute) executable path.\x0d\n    // It's not really correct but what are the alternatives?\x0d\n    return path.dirname(process.execPath);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction evalModule(source\x2C print) {\x0d\n  if (print) {\x0d\n    throw new ERR_EVAL_ESM_CANNOT_PRINT();\x0d\n  }\x0d\n  const { loadESM } = require('internal/process/esm_loader');\x0d\n  const { handleMainPromise } = require('internal/modules/run_main');\x0d\n  return handleMainPromise(loadESM((loader) => loader.eval(source)));\x0d\n}\x0d\n\x0d\nfunction evalScript(name\x2C body\x2C breakFirstLine\x2C print) {\x0d\n  const CJSModule = require('internal/modules/cjs/loader').Module;\x0d\n  const { kVmBreakFirstLineSymbol } = require('internal/util');\x0d\n  const { pathToFileURL } = require('url');\x0d\n\x0d\n  const cwd = tryGetCwd();\x0d\n  const origModule = globalThis.module;  // Set e.g. when called from the REPL.\x0d\n\x0d\n  const module = new CJSModule(name);\x0d\n  module.filename = path.join(cwd\x2C name);\x0d\n  module.paths = CJSModule._nodeModulePaths(cwd);\x0d\n\x0d\n  const asyncESM = require('internal/process/esm_loader');\x0d\n  const baseUrl = pathToFileURL(module.filename).href;\x0d\n\x0d\n  // Create wrapper for cache entry\x0d\n  const script = `\x0d\n    globalThis.module = module;\x0d\n    globalThis.exports = exports;\x0d\n    globalThis.__dirname = __dirname;\x0d\n    globalThis.require = require;\x0d\n    return (main) => main();\x0d\n  `;\x0d\n  globalThis.__filename = name;\x0d\n  const result = module._compile(script\x2C `${name}-wrapper`)(() =>\x0d\n    require('vm').runInThisContext(body\x2C {\x0d\n      filename: name\x2C\x0d\n      displayErrors: true\x2C\x0d\n      [kVmBreakFirstLineSymbol]: !!breakFirstLine\x2C\x0d\n      importModuleDynamically(specifier\x2C _\x2C importAssertions) {\x0d\n        const loader = asyncESM.esmLoader;\x0d\n        return loader.import(specifier\x2C baseUrl\x2C importAssertions);\x0d\n      }\x0d\n    }));\x0d\n  if (print) {\x0d\n    const { log } = require('internal/console/global');\x0d\n    log(result);\x0d\n  }\x0d\n\x0d\n  if (origModule !== undefined)\x0d\n    globalThis.module = origModule;\x0d\n}\x0d\n\x0d\nconst exceptionHandlerState = {\x0d\n  captureFn: null\x2C\x0d\n  reportFlag: false\x0d\n};\x0d\n\x0d\nfunction setUncaughtExceptionCaptureCallback(fn) {\x0d\n  if (fn === null) {\x0d\n    exceptionHandlerState.captureFn = fn;\x0d\n    shouldAbortOnUncaughtToggle[0] = 1;\x0d\n    process.report.reportOnUncaughtException = exceptionHandlerState.reportFlag;\x0d\n    return;\x0d\n  }\x0d\n  if (typeof fn !== 'function') {\x0d\n    throw new ERR_INVALID_ARG_TYPE('fn'\x2C ['Function'\x2C 'null']\x2C fn);\x0d\n  }\x0d\n  if (exceptionHandlerState.captureFn !== null) {\x0d\n    throw new ERR_UNCAUGHT_EXCEPTION_CAPTURE_ALREADY_SET();\x0d\n  }\x0d\n  exceptionHandlerState.captureFn = fn;\x0d\n  shouldAbortOnUncaughtToggle[0] = 0;\x0d\n  exceptionHandlerState.reportFlag =\x0d\n    process.report.reportOnUncaughtException === true;\x0d\n  process.report.reportOnUncaughtException = false;\x0d\n}\x0d\n\x0d\nfunction hasUncaughtExceptionCaptureCallback() {\x0d\n  return exceptionHandlerState.captureFn !== null;\x0d\n}\x0d\n\x0d\nfunction noop() {}\x0d\n\x0d\n// XXX(joyeecheung): for some reason this cannot be defined at the top-level\x0d\n// and exported to be written to process._fatalException\x2C it has to be\x0d\n// returned as an *anonymous function* wrapped inside a factory function\x2C\x0d\n// otherwise it breaks the test-timers.setInterval async hooks test -\x0d\n// this may indicate that node::errors::TriggerUncaughtException() should\x0d\n// fix up the callback scope before calling into process._fatalException\x2C\x0d\n// or this function should take extra care of the async hooks before it\x0d\n// schedules a setImmediate.\x0d\nfunction createOnGlobalUncaughtException() {\x0d\n  // The C++ land node::errors::TriggerUncaughtException() will\x0d\n  // exit the process if it returns false\x2C and continue execution if it\x0d\n  // returns true (which indicates that the exception is handled by the user).\x0d\n  return (er\x2C fromPromise) => {\x0d\n    // It's possible that defaultTriggerAsyncId was set for a constructor\x0d\n    // call that threw and was never cleared. So clear it now.\x0d\n    clearDefaultTriggerAsyncId();\x0d\n\x0d\n    // If diagnostic reporting is enabled\x2C call into its handler to see\x0d\n    // whether it is interested in handling the situation.\x0d\n    // Ignore if the error is scoped inside a domain.\x0d\n    // use == in the checks as we want to allow for null and undefined\x0d\n    if (er == null || er.domain == null) {\x0d\n      try {\x0d\n        const report = internalBinding('report');\x0d\n        if (report != null && report.shouldReportOnUncaughtException()) {\x0d\n          report.writeReport(\x0d\n            typeof er?.message === 'string' ?\x0d\n              er.message :\x0d\n              'Exception'\x2C\x0d\n            'Exception'\x2C\x0d\n            null\x2C\x0d\n            er ?? {});\x0d\n        }\x0d\n      } catch {}  // Ignore the exception. Diagnostic reporting is unavailable.\x0d\n    }\x0d\n\x0d\n    const type = fromPromise ? 'unhandledRejection' : 'uncaughtException';\x0d\n    process.emit('uncaughtExceptionMonitor'\x2C er\x2C type);\x0d\n    if (exceptionHandlerState.captureFn !== null) {\x0d\n      exceptionHandlerState.captureFn(er);\x0d\n    } else if (!process.emit('uncaughtException'\x2C er\x2C type)) {\x0d\n      // If someone handled it\x2C then great. Otherwise\x2C die in C++ land\x0d\n      // since that means that we'll exit the process\x2C emit the 'exit' event.\x0d\n      try {\x0d\n        if (!process._exiting) {\x0d\n          process._exiting = true;\x0d\n          process.exitCode = 1;\x0d\n          process.emit('exit'\x2C 1);\x0d\n        }\x0d\n      } catch {\x0d\n        // Nothing to be done about it at this point.\x0d\n      }\x0d\n      return false;\x0d\n    }\x0d\n\x0d\n    // If we handled an error\x2C then make sure any ticks get processed\x0d\n    // by ensuring that the next Immediate cycle isn't empty.\x0d\n    require('timers').setImmediate(noop);\x0d\n\x0d\n    // Emit the after() hooks now that the exception has been handled.\x0d\n    if (afterHooksExist()) {\x0d\n      do {\x0d\n        emitAfter(executionAsyncId());\x0d\n      } while (hasAsyncIdStack());\x0d\n    }\x0d\n    // And completely empty the id stack\x2C including anything that may be\x0d\n    // cached on the native side.\x0d\n    clearAsyncIdStack();\x0d\n\x0d\n    return true;\x0d\n  };\x0d\n}\x0d\n\x0d\nfunction readStdin(callback) {\x0d\n  process.stdin.setEncoding('utf8');\x0d\n\x0d\n  let code = '';\x0d\n  process.stdin.on('data'\x2C (d) => {\x0d\n    code += d;\x0d\n  });\x0d\n\x0d\n  process.stdin.on('end'\x2C () => {\x0d\n    callback(code);\x0d\n  });\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  readStdin\x2C\x0d\n  tryGetCwd\x2C\x0d\n  evalModule\x2C\x0d\n  evalScript\x2C\x0d\n  onGlobalUncaughtException: createOnGlobalUncaughtException()\x2C\x0d\n  setUncaughtExceptionCaptureCallback\x2C\x0d\n  hasUncaughtExceptionCaptureCallback\x0d\n};\x0d\n
code-source-info,0x2969828ccfe,79,3545,3604,C0O3553C5O3582C10O3592C11O3601,,
code-creation,LazyCompile,10,306765,0x2969828d61e,324, node:internal/process/execution:136:10,0x13c5c2f1758,~
code-source-info,0x2969828d61e,79,4452,6652,C0O4619C5O4619C8O4916C13O4937C23O4992C29O4992C34O5028C37O5057C42O5057C48O5112C63O5147C74O5190C94O5286C96O5112C107O5416C118O5479C121O5487C135O5487C140O5536C145O5562C151O5591C156O5613C161O5613C168O5640C171O5653C185O5653C195O5865C198O5878C204O5901C208O5918C212O5937C217O5954C221O5970C224O5978C235O5978C247O6094C248O6107C249O6256C255O6256C260O6273C268O6274C273O6373C278O6377C283O6419C290O6429C293O6429C297O6419C301O6466C306O6466C311O6405C314O6607C319O6607C322O6635C323O6647,,
code-creation,LazyCompile,10,306888,0x2969828d8de,18,clearDefaultTriggerAsyncId node:internal/async_hooks:442:36,0x147335f89d0,~
script-source,13,node:internal/async_hooks,'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeSlice\x2C\x0d\n  ErrorCaptureStackTrace\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  Symbol\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst promiseHooks = require('internal/promise_hooks');\x0d\n\x0d\nconst async_wrap = internalBinding('async_wrap');\x0d\nconst { setCallbackTrampoline } = async_wrap;\x0d\n/* async_hook_fields is a Uint32Array wrapping the uint32_t array of\x0d\n * Environment::AsyncHooks::fields_[]. Each index tracks the number of active\x0d\n * hooks for each type.\x0d\n *\x0d\n * async_id_fields is a Float64Array wrapping the double array of\x0d\n * Environment::AsyncHooks::async_id_fields_[]. Each index contains the ids for\x0d\n * the various asynchronous states of the application. These are:\x0d\n *  kExecutionAsyncId: The async_id assigned to the resource responsible for the\x0d\n *    current execution stack.\x0d\n *  kTriggerAsyncId: The async_id of the resource that caused (or 'triggered')\x0d\n *    the resource corresponding to the current execution stack.\x0d\n *  kAsyncIdCounter: Incremental counter tracking the next assigned async_id.\x0d\n *  kDefaultTriggerAsyncId: Written immediately before a resource's constructor\x0d\n *    that sets the value of the init()'s triggerAsyncId. The precedence order\x0d\n *    of retrieving the triggerAsyncId value is:\x0d\n *    1. the value passed directly to the constructor\x0d\n *    2. value set in kDefaultTriggerAsyncId\x0d\n *    3. executionAsyncId of the current resource.\x0d\n *\x0d\n * async_ids_stack is a Float64Array that contains part of the async ID\x0d\n * stack. Each pushAsyncContext() call adds two doubles to it\x2C and each\x0d\n * popAsyncContext() call removes two doubles from it.\x0d\n * It has a fixed size\x2C so if that is exceeded\x2C calls to the native\x0d\n * side are used instead in pushAsyncContext() and popAsyncContext().\x0d\n */\x0d\nconst {\x0d\n  async_hook_fields\x2C\x0d\n  async_id_fields\x2C\x0d\n  execution_async_resources\x0d\n} = async_wrap;\x0d\n// Store the pair executionAsyncId and triggerAsyncId in a AliasedFloat64Array\x0d\n// in Environment::AsyncHooks::async_ids_stack_ which tracks the resource\x0d\n// responsible for the current execution stack. This is unwound as each resource\x0d\n// exits. In the case of a fatal exception this stack is emptied after calling\x0d\n// each hook's after() callback.\x0d\nconst {\x0d\n  pushAsyncContext: pushAsyncContext_\x2C\x0d\n  popAsyncContext: popAsyncContext_\x2C\x0d\n  executionAsyncResource: executionAsyncResource_\x2C\x0d\n  clearAsyncIdStack\x2C\x0d\n} = async_wrap;\x0d\n// Properties in active_hooks are used to keep track of the set of hooks being\x0d\n// executed in case another hook is enabled/disabled. The new set of hooks is\x0d\n// then restored once the active set of hooks is finished executing.\x0d\nconst active_hooks = {\x0d\n  // Array of all AsyncHooks that will be iterated whenever an async event\x0d\n  // fires. Using var instead of (preferably const) in order to assign\x0d\n  // active_hooks.tmp_array if a hook is enabled/disabled during hook\x0d\n  // execution.\x0d\n  array: []\x2C\x0d\n  // Use a counter to track nested calls of async hook callbacks and make sure\x0d\n  // the active_hooks.array isn't altered mid execution.\x0d\n  call_depth: 0\x2C\x0d\n  // Use to temporarily store and updated active_hooks.array if the user\x0d\n  // enables or disables a hook while hooks are being processed. If a hook is\x0d\n  // enabled() or disabled() during hook execution then the current set of\x0d\n  // active hooks is duplicated and set equal to active_hooks.tmp_array. Any\x0d\n  // subsequent changes are on the duplicated array. When all hooks have\x0d\n  // completed executing active_hooks.tmp_array is assigned to\x0d\n  // active_hooks.array.\x0d\n  tmp_array: null\x2C\x0d\n  // Keep track of the field counts held in active_hooks.tmp_array. Because the\x0d\n  // async_hook_fields can't be reassigned\x2C store each uint32 in an array that\x0d\n  // is written back to async_hook_fields when active_hooks.array is restored.\x0d\n  tmp_fields: null\x0d\n};\x0d\n\x0d\nconst { registerDestroyHook } = async_wrap;\x0d\nconst { enqueueMicrotask } = internalBinding('task_queue');\x0d\nconst { resource_symbol\x2C owner_symbol } = internalBinding('symbols');\x0d\n\x0d\n// Each constant tracks how many callbacks there are for any given step of\x0d\n// async execution. These are tracked so if the user didn't include callbacks\x0d\n// for a given step\x2C that step can bail out early.\x0d\nconst {\x0d\n  kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x2C\x0d\n  kCheck\x2C kExecutionAsyncId\x2C kAsyncIdCounter\x2C kTriggerAsyncId\x2C\x0d\n  kDefaultTriggerAsyncId\x2C kStackLength\x2C kUsesExecutionAsyncResource\x2C\x0d\n} = async_wrap.constants;\x0d\n\x0d\nconst { async_id_symbol\x2C\x0d\n        trigger_async_id_symbol } = internalBinding('symbols');\x0d\n\x0d\n// Lazy load of internal/util/inspect;\x0d\nlet inspect;\x0d\n\x0d\n// Used in AsyncHook and AsyncResource.\x0d\nconst init_symbol = Symbol('init');\x0d\nconst before_symbol = Symbol('before');\x0d\nconst after_symbol = Symbol('after');\x0d\nconst destroy_symbol = Symbol('destroy');\x0d\nconst promise_resolve_symbol = Symbol('promiseResolve');\x0d\nconst emitBeforeNative = emitHookFactory(before_symbol\x2C 'emitBeforeNative');\x0d\nconst emitAfterNative = emitHookFactory(after_symbol\x2C 'emitAfterNative');\x0d\nconst emitDestroyNative = emitHookFactory(destroy_symbol\x2C 'emitDestroyNative');\x0d\nconst emitPromiseResolveNative =\x0d\n    emitHookFactory(promise_resolve_symbol\x2C 'emitPromiseResolveNative');\x0d\n\x0d\nlet domain_cb;\x0d\nfunction useDomainTrampoline(fn) {\x0d\n  domain_cb = fn;\x0d\n}\x0d\n\x0d\nfunction callbackTrampoline(asyncId\x2C resource\x2C cb\x2C ...args) {\x0d\n  const index = async_hook_fields[kStackLength] - 1;\x0d\n  execution_async_resources[index] = resource;\x0d\n\x0d\n  if (asyncId !== 0 && hasHooks(kBefore))\x0d\n    emitBeforeNative(asyncId);\x0d\n\x0d\n  let result;\x0d\n  if (asyncId === 0 && typeof domain_cb === 'function') {\x0d\n    args.unshift(cb);\x0d\n    result = domain_cb.apply(this\x2C args);\x0d\n  } else {\x0d\n    result = cb.apply(this\x2C args);\x0d\n  }\x0d\n\x0d\n  if (asyncId !== 0 && hasHooks(kAfter))\x0d\n    emitAfterNative(asyncId);\x0d\n\x0d\n  execution_async_resources.pop();\x0d\n  return result;\x0d\n}\x0d\n\x0d\nconst topLevelResource = {};\x0d\n\x0d\nfunction executionAsyncResource() {\x0d\n  // Indicate to the native layer that this function is likely to be used\x2C\x0d\n  // in which case it will inform JS about the current async resource via\x0d\n  // the trampoline above.\x0d\n  async_hook_fields[kUsesExecutionAsyncResource] = 1;\x0d\n\x0d\n  const index = async_hook_fields[kStackLength] - 1;\x0d\n  if (index === -1) return topLevelResource;\x0d\n  const resource = execution_async_resources[index] ||\x0d\n    executionAsyncResource_(index);\x0d\n  return lookupPublicResource(resource);\x0d\n}\x0d\n\x0d\nfunction inspectExceptionValue(e) {\x0d\n  inspect ??= require('internal/util/inspect').inspect;\x0d\n  return { message: inspect(e) };\x0d\n}\x0d\n\x0d\n// Used to fatally abort the process if a callback throws.\x0d\nfunction fatalError(e) {\x0d\n  if (typeof e?.stack === 'string') {\x0d\n    process._rawDebug(e.stack);\x0d\n  } else {\x0d\n    const o = inspectExceptionValue(e);\x0d\n    ErrorCaptureStackTrace(o\x2C fatalError);\x0d\n    process._rawDebug(o.stack);\x0d\n  }\x0d\n\x0d\n  const { getOptionValue } = require('internal/options');\x0d\n  if (getOptionValue('--abort-on-uncaught-exception')) {\x0d\n    process.abort();\x0d\n  }\x0d\n  process.exit(1);\x0d\n}\x0d\n\x0d\nfunction lookupPublicResource(resource) {\x0d\n  if (typeof resource !== 'object' || resource === null) return resource;\x0d\n  // TODO(addaleax): Merge this with owner_symbol and use it across all\x0d\n  // AsyncWrap instances.\x0d\n  const publicResource = resource[resource_symbol];\x0d\n  if (publicResource !== undefined)\x0d\n    return publicResource;\x0d\n  return resource;\x0d\n}\x0d\n\x0d\n// Emit From Native //\x0d\n\x0d\n// Used by C++ to call all init() callbacks. Because some state can be setup\x0d\n// from C++ there's no need to perform all the same operations as in\x0d\n// emitInitScript.\x0d\nfunction emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\x0d\n  active_hooks.call_depth += 1;\x0d\n  resource = lookupPublicResource(resource);\x0d\n  // Use a single try/catch for all hooks to avoid setting up one per iteration.\x0d\n  try {\x0d\n    // Using var here instead of let because "for (var ...)" is faster than let.\x0d\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\x0d\n    for (var i = 0; i < active_hooks.array.length; i++) {\x0d\n      if (typeof active_hooks.array[i][init_symbol] === 'function') {\x0d\n        active_hooks.array[i][init_symbol](\x0d\n          asyncId\x2C type\x2C triggerAsyncId\x2C\x0d\n          resource\x0d\n        );\x0d\n      }\x0d\n    }\x0d\n  } catch (e) {\x0d\n    fatalError(e);\x0d\n  } finally {\x0d\n    active_hooks.call_depth -= 1;\x0d\n  }\x0d\n\x0d\n  // Hooks can only be restored if there have been no recursive hook calls.\x0d\n  // Also the active hooks do not need to be restored if enable()/disable()\x0d\n  // weren't called during hook execution\x2C in which case active_hooks.tmp_array\x0d\n  // will be null.\x0d\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\x0d\n    restoreActiveHooks();\x0d\n  }\x0d\n}\x0d\n\x0d\n// Called from native. The asyncId stack handling is taken care of there\x0d\n// before this is called.\x0d\nfunction emitHook(symbol\x2C asyncId) {\x0d\n  active_hooks.call_depth += 1;\x0d\n  // Use a single try/catch for all hook to avoid setting up one per\x0d\n  // iteration.\x0d\n  try {\x0d\n    // Using var here instead of let because "for (var ...)" is faster than let.\x0d\n    // Refs: https://github.com/nodejs/node/pull/30380#issuecomment-552948364\x0d\n    for (var i = 0; i < active_hooks.array.length; i++) {\x0d\n      if (typeof active_hooks.array[i][symbol] === 'function') {\x0d\n        active_hooks.array[i][symbol](asyncId);\x0d\n      }\x0d\n    }\x0d\n  } catch (e) {\x0d\n    fatalError(e);\x0d\n  } finally {\x0d\n    active_hooks.call_depth -= 1;\x0d\n  }\x0d\n\x0d\n  // Hooks can only be restored if there have been no recursive hook calls.\x0d\n  // Also the active hooks do not need to be restored if enable()/disable()\x0d\n  // weren't called during hook execution\x2C in which case\x0d\n  // active_hooks.tmp_array will be null.\x0d\n  if (active_hooks.call_depth === 0 && active_hooks.tmp_array !== null) {\x0d\n    restoreActiveHooks();\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction emitHookFactory(symbol\x2C name) {\x0d\n  const fn = emitHook.bind(undefined\x2C symbol);\x0d\n\x0d\n  // Set the name property of the function as it looks good in the stack trace.\x0d\n  ObjectDefineProperty(fn\x2C 'name'\x2C {\x0d\n    value: name\x0d\n  });\x0d\n  return fn;\x0d\n}\x0d\n\x0d\n// Manage Active Hooks //\x0d\n\x0d\nfunction getHookArrays() {\x0d\n  if (active_hooks.call_depth === 0)\x0d\n    return [active_hooks.array\x2C async_hook_fields];\x0d\n  // If this hook is being enabled while in the middle of processing the array\x0d\n  // of currently active hooks then duplicate the current set of active hooks\x0d\n  // and store this there. This shouldn't fire until the next time hooks are\x0d\n  // processed.\x0d\n  if (active_hooks.tmp_array === null)\x0d\n    storeActiveHooks();\x0d\n  return [active_hooks.tmp_array\x2C active_hooks.tmp_fields];\x0d\n}\x0d\n\x0d\n\x0d\nfunction storeActiveHooks() {\x0d\n  active_hooks.tmp_array = ArrayPrototypeSlice(active_hooks.array);\x0d\n  // Don't want to make the assumption that kInit to kDestroy are indexes 0 to\x0d\n  // 4. So do this the long way.\x0d\n  active_hooks.tmp_fields = [];\x0d\n  copyHooks(active_hooks.tmp_fields\x2C async_hook_fields);\x0d\n}\x0d\n\x0d\nfunction copyHooks(destination\x2C source) {\x0d\n  destination[kInit] = source[kInit];\x0d\n  destination[kBefore] = source[kBefore];\x0d\n  destination[kAfter] = source[kAfter];\x0d\n  destination[kDestroy] = source[kDestroy];\x0d\n  destination[kPromiseResolve] = source[kPromiseResolve];\x0d\n}\x0d\n\x0d\n\x0d\n// Then restore the correct hooks array in case any hooks were added/removed\x0d\n// during hook callback execution.\x0d\nfunction restoreActiveHooks() {\x0d\n  active_hooks.array = active_hooks.tmp_array;\x0d\n  copyHooks(async_hook_fields\x2C active_hooks.tmp_fields);\x0d\n\x0d\n  active_hooks.tmp_array = null;\x0d\n  active_hooks.tmp_fields = null;\x0d\n}\x0d\n\x0d\nfunction trackPromise(promise\x2C parent) {\x0d\n  if (promise[async_id_symbol]) {\x0d\n    return;\x0d\n  }\x0d\n\x0d\n  // Get trigger id from parent async id before making the async id of the\x0d\n  // child so if a new one must be made it will be lower than the child.\x0d\n  const triggerAsyncId = parent ? getOrSetAsyncId(parent) :\x0d\n    getDefaultTriggerAsyncId();\x0d\n\x0d\n  promise[async_id_symbol] = newAsyncId();\x0d\n  promise[trigger_async_id_symbol] = triggerAsyncId;\x0d\n}\x0d\n\x0d\nfunction promiseInitHook(promise\x2C parent) {\x0d\n  trackPromise(promise\x2C parent);\x0d\n  const asyncId = promise[async_id_symbol];\x0d\n  const triggerAsyncId = promise[trigger_async_id_symbol];\x0d\n  emitInitScript(asyncId\x2C 'PROMISE'\x2C triggerAsyncId\x2C promise);\x0d\n}\x0d\n\x0d\nfunction promiseInitHookWithDestroyTracking(promise\x2C parent) {\x0d\n  promiseInitHook(promise\x2C parent);\x0d\n  destroyTracking(promise\x2C parent);\x0d\n}\x0d\n\x0d\nconst destroyedSymbol = Symbol('destroyed');\x0d\n\x0d\nfunction destroyTracking(promise\x2C parent) {\x0d\n  trackPromise(promise\x2C parent);\x0d\n  const asyncId = promise[async_id_symbol];\x0d\n  const destroyed = { destroyed: false };\x0d\n  promise[destroyedSymbol] = destroyed;\x0d\n  registerDestroyHook(promise\x2C asyncId\x2C destroyed);\x0d\n}\x0d\n\x0d\nfunction promiseBeforeHook(promise) {\x0d\n  trackPromise(promise);\x0d\n  const asyncId = promise[async_id_symbol];\x0d\n  const triggerId = promise[trigger_async_id_symbol];\x0d\n  emitBeforeScript(asyncId\x2C triggerId\x2C promise);\x0d\n}\x0d\n\x0d\nfunction promiseAfterHook(promise) {\x0d\n  trackPromise(promise);\x0d\n  const asyncId = promise[async_id_symbol];\x0d\n  if (hasHooks(kAfter)) {\x0d\n    emitAfterNative(asyncId);\x0d\n  }\x0d\n  if (asyncId === executionAsyncId()) {\x0d\n    // This condition might not be true if async_hooks was enabled during\x0d\n    // the promise callback execution.\x0d\n    // Popping it off the stack can be skipped in that case\x2C because it is\x0d\n    // known that it would correspond to exactly one call with\x0d\n    // PromiseHookType::kBefore that was not witnessed by the PromiseHook.\x0d\n    popAsyncContext(asyncId);\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction promiseResolveHook(promise) {\x0d\n  trackPromise(promise);\x0d\n  const asyncId = promise[async_id_symbol];\x0d\n  emitPromiseResolveNative(asyncId);\x0d\n}\x0d\n\x0d\nlet wantPromiseHook = false;\x0d\nfunction enableHooks() {\x0d\n  async_hook_fields[kCheck] += 1;\x0d\n\x0d\n  setCallbackTrampoline(callbackTrampoline);\x0d\n}\x0d\n\x0d\nlet stopPromiseHook;\x0d\nfunction updatePromiseHookMode() {\x0d\n  wantPromiseHook = true;\x0d\n  let initHook;\x0d\n  if (initHooksExist()) {\x0d\n    initHook = destroyHooksExist() ? promiseInitHookWithDestroyTracking :\x0d\n      promiseInitHook;\x0d\n  } else if (destroyHooksExist()) {\x0d\n    initHook = destroyTracking;\x0d\n  }\x0d\n  if (stopPromiseHook) stopPromiseHook();\x0d\n  stopPromiseHook = promiseHooks.createHook({\x0d\n    init: initHook\x2C\x0d\n    before: promiseBeforeHook\x2C\x0d\n    after: promiseAfterHook\x2C\x0d\n    settled: promiseResolveHooksExist() ? promiseResolveHook : undefined\x0d\n  });\x0d\n}\x0d\n\x0d\nfunction disableHooks() {\x0d\n  async_hook_fields[kCheck] -= 1;\x0d\n\x0d\n  wantPromiseHook = false;\x0d\n\x0d\n  setCallbackTrampoline();\x0d\n\x0d\n  // Delay the call to `disablePromiseHook()` because we might currently be\x0d\n  // between the `before` and `after` calls of a Promise.\x0d\n  enqueueMicrotask(disablePromiseHookIfNecessary);\x0d\n}\x0d\n\x0d\nfunction disablePromiseHookIfNecessary() {\x0d\n  if (!wantPromiseHook && stopPromiseHook) {\x0d\n    stopPromiseHook();\x0d\n  }\x0d\n}\x0d\n\x0d\n// Internal Embedder API //\x0d\n\x0d\n// Increment the internal id counter and return the value. Important that the\x0d\n// counter increment first. Since it's done the same way in\x0d\n// Environment::new_async_uid()\x0d\nfunction newAsyncId() {\x0d\n  return ++async_id_fields[kAsyncIdCounter];\x0d\n}\x0d\n\x0d\nfunction getOrSetAsyncId(object) {\x0d\n  if (ObjectPrototypeHasOwnProperty(object\x2C async_id_symbol)) {\x0d\n    return object[async_id_symbol];\x0d\n  }\x0d\n\x0d\n  return object[async_id_symbol] = newAsyncId();\x0d\n}\x0d\n\x0d\n\x0d\n// Return the triggerAsyncId meant for the constructor calling it. It's up to\x0d\n// the user to safeguard this call and make sure it's zero'd out when the\x0d\n// constructor is complete.\x0d\nfunction getDefaultTriggerAsyncId() {\x0d\n  const defaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\x0d\n  // If defaultTriggerAsyncId isn't set\x2C use the executionAsyncId\x0d\n  if (defaultTriggerAsyncId < 0)\x0d\n    return async_id_fields[kExecutionAsyncId];\x0d\n  return defaultTriggerAsyncId;\x0d\n}\x0d\n\x0d\n\x0d\nfunction clearDefaultTriggerAsyncId() {\x0d\n  async_id_fields[kDefaultTriggerAsyncId] = -1;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Sets a default top level trigger ID to be used\x0d\n *\x0d\n * @template {Array<unknown>} T\x0d\n * @template {unknown} R\x0d\n * @param {number} triggerAsyncId\x0d\n * @param { (...T: args) => R } block\x0d\n * @param  {T} args\x0d\n * @returns {R}\x0d\n */\x0d\nfunction defaultTriggerAsyncIdScope(triggerAsyncId\x2C block\x2C ...args) {\x0d\n  if (triggerAsyncId === undefined)\x0d\n    return block.apply(null\x2C args);\x0d\n  // CHECK(NumberIsSafeInteger(triggerAsyncId))\x0d\n  // CHECK(triggerAsyncId > 0)\x0d\n  const oldDefaultTriggerAsyncId = async_id_fields[kDefaultTriggerAsyncId];\x0d\n  async_id_fields[kDefaultTriggerAsyncId] = triggerAsyncId;\x0d\n\x0d\n  try {\x0d\n    return block.apply(null\x2C args);\x0d\n  } finally {\x0d\n    async_id_fields[kDefaultTriggerAsyncId] = oldDefaultTriggerAsyncId;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction hasHooks(key) {\x0d\n  return async_hook_fields[key] > 0;\x0d\n}\x0d\n\x0d\nfunction enabledHooksExist() {\x0d\n  return hasHooks(kCheck);\x0d\n}\x0d\n\x0d\nfunction initHooksExist() {\x0d\n  return hasHooks(kInit);\x0d\n}\x0d\n\x0d\nfunction afterHooksExist() {\x0d\n  return hasHooks(kAfter);\x0d\n}\x0d\n\x0d\nfunction destroyHooksExist() {\x0d\n  return hasHooks(kDestroy);\x0d\n}\x0d\n\x0d\nfunction promiseResolveHooksExist() {\x0d\n  return hasHooks(kPromiseResolve);\x0d\n}\x0d\n\x0d\n\x0d\nfunction emitInitScript(asyncId\x2C type\x2C triggerAsyncId\x2C resource) {\x0d\n  // Short circuit all checks for the common case. Which is that no hooks have\x0d\n  // been set. Do this to remove performance impact for embedders (and core).\x0d\n  if (!hasHooks(kInit))\x0d\n    return;\x0d\n\x0d\n  if (triggerAsyncId === null) {\x0d\n    triggerAsyncId = getDefaultTriggerAsyncId();\x0d\n  }\x0d\n\x0d\n  emitInitNative(asyncId\x2C type\x2C triggerAsyncId\x2C resource);\x0d\n}\x0d\n\x0d\n\x0d\nfunction emitBeforeScript(asyncId\x2C triggerAsyncId\x2C resource) {\x0d\n  pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource);\x0d\n\x0d\n  if (hasHooks(kBefore))\x0d\n    emitBeforeNative(asyncId);\x0d\n}\x0d\n\x0d\n\x0d\nfunction emitAfterScript(asyncId) {\x0d\n  if (hasHooks(kAfter))\x0d\n    emitAfterNative(asyncId);\x0d\n\x0d\n  popAsyncContext(asyncId);\x0d\n}\x0d\n\x0d\n\x0d\nfunction emitDestroyScript(asyncId) {\x0d\n  // Return early if there are no destroy callbacks\x2C or invalid asyncId.\x0d\n  if (!hasHooks(kDestroy) || asyncId <= 0)\x0d\n    return;\x0d\n  async_wrap.queueDestroyAsyncId(asyncId);\x0d\n}\x0d\n\x0d\n\x0d\nfunction hasAsyncIdStack() {\x0d\n  return hasHooks(kStackLength);\x0d\n}\x0d\n\x0d\n\x0d\n// This is the equivalent of the native push_async_ids() call.\x0d\nfunction pushAsyncContext(asyncId\x2C triggerAsyncId\x2C resource) {\x0d\n  const offset = async_hook_fields[kStackLength];\x0d\n  execution_async_resources[offset] = resource;\x0d\n  if (offset * 2 >= async_wrap.async_ids_stack.length)\x0d\n    return pushAsyncContext_(asyncId\x2C triggerAsyncId);\x0d\n  async_wrap.async_ids_stack[offset * 2] = async_id_fields[kExecutionAsyncId];\x0d\n  async_wrap.async_ids_stack[offset * 2 + 1] = async_id_fields[kTriggerAsyncId];\x0d\n  async_hook_fields[kStackLength]++;\x0d\n  async_id_fields[kExecutionAsyncId] = asyncId;\x0d\n  async_id_fields[kTriggerAsyncId] = triggerAsyncId;\x0d\n}\x0d\n\x0d\n\x0d\n// This is the equivalent of the native pop_async_ids() call.\x0d\nfunction popAsyncContext(asyncId) {\x0d\n  const stackLength = async_hook_fields[kStackLength];\x0d\n  if (stackLength === 0) return false;\x0d\n\x0d\n  if (enabledHooksExist() && async_id_fields[kExecutionAsyncId] !== asyncId) {\x0d\n    // Do the same thing as the native code (i.e. crash hard).\x0d\n    return popAsyncContext_(asyncId);\x0d\n  }\x0d\n\x0d\n  const offset = stackLength - 1;\x0d\n  async_id_fields[kExecutionAsyncId] = async_wrap.async_ids_stack[2 * offset];\x0d\n  async_id_fields[kTriggerAsyncId] = async_wrap.async_ids_stack[2 * offset + 1];\x0d\n  execution_async_resources.pop();\x0d\n  async_hook_fields[kStackLength] = offset;\x0d\n  return offset > 0;\x0d\n}\x0d\n\x0d\n\x0d\nfunction executionAsyncId() {\x0d\n  return async_id_fields[kExecutionAsyncId];\x0d\n}\x0d\n\x0d\nfunction triggerAsyncId() {\x0d\n  return async_id_fields[kTriggerAsyncId];\x0d\n}\x0d\n\x0d\n\x0d\nmodule.exports = {\x0d\n  executionAsyncId\x2C\x0d\n  triggerAsyncId\x2C\x0d\n  // Private API\x0d\n  getHookArrays\x2C\x0d\n  symbols: {\x0d\n    async_id_symbol\x2C trigger_async_id_symbol\x2C\x0d\n    init_symbol\x2C before_symbol\x2C after_symbol\x2C destroy_symbol\x2C\x0d\n    promise_resolve_symbol\x2C owner_symbol\x0d\n  }\x2C\x0d\n  constants: {\x0d\n    kInit\x2C kBefore\x2C kAfter\x2C kDestroy\x2C kTotals\x2C kPromiseResolve\x0d\n  }\x2C\x0d\n  enableHooks\x2C\x0d\n  disableHooks\x2C\x0d\n  updatePromiseHookMode\x2C\x0d\n  clearDefaultTriggerAsyncId\x2C\x0d\n  clearAsyncIdStack\x2C\x0d\n  hasAsyncIdStack\x2C\x0d\n  executionAsyncResource\x2C\x0d\n  // Internal Embedder API\x0d\n  newAsyncId\x2C\x0d\n  getOrSetAsyncId\x2C\x0d\n  getDefaultTriggerAsyncId\x2C\x0d\n  defaultTriggerAsyncIdScope\x2C\x0d\n  enabledHooksExist\x2C\x0d\n  initHooksExist\x2C\x0d\n  afterHooksExist\x2C\x0d\n  destroyHooksExist\x2C\x0d\n  emitInit: emitInitScript\x2C\x0d\n  emitBefore: emitBeforeScript\x2C\x0d\n  emitAfter: emitAfterScript\x2C\x0d\n  emitDestroy: emitDestroyScript\x2C\x0d\n  pushAsyncContext\x2C\x0d\n  popAsyncContext\x2C\x0d\n  registerDestroyHook\x2C\x0d\n  useDomainTrampoline\x2C\x0d\n  nativeHooks: {\x0d\n    init: emitInitNative\x2C\x0d\n    before: emitBeforeNative\x2C\x0d\n    after: emitAfterNative\x2C\x0d\n    destroy: emitDestroyNative\x2C\x0d\n    promise_resolve: emitPromiseResolveNative\x0d\n  }\x2C\x0d\n  asyncWrap: {\x0d\n    Providers: async_wrap.Providers\x2C\x0d\n  }\x0d\n};\x0d\n
code-source-info,0x2969828d8de,13,15708,15764,C0O15716C7O15732C12O15756C17O15763,,
code-creation,LazyCompile,10,307889,0x2969828ed7e,19,handleProcessExit node:internal/modules/esm/handle_process_exit:6:27,0x14121bd9010,~
script-source,31,node:internal/modules/esm/handle_process_exit,'use strict';\x0d\n\x0d\n// Handle a Promise from running code that potentially does Top-Level Await.\x0d\n// In that case\x2C it makes sense to set the exit code to a specific non-zero\x0d\n// value if the main code never finishes running.\x0d\nfunction handleProcessExit() {\x0d\n  process.exitCode ??= 13;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  handleProcessExit\x2C\x0d\n};\x0d\n
code-source-info,0x2969828ed7e,31,249,284,C0O257C13O274C18O283,,
code-creation,LazyCompile,10,307965,0x2969828ef0e,46,beforeInspector node:internal/errors:738:18,0x147335e62a0,~
code-source-info,0x2969828ef0e,11,22873,23262,C0O22888C2O22905C4O22904C11O22973C15O22979C19O23091C21O23111C23O23110C27O23140C31O23103C41O23251C45O23257,,
code-creation,LazyCompile,10,308065,0x2969828f206,243,afterInspector node:internal/errors:752:17,0x147335e6310,~
code-source-info,0x2969828f206,11,23281,24706,C0O23324C5O23352C7O23842C10O23854C17O23863C22O23898C28O23898C33O23919C38O23920C43O23959C50O23977C55O24002C62O23977C70O24050C73O23959C79O24066C80O24073C86O24077C93O24090C101O24094C106O24114C108O24259C111O24259C115O24169C125O24227C130O24306C140O24341C145O24364C153O24365C161O24384C172O24417C177O24440C182O24441C194O24526C201O24544C207O24599C210O24615C215O24630C223O24599C232O24518C237O24650C240O24673C242O24694,,
code-creation,LazyCompile,10,308239,0x29698290236,30,lazyInternalUtilInspect node:internal/errors:184:33,0x147335e5758,~
code-source-info,0x29698290236,11,5436,5571,C0O5444C6O5477C12O5499C19O5497C25O5541C29O5568,,
code-creation,Eval,10,308561,0x296982909ae,5, node:internal/tty:1:1,0x29698290758,~
script-source,151,node:internal/tty,// MIT License\x0d\n\x0d\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)\x0d\n\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a copy\x0d\n// of this software and associated documentation files (the "Software")\x2C to deal\x0d\n// in the Software without restriction\x2C including without limitation the rights\x0d\n// to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C distribute\x2C sublicense\x2C and/or sell\x0d\n// copies of the Software\x2C and to permit persons to whom the Software is\x0d\n// furnished to do so\x2C subject to the following conditions:\x0d\n\x0d\n// The above copyright notice and this permission notice shall be included in\x0d\n// all copies or substantial portions of the Software.\x0d\n\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS OR\x0d\n// IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\x2C\x0d\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\x0d\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C DAMAGES OR OTHER\x0d\n// LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR OTHERWISE\x2C ARISING FROM\x2C\x0d\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\x0d\n// SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypeSome\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n  StringPrototypeToLowerCase\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { validateInteger } = require('internal/validators');\x0d\n\x0d\nlet OSRelease;\x0d\n\x0d\nconst COLORS_2 = 1;\x0d\nconst COLORS_16 = 4;\x0d\nconst COLORS_256 = 8;\x0d\nconst COLORS_16m = 24;\x0d\n\x0d\n// Some entries were taken from `dircolors`\x0d\n// (https://linux.die.net/man/1/dircolors). The corresponding terminals might\x0d\n// support more than 16 colors\x2C but this was not tested for.\x0d\n//\x0d\n// Copyright (C) 1996-2016 Free Software Foundation\x2C Inc. Copying and\x0d\n// distribution of this file\x2C with or without modification\x2C are permitted\x0d\n// provided the copyright notice and this notice are preserved.\x0d\nconst TERM_ENVS = {\x0d\n  'eterm': COLORS_16\x2C\x0d\n  'cons25': COLORS_16\x2C\x0d\n  'console': COLORS_16\x2C\x0d\n  'cygwin': COLORS_16\x2C\x0d\n  'dtterm': COLORS_16\x2C\x0d\n  'gnome': COLORS_16\x2C\x0d\n  'hurd': COLORS_16\x2C\x0d\n  'jfbterm': COLORS_16\x2C\x0d\n  'konsole': COLORS_16\x2C\x0d\n  'kterm': COLORS_16\x2C\x0d\n  'mlterm': COLORS_16\x2C\x0d\n  'mosh': COLORS_16m\x2C\x0d\n  'putty': COLORS_16\x2C\x0d\n  'st': COLORS_16\x2C\x0d\n  // https://github.com/da-x/rxvt-unicode/tree/v9.22-with-24bit-color\x0d\n  'rxvt-unicode-24bit': COLORS_16m\x2C\x0d\n  // https://gist.github.com/XVilka/8346728#gistcomment-2823421\x0d\n  'terminator': COLORS_16m\x0d\n};\x0d\n\x0d\nconst TERM_ENVS_REG_EXP = [\x0d\n  /ansi/\x2C\x0d\n  /color/\x2C\x0d\n  /linux/\x2C\x0d\n  /^con[0-9]*x[0-9]/\x2C\x0d\n  /^rxvt/\x2C\x0d\n  /^screen/\x2C\x0d\n  /^xterm/\x2C\x0d\n  /^vt100/\x2C\x0d\n];\x0d\n\x0d\nlet warned = false;\x0d\nfunction warnOnDeactivatedColors(env) {\x0d\n  if (warned)\x0d\n    return;\x0d\n  let name = '';\x0d\n  if (env.NODE_DISABLE_COLORS !== undefined)\x0d\n    name = 'NODE_DISABLE_COLORS';\x0d\n  if (env.NO_COLOR !== undefined) {\x0d\n    if (name !== '') {\x0d\n      name += "' and '";\x0d\n    }\x0d\n    name += 'NO_COLOR';\x0d\n  }\x0d\n\x0d\n  if (name !== '') {\x0d\n    process.emitWarning(\x0d\n      `The '${name}' env is ignored due to the 'FORCE_COLOR' env being set.`\x2C\x0d\n      'Warning'\x0d\n    );\x0d\n    warned = true;\x0d\n  }\x0d\n}\x0d\n\x0d\n// The `getColorDepth` API got inspired by multiple sources such as\x0d\n// https://github.com/chalk/supports-color\x2C\x0d\n// https://github.com/isaacs/color-support.\x0d\nfunction getColorDepth(env = process.env) {\x0d\n  // Use level 0-3 to support the same levels as `chalk` does. This is done for\x0d\n  // consistency throughout the ecosystem.\x0d\n  if (env.FORCE_COLOR !== undefined) {\x0d\n    switch (env.FORCE_COLOR) {\x0d\n      case '':\x0d\n      case '1':\x0d\n      case 'true':\x0d\n        warnOnDeactivatedColors(env);\x0d\n        return COLORS_16;\x0d\n      case '2':\x0d\n        warnOnDeactivatedColors(env);\x0d\n        return COLORS_256;\x0d\n      case '3':\x0d\n        warnOnDeactivatedColors(env);\x0d\n        return COLORS_16m;\x0d\n      default:\x0d\n        return COLORS_2;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (env.NODE_DISABLE_COLORS !== undefined ||\x0d\n      // See https://no-color.org/\x0d\n      env.NO_COLOR !== undefined ||\x0d\n      // The "dumb" special terminal\x2C as defined by terminfo\x2C doesn't support\x0d\n      // ANSI color control codes.\x0d\n      // See https://invisible-island.net/ncurses/terminfo.ti.html#toc-_Specials\x0d\n      env.TERM === 'dumb') {\x0d\n    return COLORS_2;\x0d\n  }\x0d\n\x0d\n  if (process.platform === 'win32') {\x0d\n    // Lazy load for startup performance.\x0d\n    if (OSRelease === undefined) {\x0d\n      const { release } = require('os');\x0d\n      OSRelease = StringPrototypeSplit(release()\x2C '.');\x0d\n    }\x0d\n    // Windows 10 build 10586 is the first Windows release that supports 256\x0d\n    // colors. Windows 10 build 14931 is the first release that supports\x0d\n    // 16m/TrueColor.\x0d\n    if (+OSRelease[0] >= 10) {\x0d\n      const build = +OSRelease[2];\x0d\n      if (build >= 14931)\x0d\n        return COLORS_16m;\x0d\n      if (build >= 10586)\x0d\n        return COLORS_256;\x0d\n    }\x0d\n\x0d\n    return COLORS_16;\x0d\n  }\x0d\n\x0d\n  if (env.TMUX) {\x0d\n    return COLORS_256;\x0d\n  }\x0d\n\x0d\n  if (env.CI) {\x0d\n    if ([\x0d\n      'APPVEYOR'\x2C\x0d\n      'BUILDKITE'\x2C\x0d\n      'CIRCLECI'\x2C\x0d\n      'DRONE'\x2C\x0d\n      'GITHUB_ACTIONS'\x2C\x0d\n      'GITLAB_CI'\x2C\x0d\n      'TRAVIS'\x2C\x0d\n    ].some((sign) => sign in env) || env.CI_NAME === 'codeship') {\x0d\n      return COLORS_256;\x0d\n    }\x0d\n    return COLORS_2;\x0d\n  }\x0d\n\x0d\n  if ('TEAMCITY_VERSION' in env) {\x0d\n    return RegExpPrototypeTest(/^(9\\.(0*[1-9]\\d*)\\.|\\d{2\x2C}\\.)/\x2C env.TEAMCITY_VERSION) ?\x0d\n      COLORS_16 : COLORS_2;\x0d\n  }\x0d\n\x0d\n  switch (env.TERM_PROGRAM) {\x0d\n    case 'iTerm.app':\x0d\n      if (!env.TERM_PROGRAM_VERSION ||\x0d\n        RegExpPrototypeTest(/^[0-2]\\./\x2C env.TERM_PROGRAM_VERSION)\x0d\n      ) {\x0d\n        return COLORS_256;\x0d\n      }\x0d\n      return COLORS_16m;\x0d\n    case 'HyperTerm':\x0d\n    case 'MacTerm':\x0d\n      return COLORS_16m;\x0d\n    case 'Apple_Terminal':\x0d\n      return COLORS_256;\x0d\n  }\x0d\n\x0d\n  if (env.COLORTERM === 'truecolor' || env.COLORTERM === '24bit') {\x0d\n    return COLORS_16m;\x0d\n  }\x0d\n\x0d\n  if (env.TERM) {\x0d\n    if (RegExpPrototypeTest(/^xterm-256/\x2C env.TERM)) {\x0d\n      return COLORS_256;\x0d\n    }\x0d\n\x0d\n    const termEnv = StringPrototypeToLowerCase(env.TERM);\x0d\n\x0d\n    if (TERM_ENVS[termEnv]) {\x0d\n      return TERM_ENVS[termEnv];\x0d\n    }\x0d\n    if (ArrayPrototypeSome(TERM_ENVS_REG_EXP\x2C\x0d\n                           (term) => RegExpPrototypeTest(term\x2C termEnv))) {\x0d\n      return COLORS_16;\x0d\n    }\x0d\n  }\x0d\n  // Move 16 color COLORTERM below 16m and 256\x0d\n  if (env.COLORTERM) {\x0d\n    return COLORS_16;\x0d\n  }\x0d\n  return COLORS_2;\x0d\n}\x0d\n\x0d\nfunction hasColors(count\x2C env) {\x0d\n  if (env === undefined &&\x0d\n      (count === undefined || (typeof count === 'object' && count !== null))) {\x0d\n    env = count;\x0d\n    count = 16;\x0d\n  } else {\x0d\n    validateInteger(count\x2C 'count'\x2C 2);\x0d\n  }\x0d\n\x0d\n  return count <= 2 ** getColorDepth(env);\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  getColorDepth\x2C\x0d\n  hasColors\x0d\n};\x0d\n
code-source-info,0x296982909ae,151,0,6683,C0O0C4O6683,,
code-creation,Function,10,308915,0x29698290e0e,358, node:internal/tty:1:1,0x29698290928,~
code-source-info,0x29698290e0e,151,0,6683,C0O0C69O1211C75O1234C81O1258C87O1283C93O1360C99O1360C104O1340C110O1399C111O1399C113O1430C115O1430C117O1452C119O1452C121O1475C123O1475C125O1498C127O1498C129O1924C136O1938C142O1962C148O1987C154O2011C160O2035C166O2058C172O2080C178O2105C184O2130C190O2153C196O2177C202O2199C208O2223C214O2243C220O2350C226O2444C232O1924C234O2488C328O2488C330O2620C331O2620C333O6628C340O6650C346O6668C352O6643C357O6682,,
code-creation,LazyCompile,10,309118,0x296982918e6,63,hasColors node:internal/tty:222:19,0x29698290a80,~
code-source-info,0x296982918e6,151,6359,6624,C0O6377C18O6488C21O6506C27O6535C41O6535C46O6581C52O6602C56O6599C59O6594C62O6621,,
code-creation,LazyCompile,10,309270,0x2969829275e,762,getColorDepth node:internal/tty:106:23,0x29698290a30,~
code-source-info,0x2969829275e,151,3285,6337,C0O3285C17O3300C27O3435C30O3443C36O3477C39O3489C81O3566C89O3566C93O3605C99O3622C100O3649C108O3649C112O3688C118O3706C119O3733C127O3733C131O3772C137O3790C138O3816C144O3832C145O3850C148O3858C157O3942C166O4176C173O4181C178O4200C184O4216C185O4227C190O4239C197O4248C202O4311C210O4369C218O4369C223O4357C228O4391C235O4424C242O4403C252O4401C260O4628C268O4642C271O4632C276O4646C281O4676C290O4686C293O4676C296O4698C300O4708C305O4727C311O4745C312O4753C316O4763C321O4782C327O4800C328O4815C334O4832C335O4843C338O4851C344O4864C350O4882C351O4893C354O4901C360O4912C365O5061C375O5061C385O5096C392O5104C397O5129C403O5147C404O5160C410O5176C411O5187C416O5210C421O5225C436O5289C441O5232C452O5316C460O5328C462O5337C463O5348C466O5360C501O5406C504O5415C514O5448C525O5484C530O5448C537O5526C543O5544C544O5561C550O5579C551O5631C557O5649C558O5685C564O5703C565O5714C568O5722C575O5732C583O5755C590O5765C595O5785C601O5803C602O5814C605O5822C618O5835C635O5877C640O5839C647O5893C653O5911C654O5942C666O5973C671O5942C675O5942C677O5987C686O6000C691O6020C700O6036C703O6046C704O6059C715O6082C723O6063C730O6185C736O6202C739O6266C742O6274C748O6292C754O6309C755O6318C761O6334,,
code-creation,Eval,10,309699,0x296982934fe,5, node:os:1:1,0x296982931a8,~
script-source,152,node:os,// Copyright Joyent\x2C Inc. and other Node contributors.\x0d\n//\x0d\n// Permission is hereby granted\x2C free of charge\x2C to any person obtaining a\x0d\n// copy of this software and associated documentation files (the\x0d\n// "Software")\x2C to deal in the Software without restriction\x2C including\x0d\n// without limitation the rights to use\x2C copy\x2C modify\x2C merge\x2C publish\x2C\x0d\n// distribute\x2C sublicense\x2C and/or sell copies of the Software\x2C and to permit\x0d\n// persons to whom the Software is furnished to do so\x2C subject to the\x0d\n// following conditions:\x0d\n//\x0d\n// The above copyright notice and this permission notice shall be included\x0d\n// in all copies or substantial portions of the Software.\x0d\n//\x0d\n// THE SOFTWARE IS PROVIDED "AS IS"\x2C WITHOUT WARRANTY OF ANY KIND\x2C EXPRESS\x0d\n// OR IMPLIED\x2C INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\x0d\n// MERCHANTABILITY\x2C FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\x0d\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM\x2C\x0d\n// DAMAGES OR OTHER LIABILITY\x2C WHETHER IN AN ACTION OF CONTRACT\x2C TORT OR\x0d\n// OTHERWISE\x2C ARISING FROM\x2C OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\x0d\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\x0d\n\x0d\n'use strict';\x0d\n\x0d\nconst {\x0d\n  ArrayPrototypePush\x2C\x0d\n  Float64Array\x2C\x0d\n  NumberParseInt\x2C\x0d\n  ObjectDefineProperties\x2C\x0d\n  StringPrototypeEndsWith\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n  SymbolToPrimitive\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst { safeGetenv } = internalBinding('credentials');\x0d\nconst constants = internalBinding('constants').os;\x0d\nconst isWindows = process.platform === 'win32';\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_SYSTEM_ERROR\x0d\n  }\x2C\x0d\n  hideStackFrames\x0d\n} = require('internal/errors');\x0d\nconst { validateInt32 } = require('internal/validators');\x0d\n\x0d\nconst {\x0d\n  getCPUs\x2C\x0d\n  getFreeMem\x2C\x0d\n  getHomeDirectory: _getHomeDirectory\x2C\x0d\n  getHostname: _getHostname\x2C\x0d\n  getInterfaceAddresses: _getInterfaceAddresses\x2C\x0d\n  getLoadAvg\x2C\x0d\n  getPriority: _getPriority\x2C\x0d\n  getOSInformation: _getOSInformation\x2C\x0d\n  getTotalMem\x2C\x0d\n  getUserInfo\x2C\x0d\n  getUptime\x2C\x0d\n  isBigEndian\x2C\x0d\n  setPriority: _setPriority\x0d\n} = internalBinding('os');\x0d\n\x0d\nfunction getCheckedFunction(fn) {\x0d\n  return hideStackFrames(function checkError(...args) {\x0d\n    const ctx = {};\x0d\n    const ret = fn(...args\x2C ctx);\x0d\n    if (ret === undefined) {\x0d\n      throw new ERR_SYSTEM_ERROR(ctx);\x0d\n    }\x0d\n    return ret;\x0d\n  });\x0d\n}\x0d\n\x0d\nconst {\x0d\n  0: type\x2C\x0d\n  1: version\x2C\x0d\n  2: release\x2C\x0d\n} = _getOSInformation();\x0d\n\x0d\nconst getHomeDirectory = getCheckedFunction(_getHomeDirectory);\x0d\nconst getHostname = getCheckedFunction(_getHostname);\x0d\nconst getInterfaceAddresses = getCheckedFunction(_getInterfaceAddresses);\x0d\n/**\x0d\n * @returns {string}\x0d\n */\x0d\nconst getOSRelease = () => release;\x0d\n/**\x0d\n * @returns {string}\x0d\n */\x0d\nconst getOSType = () => type;\x0d\n/**\x0d\n * @returns {string}\x0d\n */\x0d\nconst getOSVersion = () => version;\x0d\n\x0d\ngetFreeMem[SymbolToPrimitive] = () => getFreeMem();\x0d\ngetHostname[SymbolToPrimitive] = () => getHostname();\x0d\ngetOSVersion[SymbolToPrimitive] = () => getOSVersion();\x0d\ngetOSType[SymbolToPrimitive] = () => getOSType();\x0d\ngetOSRelease[SymbolToPrimitive] = () => getOSRelease();\x0d\ngetHomeDirectory[SymbolToPrimitive] = () => getHomeDirectory();\x0d\ngetTotalMem[SymbolToPrimitive] = () => getTotalMem();\x0d\ngetUptime[SymbolToPrimitive] = () => getUptime();\x0d\n\x0d\nconst kEndianness = isBigEndian ? 'BE' : 'LE';\x0d\n\x0d\nconst avgValues = new Float64Array(3);\x0d\n\x0d\n/**\x0d\n * @returns {[number\x2C number\x2C number]}\x0d\n */\x0d\nfunction loadavg() {\x0d\n  getLoadAvg(avgValues);\x0d\n  return [avgValues[0]\x2C avgValues[1]\x2C avgValues[2]];\x0d\n}\x0d\n\x0d\n/**\x0d\n * Returns an array of objects containing information about each\x0d\n * logical CPU core.\x0d\n *\x0d\n * @returns {Array<{\x0d\n *  model: string\x0d\n *  speed: number\x0d\n *  times: {\x0d\n *    user: number\x0d\n *    nice: number\x0d\n *    sys: number\x0d\n *    idle: number\x0d\n *    irq: number\x0d\n *  }\x0d\n * }>}\x0d\n */\x0d\nfunction cpus() {\x0d\n  // [] is a bugfix for a regression introduced in 51cea61\x0d\n  const data = getCPUs() || [];\x0d\n  const result = [];\x0d\n  let i = 0;\x0d\n  while (i < data.length) {\x0d\n    ArrayPrototypePush(result\x2C {\x0d\n      model: data[i++]\x2C\x0d\n      speed: data[i++]\x2C\x0d\n      times: {\x0d\n        user: data[i++]\x2C\x0d\n        nice: data[i++]\x2C\x0d\n        sys: data[i++]\x2C\x0d\n        idle: data[i++]\x2C\x0d\n        irq: data[i++]\x0d\n      }\x0d\n    });\x0d\n  }\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @returns {string}\x0d\n */\x0d\nfunction arch() {\x0d\n  return process.arch;\x0d\n}\x0d\narch[SymbolToPrimitive] = () => process.arch;\x0d\n\x0d\n/**\x0d\n * @returns {string}\x0d\n */\x0d\nfunction platform() {\x0d\n  return process.platform;\x0d\n}\x0d\nplatform[SymbolToPrimitive] = () => process.platform;\x0d\n\x0d\n/**\x0d\n * @returns {string}\x0d\n */\x0d\nfunction tmpdir() {\x0d\n  var path;\x0d\n  if (isWindows) {\x0d\n    path = process.env.TEMP ||\x0d\n           process.env.TMP ||\x0d\n           (process.env.SystemRoot || process.env.windir) + '\\\\temp';\x0d\n    if (path.length > 1 && StringPrototypeEndsWith(path\x2C '\\\\') &&\x0d\n        !StringPrototypeEndsWith(path\x2C ':\\\\'))\x0d\n      path = StringPrototypeSlice(path\x2C 0\x2C -1);\x0d\n  } else {\x0d\n    path = safeGetenv('TMPDIR') ||\x0d\n           safeGetenv('TMP') ||\x0d\n           safeGetenv('TEMP') ||\x0d\n           '/tmp';\x0d\n    if (path.length > 1 && StringPrototypeEndsWith(path\x2C '/'))\x0d\n      path = StringPrototypeSlice(path\x2C 0\x2C -1);\x0d\n  }\x0d\n\x0d\n  return path;\x0d\n}\x0d\ntmpdir[SymbolToPrimitive] = () => tmpdir();\x0d\n\x0d\n/**\x0d\n * @returns {'BE' | 'LE'}\x0d\n */\x0d\nfunction endianness() {\x0d\n  return kEndianness;\x0d\n}\x0d\nendianness[SymbolToPrimitive] = () => kEndianness;\x0d\n\x0d\n// Returns the number of ones in the binary representation of the decimal\x0d\n// number.\x0d\nfunction countBinaryOnes(n) {\x0d\n  // Count the number of bits set in parallel\x2C which is faster than looping\x0d\n  n = n - ((n >>> 1) & 0x55555555);\x0d\n  n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);\x0d\n  return ((n + (n >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;\x0d\n}\x0d\n\x0d\nfunction getCIDR(address\x2C netmask\x2C family) {\x0d\n  let ones = 0;\x0d\n  let split = '.';\x0d\n  let range = 10;\x0d\n  let groupLength = 8;\x0d\n  let hasZeros = false;\x0d\n\x0d\n  if (family === 'IPv6') {\x0d\n    split = ':';\x0d\n    range = 16;\x0d\n    groupLength = 16;\x0d\n  }\x0d\n\x0d\n  const parts = StringPrototypeSplit(netmask\x2C split);\x0d\n  for (var i = 0; i < parts.length; i++) {\x0d\n    if (parts[i] !== '') {\x0d\n      const binary = NumberParseInt(parts[i]\x2C range);\x0d\n      const tmp = countBinaryOnes(binary);\x0d\n      ones += tmp;\x0d\n      if (hasZeros) {\x0d\n        if (tmp !== 0) {\x0d\n          return null;\x0d\n        }\x0d\n      } else if (tmp !== groupLength) {\x0d\n        if ((binary & 1) !== 0) {\x0d\n          return null;\x0d\n        }\x0d\n        hasZeros = true;\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return `${address}/${ones}`;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @returns {Record<string\x2C Array<{\x0d\n *  address: string\x0d\n *  netmask: string\x0d\n *  family: 'IPv4' | 'IPv6'\x0d\n *  mac: string\x0d\n *  internal: boolean\x0d\n *  scopeid: number\x0d\n *  cidr: string | null\x0d\n * }>>}\x0d\n */\x0d\nfunction networkInterfaces() {\x0d\n  const data = getInterfaceAddresses();\x0d\n  const result = {};\x0d\n\x0d\n  if (data === undefined)\x0d\n    return result;\x0d\n  for (var i = 0; i < data.length; i += 7) {\x0d\n    const name = data[i];\x0d\n    const entry = {\x0d\n      address: data[i + 1]\x2C\x0d\n      netmask: data[i + 2]\x2C\x0d\n      family: data[i + 3]\x2C\x0d\n      mac: data[i + 4]\x2C\x0d\n      internal: data[i + 5]\x2C\x0d\n      cidr: getCIDR(data[i + 1]\x2C data[i + 2]\x2C data[i + 3])\x0d\n    };\x0d\n    const scopeid = data[i + 6];\x0d\n    if (scopeid !== -1)\x0d\n      entry.scopeid = scopeid;\x0d\n\x0d\n    const existing = result[name];\x0d\n    if (existing !== undefined)\x0d\n      ArrayPrototypePush(existing\x2C entry);\x0d\n    else\x0d\n      result[name] = [entry];\x0d\n  }\x0d\n\x0d\n  return result;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {number} [pid=0]\x0d\n * @param {number} priority\x0d\n * @returns {void}\x0d\n */\x0d\nfunction setPriority(pid\x2C priority) {\x0d\n  if (priority === undefined) {\x0d\n    priority = pid;\x0d\n    pid = 0;\x0d\n  }\x0d\n\x0d\n  validateInt32(pid\x2C 'pid');\x0d\n  validateInt32(priority\x2C 'priority'\x2C -20\x2C 19);\x0d\n\x0d\n  const ctx = {};\x0d\n\x0d\n  if (_setPriority(pid\x2C priority\x2C ctx) !== 0)\x0d\n    throw new ERR_SYSTEM_ERROR(ctx);\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {number} [pid=0]\x0d\n * @returns {number}\x0d\n */\x0d\nfunction getPriority(pid) {\x0d\n  if (pid === undefined)\x0d\n    pid = 0;\x0d\n  else\x0d\n    validateInt32(pid\x2C 'pid');\x0d\n\x0d\n  const ctx = {};\x0d\n  const priority = _getPriority(pid\x2C ctx);\x0d\n\x0d\n  if (priority === undefined)\x0d\n    throw new ERR_SYSTEM_ERROR(ctx);\x0d\n\x0d\n  return priority;\x0d\n}\x0d\n\x0d\n/**\x0d\n * @param {{ encoding?: string }} [options=utf8] If `encoding` is set to\x0d\n * `'buffer'`\x2C the `username`\x2C `shell`\x2C and `homedir` values will\x0d\n * be `Buffer` instances.\x0d\n * @returns {{\x0d\n *   uid: number\x0d\n *   gid: number\x0d\n *   username: string\x0d\n *   homedir: string\x0d\n *   shell: string | null\x0d\n * }}\x0d\n */\x0d\nfunction userInfo(options) {\x0d\n  if (typeof options !== 'object')\x0d\n    options = null;\x0d\n\x0d\n  const ctx = {};\x0d\n  const user = getUserInfo(options\x2C ctx);\x0d\n\x0d\n  if (user === undefined)\x0d\n    throw new ERR_SYSTEM_ERROR(ctx);\x0d\n\x0d\n  return user;\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  arch\x2C\x0d\n  cpus\x2C\x0d\n  endianness\x2C\x0d\n  freemem: getFreeMem\x2C\x0d\n  getPriority\x2C\x0d\n  homedir: getHomeDirectory\x2C\x0d\n  hostname: getHostname\x2C\x0d\n  loadavg\x2C\x0d\n  networkInterfaces\x2C\x0d\n  platform\x2C\x0d\n  release: getOSRelease\x2C\x0d\n  setPriority\x2C\x0d\n  tmpdir\x2C\x0d\n  totalmem: getTotalMem\x2C\x0d\n  type: getOSType\x2C\x0d\n  userInfo\x2C\x0d\n  uptime: getUptime\x2C\x0d\n  version: getOSVersion\x0d\n};\x0d\n\x0d\nObjectDefineProperties(module.exports\x2C {\x0d\n  constants: {\x0d\n    configurable: false\x2C\x0d\n    enumerable: true\x2C\x0d\n    value: constants\x0d\n  }\x2C\x0d\n\x0d\n  EOL: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x2C\x0d\n    writable: false\x2C\x0d\n    value: isWindows ? '\\r\\n' : '\\n'\x0d\n  }\x2C\x0d\n\x0d\n  devNull: {\x0d\n    configurable: true\x2C\x0d\n    enumerable: true\x2C\x0d\n    writable: false\x2C\x0d\n    value: isWindows ? '\\\\\\\\.\\\\nul' : '/dev/null'\x0d\n  }\x0d\n});\x0d\n
code-source-info,0x296982934fe,152,0,9455,C0O0C4O9455,,
code-creation,Function,10,310208,0x296982946b6,823, node:os:1:1,0x29698293478,~
code-source-info,0x296982946b6,152,0,9455,C0O0C167O1183C173O1206C178O1223C184O1242C189O1269C195O1297C201O1322C207O1347C212O1410C216O1410C222O1395C228O1461C232O1461C238O1489C243O1513C247O1521C255O1530C258O1513C260O1618C264O1618C270O1618C276O1571C282O1597C288O1673C292O1673C298O1655C304O2044C308O2044C314O1719C320O1731C326O1764C331O1799C336O1839C341O1866C347O1894C353O1929C358O1951C364O1967C370O1983C376O1997C381O2026C387O2379C392O2338C400O2350C409O2365C418O2428C422O2428C424O2488C428O2488C430O2553C434O2553C436O2651C440O2651C442O2717C446O2717C448O2783C452O2783C454O2801C458O2812C462O2831C466O2854C470O2866C474O2885C478O2909C482O2922C486O2941C490O2966C494O2976C498O2995C502O3017C506O3030C510O3049C514O3074C518O3091C522O3110C526O3139C530O3151C534O3170C538O3194C542O3204C546O3223C550O3267C560O3267C562O3315C568O3315C573O3315C575O4318C579O4337C583O4457C587O4476C591O5163C595O5170C599O5189C603O5309C607O5328C611O8686C619O8708C625O8717C631O8726C637O8750C643O8765C649O8790C655O8821C661O8837C667O8849C673O8871C679O8893C685O8910C691O8926C697O8947C703O8969C709O8983C715O9004C721O9027C727O8701C731O9077C743O9102C751O9165C761O9191C772O9275C790O9321C798O9405C816O9047C822O9454,,
code-creation,LazyCompile,10,310491,0x29698295cb6,26,getCheckedFunction node:os:63:28,0x29698293530,~
code-source-info,0x29698295cb6,152,2097,2320,C0O2097C9O2107C21O2114C25O2317,,
code-creation,LazyCompile,10,310545,0x29698296a7e,43,hideStackFrames node:internal/errors:382:25,0x147335e5b98,~
code-source-info,0x29698296a7e,11,11036,11266,C0O11164C5O11188C9O11183C13O11197C21O11218C28O11239C35O11197C40O11253C42O11263,,
code-creation,LazyCompile,10,310658,0x29698296e76,5,getOSRelease node:os:86:22,0x29698293968,~
code-source-info,0x29698296e76,152,2651,2664,C0O2657C4O2664,,
code-creation,LazyCompile,10,310845,0x29698297196,5,get node:internal/util/inspect:350:6,0x25ca271eb50,~
script-source,20,node:internal/util/inspect,'use strict';\x0d\n\x0d\nconst {\x0d\n  Array\x2C\x0d\n  ArrayIsArray\x2C\x0d\n  ArrayPrototypeFilter\x2C\x0d\n  ArrayPrototypeForEach\x2C\x0d\n  ArrayPrototypePop\x2C\x0d\n  ArrayPrototypePush\x2C\x0d\n  ArrayPrototypePushApply\x2C\x0d\n  ArrayPrototypeSort\x2C\x0d\n  ArrayPrototypeUnshift\x2C\x0d\n  BigIntPrototypeValueOf\x2C\x0d\n  BooleanPrototypeValueOf\x2C\x0d\n  DatePrototypeGetTime\x2C\x0d\n  DatePrototypeToISOString\x2C\x0d\n  DatePrototypeToString\x2C\x0d\n  ErrorPrototypeToString\x2C\x0d\n  FunctionPrototypeCall\x2C\x0d\n  FunctionPrototypeToString\x2C\x0d\n  JSONStringify\x2C\x0d\n  MapPrototypeGetSize\x2C\x0d\n  MapPrototypeEntries\x2C\x0d\n  MathFloor\x2C\x0d\n  MathMax\x2C\x0d\n  MathMin\x2C\x0d\n  MathRound\x2C\x0d\n  MathSqrt\x2C\x0d\n  MathTrunc\x2C\x0d\n  Number\x2C\x0d\n  NumberIsFinite\x2C\x0d\n  NumberIsNaN\x2C\x0d\n  NumberParseFloat\x2C\x0d\n  NumberParseInt\x2C\x0d\n  NumberPrototypeValueOf\x2C\x0d\n  Object\x2C\x0d\n  ObjectAssign\x2C\x0d\n  ObjectCreate\x2C\x0d\n  ObjectDefineProperty\x2C\x0d\n  ObjectGetOwnPropertyDescriptor\x2C\x0d\n  ObjectGetOwnPropertyNames\x2C\x0d\n  ObjectGetOwnPropertySymbols\x2C\x0d\n  ObjectGetPrototypeOf\x2C\x0d\n  ObjectIs\x2C\x0d\n  ObjectKeys\x2C\x0d\n  ObjectPrototypeHasOwnProperty\x2C\x0d\n  ObjectPrototypePropertyIsEnumerable\x2C\x0d\n  ObjectSeal\x2C\x0d\n  ObjectSetPrototypeOf\x2C\x0d\n  ReflectOwnKeys\x2C\x0d\n  RegExp\x2C\x0d\n  RegExpPrototypeTest\x2C\x0d\n  RegExpPrototypeToString\x2C\x0d\n  SafeStringIterator\x2C\x0d\n  SafeMap\x2C\x0d\n  SafeSet\x2C\x0d\n  SetPrototypeGetSize\x2C\x0d\n  SetPrototypeValues\x2C\x0d\n  String\x2C\x0d\n  StringPrototypeCharCodeAt\x2C\x0d\n  StringPrototypeCodePointAt\x2C\x0d\n  StringPrototypeIncludes\x2C\x0d\n  StringPrototypeNormalize\x2C\x0d\n  StringPrototypePadEnd\x2C\x0d\n  StringPrototypePadStart\x2C\x0d\n  StringPrototypeRepeat\x2C\x0d\n  StringPrototypeReplace\x2C\x0d\n  StringPrototypeSlice\x2C\x0d\n  StringPrototypeSplit\x2C\x0d\n  StringPrototypeToLowerCase\x2C\x0d\n  StringPrototypeTrim\x2C\x0d\n  StringPrototypeValueOf\x2C\x0d\n  SymbolPrototypeToString\x2C\x0d\n  SymbolPrototypeValueOf\x2C\x0d\n  SymbolIterator\x2C\x0d\n  SymbolToStringTag\x2C\x0d\n  TypedArrayPrototypeGetLength\x2C\x0d\n  TypedArrayPrototypeGetSymbolToStringTag\x2C\x0d\n  Uint8Array\x2C\x0d\n  globalThis\x2C\x0d\n  uncurryThis\x2C\x0d\n} = primordials;\x0d\n\x0d\nconst {\x0d\n  getOwnNonIndexProperties\x2C\x0d\n  getPromiseDetails\x2C\x0d\n  getProxyDetails\x2C\x0d\n  kPending\x2C\x0d\n  kRejected\x2C\x0d\n  previewEntries\x2C\x0d\n  getConstructorName: internalGetConstructorName\x2C\x0d\n  getExternalValue\x2C\x0d\n  propertyFilter: {\x0d\n    ALL_PROPERTIES\x2C\x0d\n    ONLY_ENUMERABLE\x0d\n  }\x0d\n} = internalBinding('util');\x0d\n\x0d\nconst {\x0d\n  customInspectSymbol\x2C\x0d\n  isError\x2C\x0d\n  join\x2C\x0d\n  removeColors\x0d\n} = require('internal/util');\x0d\n\x0d\nconst {\x0d\n  codes: {\x0d\n    ERR_INVALID_ARG_TYPE\x0d\n  }\x2C\x0d\n  isStackOverflowError\x0d\n} = require('internal/errors');\x0d\n\x0d\nconst {\x0d\n  isAsyncFunction\x2C\x0d\n  isGeneratorFunction\x2C\x0d\n  isAnyArrayBuffer\x2C\x0d\n  isArrayBuffer\x2C\x0d\n  isArgumentsObject\x2C\x0d\n  isBoxedPrimitive\x2C\x0d\n  isDataView\x2C\x0d\n  isExternal\x2C\x0d\n  isMap\x2C\x0d\n  isMapIterator\x2C\x0d\n  isModuleNamespaceObject\x2C\x0d\n  isNativeError\x2C\x0d\n  isPromise\x2C\x0d\n  isSet\x2C\x0d\n  isSetIterator\x2C\x0d\n  isWeakMap\x2C\x0d\n  isWeakSet\x2C\x0d\n  isRegExp\x2C\x0d\n  isDate\x2C\x0d\n  isTypedArray\x2C\x0d\n  isStringObject\x2C\x0d\n  isNumberObject\x2C\x0d\n  isBooleanObject\x2C\x0d\n  isBigIntObject\x2C\x0d\n} = require('internal/util/types');\x0d\n\x0d\nconst assert = require('internal/assert');\x0d\n\x0d\nconst { NativeModule } = require('internal/bootstrap/loaders');\x0d\nconst {\x0d\n  validateObject\x2C\x0d\n  validateString\x2C\x0d\n} = require('internal/validators');\x0d\n\x0d\nlet hexSlice;\x0d\n\x0d\nconst builtInObjects = new SafeSet(\x0d\n  ArrayPrototypeFilter(\x0d\n    ObjectGetOwnPropertyNames(globalThis)\x2C\x0d\n    (e) => RegExpPrototypeTest(/^[A-Z][a-zA-Z0-9]+$/\x2C e)\x0d\n  )\x0d\n);\x0d\n\x0d\n// https://tc39.es/ecma262/#sec-IsHTMLDDA-internal-slot\x0d\nconst isUndetectableObject = (v) => typeof v === 'undefined' && v !== undefined;\x0d\n\x0d\n// These options must stay in sync with `getUserOptions`. So if any option will\x0d\n// be added or removed\x2C `getUserOptions` must also be updated accordingly.\x0d\nconst inspectDefaultOptions = ObjectSeal({\x0d\n  showHidden: false\x2C\x0d\n  depth: 2\x2C\x0d\n  colors: false\x2C\x0d\n  customInspect: true\x2C\x0d\n  showProxy: false\x2C\x0d\n  maxArrayLength: 100\x2C\x0d\n  maxStringLength: 10000\x2C\x0d\n  breakLength: 80\x2C\x0d\n  compact: 3\x2C\x0d\n  sorted: false\x2C\x0d\n  getters: false\x2C\x0d\n  numericSeparator: false\x2C\x0d\n});\x0d\n\x0d\nconst kObjectType = 0;\x0d\nconst kArrayType = 1;\x0d\nconst kArrayExtrasType = 2;\x0d\n\x0d\n/* eslint-disable no-control-regex */\x0d\nconst strEscapeSequencesRegExp = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\x0d\nconst strEscapeSequencesReplacer = /[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\x0d\nconst strEscapeSequencesRegExpSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/;\x0d\nconst strEscapeSequencesReplacerSingle = /[\\x00-\\x1f\\x5c\\x7f-\\x9f]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|(?<![\\ud800-\\udbff])[\\udc00-\\udfff]/g;\x0d\n/* eslint-enable no-control-regex */\x0d\n\x0d\nconst keyStrRegExp = /^[a-zA-Z_][a-zA-Z_0-9]*$/;\x0d\nconst numberRegExp = /^(0|[1-9][0-9]*)$/;\x0d\n\x0d\nconst coreModuleRegExp = /^ {4}at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/;\x0d\nconst nodeModulesRegExp = /[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g;\x0d\n\x0d\nconst classRegExp = /^(\\s+[^(]*?)\\s*{/;\x0d\n// eslint-disable-next-line node-core/no-unescaped-regexp-dot\x0d\nconst stripCommentsRegExp = /(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g;\x0d\n\x0d\nconst kMinLineLength = 16;\x0d\n\x0d\n// Constants to map the iterator state.\x0d\nconst kWeak = 0;\x0d\nconst kIterator = 1;\x0d\nconst kMapEntries = 2;\x0d\n\x0d\n// Escaped control characters (plus the single quote and the backslash). Use\x0d\n// empty strings to fill up unused entries.\x0d\nconst meta = [\x0d\n  '\\\\x00'\x2C '\\\\x01'\x2C '\\\\x02'\x2C '\\\\x03'\x2C '\\\\x04'\x2C '\\\\x05'\x2C '\\\\x06'\x2C '\\\\x07'\x2C // x07\x0d\n  '\\\\b'\x2C '\\\\t'\x2C '\\\\n'\x2C '\\\\x0B'\x2C '\\\\f'\x2C '\\\\r'\x2C '\\\\x0E'\x2C '\\\\x0F'\x2C           // x0F\x0d\n  '\\\\x10'\x2C '\\\\x11'\x2C '\\\\x12'\x2C '\\\\x13'\x2C '\\\\x14'\x2C '\\\\x15'\x2C '\\\\x16'\x2C '\\\\x17'\x2C // x17\x0d\n  '\\\\x18'\x2C '\\\\x19'\x2C '\\\\x1A'\x2C '\\\\x1B'\x2C '\\\\x1C'\x2C '\\\\x1D'\x2C '\\\\x1E'\x2C '\\\\x1F'\x2C // x1F\x0d\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C "\\\\'"\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C      // x2F\x0d\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x3F\x0d\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x4F\x0d\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\\\\\'\x2C ''\x2C ''\x2C ''\x2C     // x5F\x0d\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C         // x6F\x0d\n  ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C ''\x2C '\\\\x7F'\x2C    // x7F\x0d\n  '\\\\x80'\x2C '\\\\x81'\x2C '\\\\x82'\x2C '\\\\x83'\x2C '\\\\x84'\x2C '\\\\x85'\x2C '\\\\x86'\x2C '\\\\x87'\x2C // x87\x0d\n  '\\\\x88'\x2C '\\\\x89'\x2C '\\\\x8A'\x2C '\\\\x8B'\x2C '\\\\x8C'\x2C '\\\\x8D'\x2C '\\\\x8E'\x2C '\\\\x8F'\x2C // x8F\x0d\n  '\\\\x90'\x2C '\\\\x91'\x2C '\\\\x92'\x2C '\\\\x93'\x2C '\\\\x94'\x2C '\\\\x95'\x2C '\\\\x96'\x2C '\\\\x97'\x2C // x97\x0d\n  '\\\\x98'\x2C '\\\\x99'\x2C '\\\\x9A'\x2C '\\\\x9B'\x2C '\\\\x9C'\x2C '\\\\x9D'\x2C '\\\\x9E'\x2C '\\\\x9F'\x2C // x9F\x0d\n];\x0d\n\x0d\n// Regex used for ansi escape code splitting\x0d\n// Adopted from https://github.com/chalk/ansi-regex/blob/HEAD/index.js\x0d\n// License: MIT\x2C authors: @sindresorhus\x2C Qix-\x2C arjunmehta and LitoMore\x0d\n// Matches all ansi escape code sequences in a string\x0d\nconst ansiPattern = '[\\\\u001B\\\\u009B][[\\\\]()#;?]*' +\x0d\n  '(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*' +\x0d\n  '|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)' +\x0d\n  '|(?:(?:\\\\d{1\x2C4}(?:;\\\\d{0\x2C4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))';\x0d\nconst ansi = new RegExp(ansiPattern\x2C 'g');\x0d\n\x0d\nlet getStringWidth;\x0d\n\x0d\nfunction getUserOptions(ctx\x2C isCrossContext) {\x0d\n  const ret = {\x0d\n    stylize: ctx.stylize\x2C\x0d\n    showHidden: ctx.showHidden\x2C\x0d\n    depth: ctx.depth\x2C\x0d\n    colors: ctx.colors\x2C\x0d\n    customInspect: ctx.customInspect\x2C\x0d\n    showProxy: ctx.showProxy\x2C\x0d\n    maxArrayLength: ctx.maxArrayLength\x2C\x0d\n    maxStringLength: ctx.maxStringLength\x2C\x0d\n    breakLength: ctx.breakLength\x2C\x0d\n    compact: ctx.compact\x2C\x0d\n    sorted: ctx.sorted\x2C\x0d\n    getters: ctx.getters\x2C\x0d\n    numericSeparator: ctx.numericSeparator\x2C\x0d\n    ...ctx.userOptions\x0d\n  };\x0d\n\x0d\n  // Typically\x2C the target value will be an instance of `Object`. If that is\x0d\n  // *not* the case\x2C the object may come from another vm.Context\x2C and we want\x0d\n  // to avoid passing it objects from this Context in that case\x2C so we remove\x0d\n  // the prototype from the returned object itself + the `stylize()` function\x2C\x0d\n  // and remove all other non-primitives\x2C including non-primitive user options.\x0d\n  if (isCrossContext) {\x0d\n    ObjectSetPrototypeOf(ret\x2C null);\x0d\n    for (const key of ObjectKeys(ret)) {\x0d\n      if ((typeof ret[key] === 'object' || typeof ret[key] === 'function') &&\x0d\n          ret[key] !== null) {\x0d\n        delete ret[key];\x0d\n      }\x0d\n    }\x0d\n    ret.stylize = ObjectSetPrototypeOf((value\x2C flavour) => {\x0d\n      let stylized;\x0d\n      try {\x0d\n        stylized = `${ctx.stylize(value\x2C flavour)}`;\x0d\n      } catch {}\x0d\n\x0d\n      if (typeof stylized !== 'string') return value;\x0d\n      // `stylized` is a string as it should be\x2C which is safe to pass along.\x0d\n      return stylized;\x0d\n    }\x2C null);\x0d\n  }\x0d\n\x0d\n  return ret;\x0d\n}\x0d\n\x0d\n/**\x0d\n * Echos the value of any input. Tries to print the value out\x0d\n * in the best way possible given the different types.\x0d\n *\x0d\n * @param {any} value The value to print out.\x0d\n * @param {object} opts Optional options object that alters the output.\x0d\n */\x0d\n/* Legacy: value\x2C showHidden\x2C depth\x2C colors */\x0d\nfunction inspect(value\x2C opts) {\x0d\n  // Default options\x0d\n  const ctx = {\x0d\n    budget: {}\x2C\x0d\n    indentationLvl: 0\x2C\x0d\n    seen: []\x2C\x0d\n    currentDepth: 0\x2C\x0d\n    stylize: stylizeNoColor\x2C\x0d\n    showHidden: inspectDefaultOptions.showHidden\x2C\x0d\n    depth: inspectDefaultOptions.depth\x2C\x0d\n    colors: inspectDefaultOptions.colors\x2C\x0d\n    customInspect: inspectDefaultOptions.customInspect\x2C\x0d\n    showProxy: inspectDefaultOptions.showProxy\x2C\x0d\n    maxArrayLength: inspectDefaultOptions.maxArrayLength\x2C\x0d\n    maxStringLength: inspectDefaultOptions.maxStringLength\x2C\x0d\n    breakLength: inspectDefaultOptions.breakLength\x2C\x0d\n    compact: inspectDefaultOptions.compact\x2C\x0d\n    sorted: inspectDefaultOptions.sorted\x2C\x0d\n    getters: inspectDefaultOptions.getters\x2C\x0d\n    numericSeparator: inspectDefaultOptions.numericSeparator\x2C\x0d\n  };\x0d\n  if (arguments.length > 1) {\x0d\n    // Legacy...\x0d\n    if (arguments.length > 2) {\x0d\n      if (arguments[2] !== undefined) {\x0d\n        ctx.depth = arguments[2];\x0d\n      }\x0d\n      if (arguments.length > 3 && arguments[3] !== undefined) {\x0d\n        ctx.colors = arguments[3];\x0d\n      }\x0d\n    }\x0d\n    // Set user-specified options\x0d\n    if (typeof opts === 'boolean') {\x0d\n      ctx.showHidden = opts;\x0d\n    } else if (opts) {\x0d\n      const optKeys = ObjectKeys(opts);\x0d\n      for (let i = 0; i < optKeys.length; ++i) {\x0d\n        const key = optKeys[i];\x0d\n        // TODO(BridgeAR): Find a solution what to do about stylize. Either make\x0d\n        // this function public or add a new API with a similar or better\x0d\n        // functionality.\x0d\n        if (\x0d\n          ObjectPrototypeHasOwnProperty(inspectDefaultOptions\x2C key) ||\x0d\n          key === 'stylize') {\x0d\n          ctx[key] = opts[key];\x0d\n        } else if (ctx.userOptions === undefined) {\x0d\n          // This is required to pass through the actual user input.\x0d\n          ctx.userOptions = opts;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\x0d\n  if (ctx.maxArrayLength === null) ctx.maxArrayLength = Infinity;\x0d\n  if (ctx.maxStringLength === null) ctx.maxStringLength = Infinity;\x0d\n  return formatValue(ctx\x2C value\x2C 0);\x0d\n}\x0d\ninspect.custom = customInspectSymbol;\x0d\n\x0d\nObjectDefineProperty(inspect\x2C 'defaultOptions'\x2C {\x0d\n  get() {\x0d\n    return inspectDefaultOptions;\x0d\n  }\x2C\x0d\n  set(options) {\x0d\n    validateObject(options\x2C 'options');\x0d\n    return ObjectAssign(inspectDefaultOptions\x2C options);\x0d\n  }\x0d\n});\x0d\n\x0d\n// Set Graphics Rendition https://en.wikipedia.org/wiki/ANSI_escape_code#graphics\x0d\n// Each color consists of an array with the color code as first entry and the\x0d\n// reset code as second entry.\x0d\nconst defaultFG = 39;\x0d\nconst defaultBG = 49;\x0d\ninspect.colors = ObjectAssign(ObjectCreate(null)\x2C {\x0d\n  reset: [0\x2C 0]\x2C\x0d\n  bold: [1\x2C 22]\x2C\x0d\n  dim: [2\x2C 22]\x2C // Alias: faint\x0d\n  italic: [3\x2C 23]\x2C\x0d\n  underline: [4\x2C 24]\x2C\x0d\n  blink: [5\x2C 25]\x2C\x0d\n  // Swap foreground and background colors\x0d\n  inverse: [7\x2C 27]\x2C // Alias: swapcolors\x2C swapColors\x0d\n  hidden: [8\x2C 28]\x2C // Alias: conceal\x0d\n  strikethrough: [9\x2C 29]\x2C // Alias: strikeThrough\x2C crossedout\x2C crossedOut\x0d\n  doubleunderline: [21\x2C 24]\x2C // Alias: doubleUnderline\x0d\n  black: [30\x2C defaultFG]\x2C\x0d\n  red: [31\x2C defaultFG]\x2C\x0d\n  green: [32\x2C defaultFG]\x2C\x0d\n  yellow: [33\x2C defaultFG]\x2C\x0d\n  blue: [34\x2C defaultFG]\x2C\x0d\n  magenta: [35\x2C defaultFG]\x2C\x0d\n  cyan: [36\x2C defaultFG]\x2C\x0d\n  white: [37\x2C defaultFG]\x2C\x0d\n  bgBlack: [40\x2C defaultBG]\x2C\x0d\n  bgRed: [41\x2C defaultBG]\x2C\x0d\n  bgGreen: [42\x2C defaultBG]\x2C\x0d\n  bgYellow: [43\x2C defaultBG]\x2C\x0d\n  bgBlue: [44\x2C defaultBG]\x2C\x0d\n  bgMagenta: [45\x2C defaultBG]\x2C\x0d\n  bgCyan: [46\x2C defaultBG]\x2C\x0d\n  bgWhite: [47\x2C defaultBG]\x2C\x0d\n  framed: [51\x2C 54]\x2C\x0d\n  overlined: [53\x2C 55]\x2C\x0d\n  gray: [90\x2C defaultFG]\x2C // Alias: grey\x2C blackBright\x0d\n  redBright: [91\x2C defaultFG]\x2C\x0d\n  greenBright: [92\x2C defaultFG]\x2C\x0d\n  yellowBright: [93\x2C defaultFG]\x2C\x0d\n  blueBright: [94\x2C defaultFG]\x2C\x0d\n  magentaBright: [95\x2C defaultFG]\x2C\x0d\n  cyanBright: [96\x2C defaultFG]\x2C\x0d\n  whiteBright: [97\x2C defaultFG]\x2C\x0d\n  bgGray: [100\x2C defaultBG]\x2C // Alias: bgGrey\x2C bgBlackBright\x0d\n  bgRedBright: [101\x2C defaultBG]\x2C\x0d\n  bgGreenBright: [102\x2C defaultBG]\x2C\x0d\n  bgYellowBright: [103\x2C defaultBG]\x2C\x0d\n  bgBlueBright: [104\x2C defaultBG]\x2C\x0d\n  bgMagentaBright: [105\x2C defaultBG]\x2C\x0d\n  bgCyanBright: [106\x2C defaultBG]\x2C\x0d\n  bgWhiteBright: [107\x2C defaultBG]\x2C\x0d\n});\x0d\n\x0d\nfunction defineColorAlias(target\x2C alias) {\x0d\n  ObjectDefineProperty(inspect.colors\x2C alias\x2C {\x0d\n    get() {\x0d\n      return this[target];\x0d\n    }\x2C\x0d\n    set(value) {\x0d\n      this[target] = value;\x0d\n    }\x2C\x0d\n    configurable: true\x2C\x0d\n    enumerable: false\x0d\n  });\x0d\n}\x0d\n\x0d\ndefineColorAlias('gray'\x2C 'grey');\x0d\ndefineColorAlias('gray'\x2C 'blackBright');\x0d\ndefineColorAlias('bgGray'\x2C 'bgGrey');\x0d\ndefineColorAlias('bgGray'\x2C 'bgBlackBright');\x0d\ndefineColorAlias('dim'\x2C 'faint');\x0d\ndefineColorAlias('strikethrough'\x2C 'crossedout');\x0d\ndefineColorAlias('strikethrough'\x2C 'strikeThrough');\x0d\ndefineColorAlias('strikethrough'\x2C 'crossedOut');\x0d\ndefineColorAlias('hidden'\x2C 'conceal');\x0d\ndefineColorAlias('inverse'\x2C 'swapColors');\x0d\ndefineColorAlias('inverse'\x2C 'swapcolors');\x0d\ndefineColorAlias('doubleunderline'\x2C 'doubleUnderline');\x0d\n\x0d\n// TODO(BridgeAR): Add function style support for more complex styles.\x0d\n// Don't use 'blue' not visible on cmd.exe\x0d\ninspect.styles = ObjectAssign(ObjectCreate(null)\x2C {\x0d\n  special: 'cyan'\x2C\x0d\n  number: 'yellow'\x2C\x0d\n  bigint: 'yellow'\x2C\x0d\n  boolean: 'yellow'\x2C\x0d\n  undefined: 'grey'\x2C\x0d\n  null: 'bold'\x2C\x0d\n  string: 'green'\x2C\x0d\n  symbol: 'green'\x2C\x0d\n  date: 'magenta'\x2C\x0d\n  // "name": intentionally not styling\x0d\n  // TODO(BridgeAR): Highlight regular expressions properly.\x0d\n  regexp: 'red'\x2C\x0d\n  module: 'underline'\x0d\n});\x0d\n\x0d\nfunction addQuotes(str\x2C quotes) {\x0d\n  if (quotes === -1) {\x0d\n    return `"${str}"`;\x0d\n  }\x0d\n  if (quotes === -2) {\x0d\n    return `\\`${str}\\``;\x0d\n  }\x0d\n  return `'${str}'`;\x0d\n}\x0d\n\x0d\nfunction escapeFn(str) {\x0d\n  const charCode = StringPrototypeCharCodeAt(str);\x0d\n  return meta.length > charCode ? meta[charCode] : `\\\\u${charCode.toString(16)}`;\x0d\n}\x0d\n\x0d\n// Escape control characters\x2C single quotes and the backslash.\x0d\n// This is similar to JSON stringify escaping.\x0d\nfunction strEscape(str) {\x0d\n  let escapeTest = strEscapeSequencesRegExp;\x0d\n  let escapeReplace = strEscapeSequencesReplacer;\x0d\n  let singleQuote = 39;\x0d\n\x0d\n  // Check for double quotes. If not present\x2C do not escape single quotes and\x0d\n  // instead wrap the text in double quotes. If double quotes exist\x2C check for\x0d\n  // backticks. If they do not exist\x2C use those as fallback instead of the\x0d\n  // double quotes.\x0d\n  if (StringPrototypeIncludes(str\x2C "'")) {\x0d\n    // This invalidates the charCode and therefore can not be matched for\x0d\n    // anymore.\x0d\n    if (!StringPrototypeIncludes(str\x2C '"')) {\x0d\n      singleQuote = -1;\x0d\n    } else if (!StringPrototypeIncludes(str\x2C '`') &&\x0d\n               !StringPrototypeIncludes(str\x2C '${')) {\x0d\n      singleQuote = -2;\x0d\n    }\x0d\n    if (singleQuote !== 39) {\x0d\n      escapeTest = strEscapeSequencesRegExpSingle;\x0d\n      escapeReplace = strEscapeSequencesReplacerSingle;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // Some magic numbers that worked out fine while benchmarking with v8 6.0\x0d\n  if (str.length < 5000 && !RegExpPrototypeTest(escapeTest\x2C str))\x0d\n    return addQuotes(str\x2C singleQuote);\x0d\n  if (str.length > 100) {\x0d\n    str = StringPrototypeReplace(str\x2C escapeReplace\x2C escapeFn);\x0d\n    return addQuotes(str\x2C singleQuote);\x0d\n  }\x0d\n\x0d\n  let result = '';\x0d\n  let last = 0;\x0d\n  for (let i = 0; i < str.length; i++) {\x0d\n    const point = StringPrototypeCharCodeAt(str\x2C i);\x0d\n    if (point === singleQuote ||\x0d\n        point === 92 ||\x0d\n        point < 32 ||\x0d\n        (point > 126 && point < 160)) {\x0d\n      if (last === i) {\x0d\n        result += meta[point];\x0d\n      } else {\x0d\n        result += `${StringPrototypeSlice(str\x2C last\x2C i)}${meta[point]}`;\x0d\n      }\x0d\n      last = i + 1;\x0d\n    } else if (point >= 0xd800 && point <= 0xdfff) {\x0d\n      if (point <= 0xdbff && i + 1 < str.length) {\x0d\n        const point = StringPrototypeCharCodeAt(str\x2C i + 1);\x0d\n        if (point >= 0xdc00 && point <= 0xdfff) {\x0d\n          i++;\x0d\n          continue;\x0d\n        }\x0d\n      }\x0d\n      result += `${StringPrototypeSlice(str\x2C last\x2C i)}${`\\\\u${point.toString(16)}`}`;\x0d\n      last = i + 1;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (last !== str.length) {\x0d\n    result += StringPrototypeSlice(str\x2C last);\x0d\n  }\x0d\n  return addQuotes(result\x2C singleQuote);\x0d\n}\x0d\n\x0d\nfunction stylizeWithColor(str\x2C styleType) {\x0d\n  const style = inspect.styles[styleType];\x0d\n  if (style !== undefined) {\x0d\n    const color = inspect.colors[style];\x0d\n    if (color !== undefined)\x0d\n      return `\\u001b[${color[0]}m${str}\\u001b[${color[1]}m`;\x0d\n  }\x0d\n  return str;\x0d\n}\x0d\n\x0d\nfunction stylizeNoColor(str) {\x0d\n  return str;\x0d\n}\x0d\n\x0d\n// Return a new empty array to push in the results of the default formatter.\x0d\nfunction getEmptyFormatArray() {\x0d\n  return [];\x0d\n}\x0d\n\x0d\nfunction isInstanceof(object\x2C proto) {\x0d\n  try {\x0d\n    return object instanceof proto;\x0d\n  } catch {\x0d\n    return false;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction getConstructorName(obj\x2C ctx\x2C recurseTimes\x2C protoProps) {\x0d\n  let firstProto;\x0d\n  const tmp = obj;\x0d\n  while (obj || isUndetectableObject(obj)) {\x0d\n    const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\x0d\n    if (descriptor !== undefined &&\x0d\n        typeof descriptor.value === 'function' &&\x0d\n        descriptor.value.name !== '' &&\x0d\n        isInstanceof(tmp\x2C descriptor.value)) {\x0d\n      if (protoProps !== undefined &&\x0d\n         (firstProto !== obj ||\x0d\n         !builtInObjects.has(descriptor.value.name))) {\x0d\n        addPrototypeProperties(\x0d\n          ctx\x2C tmp\x2C firstProto || tmp\x2C recurseTimes\x2C protoProps);\x0d\n      }\x0d\n      return descriptor.value.name;\x0d\n    }\x0d\n\x0d\n    obj = ObjectGetPrototypeOf(obj);\x0d\n    if (firstProto === undefined) {\x0d\n      firstProto = obj;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (firstProto === null) {\x0d\n    return null;\x0d\n  }\x0d\n\x0d\n  const res = internalGetConstructorName(tmp);\x0d\n\x0d\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\x0d\n    return `${res} <Complex prototype>`;\x0d\n  }\x0d\n\x0d\n  const protoConstr = getConstructorName(\x0d\n    firstProto\x2C ctx\x2C recurseTimes + 1\x2C protoProps);\x0d\n\x0d\n  if (protoConstr === null) {\x0d\n    return `${res} <${inspect(firstProto\x2C {\x0d\n      ...ctx\x2C\x0d\n      customInspect: false\x2C\x0d\n      depth: -1\x0d\n    })}>`;\x0d\n  }\x0d\n\x0d\n  return `${res} <${protoConstr}>`;\x0d\n}\x0d\n\x0d\n// This function has the side effect of adding prototype properties to the\x0d\n// `output` argument (which is an array). This is intended to highlight user\x0d\n// defined prototype properties.\x0d\nfunction addPrototypeProperties(ctx\x2C main\x2C obj\x2C recurseTimes\x2C output) {\x0d\n  let depth = 0;\x0d\n  let keys;\x0d\n  let keySet;\x0d\n  do {\x0d\n    if (depth !== 0 || main === obj) {\x0d\n      obj = ObjectGetPrototypeOf(obj);\x0d\n      // Stop as soon as a null prototype is encountered.\x0d\n      if (obj === null) {\x0d\n        return;\x0d\n      }\x0d\n      // Stop as soon as a built-in object type is detected.\x0d\n      const descriptor = ObjectGetOwnPropertyDescriptor(obj\x2C 'constructor');\x0d\n      if (descriptor !== undefined &&\x0d\n          typeof descriptor.value === 'function' &&\x0d\n          builtInObjects.has(descriptor.value.name)) {\x0d\n        return;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    if (depth === 0) {\x0d\n      keySet = new SafeSet();\x0d\n    } else {\x0d\n      ArrayPrototypeForEach(keys\x2C (key) => keySet.add(key));\x0d\n    }\x0d\n    // Get all own property names and symbols.\x0d\n    keys = ReflectOwnKeys(obj);\x0d\n    ArrayPrototypePush(ctx.seen\x2C main);\x0d\n    for (const key of keys) {\x0d\n      // Ignore the `constructor` property and keys that exist on layers above.\x0d\n      if (key === 'constructor' ||\x0d\n          ObjectPrototypeHasOwnProperty(main\x2C key) ||\x0d\n          (depth !== 0 && keySet.has(key))) {\x0d\n        continue;\x0d\n      }\x0d\n      const desc = ObjectGetOwnPropertyDescriptor(obj\x2C key);\x0d\n      if (typeof desc.value === 'function') {\x0d\n        continue;\x0d\n      }\x0d\n      const value = formatProperty(\x0d\n        ctx\x2C obj\x2C recurseTimes\x2C key\x2C kObjectType\x2C desc\x2C main);\x0d\n      if (ctx.colors) {\x0d\n        // Faint!\x0d\n        ArrayPrototypePush(output\x2C `\\u001b[2m${value}\\u001b[22m`);\x0d\n      } else {\x0d\n        ArrayPrototypePush(output\x2C value);\x0d\n      }\x0d\n    }\x0d\n    ArrayPrototypePop(ctx.seen);\x0d\n  // Limit the inspection to up to three prototype layers. Using `recurseTimes`\x0d\n  // is not a good choice here\x2C because it's as if the properties are declared\x0d\n  // on the current object from the users perspective.\x0d\n  } while (++depth !== 3);\x0d\n}\x0d\n\x0d\nfunction getPrefix(constructor\x2C tag\x2C fallback\x2C size = '') {\x0d\n  if (constructor === null) {\x0d\n    if (tag !== '' && fallback !== tag) {\x0d\n      return `[${fallback}${size}: null prototype] [${tag}] `;\x0d\n    }\x0d\n    return `[${fallback}${size}: null prototype] `;\x0d\n  }\x0d\n\x0d\n  if (tag !== '' && constructor !== tag) {\x0d\n    return `${constructor}${size} [${tag}] `;\x0d\n  }\x0d\n  return `${constructor}${size} `;\x0d\n}\x0d\n\x0d\n// Look up the keys of the object.\x0d\nfunction getKeys(value\x2C showHidden) {\x0d\n  let keys;\x0d\n  const symbols = ObjectGetOwnPropertySymbols(value);\x0d\n  if (showHidden) {\x0d\n    keys = ObjectGetOwnPropertyNames(value);\x0d\n    if (symbols.length !== 0)\x0d\n      ArrayPrototypePushApply(keys\x2C symbols);\x0d\n  } else {\x0d\n    // This might throw if `value` is a Module Namespace Object from an\x0d\n    // unevaluated module\x2C but we don't want to perform the actual type\x0d\n    // check because it's expensive.\x0d\n    // TODO(devsnek): track https://github.com/tc39/ecma262/issues/1209\x0d\n    // and modify this logic as needed.\x0d\n    try {\x0d\n      keys = ObjectKeys(value);\x0d\n    } catch (err) {\x0d\n      assert(isNativeError(err) && err.name === 'ReferenceError' &&\x0d\n             isModuleNamespaceObject(value));\x0d\n      keys = ObjectGetOwnPropertyNames(value);\x0d\n    }\x0d\n    if (symbols.length !== 0) {\x0d\n      const filter = (key) => ObjectPrototypePropertyIsEnumerable(value\x2C key);\x0d\n      ArrayPrototypePushApply(keys\x2C ArrayPrototypeFilter(symbols\x2C filter));\x0d\n    }\x0d\n  }\x0d\n  return keys;\x0d\n}\x0d\n\x0d\nfunction getCtxStyle(value\x2C constructor\x2C tag) {\x0d\n  let fallback = '';\x0d\n  if (constructor === null) {\x0d\n    fallback = internalGetConstructorName(value);\x0d\n    if (fallback === tag) {\x0d\n      fallback = 'Object';\x0d\n    }\x0d\n  }\x0d\n  return getPrefix(constructor\x2C tag\x2C fallback);\x0d\n}\x0d\n\x0d\nfunction formatProxy(ctx\x2C proxy\x2C recurseTimes) {\x0d\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\x0d\n    return ctx.stylize('Proxy [Array]'\x2C 'special');\x0d\n  }\x0d\n  recurseTimes += 1;\x0d\n  ctx.indentationLvl += 2;\x0d\n  const res = [\x0d\n    formatValue(ctx\x2C proxy[0]\x2C recurseTimes)\x2C\x0d\n    formatValue(ctx\x2C proxy[1]\x2C recurseTimes)\x2C\x0d\n  ];\x0d\n  ctx.indentationLvl -= 2;\x0d\n  return reduceToSingleString(\x0d\n    ctx\x2C res\x2C ''\x2C ['Proxy ['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\x0d\n}\x0d\n\x0d\n// Note: using `formatValue` directly requires the indentation level to be\x0d\n// corrected by setting `ctx.indentationLvL += diff` and then to decrease the\x0d\n// value afterwards again.\x0d\nfunction formatValue(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\x0d\n  // Primitive types cannot have properties.\x0d\n  if (typeof value !== 'object' &&\x0d\n      typeof value !== 'function' &&\x0d\n      !isUndetectableObject(value)) {\x0d\n    return formatPrimitive(ctx.stylize\x2C value\x2C ctx);\x0d\n  }\x0d\n  if (value === null) {\x0d\n    return ctx.stylize('null'\x2C 'null');\x0d\n  }\x0d\n\x0d\n  // Memorize the context for custom inspection on proxies.\x0d\n  const context = value;\x0d\n  // Always check for proxies to prevent side effects and to prevent triggering\x0d\n  // any proxy handlers.\x0d\n  const proxy = getProxyDetails(value\x2C !!ctx.showProxy);\x0d\n  if (proxy !== undefined) {\x0d\n    if (ctx.showProxy) {\x0d\n      return formatProxy(ctx\x2C proxy\x2C recurseTimes);\x0d\n    }\x0d\n    value = proxy;\x0d\n  }\x0d\n\x0d\n  // Provide a hook for user-specified inspect functions.\x0d\n  // Check that value is an object with an inspect function on it.\x0d\n  if (ctx.customInspect) {\x0d\n    const maybeCustom = value[customInspectSymbol];\x0d\n    if (typeof maybeCustom === 'function' &&\x0d\n        // Filter out the util module\x2C its inspect function is special.\x0d\n        maybeCustom !== inspect &&\x0d\n        // Also filter out any prototype objects using the circular check.\x0d\n        !(value.constructor && value.constructor.prototype === value)) {\x0d\n      // This makes sure the recurseTimes are reported as before while using\x0d\n      // a counter internally.\x0d\n      const depth = ctx.depth === null ? null : ctx.depth - recurseTimes;\x0d\n      const isCrossContext =\x0d\n        proxy !== undefined || !(context instanceof Object);\x0d\n      const ret = FunctionPrototypeCall(\x0d\n        maybeCustom\x2C\x0d\n        context\x2C\x0d\n        depth\x2C\x0d\n        getUserOptions(ctx\x2C isCrossContext)\x2C\x0d\n        inspect\x0d\n      );\x0d\n      // If the custom inspection method returned `this`\x2C don't go into\x0d\n      // infinite recursion.\x0d\n      if (ret !== context) {\x0d\n        if (typeof ret !== 'string') {\x0d\n          return formatValue(ctx\x2C ret\x2C recurseTimes);\x0d\n        }\x0d\n        return ret.replace(/\\n/g\x2C `\\n${' '.repeat(ctx.indentationLvl)}`);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  // Using an array here is actually better for the average case than using\x0d\n  // a Set. `seen` will only check for the depth and will never grow too large.\x0d\n  if (ctx.seen.includes(value)) {\x0d\n    let index = 1;\x0d\n    if (ctx.circular === undefined) {\x0d\n      ctx.circular = new SafeMap();\x0d\n      ctx.circular.set(value\x2C index);\x0d\n    } else {\x0d\n      index = ctx.circular.get(value);\x0d\n      if (index === undefined) {\x0d\n        index = ctx.circular.size + 1;\x0d\n        ctx.circular.set(value\x2C index);\x0d\n      }\x0d\n    }\x0d\n    return ctx.stylize(`[Circular *${index}]`\x2C 'special');\x0d\n  }\x0d\n\x0d\n  return formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray);\x0d\n}\x0d\n\x0d\nfunction formatRaw(ctx\x2C value\x2C recurseTimes\x2C typedArray) {\x0d\n  let keys;\x0d\n  let protoProps;\x0d\n  if (ctx.showHidden && (recurseTimes <= ctx.depth || ctx.depth === null)) {\x0d\n    protoProps = [];\x0d\n  }\x0d\n\x0d\n  const constructor = getConstructorName(value\x2C ctx\x2C recurseTimes\x2C protoProps);\x0d\n  // Reset the variable to check for this later on.\x0d\n  if (protoProps !== undefined && protoProps.length === 0) {\x0d\n    protoProps = undefined;\x0d\n  }\x0d\n\x0d\n  let tag = value[SymbolToStringTag];\x0d\n  // Only list the tag in case it's non-enumerable / not an own property.\x0d\n  // Otherwise we'd print this twice.\x0d\n  if (typeof tag !== 'string' ||\x0d\n      (tag !== '' &&\x0d\n      (ctx.showHidden ?\x0d\n        ObjectPrototypeHasOwnProperty :\x0d\n        ObjectPrototypePropertyIsEnumerable)(\x0d\n        value\x2C SymbolToStringTag\x0d\n      ))) {\x0d\n    tag = '';\x0d\n  }\x0d\n  let base = '';\x0d\n  let formatter = getEmptyFormatArray;\x0d\n  let braces;\x0d\n  let noIterator = true;\x0d\n  let i = 0;\x0d\n  const filter = ctx.showHidden ? ALL_PROPERTIES : ONLY_ENUMERABLE;\x0d\n\x0d\n  let extrasType = kObjectType;\x0d\n\x0d\n  // Iterators and the rest are split to reduce checks.\x0d\n  // We have to check all values in case the constructor is set to null.\x0d\n  // Otherwise it would not possible to identify all types properly.\x0d\n  if (value[SymbolIterator] || constructor === null) {\x0d\n    noIterator = false;\x0d\n    if (ArrayIsArray(value)) {\x0d\n      // Only set the constructor for non ordinary ("Array [...]") arrays.\x0d\n      const prefix = (constructor !== 'Array' || tag !== '') ?\x0d\n        getPrefix(constructor\x2C tag\x2C 'Array'\x2C `(${value.length})`) :\x0d\n        '';\x0d\n      keys = getOwnNonIndexProperties(value\x2C filter);\x0d\n      braces = [`${prefix}[`\x2C ']'];\x0d\n      if (value.length === 0 && keys.length === 0 && protoProps === undefined)\x0d\n        return `${braces[0]}]`;\x0d\n      extrasType = kArrayExtrasType;\x0d\n      formatter = formatArray;\x0d\n    } else if (isSet(value)) {\x0d\n      const size = SetPrototypeGetSize(value);\x0d\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Set'\x2C `(${size})`);\x0d\n      keys = getKeys(value\x2C ctx.showHidden);\x0d\n      formatter = constructor !== null ?\x0d\n        formatSet.bind(null\x2C value) :\x0d\n        formatSet.bind(null\x2C SetPrototypeValues(value));\x0d\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\x0d\n        return `${prefix}{}`;\x0d\n      braces = [`${prefix}{`\x2C '}'];\x0d\n    } else if (isMap(value)) {\x0d\n      const size = MapPrototypeGetSize(value);\x0d\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Map'\x2C `(${size})`);\x0d\n      keys = getKeys(value\x2C ctx.showHidden);\x0d\n      formatter = constructor !== null ?\x0d\n        formatMap.bind(null\x2C value) :\x0d\n        formatMap.bind(null\x2C MapPrototypeEntries(value));\x0d\n      if (size === 0 && keys.length === 0 && protoProps === undefined)\x0d\n        return `${prefix}{}`;\x0d\n      braces = [`${prefix}{`\x2C '}'];\x0d\n    } else if (isTypedArray(value)) {\x0d\n      keys = getOwnNonIndexProperties(value\x2C filter);\x0d\n      let bound = value;\x0d\n      let fallback = '';\x0d\n      if (constructor === null) {\x0d\n        fallback = TypedArrayPrototypeGetSymbolToStringTag(value);\x0d\n        // Reconstruct the array information.\x0d\n        bound = new primordials[fallback](value);\x0d\n      }\x0d\n      const size = TypedArrayPrototypeGetLength(value);\x0d\n      const prefix = getPrefix(constructor\x2C tag\x2C fallback\x2C `(${size})`);\x0d\n      braces = [`${prefix}[`\x2C ']'];\x0d\n      if (value.length === 0 && keys.length === 0 && !ctx.showHidden)\x0d\n        return `${braces[0]}]`;\x0d\n      // Special handle the value. The original value is required below. The\x0d\n      // bound function is required to reconstruct missing information.\x0d\n      formatter = formatTypedArray.bind(null\x2C bound\x2C size);\x0d\n      extrasType = kArrayExtrasType;\x0d\n    } else if (isMapIterator(value)) {\x0d\n      keys = getKeys(value\x2C ctx.showHidden);\x0d\n      braces = getIteratorBraces('Map'\x2C tag);\x0d\n      // Add braces to the formatter parameters.\x0d\n      formatter = formatIterator.bind(null\x2C braces);\x0d\n    } else if (isSetIterator(value)) {\x0d\n      keys = getKeys(value\x2C ctx.showHidden);\x0d\n      braces = getIteratorBraces('Set'\x2C tag);\x0d\n      // Add braces to the formatter parameters.\x0d\n      formatter = formatIterator.bind(null\x2C braces);\x0d\n    } else {\x0d\n      noIterator = true;\x0d\n    }\x0d\n  }\x0d\n  if (noIterator) {\x0d\n    keys = getKeys(value\x2C ctx.showHidden);\x0d\n    braces = ['{'\x2C '}'];\x0d\n    if (constructor === 'Object') {\x0d\n      if (isArgumentsObject(value)) {\x0d\n        braces[0] = '[Arguments] {';\x0d\n      } else if (tag !== '') {\x0d\n        braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Object')}{`;\x0d\n      }\x0d\n      if (keys.length === 0 && protoProps === undefined) {\x0d\n        return `${braces[0]}}`;\x0d\n      }\x0d\n    } else if (typeof value === 'function') {\x0d\n      base = getFunctionBase(value\x2C constructor\x2C tag);\x0d\n      if (keys.length === 0 && protoProps === undefined)\x0d\n        return ctx.stylize(base\x2C 'special');\x0d\n    } else if (isRegExp(value)) {\x0d\n      // Make RegExps say that they are RegExps\x0d\n      base = RegExpPrototypeToString(\x0d\n        constructor !== null ? value : new RegExp(value)\x0d\n      );\x0d\n      const prefix = getPrefix(constructor\x2C tag\x2C 'RegExp');\x0d\n      if (prefix !== 'RegExp ')\x0d\n        base = `${prefix}${base}`;\x0d\n      if ((keys.length === 0 && protoProps === undefined) ||\x0d\n          (recurseTimes > ctx.depth && ctx.depth !== null)) {\x0d\n        return ctx.stylize(base\x2C 'regexp');\x0d\n      }\x0d\n    } else if (isDate(value)) {\x0d\n      // Make dates with properties first say the date\x0d\n      base = NumberIsNaN(DatePrototypeGetTime(value)) ?\x0d\n        DatePrototypeToString(value) :\x0d\n        DatePrototypeToISOString(value);\x0d\n      const prefix = getPrefix(constructor\x2C tag\x2C 'Date');\x0d\n      if (prefix !== 'Date ')\x0d\n        base = `${prefix}${base}`;\x0d\n      if (keys.length === 0 && protoProps === undefined) {\x0d\n        return ctx.stylize(base\x2C 'date');\x0d\n      }\x0d\n    } else if (isError(value)) {\x0d\n      base = formatError(value\x2C constructor\x2C tag\x2C ctx\x2C keys);\x0d\n      if (keys.length === 0 && protoProps === undefined)\x0d\n        return base;\x0d\n    } else if (isAnyArrayBuffer(value)) {\x0d\n      // Fast path for ArrayBuffer and SharedArrayBuffer.\x0d\n      // Can't do the same for DataView because it has a non-primitive\x0d\n      // .buffer property that we need to recurse for.\x0d\n      const arrayType = isArrayBuffer(value) ? 'ArrayBuffer' :\x0d\n        'SharedArrayBuffer';\x0d\n      const prefix = getPrefix(constructor\x2C tag\x2C arrayType);\x0d\n      if (typedArray === undefined) {\x0d\n        formatter = formatArrayBuffer;\x0d\n      } else if (keys.length === 0 && protoProps === undefined) {\x0d\n        return prefix +\x0d\n              `{ byteLength: ${formatNumber(ctx.stylize\x2C value.byteLength\x2C false)} }`;\x0d\n      }\x0d\n      braces[0] = `${prefix}{`;\x0d\n      ArrayPrototypeUnshift(keys\x2C 'byteLength');\x0d\n    } else if (isDataView(value)) {\x0d\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'DataView')}{`;\x0d\n      // .buffer goes last\x2C it's not a primitive like the others.\x0d\n      ArrayPrototypeUnshift(keys\x2C 'byteLength'\x2C 'byteOffset'\x2C 'buffer');\x0d\n    } else if (isPromise(value)) {\x0d\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Promise')}{`;\x0d\n      formatter = formatPromise;\x0d\n    } else if (isWeakSet(value)) {\x0d\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakSet')}{`;\x0d\n      formatter = ctx.showHidden ? formatWeakSet : formatWeakCollection;\x0d\n    } else if (isWeakMap(value)) {\x0d\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'WeakMap')}{`;\x0d\n      formatter = ctx.showHidden ? formatWeakMap : formatWeakCollection;\x0d\n    } else if (isModuleNamespaceObject(value)) {\x0d\n      braces[0] = `${getPrefix(constructor\x2C tag\x2C 'Module')}{`;\x0d\n      // Special handle keys for namespace objects.\x0d\n      formatter = formatNamespaceObject.bind(null\x2C keys);\x0d\n    } else if (isBoxedPrimitive(value)) {\x0d\n      base = getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag);\x0d\n      if (keys.length === 0 && protoProps === undefined) {\x0d\n        return base;\x0d\n      }\x0d\n    } else {\x0d\n      if (keys.length === 0 && protoProps === undefined) {\x0d\n        if (isExternal(value)) {\x0d\n          const address = getExternalValue(value).toString(16);\x0d\n          return ctx.stylize(`[External: ${address}]`\x2C 'special');\x0d\n        }\x0d\n        return `${getCtxStyle(value\x2C constructor\x2C tag)}{}`;\x0d\n      }\x0d\n      braces[0] = `${getCtxStyle(value\x2C constructor\x2C tag)}{`;\x0d\n    }\x0d\n  }\x0d\n\x0d\n  if (recurseTimes > ctx.depth && ctx.depth !== null) {\x0d\n    let constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\x0d\n    if (constructor !== null)\x0d\n      constructorName = `[${constructorName}]`;\x0d\n    return ctx.stylize(constructorName\x2C 'special');\x0d\n  }\x0d\n  recurseTimes += 1;\x0d\n\x0d\n  ctx.seen.push(value);\x0d\n  ctx.currentDepth = recurseTimes;\x0d\n  let output;\x0d\n  const indentationLvl = ctx.indentationLvl;\x0d\n  try {\x0d\n    output = formatter(ctx\x2C value\x2C recurseTimes);\x0d\n    for (i = 0; i < keys.length; i++) {\x0d\n      output.push(\x0d\n        formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C extrasType));\x0d\n    }\x0d\n    if (protoProps !== undefined) {\x0d\n      output.push(...protoProps);\x0d\n    }\x0d\n  } catch (err) {\x0d\n    const constructorName = getCtxStyle(value\x2C constructor\x2C tag).slice(0\x2C -1);\x0d\n    return handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl);\x0d\n  }\x0d\n  if (ctx.circular !== undefined) {\x0d\n    const index = ctx.circular.get(value);\x0d\n    if (index !== undefined) {\x0d\n      const reference = ctx.stylize(`<ref *${index}>`\x2C 'special');\x0d\n      // Add reference always to the very beginning of the output.\x0d\n      if (ctx.compact !== true) {\x0d\n        base = base === '' ? reference : `${reference} ${base}`;\x0d\n      } else {\x0d\n        braces[0] = `${reference} ${braces[0]}`;\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n  ctx.seen.pop();\x0d\n\x0d\n  if (ctx.sorted) {\x0d\n    const comparator = ctx.sorted === true ? undefined : ctx.sorted;\x0d\n    if (extrasType === kObjectType) {\x0d\n      output = output.sort(comparator);\x0d\n    } else if (keys.length > 1) {\x0d\n      const sorted = output.slice(output.length - keys.length).sort(comparator);\x0d\n      output.splice(output.length - keys.length\x2C keys.length\x2C ...sorted);\x0d\n    }\x0d\n  }\x0d\n\x0d\n  const res = reduceToSingleString(\x0d\n    ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value);\x0d\n  const budget = ctx.budget[ctx.indentationLvl] || 0;\x0d\n  const newLength = budget + res.length;\x0d\n  ctx.budget[ctx.indentationLvl] = newLength;\x0d\n  // If any indentationLvl exceeds this limit\x2C limit further inspecting to the\x0d\n  // minimum. Otherwise the recursive algorithm might continue inspecting the\x0d\n  // object even though the maximum string size (~2 ** 28 on 32 bit systems and\x0d\n  // ~2 ** 30 on 64 bit systems) exceeded. The actual output is not limited at\x0d\n  // exactly 2 ** 27 but a bit higher. This depends on the object shape.\x0d\n  // This limit also makes sure that huge objects don't block the event loop\x0d\n  // significantly.\x0d\n  if (newLength > 2 ** 27) {\x0d\n    ctx.depth = -1;\x0d\n  }\x0d\n  return res;\x0d\n}\x0d\n\x0d\nfunction getIteratorBraces(type\x2C tag) {\x0d\n  if (tag !== `${type} Iterator`) {\x0d\n    if (tag !== '')\x0d\n      tag += '] [';\x0d\n    tag += `${type} Iterator`;\x0d\n  }\x0d\n  return [`[${tag}] {`\x2C '}'];\x0d\n}\x0d\n\x0d\nfunction getBoxedBase(value\x2C ctx\x2C keys\x2C constructor\x2C tag) {\x0d\n  let fn;\x0d\n  let type;\x0d\n  if (isNumberObject(value)) {\x0d\n    fn = NumberPrototypeValueOf;\x0d\n    type = 'Number';\x0d\n  } else if (isStringObject(value)) {\x0d\n    fn = StringPrototypeValueOf;\x0d\n    type = 'String';\x0d\n    // For boxed Strings\x2C we have to remove the 0-n indexed entries\x2C\x0d\n    // since they just noisy up the output and are redundant\x0d\n    // Make boxed primitive Strings look like such\x0d\n    keys.splice(0\x2C value.length);\x0d\n  } else if (isBooleanObject(value)) {\x0d\n    fn = BooleanPrototypeValueOf;\x0d\n    type = 'Boolean';\x0d\n  } else if (isBigIntObject(value)) {\x0d\n    fn = BigIntPrototypeValueOf;\x0d\n    type = 'BigInt';\x0d\n  } else {\x0d\n    fn = SymbolPrototypeValueOf;\x0d\n    type = 'Symbol';\x0d\n  }\x0d\n  let base = `[${type}`;\x0d\n  if (type !== constructor) {\x0d\n    if (constructor === null) {\x0d\n      base += ' (null prototype)';\x0d\n    } else {\x0d\n      base += ` (${constructor})`;\x0d\n    }\x0d\n  }\x0d\n  base += `: ${formatPrimitive(stylizeNoColor\x2C fn(value)\x2C ctx)}]`;\x0d\n  if (tag !== '' && tag !== constructor) {\x0d\n    base += ` [${tag}]`;\x0d\n  }\x0d\n  if (keys.length !== 0 || ctx.stylize === stylizeNoColor)\x0d\n    return base;\x0d\n  return ctx.stylize(base\x2C StringPrototypeToLowerCase(type));\x0d\n}\x0d\n\x0d\nfunction getClassBase(value\x2C constructor\x2C tag) {\x0d\n  const hasName = ObjectPrototypeHasOwnProperty(value\x2C 'name');\x0d\n  const name = (hasName && value.name) || '(anonymous)';\x0d\n  let base = `class ${name}`;\x0d\n  if (constructor !== 'Function' && constructor !== null) {\x0d\n    base += ` [${constructor}]`;\x0d\n  }\x0d\n  if (tag !== '' && constructor !== tag) {\x0d\n    base += ` [${tag}]`;\x0d\n  }\x0d\n  if (constructor !== null) {\x0d\n    const superName = ObjectGetPrototypeOf(value).name;\x0d\n    if (superName) {\x0d\n      base += ` extends ${superName}`;\x0d\n    }\x0d\n  } else {\x0d\n    base += ' extends [null prototype]';\x0d\n  }\x0d\n  return `[${base}]`;\x0d\n}\x0d\n\x0d\nfunction getFunctionBase(value\x2C constructor\x2C tag) {\x0d\n  const stringified = FunctionPrototypeToString(value);\x0d\n  if (stringified.startsWith('class') && stringified.endsWith('}')) {\x0d\n    const slice = stringified.slice(5\x2C -1);\x0d\n    const bracketIndex = slice.indexOf('{');\x0d\n    if (bracketIndex !== -1 &&\x0d\n        (!slice.slice(0\x2C bracketIndex).includes('(') ||\x0d\n          // Slow path to guarantee that it's indeed a class.\x0d\n          classRegExp.test(slice.replace(stripCommentsRegExp)))) {\x0d\n      return getClassBase(value\x2C constructor\x2C tag);\x0d\n    }\x0d\n  }\x0d\n  let type = 'Function';\x0d\n  if (isGeneratorFunction(value)) {\x0d\n    type = `Generator${type}`;\x0d\n  }\x0d\n  if (isAsyncFunction(value)) {\x0d\n    type = `Async${type}`;\x0d\n  }\x0d\n  let base = `[${type}`;\x0d\n  if (constructor === null) {\x0d\n    base += ' (null prototype)';\x0d\n  }\x0d\n  if (value.name === '') {\x0d\n    base += ' (anonymous)';\x0d\n  } else {\x0d\n    base += `: ${value.name}`;\x0d\n  }\x0d\n  base += ']';\x0d\n  if (constructor !== type && constructor !== null) {\x0d\n    base += ` ${constructor}`;\x0d\n  }\x0d\n  if (tag !== '' && constructor !== tag) {\x0d\n    base += ` [${tag}]`;\x0d\n  }\x0d\n  return base;\x0d\n}\x0d\n\x0d\nfunction identicalSequenceRange(a\x2C b) {\x0d\n  for (let i = 0; i < a.length - 3; i++) {\x0d\n    // Find the first entry of b that matches the current entry of a.\x0d\n    const pos = b.indexOf(a[i]);\x0d\n    if (pos !== -1) {\x0d\n      const rest = b.length - pos;\x0d\n      if (rest > 3) {\x0d\n        let len = 1;\x0d\n        const maxLen = MathMin(a.length - i\x2C rest);\x0d\n        // Count the number of consecutive entries.\x0d\n        while (maxLen > len && a[i + len] === b[pos + len]) {\x0d\n          len++;\x0d\n        }\x0d\n        if (len > 3) {\x0d\n          return { len\x2C offset: i };\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  return { len: 0\x2C offset: 0 };\x0d\n}\x0d\n\x0d\nfunction getStackString(error) {\x0d\n  return error.stack ? String(error.stack) : ErrorPrototypeToString(error);\x0d\n}\x0d\n\x0d\nfunction getStackFrames(ctx\x2C err\x2C stack) {\x0d\n  const frames = stack.split('\\n');\x0d\n\x0d\n  // Remove stack frames identical to frames in cause.\x0d\n  if (err.cause && isError(err.cause)) {\x0d\n    const causeStack = getStackString(err.cause);\x0d\n    const causeStackStart = causeStack.indexOf('\\n    at');\x0d\n    if (causeStackStart !== -1) {\x0d\n      const causeFrames = causeStack.slice(causeStackStart + 1).split('\\n');\x0d\n      const { len\x2C offset } = identicalSequenceRange(frames\x2C causeFrames);\x0d\n      if (len > 0) {\x0d\n        const skipped = len - 2;\x0d\n        const msg = `    ... ${skipped} lines matching cause stack trace ...`;\x0d\n        frames.splice(offset + 1\x2C skipped\x2C ctx.stylize(msg\x2C 'undefined'));\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n  return frames;\x0d\n}\x0d\n\x0d\nfunction improveStack(stack\x2C constructor\x2C name\x2C tag) {\x0d\n  // A stack trace may contain arbitrary data. Only manipulate the output\x0d\n  // for "regular errors" (errors that "look normal") for now.\x0d\n  let len = name.length;\x0d\n\x0d\n  if (constructor === null ||\x0d\n      (name.endsWith('Error') &&\x0d\n      stack.startsWith(name) &&\x0d\n      (stack.length === len || stack[len] === ':' || stack[len] === '\\n'))) {\x0d\n    let fallback = 'Error';\x0d\n    if (constructor === null) {\x0d\n      const start = stack.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/) ||\x0d\n        stack.match(/^([a-z_A-Z0-9-]*Error)$/);\x0d\n      fallback = (start && start[1]) || '';\x0d\n      len = fallback.length;\x0d\n      fallback = fallback || 'Error';\x0d\n    }\x0d\n    const prefix = getPrefix(constructor\x2C tag\x2C fallback).slice(0\x2C -1);\x0d\n    if (name !== prefix) {\x0d\n      if (prefix.includes(name)) {\x0d\n        if (len === 0) {\x0d\n          stack = `${prefix}: ${stack}`;\x0d\n        } else {\x0d\n          stack = `${prefix}${stack.slice(len)}`;\x0d\n        }\x0d\n      } else {\x0d\n        stack = `${prefix} [${name}]${stack.slice(len)}`;\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n  return stack;\x0d\n}\x0d\n\x0d\nfunction removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack) {\x0d\n  if (!ctx.showHidden && keys.length !== 0) {\x0d\n    for (const name of ['name'\x2C 'message'\x2C 'stack']) {\x0d\n      const index = keys.indexOf(name);\x0d\n      // Only hide the property in case it's part of the original stack\x0d\n      if (index !== -1 && stack.includes(err[name])) {\x0d\n        keys.splice(index\x2C 1);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction formatError(err\x2C constructor\x2C tag\x2C ctx\x2C keys) {\x0d\n  const name = err.name != null ? String(err.name) : 'Error';\x0d\n  let stack = getStackString(err);\x0d\n\x0d\n  removeDuplicateErrorKeys(ctx\x2C keys\x2C err\x2C stack);\x0d\n\x0d\n  if ('cause' in err &&\x0d\n      (keys.length === 0 || !keys.includes('cause'))) {\x0d\n    keys.push('cause');\x0d\n  }\x0d\n\x0d\n  stack = improveStack(stack\x2C constructor\x2C name\x2C tag);\x0d\n\x0d\n  // Ignore the error message if it's contained in the stack.\x0d\n  let pos = (err.message && stack.indexOf(err.message)) || -1;\x0d\n  if (pos !== -1)\x0d\n    pos += err.message.length;\x0d\n  // Wrap the error in brackets in case it has no stack trace.\x0d\n  const stackStart = stack.indexOf('\\n    at'\x2C pos);\x0d\n  if (stackStart === -1) {\x0d\n    stack = `[${stack}]`;\x0d\n  } else {\x0d\n    let newStack = stack.slice(0\x2C stackStart);\x0d\n    const lines = getStackFrames(ctx\x2C err\x2C stack.slice(stackStart + 1));\x0d\n    if (ctx.colors) {\x0d\n      // Highlight userland code and node modules.\x0d\n      for (const line of lines) {\x0d\n        const core = line.match(coreModuleRegExp);\x0d\n        if (core !== null && NativeModule.exists(core[1])) {\x0d\n          newStack += `\\n${ctx.stylize(line\x2C 'undefined')}`;\x0d\n        } else {\x0d\n          // This adds underscores to all node_modules to quickly identify them.\x0d\n          let nodeModule;\x0d\n          newStack += '\\n';\x0d\n          let pos = 0;\x0d\n          while (nodeModule = nodeModulesRegExp.exec(line)) {\x0d\n            // '/node_modules/'.length === 14\x0d\n            newStack += line.slice(pos\x2C nodeModule.index + 14);\x0d\n            newStack += ctx.stylize(nodeModule[1]\x2C 'module');\x0d\n            pos = nodeModule.index + nodeModule[0].length;\x0d\n          }\x0d\n          newStack += pos === 0 ? line : line.slice(pos);\x0d\n        }\x0d\n      }\x0d\n    } else {\x0d\n      newStack += `\\n${lines.join('\\n')}`;\x0d\n    }\x0d\n    stack = newStack;\x0d\n  }\x0d\n  // The message and the stack have to be indented as well!\x0d\n  if (ctx.indentationLvl !== 0) {\x0d\n    const indentation = ' '.repeat(ctx.indentationLvl);\x0d\n    stack = stack.replace(/\\n/g\x2C `\\n${indentation}`);\x0d\n  }\x0d\n  return stack;\x0d\n}\x0d\n\x0d\nfunction groupArrayElements(ctx\x2C output\x2C value) {\x0d\n  let totalLength = 0;\x0d\n  let maxLength = 0;\x0d\n  let i = 0;\x0d\n  let outputLength = output.length;\x0d\n  if (ctx.maxArrayLength < output.length) {\x0d\n    // This makes sure the "... n more items" part is not taken into account.\x0d\n    outputLength--;\x0d\n  }\x0d\n  const separatorSpace = 2; // Add 1 for the space and 1 for the separator.\x0d\n  const dataLen = new Array(outputLength);\x0d\n  // Calculate the total length of all output entries and the individual max\x0d\n  // entries length of all output entries. We have to remove colors first\x2C\x0d\n  // otherwise the length would not be calculated properly.\x0d\n  for (; i < outputLength; i++) {\x0d\n    const len = getStringWidth(output[i]\x2C ctx.colors);\x0d\n    dataLen[i] = len;\x0d\n    totalLength += len + separatorSpace;\x0d\n    if (maxLength < len)\x0d\n      maxLength = len;\x0d\n  }\x0d\n  // Add two to `maxLength` as we add a single whitespace character plus a comma\x0d\n  // in-between two entries.\x0d\n  const actualMax = maxLength + separatorSpace;\x0d\n  // Check if at least three entries fit next to each other and prevent grouping\x0d\n  // of arrays that contains entries of very different length (i.e.\x2C if a single\x0d\n  // entry is longer than 1/5 of all other entries combined). Otherwise the\x0d\n  // space in-between small entries would be enormous.\x0d\n  if (actualMax * 3 + ctx.indentationLvl < ctx.breakLength &&\x0d\n      (totalLength / actualMax > 5 || maxLength <= 6)) {\x0d\n\x0d\n    const approxCharHeights = 2.5;\x0d\n    const averageBias = MathSqrt(actualMax - totalLength / output.length);\x0d\n    const biasedMax = MathMax(actualMax - 3 - averageBias\x2C 1);\x0d\n    // Dynamically check how many columns seem possible.\x0d\n    const columns = MathMin(\x0d\n      // Ideally a square should be drawn. We expect a character to be about 2.5\x0d\n      // times as high as wide. This is the area formula to calculate a square\x0d\n      // which contains n rectangles of size `actualMax * approxCharHeights`.\x0d\n      // Divide that by `actualMax` to receive the correct number of columns.\x0d\n      // The added bias increases the columns for short entries.\x0d\n      MathRound(\x0d\n        MathSqrt(\x0d\n          approxCharHeights * biasedMax * outputLength\x0d\n        ) / biasedMax\x0d\n      )\x2C\x0d\n      // Do not exceed the breakLength.\x0d\n      MathFloor((ctx.breakLength - ctx.indentationLvl) / actualMax)\x2C\x0d\n      // Limit array grouping for small `compact` modes as the user requested\x0d\n      // minimal grouping.\x0d\n      ctx.compact * 4\x2C\x0d\n      // Limit the columns to a maximum of fifteen.\x0d\n      15\x0d\n    );\x0d\n    // Return with the original output if no grouping should happen.\x0d\n    if (columns <= 1) {\x0d\n      return output;\x0d\n    }\x0d\n    const tmp = [];\x0d\n    const maxLineLength = [];\x0d\n    for (let i = 0; i < columns; i++) {\x0d\n      let lineMaxLength = 0;\x0d\n      for (let j = i; j < output.length; j += columns) {\x0d\n        if (dataLen[j] > lineMaxLength)\x0d\n          lineMaxLength = dataLen[j];\x0d\n      }\x0d\n      lineMaxLength += separatorSpace;\x0d\n      maxLineLength[i] = lineMaxLength;\x0d\n    }\x0d\n    let order = StringPrototypePadStart;\x0d\n    if (value !== undefined) {\x0d\n      for (let i = 0; i < output.length; i++) {\x0d\n        if (typeof value[i] !== 'number' && typeof value[i] !== 'bigint') {\x0d\n          order = StringPrototypePadEnd;\x0d\n          break;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n    // Each iteration creates a single line of grouped entries.\x0d\n    for (let i = 0; i < outputLength; i += columns) {\x0d\n      // The last lines may contain less entries than columns.\x0d\n      const max = MathMin(i + columns\x2C outputLength);\x0d\n      let str = '';\x0d\n      let j = i;\x0d\n      for (; j < max - 1; j++) {\x0d\n        // Calculate extra color padding in case it's active. This has to be\x0d\n        // done line by line as some lines might contain more colors than\x0d\n        // others.\x0d\n        const padding = maxLineLength[j - i] + output[j].length - dataLen[j];\x0d\n        str += order(`${output[j]}\x2C `\x2C padding\x2C ' ');\x0d\n      }\x0d\n      if (order === StringPrototypePadStart) {\x0d\n        const padding = maxLineLength[j - i] +\x0d\n                        output[j].length -\x0d\n                        dataLen[j] -\x0d\n                        separatorSpace;\x0d\n        str += StringPrototypePadStart(output[j]\x2C padding\x2C ' ');\x0d\n      } else {\x0d\n        str += output[j];\x0d\n      }\x0d\n      ArrayPrototypePush(tmp\x2C str);\x0d\n    }\x0d\n    if (ctx.maxArrayLength < output.length) {\x0d\n      ArrayPrototypePush(tmp\x2C output[outputLength]);\x0d\n    }\x0d\n    output = tmp;\x0d\n  }\x0d\n  return output;\x0d\n}\x0d\n\x0d\nfunction handleMaxCallStackSize(ctx\x2C err\x2C constructorName\x2C indentationLvl) {\x0d\n  if (isStackOverflowError(err)) {\x0d\n    ctx.seen.pop();\x0d\n    ctx.indentationLvl = indentationLvl;\x0d\n    return ctx.stylize(\x0d\n      `[${constructorName}: Inspection interrupted ` +\x0d\n        'prematurely. Maximum call stack size exceeded.]'\x2C\x0d\n      'special'\x0d\n    );\x0d\n  }\x0d\n  /* c8 ignore next */\x0d\n  assert.fail(err.stack);\x0d\n}\x0d\n\x0d\nfunction addNumericSeparator(integerString) {\x0d\n  let result = '';\x0d\n  let i = integerString.length;\x0d\n  const start = integerString.startsWith('-') ? 1 : 0;\x0d\n  for (; i >= start + 4; i -= 3) {\x0d\n    result = `_${integerString.slice(i - 3\x2C i)}${result}`;\x0d\n  }\x0d\n  return i === integerString.length ?\x0d\n    integerString :\x0d\n    `${integerString.slice(0\x2C i)}${result}`;\x0d\n}\x0d\n\x0d\nfunction addNumericSeparatorEnd(integerString) {\x0d\n  let result = '';\x0d\n  let i = 0;\x0d\n  for (; i < integerString.length - 3; i += 3) {\x0d\n    result += `${integerString.slice(i\x2C i + 3)}_`;\x0d\n  }\x0d\n  return i === 0 ?\x0d\n    integerString :\x0d\n    `${result}${integerString.slice(i)}`;\x0d\n}\x0d\n\x0d\nfunction formatNumber(fn\x2C number\x2C numericSeparator) {\x0d\n  if (!numericSeparator) {\x0d\n    // Format -0 as '-0'. Checking `number === -0` won't distinguish 0 from -0.\x0d\n    if (ObjectIs(number\x2C -0)) {\x0d\n      return fn('-0'\x2C 'number');\x0d\n    }\x0d\n    return fn(`${number}`\x2C 'number');\x0d\n  }\x0d\n  const integer = MathTrunc(number);\x0d\n  const string = String(integer);\x0d\n  if (integer === number) {\x0d\n    if (!NumberIsFinite(number) || string.includes('e')) {\x0d\n      return fn(string\x2C 'number');\x0d\n    }\x0d\n    return fn(`${addNumericSeparator(string)}`\x2C 'number');\x0d\n  }\x0d\n  if (NumberIsNaN(number)) {\x0d\n    return fn(string\x2C 'number');\x0d\n  }\x0d\n  return fn(`${\x0d\n    addNumericSeparator(string)\x0d\n  }.${\x0d\n    addNumericSeparatorEnd(String(number).slice(string.length + 1))\x0d\n  }`\x2C 'number');\x0d\n}\x0d\n\x0d\nfunction formatBigInt(fn\x2C bigint\x2C numericSeparator) {\x0d\n  const string = String(bigint);\x0d\n  if (!numericSeparator) {\x0d\n    return fn(`${string}n`\x2C 'bigint');\x0d\n  }\x0d\n  return fn(`${addNumericSeparator(string)}n`\x2C 'bigint');\x0d\n}\x0d\n\x0d\nfunction formatPrimitive(fn\x2C value\x2C ctx) {\x0d\n  if (typeof value === 'string') {\x0d\n    let trailer = '';\x0d\n    if (value.length > ctx.maxStringLength) {\x0d\n      const remaining = value.length - ctx.maxStringLength;\x0d\n      value = value.slice(0\x2C ctx.maxStringLength);\x0d\n      trailer = `... ${remaining} more character${remaining > 1 ? 's' : ''}`;\x0d\n    }\x0d\n    if (ctx.compact !== true &&\x0d\n        // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\x0d\n        // function.\x0d\n        value.length > kMinLineLength &&\x0d\n        value.length > ctx.breakLength - ctx.indentationLvl - 4) {\x0d\n      return value\x0d\n        .split(/(?<=\\n)/)\x0d\n        .map((line) => fn(strEscape(line)\x2C 'string'))\x0d\n        .join(` +\\n${' '.repeat(ctx.indentationLvl + 2)}`) + trailer;\x0d\n    }\x0d\n    return fn(strEscape(value)\x2C 'string') + trailer;\x0d\n  }\x0d\n  if (typeof value === 'number')\x0d\n    return formatNumber(fn\x2C value\x2C ctx.numericSeparator);\x0d\n  if (typeof value === 'bigint')\x0d\n    return formatBigInt(fn\x2C value\x2C ctx.numericSeparator);\x0d\n  if (typeof value === 'boolean')\x0d\n    return fn(`${value}`\x2C 'boolean');\x0d\n  if (typeof value === 'undefined')\x0d\n    return fn('undefined'\x2C 'undefined');\x0d\n  // es6 symbol primitive\x0d\n  return fn(SymbolPrototypeToString(value)\x2C 'symbol');\x0d\n}\x0d\n\x0d\nfunction formatNamespaceObject(keys\x2C ctx\x2C value\x2C recurseTimes) {\x0d\n  const output = new Array(keys.length);\x0d\n  for (let i = 0; i < keys.length; i++) {\x0d\n    try {\x0d\n      output[i] = formatProperty(ctx\x2C value\x2C recurseTimes\x2C keys[i]\x2C\x0d\n                                 kObjectType);\x0d\n    } catch (err) {\x0d\n      assert(isNativeError(err) && err.name === 'ReferenceError');\x0d\n      // Use the existing functionality. This makes sure the indentation and\x0d\n      // line breaks are always correct. Otherwise it is very difficult to keep\x0d\n      // this aligned\x2C even though this is a hacky way of dealing with this.\x0d\n      const tmp = { [keys[i]]: '' };\x0d\n      output[i] = formatProperty(ctx\x2C tmp\x2C recurseTimes\x2C keys[i]\x2C kObjectType);\x0d\n      const pos = output[i].lastIndexOf(' ');\x0d\n      // We have to find the last whitespace and have to replace that value as\x0d\n      // it will be visualized as a regular string.\x0d\n      output[i] = output[i].slice(0\x2C pos + 1) +\x0d\n                  ctx.stylize('<uninitialized>'\x2C 'special');\x0d\n    }\x0d\n  }\x0d\n  // Reset the keys to an empty array. This prevents duplicated inspection.\x0d\n  keys.length = 0;\x0d\n  return output;\x0d\n}\x0d\n\x0d\n// The array is sparse and/or has extra keys\x0d\nfunction formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C maxLength\x2C output\x2C i) {\x0d\n  const keys = ObjectKeys(value);\x0d\n  let index = i;\x0d\n  for (; i < keys.length && output.length < maxLength; i++) {\x0d\n    const key = keys[i];\x0d\n    const tmp = +key;\x0d\n    // Arrays can only have up to 2^32 - 1 entries\x0d\n    if (tmp > 2 ** 32 - 2) {\x0d\n      break;\x0d\n    }\x0d\n    if (`${index}` !== key) {\x0d\n      if (!numberRegExp.test(key)) {\x0d\n        break;\x0d\n      }\x0d\n      const emptyItems = tmp - index;\x0d\n      const ending = emptyItems > 1 ? 's' : '';\x0d\n      const message = `<${emptyItems} empty item${ending}>`;\x0d\n      output.push(ctx.stylize(message\x2C 'undefined'));\x0d\n      index = tmp;\x0d\n      if (output.length === maxLength) {\x0d\n        break;\x0d\n      }\x0d\n    }\x0d\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C kArrayType));\x0d\n    index++;\x0d\n  }\x0d\n  const remaining = value.length - index;\x0d\n  if (output.length !== maxLength) {\x0d\n    if (remaining > 0) {\x0d\n      const ending = remaining > 1 ? 's' : '';\x0d\n      const message = `<${remaining} empty item${ending}>`;\x0d\n      output.push(ctx.stylize(message\x2C 'undefined'));\x0d\n    }\x0d\n  } else if (remaining > 0) {\x0d\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\x0d\n  }\x0d\n  return output;\x0d\n}\x0d\n\x0d\nfunction formatArrayBuffer(ctx\x2C value) {\x0d\n  let buffer;\x0d\n  try {\x0d\n    buffer = new Uint8Array(value);\x0d\n  } catch {\x0d\n    return [ctx.stylize('(detached)'\x2C 'special')];\x0d\n  }\x0d\n  if (hexSlice === undefined)\x0d\n    hexSlice = uncurryThis(require('buffer').Buffer.prototype.hexSlice);\x0d\n  let str = StringPrototypeTrim(StringPrototypeReplace(\x0d\n    hexSlice(buffer\x2C 0\x2C MathMin(ctx.maxArrayLength\x2C buffer.length))\x2C\x0d\n    /(.{2})/g\x2C '$1 '));\x0d\n  const remaining = buffer.length - ctx.maxArrayLength;\x0d\n  if (remaining > 0)\x0d\n    str += ` ... ${remaining} more byte${remaining > 1 ? 's' : ''}`;\x0d\n  return [`${ctx.stylize('[Uint8Contents]'\x2C 'special')}: <${str}>`];\x0d\n}\x0d\n\x0d\nfunction formatArray(ctx\x2C value\x2C recurseTimes) {\x0d\n  const valLen = value.length;\x0d\n  const len = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C valLen);\x0d\n\x0d\n  const remaining = valLen - len;\x0d\n  const output = [];\x0d\n  for (let i = 0; i < len; i++) {\x0d\n    // Special handle sparse arrays.\x0d\n    if (!ObjectPrototypeHasOwnProperty(value\x2C i)) {\x0d\n      return formatSpecialArray(ctx\x2C value\x2C recurseTimes\x2C len\x2C output\x2C i);\x0d\n    }\x0d\n    output.push(formatProperty(ctx\x2C value\x2C recurseTimes\x2C i\x2C kArrayType));\x0d\n  }\x0d\n  if (remaining > 0)\x0d\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\x0d\n  return output;\x0d\n}\x0d\n\x0d\nfunction formatTypedArray(value\x2C length\x2C ctx\x2C ignored\x2C recurseTimes) {\x0d\n  const maxLength = MathMin(MathMax(0\x2C ctx.maxArrayLength)\x2C length);\x0d\n  const remaining = value.length - maxLength;\x0d\n  const output = new Array(maxLength);\x0d\n  const elementFormatter = value.length > 0 && typeof value[0] === 'number' ?\x0d\n    formatNumber :\x0d\n    formatBigInt;\x0d\n  for (let i = 0; i < maxLength; ++i) {\x0d\n    output[i] = elementFormatter(ctx.stylize\x2C value[i]\x2C ctx.numericSeparator);\x0d\n  }\x0d\n  if (remaining > 0) {\x0d\n    output[maxLength] = `... ${remaining} more item${remaining > 1 ? 's' : ''}`;\x0d\n  }\x0d\n  if (ctx.showHidden) {\x0d\n    // .buffer goes last\x2C it's not a primitive like the others.\x0d\n    // All besides `BYTES_PER_ELEMENT` are actually getters.\x0d\n    ctx.indentationLvl += 2;\x0d\n    for (const key of [\x0d\n      'BYTES_PER_ELEMENT'\x2C\x0d\n      'length'\x2C\x0d\n      'byteLength'\x2C\x0d\n      'byteOffset'\x2C\x0d\n      'buffer'\x2C\x0d\n    ]) {\x0d\n      const str = formatValue(ctx\x2C value[key]\x2C recurseTimes\x2C true);\x0d\n      ArrayPrototypePush(output\x2C `[${key}]: ${str}`);\x0d\n    }\x0d\n    ctx.indentationLvl -= 2;\x0d\n  }\x0d\n  return output;\x0d\n}\x0d\n\x0d\nfunction formatSet(value\x2C ctx\x2C ignored\x2C recurseTimes) {\x0d\n  const output = [];\x0d\n  ctx.indentationLvl += 2;\x0d\n  for (const v of value) {\x0d\n    ArrayPrototypePush(output\x2C formatValue(ctx\x2C v\x2C recurseTimes));\x0d\n  }\x0d\n  ctx.indentationLvl -= 2;\x0d\n  return output;\x0d\n}\x0d\n\x0d\nfunction formatMap(value\x2C ctx\x2C ignored\x2C recurseTimes) {\x0d\n  const output = [];\x0d\n  ctx.indentationLvl += 2;\x0d\n  for (const { 0: k\x2C 1: v } of value) {\x0d\n    output.push(\x0d\n      `${formatValue(ctx\x2C k\x2C recurseTimes)} => ${formatValue(ctx\x2C v\x2C recurseTimes)}`\x0d\n    );\x0d\n  }\x0d\n  ctx.indentationLvl -= 2;\x0d\n  return output;\x0d\n}\x0d\n\x0d\nfunction formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\x0d\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\x0d\n  const maxLength = MathMin(maxArrayLength\x2C entries.length);\x0d\n  const output = new Array(maxLength);\x0d\n  ctx.indentationLvl += 2;\x0d\n  for (let i = 0; i < maxLength; i++) {\x0d\n    output[i] = formatValue(ctx\x2C entries[i]\x2C recurseTimes);\x0d\n  }\x0d\n  ctx.indentationLvl -= 2;\x0d\n  if (state === kWeak && !ctx.sorted) {\x0d\n    // Sort all entries to have a halfway reliable output (if more entries than\x0d\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\x0d\n    // output is not sorted anyway.\x0d\n    ArrayPrototypeSort(output);\x0d\n  }\x0d\n  const remaining = entries.length - maxLength;\x0d\n  if (remaining > 0) {\x0d\n    ArrayPrototypePush(output\x2C\x0d\n                       `... ${remaining} more item${remaining > 1 ? 's' : ''}`);\x0d\n  }\x0d\n  return output;\x0d\n}\x0d\n\x0d\nfunction formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C state) {\x0d\n  const maxArrayLength = MathMax(ctx.maxArrayLength\x2C 0);\x0d\n  // Entries exist as [key1\x2C val1\x2C key2\x2C val2\x2C ...]\x0d\n  const len = entries.length / 2;\x0d\n  const remaining = len - maxArrayLength;\x0d\n  const maxLength = MathMin(maxArrayLength\x2C len);\x0d\n  let output = new Array(maxLength);\x0d\n  let i = 0;\x0d\n  ctx.indentationLvl += 2;\x0d\n  if (state === kWeak) {\x0d\n    for (; i < maxLength; i++) {\x0d\n      const pos = i * 2;\x0d\n      output[i] =\x0d\n        `${formatValue(ctx\x2C entries[pos]\x2C recurseTimes)} => ${formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)}`;\x0d\n    }\x0d\n    // Sort all entries to have a halfway reliable output (if more entries than\x0d\n    // retrieved ones exist\x2C we can not reliably return the same output) if the\x0d\n    // output is not sorted anyway.\x0d\n    if (!ctx.sorted)\x0d\n      output = output.sort();\x0d\n  } else {\x0d\n    for (; i < maxLength; i++) {\x0d\n      const pos = i * 2;\x0d\n      const res = [\x0d\n        formatValue(ctx\x2C entries[pos]\x2C recurseTimes)\x2C\x0d\n        formatValue(ctx\x2C entries[pos + 1]\x2C recurseTimes)\x2C\x0d\n      ];\x0d\n      output[i] = reduceToSingleString(\x0d\n        ctx\x2C res\x2C ''\x2C ['['\x2C ']']\x2C kArrayExtrasType\x2C recurseTimes);\x0d\n    }\x0d\n  }\x0d\n  ctx.indentationLvl -= 2;\x0d\n  if (remaining > 0) {\x0d\n    output.push(`... ${remaining} more item${remaining > 1 ? 's' : ''}`);\x0d\n  }\x0d\n  return output;\x0d\n}\x0d\n\x0d\nfunction formatWeakCollection(ctx) {\x0d\n  return [ctx.stylize('<items unknown>'\x2C 'special')];\x0d\n}\x0d\n\x0d\nfunction formatWeakSet(ctx\x2C value\x2C recurseTimes) {\x0d\n  const entries = previewEntries(value);\x0d\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\x0d\n}\x0d\n\x0d\nfunction formatWeakMap(ctx\x2C value\x2C recurseTimes) {\x0d\n  const entries = previewEntries(value);\x0d\n  return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kWeak);\x0d\n}\x0d\n\x0d\nfunction formatIterator(braces\x2C ctx\x2C value\x2C recurseTimes) {\x0d\n  const { 0: entries\x2C 1: isKeyValue } = previewEntries(value\x2C true);\x0d\n  if (isKeyValue) {\x0d\n    // Mark entry iterators as such.\x0d\n    braces[0] = braces[0].replace(/ Iterator] {$/\x2C ' Entries] {');\x0d\n    return formatMapIterInner(ctx\x2C recurseTimes\x2C entries\x2C kMapEntries);\x0d\n  }\x0d\n\x0d\n  return formatSetIterInner(ctx\x2C recurseTimes\x2C entries\x2C kIterator);\x0d\n}\x0d\n\x0d\nfunction formatPromise(ctx\x2C value\x2C recurseTimes) {\x0d\n  let output;\x0d\n  const { 0: state\x2C 1: result } = getPromiseDetails(value);\x0d\n  if (state === kPending) {\x0d\n    output = [ctx.stylize('<pending>'\x2C 'special')];\x0d\n  } else {\x0d\n    ctx.indentationLvl += 2;\x0d\n    const str = formatValue(ctx\x2C result\x2C recurseTimes);\x0d\n    ctx.indentationLvl -= 2;\x0d\n    output = [\x0d\n      state === kRejected ?\x0d\n        `${ctx.stylize('<rejected>'\x2C 'special')} ${str}` :\x0d\n        str\x2C\x0d\n    ];\x0d\n  }\x0d\n  return output;\x0d\n}\x0d\n\x0d\nfunction formatProperty(ctx\x2C value\x2C recurseTimes\x2C key\x2C type\x2C desc\x2C\x0d\n                        original = value) {\x0d\n  let name\x2C str;\x0d\n  let extra = ' ';\x0d\n  desc = desc || ObjectGetOwnPropertyDescriptor(value\x2C key) ||\x0d\n    { value: value[key]\x2C enumerable: true };\x0d\n  if (desc.value !== undefined) {\x0d\n    const diff = (ctx.compact !== true || type !== kObjectType) ? 2 : 3;\x0d\n    ctx.indentationLvl += diff;\x0d\n    str = formatValue(ctx\x2C desc.value\x2C recurseTimes);\x0d\n    if (diff === 3 && ctx.breakLength < getStringWidth(str\x2C ctx.colors)) {\x0d\n      extra = `\\n${' '.repeat(ctx.indentationLvl)}`;\x0d\n    }\x0d\n    ctx.indentationLvl -= diff;\x0d\n  } else if (desc.get !== undefined) {\x0d\n    const label = desc.set !== undefined ? 'Getter/Setter' : 'Getter';\x0d\n    const s = ctx.stylize;\x0d\n    const sp = 'special';\x0d\n    if (ctx.getters && (ctx.getters === true ||\x0d\n          (ctx.getters === 'get' && desc.set === undefined) ||\x0d\n          (ctx.getters === 'set' && desc.set !== undefined))) {\x0d\n      try {\x0d\n        const tmp = FunctionPrototypeCall(desc.get\x2C original);\x0d\n        ctx.indentationLvl += 2;\x0d\n        if (tmp === null) {\x0d\n          str = `${s(`[${label}:`\x2C sp)} ${s('null'\x2C 'null')}${s(']'\x2C sp)}`;\x0d\n        } else if (typeof tmp === 'object') {\x0d\n          str = `${s(`[${label}]`\x2C sp)} ${formatValue(ctx\x2C tmp\x2C recurseTimes)}`;\x0d\n        } else {\x0d\n          const primitive = formatPrimitive(s\x2C tmp\x2C ctx);\x0d\n          str = `${s(`[${label}:`\x2C sp)} ${primitive}${s(']'\x2C sp)}`;\x0d\n        }\x0d\n        ctx.indentationLvl -= 2;\x0d\n      } catch (err) {\x0d\n        const message = `<Inspection threw (${err.message})>`;\x0d\n        str = `${s(`[${label}:`\x2C sp)} ${message}${s(']'\x2C sp)}`;\x0d\n      }\x0d\n    } else {\x0d\n      str = ctx.stylize(`[${label}]`\x2C sp);\x0d\n    }\x0d\n  } else if (desc.set !== undefined) {\x0d\n    str = ctx.stylize('[Setter]'\x2C 'special');\x0d\n  } else {\x0d\n    str = ctx.stylize('undefined'\x2C 'undefined');\x0d\n  }\x0d\n  if (type === kArrayType) {\x0d\n    return str;\x0d\n  }\x0d\n  if (typeof key === 'symbol') {\x0d\n    const tmp = StringPrototypeReplace(\x0d\n      SymbolPrototypeToString(key)\x2C\x0d\n      strEscapeSequencesReplacer\x2C escapeFn\x0d\n    );\x0d\n    name = `[${ctx.stylize(tmp\x2C 'symbol')}]`;\x0d\n  } else if (key === '__proto__') {\x0d\n    name = "['__proto__']";\x0d\n  } else if (desc.enumerable === false) {\x0d\n    const tmp = StringPrototypeReplace(key\x2C\x0d\n                                       strEscapeSequencesReplacer\x2C escapeFn);\x0d\n    name = `[${tmp}]`;\x0d\n  } else if (RegExpPrototypeTest(keyStrRegExp\x2C key)) {\x0d\n    name = ctx.stylize(key\x2C 'name');\x0d\n  } else {\x0d\n    name = ctx.stylize(strEscape(key)\x2C 'string');\x0d\n  }\x0d\n  return `${name}:${extra}${str}`;\x0d\n}\x0d\n\x0d\nfunction isBelowBreakLength(ctx\x2C output\x2C start\x2C base) {\x0d\n  // Each entry is separated by at least a comma. Thus\x2C we start with a total\x0d\n  // length of at least `output.length`. In addition\x2C some cases have a\x0d\n  // whitespace in-between each other that is added to the total as well.\x0d\n  // TODO(BridgeAR): Add unicode support. Use the readline getStringWidth\x0d\n  // function. Check the performance overhead and make it an opt-in in case it's\x0d\n  // significant.\x0d\n  let totalLength = output.length + start;\x0d\n  if (totalLength + output.length > ctx.breakLength)\x0d\n    return false;\x0d\n  for (let i = 0; i < output.length; i++) {\x0d\n    if (ctx.colors) {\x0d\n      totalLength += removeColors(output[i]).length;\x0d\n    } else {\x0d\n      totalLength += output[i].length;\x0d\n    }\x0d\n    if (totalLength > ctx.breakLength) {\x0d\n      return false;\x0d\n    }\x0d\n  }\x0d\n  // Do not line up properties on the same line if `base` contains line breaks.\x0d\n  return base === '' || !StringPrototypeIncludes(base\x2C '\\n');\x0d\n}\x0d\n\x0d\nfunction reduceToSingleString(\x0d\n  ctx\x2C output\x2C base\x2C braces\x2C extrasType\x2C recurseTimes\x2C value) {\x0d\n  if (ctx.compact !== true) {\x0d\n    if (typeof ctx.compact === 'number' && ctx.compact >= 1) {\x0d\n      // Memorize the original output length. In case the output is grouped\x2C\x0d\n      // prevent lining up the entries on a single line.\x0d\n      const entries = output.length;\x0d\n      // Group array elements together if the array contains at least six\x0d\n      // separate entries.\x0d\n      if (extrasType === kArrayExtrasType && entries > 6) {\x0d\n        output = groupArrayElements(ctx\x2C output\x2C value);\x0d\n      }\x0d\n      // `ctx.currentDepth` is set to the most inner depth of the currently\x0d\n      // inspected object part while `recurseTimes` is the actual current depth\x0d\n      // that is inspected.\x0d\n      //\x0d\n      // Example:\x0d\n      //\x0d\n      // const a = { first: [ 1\x2C 2\x2C 3 ]\x2C second: { inner: [ 1\x2C 2\x2C 3 ] } }\x0d\n      //\x0d\n      // The deepest depth of `a` is 2 (a.second.inner) and `a.first` has a max\x0d\n      // depth of 1.\x0d\n      //\x0d\n      // Consolidate all entries of the local most inner depth up to\x0d\n      // `ctx.compact`\x2C as long as the properties are smaller than\x0d\n      // `ctx.breakLength`.\x0d\n      if (ctx.currentDepth - recurseTimes < ctx.compact &&\x0d\n          entries === output.length) {\x0d\n        // Line up all entries on a single line in case the entries do not\x0d\n        // exceed `breakLength`. Add 10 as constant to start next to all other\x0d\n        // factors that may reduce `breakLength`.\x0d\n        const start = output.length + ctx.indentationLvl +\x0d\n                      braces[0].length + base.length + 10;\x0d\n        if (isBelowBreakLength(ctx\x2C output\x2C start\x2C base)) {\x0d\n          const joinedOutput = join(output\x2C '\x2C ');\x0d\n          if (!joinedOutput.includes('\\n')) {\x0d\n            return `${base ? `${base} ` : ''}${braces[0]} ${joinedOutput}` +\x0d\n              ` ${braces[1]}`;\x0d\n          }\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n    // Line up each entry on an individual line.\x0d\n    const indentation = `\\n${StringPrototypeRepeat(' '\x2C ctx.indentationLvl)}`;\x0d\n    return `${base ? `${base} ` : ''}${braces[0]}${indentation}  ` +\x0d\n      `${join(output\x2C `\x2C${indentation}  `)}${indentation}${braces[1]}`;\x0d\n  }\x0d\n  // Line up all entries on a single line in case the entries do not exceed\x0d\n  // `breakLength`.\x0d\n  if (isBelowBreakLength(ctx\x2C output\x2C 0\x2C base)) {\x0d\n    return `${braces[0]}${base ? ` ${base}` : ''} ${join(output\x2C '\x2C ')} ` +\x0d\n      braces[1];\x0d\n  }\x0d\n  const indentation = StringPrototypeRepeat(' '\x2C ctx.indentationLvl);\x0d\n  // If the opening "brace" is too large\x2C like in the case of "Set {"\x2C\x0d\n  // we need to force the first item to be on the next line or the\x0d\n  // items will not line up correctly.\x0d\n  const ln = base === '' && braces[0].length === 1 ?\x0d\n    ' ' : `${base ? ` ${base}` : ''}\\n${indentation}  `;\x0d\n  // Line up each entry on an individual line.\x0d\n  return `${braces[0]}${ln}${join(output\x2C `\x2C\\n${indentation}  `)} ${braces[1]}`;\x0d\n}\x0d\n\x0d\nfunction hasBuiltInToString(value) {\x0d\n  // Prevent triggering proxy traps.\x0d\n  const getFullProxy = false;\x0d\n  const proxyTarget = getProxyDetails(value\x2C getFullProxy);\x0d\n  if (proxyTarget !== undefined) {\x0d\n    value = proxyTarget;\x0d\n  }\x0d\n\x0d\n  // Count objects that have no `toString` function as built-in.\x0d\n  if (typeof value.toString !== 'function') {\x0d\n    return true;\x0d\n  }\x0d\n\x0d\n  // The object has a own `toString` property. Thus it's not not a built-in one.\x0d\n  if (ObjectPrototypeHasOwnProperty(value\x2C 'toString')) {\x0d\n    return false;\x0d\n  }\x0d\n\x0d\n  // Find the object that has the `toString` property as own property in the\x0d\n  // prototype chain.\x0d\n  let pointer = value;\x0d\n  do {\x0d\n    pointer = ObjectGetPrototypeOf(pointer);\x0d\n  } while (!ObjectPrototypeHasOwnProperty(pointer\x2C 'toString'));\x0d\n\x0d\n  // Check closer if the object is a built-in.\x0d\n  const descriptor = ObjectGetOwnPropertyDescriptor(pointer\x2C 'constructor');\x0d\n  return descriptor !== undefined &&\x0d\n    typeof descriptor.value === 'function' &&\x0d\n    builtInObjects.has(descriptor.value.name);\x0d\n}\x0d\n\x0d\nconst firstErrorLine = (error) =>\x0d\n  StringPrototypeSplit(error.message\x2C '\\n'\x2C 1)[0];\x0d\nlet CIRCULAR_ERROR_MESSAGE;\x0d\nfunction tryStringify(arg) {\x0d\n  try {\x0d\n    return JSONStringify(arg);\x0d\n  } catch (err) {\x0d\n    // Populate the circular error message lazily\x0d\n    if (!CIRCULAR_ERROR_MESSAGE) {\x0d\n      try {\x0d\n        const a = {}; a.a = a; JSONStringify(a);\x0d\n      } catch (circularError) {\x0d\n        CIRCULAR_ERROR_MESSAGE = firstErrorLine(circularError);\x0d\n      }\x0d\n    }\x0d\n    if (err.name === 'TypeError' &&\x0d\n        firstErrorLine(err) === CIRCULAR_ERROR_MESSAGE) {\x0d\n      return '[Circular]';\x0d\n    }\x0d\n    throw err;\x0d\n  }\x0d\n}\x0d\n\x0d\nfunction format(...args) {\x0d\n  return formatWithOptionsInternal(undefined\x2C args);\x0d\n}\x0d\n\x0d\nfunction formatWithOptions(inspectOptions\x2C ...args) {\x0d\n  if (typeof inspectOptions !== 'object' || inspectOptions === null) {\x0d\n    throw new ERR_INVALID_ARG_TYPE(\x0d\n      'inspectOptions'\x2C 'object'\x2C inspectOptions);\x0d\n  }\x0d\n  return formatWithOptionsInternal(inspectOptions\x2C args);\x0d\n}\x0d\n\x0d\nfunction formatNumberNoColor(number\x2C options) {\x0d\n  return formatNumber(\x0d\n    stylizeNoColor\x2C\x0d\n    number\x2C\x0d\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\x0d\n  );\x0d\n}\x0d\n\x0d\nfunction formatBigIntNoColor(bigint\x2C options) {\x0d\n  return formatBigInt(\x0d\n    stylizeNoColor\x2C\x0d\n    bigint\x2C\x0d\n    options?.numericSeparator ?? inspectDefaultOptions.numericSeparator\x0d\n  );\x0d\n}\x0d\n\x0d\nfunction formatWithOptionsInternal(inspectOptions\x2C args) {\x0d\n  const first = args[0];\x0d\n  let a = 0;\x0d\n  let str = '';\x0d\n  let join = '';\x0d\n\x0d\n  if (typeof first === 'string') {\x0d\n    if (args.length === 1) {\x0d\n      return first;\x0d\n    }\x0d\n    let tempStr;\x0d\n    let lastPos = 0;\x0d\n\x0d\n    for (let i = 0; i < first.length - 1; i++) {\x0d\n      if (StringPrototypeCharCodeAt(first\x2C i) === 37) { // '%'\x0d\n        const nextChar = StringPrototypeCharCodeAt(first\x2C ++i);\x0d\n        if (a + 1 !== args.length) {\x0d\n          switch (nextChar) {\x0d\n            case 115: { // 's'\x0d\n              const tempArg = args[++a];\x0d\n              if (typeof tempArg === 'number') {\x0d\n                tempStr = formatNumberNoColor(tempArg\x2C inspectOptions);\x0d\n              } else if (typeof tempArg === 'bigint') {\x0d\n                tempStr = formatBigIntNoColor(tempArg\x2C inspectOptions);\x0d\n              } else if (typeof tempArg !== 'object' ||\x0d\n                         tempArg === null ||\x0d\n                         !hasBuiltInToString(tempArg)) {\x0d\n                tempStr = String(tempArg);\x0d\n              } else {\x0d\n                tempStr = inspect(tempArg\x2C {\x0d\n                  ...inspectOptions\x2C\x0d\n                  compact: 3\x2C\x0d\n                  colors: false\x2C\x0d\n                  depth: 0\x0d\n                });\x0d\n              }\x0d\n              break;\x0d\n            }\x0d\n            case 106: // 'j'\x0d\n              tempStr = tryStringify(args[++a]);\x0d\n              break;\x0d\n            case 100: { // 'd'\x0d\n              const tempNum = args[++a];\x0d\n              if (typeof tempNum === 'bigint') {\x0d\n                tempStr = formatBigIntNoColor(tempNum\x2C inspectOptions);\x0d\n              } else if (typeof tempNum === 'symbol') {\x0d\n                tempStr = 'NaN';\x0d\n              } else {\x0d\n                tempStr = formatNumberNoColor(Number(tempNum)\x2C inspectOptions);\x0d\n              }\x0d\n              break;\x0d\n            }\x0d\n            case 79: // 'O'\x0d\n              tempStr = inspect(args[++a]\x2C inspectOptions);\x0d\n              break;\x0d\n            case 111: // 'o'\x0d\n              tempStr = inspect(args[++a]\x2C {\x0d\n                ...inspectOptions\x2C\x0d\n                showHidden: true\x2C\x0d\n                showProxy: true\x2C\x0d\n                depth: 4\x0d\n              });\x0d\n              break;\x0d\n            case 105: { // 'i'\x0d\n              const tempInteger = args[++a];\x0d\n              if (typeof tempInteger === 'bigint') {\x0d\n                tempStr = formatBigIntNoColor(tempInteger\x2C inspectOptions);\x0d\n              } else if (typeof tempInteger === 'symbol') {\x0d\n                tempStr = 'NaN';\x0d\n              } else {\x0d\n                tempStr = formatNumberNoColor(\x0d\n                  NumberParseInt(tempInteger)\x2C inspectOptions);\x0d\n              }\x0d\n              break;\x0d\n            }\x0d\n            case 102: { // 'f'\x0d\n              const tempFloat = args[++a];\x0d\n              if (typeof tempFloat === 'symbol') {\x0d\n                tempStr = 'NaN';\x0d\n              } else {\x0d\n                tempStr = formatNumberNoColor(\x0d\n                  NumberParseFloat(tempFloat)\x2C inspectOptions);\x0d\n              }\x0d\n              break;\x0d\n            }\x0d\n            case 99: // 'c'\x0d\n              a += 1;\x0d\n              tempStr = '';\x0d\n              break;\x0d\n            case 37: // '%'\x0d\n              str += StringPrototypeSlice(first\x2C lastPos\x2C i);\x0d\n              lastPos = i + 1;\x0d\n              continue;\x0d\n            default: // Any other character is not a correct placeholder\x0d\n              continue;\x0d\n          }\x0d\n          if (lastPos !== i - 1) {\x0d\n            str += StringPrototypeSlice(first\x2C lastPos\x2C i - 1);\x0d\n          }\x0d\n          str += tempStr;\x0d\n          lastPos = i + 1;\x0d\n        } else if (nextChar === 37) {\x0d\n          str += StringPrototypeSlice(first\x2C lastPos\x2C i);\x0d\n          lastPos = i + 1;\x0d\n        }\x0d\n      }\x0d\n    }\x0d\n    if (lastPos !== 0) {\x0d\n      a++;\x0d\n      join = ' ';\x0d\n      if (lastPos < first.length) {\x0d\n        str += StringPrototypeSlice(first\x2C lastPos);\x0d\n      }\x0d\n    }\x0d\n  }\x0d\n\x0d\n  while (a < args.length) {\x0d\n    const value = args[a];\x0d\n    str += join;\x0d\n    str += typeof value !== 'string' ? inspect(value\x2C inspectOptions) : value;\x0d\n    join = ' ';\x0d\n    a++;\x0d\n  }\x0d\n  return str;\x0d\n}\x0d\n\x0d\nif (internalBinding('config').hasIntl) {\x0d\n  const icu = internalBinding('icu');\x0d\n  // icu.getStringWidth(string\x2C ambiguousAsFullWidth\x2C expandEmojiSequence)\x0d\n  // Defaults: ambiguousAsFullWidth = false; expandEmojiSequence = true;\x0d\n  // TODO(BridgeAR): Expose the options to the user. That is probably the\x0d\n  // best thing possible at the moment\x2C since it's difficult to know what\x0d\n  // the receiving end supports.\x0d\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\x0d\n    let width = 0;\x0d\n\x0d\n    if (removeControlChars)\x0d\n      str = stripVTControlCharacters(str);\x0d\n    for (let i = 0; i < str.length; i++) {\x0d\n      // Try to avoid calling into C++ by first handling the ASCII portion of\x0d\n      // the string. If it is fully ASCII\x2C we skip the C++ part.\x0d\n      const code = str.charCodeAt(i);\x0d\n      if (code >= 127) {\x0d\n        width += icu.getStringWidth(str.slice(i).normalize('NFC'));\x0d\n        break;\x0d\n      }\x0d\n      width += code >= 32 ? 1 : 0;\x0d\n    }\x0d\n    return width;\x0d\n  };\x0d\n} else {\x0d\n  /**\x0d\n   * Returns the number of columns required to display the given string.\x0d\n   */\x0d\n  getStringWidth = function getStringWidth(str\x2C removeControlChars = true) {\x0d\n    let width = 0;\x0d\n\x0d\n    if (removeControlChars)\x0d\n      str = stripVTControlCharacters(str);\x0d\n    str = StringPrototypeNormalize(str\x2C 'NFC');\x0d\n    for (const char of new SafeStringIterator(str)) {\x0d\n      const code = StringPrototypeCodePointAt(char\x2C 0);\x0d\n      if (isFullWidthCodePoint(code)) {\x0d\n        width += 2;\x0d\n      } else if (!isZeroWidthCodePoint(code)) {\x0d\n        width++;\x0d\n      }\x0d\n    }\x0d\n\x0d\n    return width;\x0d\n  };\x0d\n\x0d\n  /**\x0d\n   * Returns true if the character represented by a given\x0d\n   * Unicode code point is full-width. Otherwise returns false.\x0d\n   */\x0d\n  const isFullWidthCodePoint = (code) => {\x0d\n    // Code points are partially derived from:\x0d\n    // https://www.unicode.org/Public/UNIDATA/EastAsianWidth.txt\x0d\n    return code >= 0x1100 && (\x0d\n      code <= 0x115f ||  // Hangul Jamo\x0d\n      code === 0x2329 || // LEFT-POINTING ANGLE BRACKET\x0d\n      code === 0x232a || // RIGHT-POINTING ANGLE BRACKET\x0d\n      // CJK Radicals Supplement .. Enclosed CJK Letters and Months\x0d\n      (code >= 0x2e80 && code <= 0x3247 && code !== 0x303f) ||\x0d\n      // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A\x0d\n      (code >= 0x3250 && code <= 0x4dbf) ||\x0d\n      // CJK Unified Ideographs .. Yi Radicals\x0d\n      (code >= 0x4e00 && code <= 0xa4c6) ||\x0d\n      // Hangul Jamo Extended-A\x0d\n      (code >= 0xa960 && code <= 0xa97c) ||\x0d\n      // Hangul Syllables\x0d\n      (code >= 0xac00 && code <= 0xd7a3) ||\x0d\n      // CJK Compatibility Ideographs\x0d\n      (code >= 0xf900 && code <= 0xfaff) ||\x0d\n      // Vertical Forms\x0d\n      (code >= 0xfe10 && code <= 0xfe19) ||\x0d\n      // CJK Compatibility Forms .. Small Form Variants\x0d\n      (code >= 0xfe30 && code <= 0xfe6b) ||\x0d\n      // Halfwidth and Fullwidth Forms\x0d\n      (code >= 0xff01 && code <= 0xff60) ||\x0d\n      (code >= 0xffe0 && code <= 0xffe6) ||\x0d\n      // Kana Supplement\x0d\n      (code >= 0x1b000 && code <= 0x1b001) ||\x0d\n      // Enclosed Ideographic Supplement\x0d\n      (code >= 0x1f200 && code <= 0x1f251) ||\x0d\n      // Miscellaneous Symbols and Pictographs 0x1f300 - 0x1f5ff\x0d\n      // Emoticons 0x1f600 - 0x1f64f\x0d\n      (code >= 0x1f300 && code <= 0x1f64f) ||\x0d\n      // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane\x0d\n      (code >= 0x20000 && code <= 0x3fffd)\x0d\n    );\x0d\n  };\x0d\n\x0d\n  const isZeroWidthCodePoint = (code) => {\x0d\n    return code <= 0x1F || // C0 control codes\x0d\n      (code >= 0x7F && code <= 0x9F) || // C1 control codes\x0d\n      (code >= 0x300 && code <= 0x36F) || // Combining Diacritical Marks\x0d\n      (code >= 0x200B && code <= 0x200F) || // Modifying Invisible Characters\x0d\n      // Combining Diacritical Marks for Symbols\x0d\n      (code >= 0x20D0 && code <= 0x20FF) ||\x0d\n      (code >= 0xFE00 && code <= 0xFE0F) || // Variation Selectors\x0d\n      (code >= 0xFE20 && code <= 0xFE2F) || // Combining Half Marks\x0d\n      (code >= 0xE0100 && code <= 0xE01EF); // Variation Selectors\x0d\n  };\x0d\n}\x0d\n\x0d\n/**\x0d\n * Remove all VT control characters. Use to estimate displayed string width.\x0d\n */\x0d\nfunction stripVTControlCharacters(str) {\x0d\n  validateString(str\x2C 'str');\x0d\n\x0d\n  return str.replace(ansi\x2C '');\x0d\n}\x0d\n\x0d\nmodule.exports = {\x0d\n  inspect\x2C\x0d\n  format\x2C\x0d\n  formatWithOptions\x2C\x0d\n  getStringWidth\x2C\x0d\n  inspectDefaultOptions\x2C\x0d\n  stripVTControlCharacters\x0d\n};\x0d\n
code-source-info,0x29698297196,20,10909,10953,C0O10919C4O10948,,
tick,0x7ff7e71870b6,315951,0,0x0,3,0x7ff7e78fdb40,0x2969828f2d8,0x7ff7e7312090,0x3063249db00,0x7ff7e7d6ec6b
code-creation,LazyCompile,10,316097,0x2969829bca6,395,inspect node:internal/util/inspect:290:17,0x25ca271eb00,~
code-source-info,0x2969829bca6,20,8744,10810,C0O8744C2O8797C9O8891C15O8924C18O8946C28O8970C31O8992C41O9012C44O9034C54O9062C57O9084C67O9115C70O9137C80O9169C83O9191C93O9229C96O9251C106O9286C109O9308C119O9335C122O9357C132O9379C135O9401C145O9423C148O9445C158O9477C161O9499C172O9540C179O9547C184O9591C191O9598C196O9612C198O9625C203O9655C205O9676C208O9665C212O9711C219O9718C226O9734C231O9764C233O9786C236O9775C240O9847C246O9887C248O9902C254O9922C258O9957C263O9957C268O9995C270O10010C274O10000C279O10046C281O10053C285O10251C292O10297C295O10267C304O10343C309O10371C311O10386C314O10380C320O10417C326O10527C328O10543C332O10020C337O9982C340O10594C346O10602C348O10614C352O10645C358O10691C361O10689C365O10712C371O10760C374O10758C378O10773C389O10780C394O10807,,
code-creation,LazyCompile,10,316491,0x2969829c19e,463,formatValue node:internal/util/inspect:743:21,0x25ca271f120,~
code-source-info,0x2969829c19e,20,23193,25859,C0O23283C14O23362C17O23362C23O23398C26O23425C37O23405C42O23446C43O23455C47O23493C58O23493C64O23517C65O23605C68O23736C73O23765C80O23736C86O23780C88O23820C94O23840C106O23847C111O23885C112O23898C117O24058C123O24100C125O24106C127O24105C131O24133C137O24268C142O24376C148O24397C153O24409C160O24419C165O24568C174O24596C181O24602C185O24657C188O24663C193O24701C195O24690C200O24729C208O24817C226O24729C232O24991C234O24999C239O25023C245O25065C257O25072C262O25108C263O25140C279O25164C284O25175C289O25164C299O25140C305O25194C306O25387C311O25392C316O25392C323O25428C326O25444C332O25477C334O25496C337O25492C342O25490C346O25518C351O25527C356O25527C364O25579C369O25588C374O25588C380O25607C382O25655C387O25664C391O25669C395O25687C400O25696C405O25696C411O25747C421O25769C435O25747C441O25790C442O25801C457O25808C462O25856,,
code-creation,LazyCompile,10,317367,0x2969829ccb6,3325,formatRaw node:internal/util/inspect:818:19,0x25ca271f170,~
code-source-info,0x2969829ccb6,20,25881,36652,C0O25929C2O25942C4O25965C10O26000C14O25993C19O26013C25O26037C28O26084C44O26084C50O26198C54O26241C61O26248C66O26262C68O26306C70O26312C72O26311C76O26449C82O26492C87O26514C95O26536C101O26577C107O26631C111O26613C118O26667C121O26696C124O26719C127O26747C129O26775C131O26792C133O26817C141O26830C147O26847C150O26886C155O27105C157O27115C159O27114C168O27163C170O27188C176O27192C182O27313C184O27326C191O27345C208O27411C231O27364C242O27444C248O27451C254O27499C265O27512C280O27546C287O27553C292O27567C299O27574C308O27618C309O27634C320O27641C321O27649C326O27687C331O27724C337O27728C343O27764C349O27764C355O27814C369O27853C388O27814C395O27870C399O27896C405O27877C411O27916C419O27970C428O27970C440O28009C451O28020C455O28020C461O28009C468O28055C469O28064C474O28078C481O28085C490O28129C500O28150C501O28158C512O28171C531O28200C537O28204C543O28240C549O28240C555O28290C569O28329C588O28290C595O28346C599O28372C605O28353C611O28392C619O28446C628O28446C640O28485C651O28496C655O28496C661O28485C668O28532C669O28541C674O28555C681O28562C690O28606C700O28627C701O28635C712O28648C731O28677C737O28681C743O28711C749O28718C755O28778C758O28807C762O28818C766O28855C772O28866C778O28970C784O28993C791O28978C798O29041C804O29041C810O29100C820O29142C842O29100C849O29159C860O29172C875O29206C882O29213C887O29227C894O29234C899O29248C905O29269C906O29285C917O29292C918O29451C922O29480C937O29480C943O29512C950O29555C956O29559C962O29590C966O29616C972O29597C978O29636C986O29645C992O29733C996O29760C1005O29760C1014O29792C1020O29796C1026O29827C1030O29853C1036O29834C1042O29873C1050O29882C1056O29970C1060O29997C1069O29997C1078O30038C1080O30072C1084O30095C1088O30121C1094O30102C1100O30139C1105O30165C1107O30181C1112O30204C1118O30208C1124O30245C1129O30255C1135O30288C1137O30296C1142O30315C1159O30330C1172O30325C1176O30397C1183O30404C1192O30450C1193O30466C1204O30473C1207O30495C1213O30537C1226O30544C1232O30602C1239O30609C1248O30664C1258O30664C1264O30689C1267O30702C1273O30706C1279O30781C1295O30857C1301O30853C1308O30788C1313O30903C1327O30903C1334O30949C1336O30960C1341O30984C1348O31003C1353O31028C1360O31035C1369O31104C1373O31098C1378O31117C1384O31156C1394O31156C1400O31180C1403O31202C1409O31206C1415O31286C1423O31305C1427O31305C1433O31293C1441O31345C1445O31345C1453O31385C1457O31385C1462O31440C1476O31440C1483O31484C1485O31495C1490O31517C1497O31536C1502O31560C1509O31567C1518O31624C1528O31624C1534O31646C1537O31668C1543O31672C1549O31697C1568O31704C1574O31769C1581O31776C1590O31820C1592O31832C1595O31845C1601O31849C1607O32088C1613O32088C1627O32179C1640O32179C1647O32226C1651O32267C1656O32321C1663O32328C1672O32374C1680O32439C1686O32454C1695O32422C1711O32388C1714O32477C1715O32494C1720O32509C1728O32504C1732O32527C1742O32527C1749O32582C1755O32586C1761O32614C1778O32629C1791O32624C1795O32747C1816O32747C1823O32826C1829O32830C1835O32857C1852O32872C1865O32867C1869O32922C1874O32961C1880O32965C1886O32992C1903O33007C1916O33002C1920O33073C1935O33136C1941O33140C1947O33167C1964O33182C1977O33177C1981O33248C1996O33311C2002O33315C2008O33356C2025O33371C2038O33366C2042O33473C2046O33507C2055O33507C2064O33537C2070O33541C2076O33575C2095O33582C2101O33648C2108O33655C2120O33701C2122O33713C2125O33753C2132O33760C2144O33806C2150O33810C2160O33858C2166O33858C2176O33881C2190O33882C2202O33918C2214O33940C2237O33918C2249O33963C2250O33984C2263O33994C2284O34035C2285O34052C2301O34067C2322O34062C2330O34148C2334O34142C2342O34161C2348O34206C2361O34206C2373O34242C2390O34243C2404O34262C2408O34295C2414O34317C2433O34353C2443O34353C2455O34389C2456O34398C2466O34426C2476O34431C2486O34431C2496O34447C2498O34464C2506O34487C2508O34525C2520O34555C2529O34564C2540O34611C2542O34627C2546O34620C2554O34656C2570O34716C2590O34671C2602O34656C2612O34636C2619O34606C2622O34747C2626O34793C2642O34793C2667O34869C2682O34869C2694O34905C2711O34906C2725O34925C2744O34932C2754O34998C2755O35015C2765O35064C2775O35073C2785O35073C2797O35090C2799O35146C2811O35163C2834O35146C2848O35268C2859O35276C2867O35297C2869O35309C2883O35333C2898O35346C2908O35379C2913O35394C2927O35413C2940O35389C2948O35448C2958O35453C2968O35453C2976O35473C2986O35511C2997O35518C3008O35545C3018O35558C3020O35577C3022O35573C3030O35615C3040O35615C3053O35654C3061O35661C3069O35697C3079O35710C3089O35724C3093O35717C3101O35697C3113O35731C3123O35732C3135O35764C3145O35778C3155O35792C3159O35785C3167O35805C3179O35764C3189O35854C3214O35854C3225O35964C3235O35975C3243O35970C3253O36031C3261O36025C3268O36046C3278O36057C3290O36073C3298O36582C3304O36596C3312O36614C3314O36624C3322O36638C3324O36649,,
code-creation,LazyCompile,10,318293,0x2969829e046,319,getConstructorName node:internal/util/inspect:565:28,0x25ca271ef40,~
code-source-info,0x2969829e046,20,17426,18705,C0O17472C2O17499C7O17518C13O17521C16O17521C22O17574C30O17574C36O17631C38O17690C46O17734C51O17740C58O17745C66O17793C71O17764C78O17810C84O17864C91O17886C94O17901C99O17916C104O17922C109O17901C116O17941C127O17986C138O17941C143O18066C148O18072C152O18077C153O18092C158O18098C164O18130C168O18169C173O17507C176O18204C180O18236C181O18248C182O18271C187O18271C192O18332C196O18326C201O18345C207O18368C216O18404C217O18435C222O18490C235O18435C241O18513C243O18546C256O18596C265O18623C275O18644C280O18564C295O18658C296O18669C308O18687C318O18702,,
code-creation,LazyCompile,10,318396,0x2969829e316,13,isInstanceof node:internal/util/inspect:557:22,0x25ca271eef0,~
code-source-info,0x2969829e316,20,17292,17395,C3O17324C5O17338C8O17355C11O17374C12O17387,,
code-creation,LazyCompile,10,318477,0x2969829e51e,223,getKeys node:internal/util/inspect:686:17,0x25ca271f030,~
code-source-info,0x2969829e51e,20,21242,22243,C0O21242C9O21271C11O21296C21O21296C26O21335C30O21358C40O21365C45O21416C51O21423C56O21437C63O21437C73O21805C83O21812C91O21810C101O21859C112O21866C118O21866C127O21892C134O21897C143O21935C151O21935C156O21859C160O21975C172O21982C179O22040C185O22047C190O22078C195O22143C206O22173C209O22173C215O22143C220O22228C222O22240,,
code-creation,LazyCompile,10,318655,0x2969829e936,717,formatError node:internal/util/inspect:1279:21,0x25ca271f490,~
code-source-info,0x2969829e936,20,42838,44868,C0O42895C9O42910C12O42921C17O42910C26O42953C29O42953C34O42979C49O42979C54O43033C59O43045C64O43068C70O43075C75O43090C83O43090C90O43122C98O43122C103O43147C118O43155C124O43283C130O43300C135O43312C140O43300C150O43332C152O43340C157O43364C162O43372C173O43472C181O43472C188O43501C190O43516C195O43531C200O43543C213O43591C220O43591C227O43632C230O43663C238O43680C243O43663C256O43632C262O43700C268O43788C292O43780C322O43780C325O43824C333O43830C337O43824C343O43858C347O43879C351O43892C359O43903C364O43892C371O43922C375O43943C385O43943C404O44088C406O44111C415O44150C417O44182C423O44202C429O44202C435O44182C437O44293C443O44315C447O44321C452O44293C465O44357C473O44375C482O44357C495O44421C502O44439C507O44443C511O44427C515O44164C518O44475C519O44491C531O44511C537O44511C546O43769C622O44564C625O44587C634O44587C650O44613C655O44708C661O44723C666O44757C669O44761C674O44772C679O44761C685O44808C701O44828C707O44808C714O44852C716O44865,,
code-creation,LazyCompile,10,318781,0x2969829ee0e,32,getStackString node:internal/util/inspect:1210:24,0x25ca271f350,~
code-source-info,0x2969829ee0e,20,40480,40569,C0O40506C8O40514C11O40527C16O40514C24O40536C27O40536C31O40566,,
code-creation,LazyCompile,10,318855,0x2969829efc6,195,removeDuplicateErrorKeys node:internal/util/inspect:1267:34,0x25ca271f440,~
code-source-info,0x2969829efc6,20,42460,42814,C0O42498C6O42517C12O42524C17O42557C46O42549C74O42549C77O42615C82O42615C88O42710C90O42720C98O42736C105O42748C109O42736C116O42773C124O42773C130O42538C194O42813,,
code-creation,LazyCompile,10,318963,0x2969829f27e,282,improveStack node:internal/util/inspect:1234:22,0x25ca271f3f0,~
code-source-info,0x2969829f27e,20,41332,42423,C0O41523C5O41536C9O41577C17O41577C24O41611C29O41611C36O41645C43O41652C50O41668C56O41674C63O41690C69O41696C74O41730C77O41744C81O41799C91O41799C98O41869C108O41869C114O41910C118O41936C126O41970C131O41985C138O42044C150O42044C156O42081C166O42082C173O42101C175O42110C180O42142C185O42142C192O42169C193O42177C198O42197C210O42219C218O42257C222O42283C227O42283C240O42333C252O42355C263O42369C268O42369C279O42407C281O42420,,
code-creation,LazyCompile,10,319079,0x2969829f636,188,getStackFrames node:internal/util/inspect:1214:24,0x25ca271f3a0,~
code-source-info,0x2969829f636,20,40596,41307,C0O40640C8O40640C14O40722C22O40731C25O40743C30O40731C36O40777C39O40796C44O40777C49O40844C57O40844C63O40870C65O40890C70O40938C77O40960C81O40938C87O40964C95O40965C101O41009C104O41009C110O40993C115O40998C120O41061C121O41069C126O41101C128O41105C132O41131C137O41142C148O41206C155O41220C159O41238C167O41238C180O41206C185O41290C187O41304,,
code-creation,LazyCompile,10,319215,0x2969829f83e,21,exists node:internal/bootstrap/loaders:236:16,0x147335cfb98,~
code-source-info,0x2969829f83e,9,7511,7560,C0O7523C5O7543C10O7547C15O7547C20O7555,,
code-creation,LazyCompile,10,319274,0x2969829f996,82,stylizeWithColor node:internal/util/inspect:538:26,0x25ca271ee00,~
code-source-info,0x2969829f996,20,16835,17084,C0O16871C3O16879C10O16885C14O16901C16O16947C19O16955C26O16961C30O16975C32O17007C36O17029C52O17036C65O17054C78O17061C79O17070C81O17081,,
code-creation,LazyCompile,10,319323,0x2969829face,6,get node:internal/util/inspect:414:8,0x25ca271ebf0,~
code-source-info,0x2969829face,20,12970,13009,C0O12982C2O12993C5O13002,,
code-creation,RegExp,3,319423,0x29be72d3440,2292,^ {4}at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$
